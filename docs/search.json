[{"title":"about","url":"/about/","content":"# 关于我\n\n<div class=\"alert-green\">此部分上次更新时间 2019-01-24 16:13:00。</div>\n\n<div class=\"alert-red\">对于一些人，在对着这个页面按 <code>Control + c</code> 之前，麻烦先看一下第 17 条。</div>\n\n1. Alynx 可以接受的称呼包括 Alynx Zhou，Alynx，AZ。\n\n2. Alynx 这个词的来历、读音是 *Alynx* is just **a lynx**。\n\n3. Alynx 的本命是 **科学超电磁炮** 中的 “超电磁炮” *御坂美琴*，*Misaka Mikoto* 和 **Fate/stay night** 里面的 “Saber” *阿尔托莉雅·潘德拉贡*。\n\n4. Alynx 是 S / M 双属性，虽然可能表现的更像 M 但是其实 S 的属性更多，**除非你是让我心甘情愿的人**。对 LGBTQIA 没有歧视但是 Alynx **只喜欢女孩子**，想要认识可爱的小姐姐，想脱单。\n\n5. Alynx 像猫一样懒，目前在 ~~北京交通大学~~ **前北下关军事基地**，~~计算机与信息技术学院~~ **反恐精英专业在读**。[北京交通大学自由与开源软件镜像站](https://mirror.bjtu.edu.cn/) 前任维护者。SUSE 北京分部的实习生。Alynx 还是 Arch Linux CN 社区里稀有的 GNOME 用户之一，希望大家爱护稀有动物。\n\n6. Alynx 喜欢 Arch Linux，Atom，C，Coffee Script，Vala，GNOME，你也许喜欢与这些对立的软件，但是 **每个人选择自己喜欢的东西一定有她的理由**，所以 **请不要强行向 Alynx 安利你喜欢的东西**。\n\n7. Alynx 喜欢音乐，目前最喜欢的乐器是半音阶口琴，有不到 4 年的琴龄，北京交通大学口琴联盟的创始人兼第一任社长，（此处应该有努力练琴的 Flag）。学过 4 年二胡并通过了业余水平十级（虽然现在几乎忘光了），选了扬琴选修课所以大概了解一点点，其他了解一点的乐器还有长号，选到课的小提琴。\n\n8. Alynx 坚持用 Steam 并拒绝 Origin/Epic/Battle.net 等不打算支持 Linux 的平台（既然你忽略 Alynx 的需求，Alynx 也忽略你），*Counter-Strike: Global Offensive* 是目前为止唯一一个玩了超过 600 小时的游戏，唯一能够玩进去的 RPG 大概是 *NieR: Automata*，感谢室友特地带 PS4 到学校还和高中同学借了光盘让 Alynx 能和另一个室友一起以 60FPS 和高清画质通关主线（这话说的有点乱套）。另外表示室友四个人一起玩 *Overcooked!* 非常开心，所以预购了 *Overcooked!2*。\n\n9. Alynx 的 Steam ID 是 Alynx Zhou，如果你想和 Alynx 一起玩游戏的话。不定期在线，并且 **如果你是那种很吵很暴躁张口就喷队友的人请不要来打扰 Alynx**。\n\n10. Alynx 喜欢 Minecraft（Java版），**不接受 Win10 版**，PE/Java 版正版玩家（非网易版）。\n\n11. Alynx 已经玩不动崩坏3rd了，即使有小姐姐 + 数一数二的渲染技术。Alynx 也肝不动 Fate/Grand Order（非的肝不过欧的）（明明是碧蓝航线！）了，~~还没抽到蓝呆是 Alynx 没有卸载游戏的一个重要理由，她已经快绝望了~~**已经抽到蓝呆了**（已经满破了）（我永远喜欢FGO）（快说声多谢叶哥哥）。\n\n12. Alynx 想研究有关游戏渲染的东西，略微懂一点 OpenGL ES 和相关的矩阵运算。\n\n13. Alynx 不仅想学日语，还抓住机会选到了日语二外的任选课。\n\n14. Alynx 认为 *Kalafina* 和 *梶浦由纪* 才是 **真正的音乐**，*Hikaru* 是 Alynx 安装 Twitter App 的唯一理由。Alynx 也喜欢陈奕迅和林俊杰以及张杰这种唱功或者音乐水平确实到位的歌手，网易云里《富士山下（live）》，《倾城》，《喜帖街》，《K歌之王》，《你给我听好》，《修炼爱情》。\n\n15. Alynx 经常懒癌发作什么也不想做，Alynx 是个不肥（182 cm / 72 KG）的宅。Alynx 喜欢猫，不太喜欢狗。\n\n16. Alynx 喜欢写一些乱七八糟的东西，即使这些没有人喜欢看，但无论如何 **这是我们在面对世界这一庞然大物时能留下的一点声音，无论是惊慌失措还是泰然面对**。\n\n17. Alynx 讨厌复制品。加上这一条是因为 Alynx 最近看到了好多部分复制这个页面的网站，Alynx 愤怒地希望这些人认清楚什么是拿来分享的什么是拿来看的。如果这些人不能理解，Alynx 表示你们 **尽管使用这个页面的样式**，因为代码就在 GitHub 上并使用 Apache-2.0 公开授权，Alynx **非常高兴你们喜欢这个主题，毕竟她用了两周来实现这些样式**。但是对于使用 CC BY-NC-ND 4.0 授权的网站内容，希望你们不要拿来充实自己的页面，这种行为有时候会让 Alynx 觉得自己写的很中二而删除对应的文章。**你有一千种介绍自己的方式，但没必要把 Alynx 的面具拿过来抠几个窟窿贴在自己脸上，因为 Alynx 会觉得痛**。你也可以给自己的网站起个独特的名字，而不是看到 StackHarbor 就觉得这个词天下第一，拿来自己用可不是夸奖 Alynx 审美的好办法。\n\n18. Alynx 喜欢的电影和动漫有《Fate/Stay Night》系列，《Fate/Zero》，《你的名字。》，《爱乐之城》，《海上钢琴师》以及《新世纪福音战士》（包括 TV 和剧场版），《黑执事》。\n\n19. Alynx 最喜欢 C，曾经在 Bilibili 直播了一段时间的 C 语言教学。如果是动态类型那么一定是 Coffee Script，如果是面向对象又要静态类型，Alynx 选择 Vala。\n\n20. Alynx 喜欢可口可乐。\n\n21. Alynx 觉得能不能写出优美的句子完全看运气，即使有时候会因为自己写不出来而感到没用。\n\n22. Alynx 觉得谈了也没用所以 **莫谈国事**。\n\n23. Alynx 的梦想是环游世界（如果不去非洲南美洲也算的话？），一个人待在陌生的，没有人知道的地方仰望天空。\n\n24. Alynx 不喜欢说话，除非是对喜欢的人 / 说喜欢的东西，当然以前说的都是编程或者音乐，身边的人总是听不懂。\n\n25. Alynx 觉得 **比起依赖别人，我更喜欢被人依赖，如果我喜欢的人能让我默默付出我就很满足了**。所以不要和 Alynx 客套。\n\n26. Alynx 强调一下 **上一条很重要**。\n\n27. Alynx 讨厌需要鼠标不停点点点的程序，比如 MS Office，Visual Studio，手还要留着玩 FPS 游戏呢。\n\n28. Alynx 能有一个所爱的人这件事情和 root 密码一样重要，即使不知道她是否爱我。\n\n29. Alynx 讨厌刷题，讨厌为了刷题写出丑陋的代码，千金难买喵乐意。\n\n30. Alynx 更喜欢 Telegram 虽然不得不用 QQ 和微信。偶尔会在 Bilibili 直播 吹口琴 / 打游戏 / 写代码。\n\n31. Alynx 宁可不看不能在 Bilibili 上看而只能在其他国内视频网站上看的视频。Alynx 也不能接受一个乱七八糟的播放器，Alynx 现在用网易云音乐下音乐然后用 PowerAMP/Rhythmbox/MPV 听。\n\n32. Alynx 希望听到别人的声音，即使我常常讨厌交流如果有什么问题，欢迎发邮件 / Telegram 甚至是去 [这里](https://github.com/AlynxZhou/AlynxZhou.github.io/issues) 发issue。\n\n33. Alynx 说你好，世界。\n\n# Build with Atom.\n\n**A hackable text editor for the 21st Century.**\n\n[![Build with Atom](/images/Atom.png)](https://atom.io/)\n\n<!--\n<div id=\"snakeGame\" class=\"snakeGame\">\n\t<script type=\"text/javascript\" src=\"snake.js\"></script>\n</div>\n-->\n"},{"title":"blogroll","url":"/blogroll/","content":"本来是打算把友情链接放到侧边栏里面的，但后来看好多人的网站里都是给链接单独开了个页面写点介绍。我觉得这样挺不错的，所以自己也搞一个。\n\n想加友链可以评论留言，或者发邮件给我。\n\n# 老相识\n\n| 头像 | 链接 | 自我介绍 | 我的介绍 |\n| :------------: | :------------: | :------------: | :------------: |\n| <img src=\"https://lgiki.cc/images/avatar.jpg\" style=\"width: 5em;\"> | [LGiki](https://lgiki.cc/) | “喵喵喵” | 节奏王 Dogiki！每天咕咕咕，从不写博客！ |\n| <img src=\"http://www.hackghost.com/image/logo.jpg\" style=\"width: 5em;\"> | [HackGhost](http://www.hackghost.com/) |  | 在五道口睡觉的某头。博客从某一天起就不更新了。 |\n| <img src=\"https://chenxy.moe/pic/chen.jpg\" style=\"width: 5em;\"> | [Art_Chen](https://chenxy.moe/) |  | 某著名 ROM 开发者，上大学了要努力写代码啊。|\n\n# 大学认识的\n\n| 头像 | 链接 | 自我介绍 | 我的介绍 |\n| :------------: | :------------: | :------------: | :------------: |\n| <img src=\"https://lrscy.github.io/img/avatar.jpg\" style=\"width: 5em;\"> | [Meow](https://lrscy.github.io/) | “一只有吱的喵~” | 刚入学的时候认识的学长，似乎也是一只猫，现在大概在美国呼吸自由的空气（大雾）。 |\n| <img src=\"https://tvax4.sinaimg.cn/crop.0.0.480.480.180/005ttpDdly8fwz8wsaiw5j30dc0dcwfu.jpg\" style=\"width: 5em;\"> | [sqyon](https://sqyon.com/) | “试图让机器帮我学习的假 ACMer” | 优秀的学弟，一定是优秀的学弟。 |\n| <img src=\"https://avatars0.githubusercontent.com/u/11513730?s=460&v=4\" style=\"width: 5em;\"> | [滑稽仓库](http://huaji.store/) |  | 董老师（咕老师）的奇怪网站。希望下次打 CSGO 前董老师能找到带麦克风的耳机。 |\n\n# Arch Linux CN 社区或者 Gentoo Linux CN 社区\n\n| 头像 | 链接 | 自我介绍 | 我的介绍 |\n| :------------: | :------------: | :------------: | :------------: |\n| <img src=\"https://blog.yoitsu.moe/theme/images/wiki.png\" style=\"width: 5em;\"> | [约伊兹的萌狼乡手札](https://blog.yoitsu.moe/) | 「虽然咱长久以来被尊为神，且被束缚在这块土地上，但咱根本不是什么伟大的神。咱就是咱。咱是赫萝。」 | 我大概能理解这是个什么物种吧……反正我是猫。 |\n| <img src=\"https://farseerfc.me/images/avatar.jpg\" style=\"width: 5em;\"> | [Farseerfc 的小窝](https://farseerfc.me/) |  | ~~爱呼吸~~ fc 老师！似乎是日本某大学的助教，看来是人生赢家，实名羡慕。 |\n| <img src=\"https://avatars0.githubusercontent.com/u/10167884?s=460&v=4\" style=\"width: 5em;\"> | [jm33_ng](https://jm33.me/) |  | 似乎是个高产的大佬，博客里都是和安全相关的（大概）。 |\n\n# 其他地方认识的\n\n| 头像 | 链接 | 自我介绍 | 我的介绍 |\n| :------------: | :------------: | :------------: | :------------: |\n| <img src=\"https://avatars1.githubusercontent.com/u/21106371?s=460&v=4\" style=\"width: 5em;\"> | [鸡腿工坊](https://jitui.moe/) |  | ~~新鲜~~ 可爱的鸡腿！ |\n| <img src=\"https://avatars1.githubusercontent.com/u/25676311?s=460&v=4\" style=\"width: 5em;\"> | [Yorushika Shi](https://sh.yorushika.live/) |  | 评论框里认识的朋友，看来保留评论框还是有必要的。 |\n|  | [Stack Pub](https://www.opfanswyx.top/) |  | 评论框认识的朋友。 |\n"},{"title":"Undefined Shell Works!","url":"/Undefined-Shell-Works/","content":"# Undefined Shell Works!\n\n```plain\n「I am the shell of my system.」\n「Command is my body, and argument is my blood.」\n「I have created over a thousand lines of logs.」\n「Unaware of less, nor aware of more.」\n「Withstood error to create many scripts, waiting for prompt's arrival.」\n「I have no mouse. This is the only bug.」\n「My whole life was `Undefined Shell Works`!」\n```\n\n# Unlimited Code Works\n\nFrom [CS Slayer/Unlimited Code Works](https://www.csslayer.info/wordpress/unlimited-code-works/)\n\n```plain\n「I am the bone of my program.」\n「Object is my body, and class is my blood.」\n「I have created over a thousand lines code.」\n「Unknown to delete, nor known to new.」\n「Have withstood pain to create many projects.」\n「Yet, those hands will never hold anything.」\n「So as I pray, Unlimited Code Works!」\n```\n"},{"title":"雲雀","url":"/posts/Hibari/","content":"ロード・エルメロイⅡ世の事件簿 -魔眼蒐集列車 Grace note- ED\n\n五线谱（带歌词）点击链接下载：[PDF 格式](./hibari.pdf)、[MSCZ 格式](./hibari.mscz)（需使用 MuseScore3 打开）。\n\n歌词参考自微博用户 [@小蟲子的覺魂](https://weibo.com/u/5699383914)。曲谱由我自己听写。\n\n<!--more-->\n\n说实话好久没听到这么有梶浦由记风格的曲子了。*花の唄* 和 *I beg you* 都不算是我特别能接受的风格，二世事件簿大概是一月份放了第一集，但我那时候坚守“不看新番”的原则错过了……不过还好，第二集才算正式的放出 OP 和 ED。无人声OP对于梶浦由记来说根本不算什么难题，相对来说 ED 就更有惊喜了，不管是对小灰还是对韦伯都很好体现出了人物身上的故事感。\n\n~~当然令人欣喜的绝对不是这个番又多了一个呆毛。~~\n\n刷了两次 HF2 之后听到这个真是治愈啊啊啊啊啊，HF2 黑呆和 B 叔打戏看出了 EVA 旧剧场版明日香大战量产机的感觉，明明画面很热血，但是就是给人绝望感。\n\n下面是数字谱：\n\n```\n[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]\n\n67 [#1 #1 #1 2 #1] 7 [3] 67 [#1 #1 #1 #4#4 33] 7\n67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67\n[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]\n[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5]\n\n[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]\n[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]\n\n[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]\n\n67 [#1 #1#1 2 #1] 77[3] 67 [#1 #1 #1 #4 33] 7\n67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67\n[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]\n[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5 6#5#4]\n\n[#4#56 7]{#1}[#4] [#4#56 7]{32#1}[76 #4#56 7]{#1}[#4 76#5 3 #4#56]\n[6#5 #4#56 7]{#1}[#4] {#43 #1}[7]{#1} [76#5#4] [76#5#5] [#567]{#1}\n\n[#4#566#4 #4#566#4 #4#5676 #5#4#5 #566]\n[6#5 #4#566#4 #4#566#4 #4#5676 #5#4#5 #566]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #4#43 3]\n[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]\n[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]\n```\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"六月，如梦一般的日子","url":"/posts/June-or-Dream/","content":"> One day I wake up,\n> finding that I am on one of the most crazy trips in my life.\n> It has been into my dream for many times,\n> but now it comes into reality,\n> which becomes the best birthday present.\n\n<!--more-->\n\n距离上次更新大概一个半月了，主要是因为考试周太忙所以没心情写博客。实际上有好多东西可以写。\n\n首先是端午节去了沈阳，不过很遗憾的是我不太喜欢拍景点照片（当然这也不是什么重点内容），所以只有一些稀松平常的照片。\n\n![](photo3.jpg)\n\n![](photo6.jpg)\n\n![](photo5.jpg)\n\n然后是有关实习的内容了，很幸运的拿到了 SUSE 北京的实习，环境超级好，而且最关键的还是找到一个自己比较感兴趣又有了解的实习。\n\n接下来就是 FGO 抽卡！盼了一年之后终于如愿以偿抽到了蓝呆！而且还是先出老福然后连续出蓝呆！没有看到金卡面之前完全没有意识到是什么，就算看到金卡还以为又是兰斯洛特或者式姐（兰斯洛特四宝的我），结果翻过来的时候完全呆住了不知道该怎么反应（抽到老福的快乐还没过去）。\n\n![](photo2.jpg)\n\n![](photo1.jpg)\n\n以及买到了 Yuki Kajiura Live 15 上海的票（因此变得超级贫穷），虽然对我这个纯 Kalafina 粉来说性价比不是很高，但由于没去过 Kalafina 的 Live（并且再也没有了）而十分后悔，因此抱着这样的想法毅然决然的自己买了票，也算是圆多年的梦吧，毕竟可以说我整个的音乐审美都来自于梶浦由纪和 Kalafina。\n\n最后附上沈阳故宫墙里奇怪的石头照片。\n\n![](photo4.jpg)\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Arch Linux 安装 UnityHub 的临时方案","url":"/posts/Archlinux-UnityHub/","content":"如果你直接使用 AUR 里 UnityHub 的 PKGBUILD 安装会出一些问题。解决方案也很简单。\n\n首先似乎 PKGBUILD 下载的版本很奇怪，不管你在 Unity 论坛里哪个链接下载的版本其实都是一个，并且和 PKGBUILD 里面的不一样，解决方法就是自己计算一下 md5 然后替换掉 PKGBUILD 里面的 md5sums。\n\n第二个就是 PKGBUILD 里面最后有这几句：\n\n```\n# Fix 7z permissions\nchmod +x \"${pkgdir}/opt/${pkgname}/resources\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64/7z\"\n```\n\n但解压出来实际上没这些文件，然后就会报错，注释掉就好了。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"不要拿愚蠢的广告来污染我的邮箱","url":"/posts/Do-Not-Fill-My-Email-with-Silly-Ads/","content":"一个多月没更新了，这次要写的不是什么技术问题，而是技术的附属问题。\n\n<!--more-->\n\n一切问题的起源是邮箱里出现的这两封邮件：\n\n![](email1.png)\n\n![](email2.png)\n\n当你使用的邮箱服务是按某种数字顺序批量注册用户名的时候，你就没办法避免这种情况，不止我自己，而是很多人都收到这种邮件，没办法，谁叫邮箱都是连号的，甚至不需要写脚本，只要用 Excel 拖一下就能生成一大串邮箱地址，毫无技术含量。\n\n从哪里开始呢？今天我不打算讨论写这么个 app 的技术问题，因为不管怎么说写这么一个系统也不是个简单的活，还是要尊重别人的劳动成果。但除了技术问题，别的问题就一大堆了。\n\n# 我不想下载\n\n没错，最大的问题其实是我看了这个东西以后根本没有下载的欲望，甚至连让我下载下来找找里面有哪些技术缺陷的欲望都没有。我也不是什么专业的传播学者或广告设计者，但从一个用户的角度而言就没有使用欲望——而且这种现象也不止我自己。\n\n# 你的情怀和我有什么关系\n\n> 今年春半，凝聚了团队无数努力和心血的项目终于开启了测试阶段。这对于我们整个团队来说都是一个饱含着拼搏意义和激动情绪的时刻。\n\n上一个想要靠卖弄情怀来宣传聊天软件的人叫罗永浩，结果如何呢？提起罗永浩大家还是首先想到 TNT、打脸，有几个想到聊天宝（**原子弹短信**）的？罗老师的原子弹短信一开始可是给用户发红包的，这年头光卖情怀可不行，大家都喜欢红包。\n\n我知道你们实现了目标非常开心，但能不能冷静下来再发广告，这句话放在这里除了浪费几 Byte 流量之外，对用户了解你的应用有什么帮助嘛？\n\n# AI 不是万能形容词\n\n> Dreamua 是首款 AI 社交应用。\n\n如果你做了个图片识别程序，你打个标签叫 AI 识图，那我觉得你的可信度有 90%，毕竟有很多现成的例子了。\n\n如果你做了个文本翻译程序，你打个标签叫 AI 翻译，那我觉得你的可信度有 70%，因为有几家财大气粗的公司在做，虽然效果不一定太好。\n\n如果你做了个自动驾驶程序，你打个标签叫 AI 驾驶，那你的可信度取决于你是不是在特斯拉上班。\n\n如果你非得叫 AI 社交……AI 社交了，还要我干什么？社交是人与人之间的互动哎，你这个 AI 社交，AI 在里面扮演什么角色呢？AI 能猜出来“今晚月色真美”的潜台词嘛？要是能猜出来，全世界的翻译官都失业了。\n\n写广告的人不懂的话可以问问程序员，最起码程序员应该懂。\n\n# 求你别搞假大空\n\n> 我们想了很久的slogan，最后把它决定为“Dreamua—遇见宇宙中最契合的TA”。\n> “宇宙”、“契合”是很宏大的词，但是我们希望可以和你一起，实现这个slogan的意义。\n\n如果语文老师没教你避免假大空，那软件工程老师应该教过你怎么写文档，**请问你们这个软件是想让我和外星生物配种嘛？**\n\n# edu 邮箱就很靠谱吗\n\n> Dreamua是一个仅对edu邮箱用户开放的高校社交App，其核心和灵魂是AI社交。注册Dreamua 账号无需填写复杂简介，仅需一个edu邮箱，一张头像，一个昵称。\n\n废话，**edu 邮箱要是那么靠谱，我就不会收到这个邮件了**——毕竟发件人也是 edu 邮箱。\n\n一个 edu 邮箱能说明什么呢？学号？学校？这个邮箱的主人可能已经毕业了，比如发邮件的这位 14xxxxxx，你是留级了在读大五？\n\n知道为什么我用 edu 邮箱申请 GitHub 学生认证不给过吗？就是因为国内的 edu 邮箱管理太松散了，完全没办法辨别真伪。那既然邮箱不能验证我是不是学生，再加一张头像一个昵称就能验证我是不是学生了吗？\n\n如果你们下次还想发广告，我觉得可以去淘宝搜索一下“教育 邮箱”，多买几个马甲，别总用一个，添加黑名单很容易的，大家只是太懒而已。\n\n# 说话能不能说准了\n\n> Dreamua是一个仅对edu邮箱用户开放的高校社交App。\n> Dreamua 测试版仅面向 edu 邮箱用户开放。\n\n第一封邮件告诉我这个社交 app 只对高校学生开放。第二封就告诉我是测试版仅面向 edu 邮箱——那以后呢？\n\n# 生人社交本身就是伪命题\n\n求求你了我们真的不是没社交就会孤独到死。不是每个人每个晚上都睡不着觉拿着微信疯狂摇一摇。我有自己认识的人，我可以认识我认识的人认识的人，我甚至看到有趣的人也可以直接上去要联系方式——或者我干脆就不想和别人说话。\n\n从小到大不爱和人说话的同学我见得多了，他们活得好好的，也没见谁需要下个 app“寻找志趣相投的伙伴”。**实在不行的话，我还有沙雕网友呢。**\n\n# 我为什么非要用你的\n\n我倒不是说微信微博 QQ 做的比你们技术好，但每个人都或多或少的被这些或者其他 app 黏着。本身这些东西已经够用了，我看不到需要切换到第 N + 1 个 app 来和别人说话的任何理由，特别是对于我们这些生活在地球外面的人，想切换就更艰难了。\n\n原子弹短信的尸体还在墙头上挂着呢，支付宝也有聊天功能，除了聊天框里的“转账”按钮，你按过别的吗？\n\n# Play 商店搜不到\n\n这一条可能有些不接地气，但对 Android 用户来说，Play 商店是最可靠的程序来源，就如同苹果的 App Store 一样。只有 Play 会定期检查手机里的 app 是不是有安全问题，其它的国内商店根本没有安全保证——拍个身份证照片注册就安全了吗？\n\n我看到你们的 app 提交了 App Store，所以应该不差那 25 美元提交 Play Store 吧，毕竟我自己的开源 app 也掏了 25 上了 Play 呢。\n\n# 官网没有可用信息\n\n还好我能够在 Google 搜索到 <https://www.dreamua.com/>，但这个页面逻辑和我自己的 app 页面 <https://livewallpaper.alynx.xyz/> 逻辑差不多嘛——就一个简单的静态页面，分几个段落，写一些半通不通的话（“年轻有朝气的初创团队，致力于打造一家有影响力、有社会责任感的互联网科技公司。”这话怎么读怎么奇怪）。既然你都注册公司了，多写几个页面问题不大吧。你们是公司，我可是一个人单打独斗写的 app，不至于和我一样套开源 bootstrap 主题吧！\n\n顺便，上面写诞生于高校宿舍，下面又写有 Uber、Facebook、Amazon、腾讯等知名互联网公司工作经验……大概能是真的，就是会让人觉得开发之后已经换了一波人一样，再说，腾讯出来的人写个前端页面不难吧。\n\n# 化再浓的妆也没用\n\n说实在的，我对用户群体的评估可能有点失误，真的有人告诉我他们的室友下载了这个 app，后一句就是喜闻乐见的“想通过这玩意脱单”。\n\n你看看你看看，人家用户都摆明了自己的需求了，就不要写什么“将宇宙中的一座座孤岛连成一片星海”了。单身直男们也该思索一下了，为什么夏目漱石说“今晚月色真美”是表白，你说“今晚月色真美”就是华为 P30 Pro 的高端黑了，你看王跃琨一下子就被开除了！太晦涩难懂是没法脱单的！\n\n# 真的别再卖情怀了\n\n> 首先谢谢你打开这封信。\n> 我们是交大的一个学生团队，我们和你们一样在学活吃渔粉，在球场踢足球，在傍晚看明湖鸭。\n> Dreamua 诞生于高校宿舍。\n\n说真的，你这样会让别人对我们宿舍里这些同学的真实水平产生怀疑——我觉得我们学校的教学还是偏重于踏踏实实讲理论老老实实学技术的，而不是选个厮杀的你死我活的行业（你们的对手不止有探探陌陌 Soul 其实还有微信微博 QQ 甚至是 Bilibili 和网易云音乐）来创业，写一堆乱七八糟的文案卖情怀。\n\n以前好像有个公众号，文案风格如出一辙，也挺喜欢卖情怀的，结果清华评特奖的时候从简历上被人挖出来婊说实际什么都没做。我觉得这种事情给人留的印象挺差的，所以还是别卖情怀了，能好好写文案就好好写，写不出来吃点渔粉踢会足球看看鸭鸭可能就有灵感了。\n\n# 百度没收录我的网站\n\n最近那个《旗帜鲜明地反对李彦宏当选工程院院士》挺出名的。我先声明一下，我的网站放在地球上，谷歌必应收录了我的网站而百度搜狗 360 这种辣鸡引擎没有收录，特别是百度还把山寨我的站点放在了搜索结果首页上。所以百度和我没什么利害关系，我也就不担心这种问题。\n\n至于腾讯封了《旗帜鲜明》我也不太担心，毕竟我这人不喜欢用微信，连公众号都没有，生平最烦举报党。\n\n我恰好想起来今天是我建站的三周年零一个月整，114777 个点击量不算太多，但从第一篇文章开始我的目标就没变过——“网站是属于自己的，我可以记录我自己的想法，喜不喜欢则是你的自由”。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Magnolia","url":"/posts/Magnolia/","content":"我不是很能欣赏花。\n\n我的鼻子并不懂得花的芬芳，我的眼睛也不是很了解花的鲜艳，大部分情况下，我连分辨花种类的兴趣都没有。但我今天还是认出了一株玉兰树，就像我高中楼门口两侧的玉兰树一样，开着白色花瓣。\n\n<!--more-->\n\n为什么认得玉兰花，说起来是个很奇怪的理由，有一段时间我非常喜欢一款包装上印着玉兰花的纸巾，我很喜欢那款包装的着色效果，虽然只是塑料制品，但是有着独特的温润感觉。另外大概也有原因是它味道并不是很浓，太浓的味道让我觉得不舒服。如果我没记错的话，我现在应该还留着一份包装。\n\n当然这件事并没有一个好的结尾，就像所有烂俗的青春文学一样。后来那款纸巾更换了新的包装，虽然还是玉兰为主题，但配色完全没有了之前的灵性。我以为我自己已经很缺乏审美了，但这个新包装的设计者不但缺乏审美，还能跑出来危害大家的眼睛。\n\n-------\n\n我总是记不住玉兰的英文该怎么拼，说错了，我大概对计算机之外的一切英文名词都不怎么敏感。多半是因为我并不会读这个单词，Mangolia，不对，Magnolia，有时候我会分不清楚“玉兰”和“蒙古”。\n\n我们先不谈有着伤感结局的玉兰纸巾，先谈真正的玉兰花。大概没有太多人注意高中校园里的两颗玉兰树，毕竟高中生每天有太多无聊的事情要考虑了，谁也没有那个闲情逸致，况且大多数人也没兴趣了解植物的区别，也包括我。\n\n虽然春天刮风是这个城市主要的气候，但是也并不是十分的没有人情味。通常来说，玉兰花开放的季节，也是会无缘无故落下一场春雨的时候。总是能有一些日子，可以在操场上的水洼里看见夕阳的倒影。也能在树下看到随着雨点一并落下的花瓣。什么时候树上的花瓣都落光了，什么时候有人情味的春天也就结束了。\n\n-------\n\n我不知道玉兰的花语是什么，因此很遗憾，我也没有办法围绕玉兰花的花语写出一篇小说。不过反正这些东西都是人附加的含义而已，就算某种花的花语是遇见幸福，那就真的能让人遇见幸福了吗？\n\n有些时候还是不要太相信那些本来是讲给小孩子听的话比较好，毕竟童话其实是大人写给大人看的。\n\n曾经我以为好搭档就应该永不分离，曾经我以为故事就应该十全十美，但后来我才知道，不完美的才更真实，大家都是成年人，就应该尊重每个人不同的决定，哪有那么多地方可以耍小孩子气。\n\n-------\n\n我最近在学日语，也算是终于开始实现很久以来的心愿了吧。\n\n老师说日语里面并不会经常重复主语，比如第一句话里已经说过主语是“我”，第二句就没必要再重复了。\n\n有时候我写东西也是这样，不太愿意在句子里说“我”，宁愿直接把主语省略掉，大概是欺骗自己，删掉主语的话，就可以当成是在说另一个人，写出来就不会觉得那么不好意思。\n\n-------\n\n“灵气”并不是什么容易获得的东西。有时候写了很多却完全不知道自己在说什么，我好像没有能把自己若无其事地叙述出来的能力。逐渐地就开始理解，物质是多么拖累精神的东西。反正喜欢的话总是被别人说出口了，电影台词也好歌词也罢，阅读总是比自己创作要舒服得多。\n\n只是很想听别人的故事而已，仿佛是身处不知何处的梦境中一样。身边的事物太吵闹了，生活太无聊，也太寒冷。\n\n四月只是春天的谎言吧，这样寒冷的日子，春天真的来了吗？还是说开放的 Magnolia，只是春天的假象而已呢？\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"如何编写 Android 视频壁纸","url":"/posts/Android-Video-Wallpaper-Implementation/","content":"最近我编写了一个 Android 的视频壁纸应用（[GitHub Repo](https://github.com/AlynxZhou/AlynxLiveWallpaper)），一开始觉得并没有什么难写的地方，应该很快就可以写出来，但是后来发现我想的太简单了。或许你也看过许多写视频壁纸的教程，但我发现他们都有一些问题，写出来的程序基本不能用，所以我打算在这里写一下如何编写一个可以发布的 Android 视频壁纸，而不是一个 demo。\n\n<!--more-->\n\n首先你需要新建一个项目，通常应该都是使用 Android Studio，我就忽略你如何与网络搏斗让 Android Studio 可用了。什么程序模板可以随便选，反正你还是要自己新建 class。最低 API 版本不要太低就行，如果你只是写一个动态壁纸，应该不需要很高的 API，因为 Android 很早就支持动态壁纸了（但为了让开发方便一点，建议只考虑 5.0 以上的就行了，反正现在即使有 5.0 以下的机器多半也成垃圾了）。\n\n# 首先让系统知道你是个壁纸……\n\n在开始写逻辑代码之前，我们还得先让系统知道你写的这是个壁纸，这需要一些起声明作用的代码。先把你 Android Studio 左侧侧栏调成文件树模式（忘了什么诡异的分类模式吧，不然你连文件在哪都找不到，试图隐藏细节只会让事情变的更复杂）。\n\n应该有一个自动生成的 `AndroidManifest.xml` 文件，我觉得你应该比我更了解这玩意是干嘛的，因为实际上我没系统地研究过 Android，我只是会一点点 Java 而已——然后靠不停的查看手册来自学。加上这两行：\n\n```xml\n<uses-permission android:name=\"android.permission.SET_WALLPAPER\" />\n<uses-feature\n  android:name=\"android.software.live_wallpaper\"\n  android:required=\"true\" />\n```\n\n你要是能把这一行加到 `<manifest>` 标签外面，我觉得你也没必要写代码了……但这个要放在 `<application>` 标签的外面，具体放在哪直接翻我仓库里的文件好了，比我用文字描述清晰的多。\n\n但是下面这个要加到 `<application>` 标签的里面：\n\n```xml\n<service\n  android:name=\".GLWallpaperService\"\n  android:permission=\"android.permission.BIND_WALLPAPER\">\n  <intent-filter>\n    <action android:name=\"android.service.wallpaper.WallpaperService\" />\n  </intent-filter>\n  <meta-data\n    android:name=\"android.service.wallpaper\"\n    android:resource=\"@xml/wallpaper\" />\n</service>\n```\n\n看到那个叫 `android:name` 的属性了吗，`.` 不能少，后面的名字则是一会你的 class 叫什么名字这里就什么名字。然后别的都是套路，可以不管，除了那个 `@xml/wallpaper`，这玩意要自己写。\n\n在你侧栏找到 `res` 目录，如果底下没有叫 `xml` 的目录的话，你就新建一个。然后你刚才那里斜杠后面是什么你就建立一个叫什么的 xml 文件，比如我写了 `@xml/wallpaper`，那就建立一个 `wallpaper.xml` 的文件，内容如下：\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<wallpaper\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:thumbnail=\"@drawable/ic_icon\"\n  android:description=\"@string/wallpaper_description\"\n  android:settingsActivity=\"xyz.alynx.livewallpaper.MainActivity\" />\n```\n\n这里面也有些地方需要改，首先那个 `@drawable/ic_icon` 是你这个程序在系统的动态壁纸列表里面的图标（然而大部分定制的系统都忽略了这玩意），你可以用 Android Studio 在 `res/drawable` 目录下面生成一个，这个可以自己去查官方文档，`ic_icon` 要换成你生成的文件的名字。`@string/wallpaper_description` 则是你的程序在列表里的名字或介绍，这个格式的意思是去 `res/values/strings.xml` 或者其他语言的 `strings.xml` 里面找字符串（写过点复杂程序的人应该都懂吧！不懂自学去！我这不是教你怎么写代码！），你可以用 Android Studio 的字符串编辑器添加一条，然后把这里的键改成你添加的。最后一个 `settingsActivity` 是干嘛的呢？在预览动态壁纸的页面会有个设置按钮，如果你的动态壁纸可以设置参数，点击那个按钮会跳进动态壁纸设置页面，设置页面就是在这里指定的类，因为我设置项不多直接放菜单里了，所以我写的是直接跳进 `MainActivity`，你写的时候也可以这样，但记得换成你的包名（不换的人我怀疑你没写过 Java，那你学个毛 Android App 开发？）。\n\n废话终于说完了可以写代码了好开心啊……\n\n# 然后你看见网上一堆胶水代码……\n\n如果你找过网上的教程，你会觉得视频壁纸是很简单的，他们都告诉你播放视频有现成的组件，你只要写几行胶水代码把它和壁纸连起来就行了……\n\n行个头！要是那么简单我就不用写这一篇文章了好吗？\n\n我们先从最基础的知识开始，动态壁纸实际上是一个 `Service`，你去实现一个 `Service`，然后系统来调用，你需要继承一个叫做 `WallpaperService` 的类，实现里面的一些方法。但实际上这个类只是个包装，真正的工作代码是里面一个叫 `Engine` 的类，具体的动态壁纸实现都是在它里面。\n\n所以你需要建立一个随便你爱叫什么的 java 文件（我不会用 Kotlin，但你愿意的话也可以用）来存放你自己的 `Service`……或者用 Android Studio 的向导也不错。比如我的就叫 `GLWallpaperService`，里面的代码看起来大概像这样：\n\n```java\npackage xyz.alynx.livewallpaper;\n\nimport android.service.wallpaper.WallpaperService;\n\npublic class GLWallpaperService extends WallpaperService {\n    public class GLWallpaperEngine extends Engine {\n\n    }\n\n    @Override\n    public Engine onCreateEngine() {\n        return new GLWallpaperEngine();\n    }\n}\n```\n\n所以你看，你只需要实现 `WallpaperService` 的一个方法，就是在系统需要 `Engine` 的时候，返回你自己的 `Engine` 实例。\n\n然后你需要在你的 `Engine`（我的是 `GLWallpaperEngine`）里面实现一些系统要求的方法，我们先说最基础的几个：\n\n```java\n        @Override\n        public void onSurfaceCreated(SurfaceHolder surfaceHolder) {\n            super.onSurfaceCreated(surfaceHolder);\n        }\n\n        @Override\n        public void onVisibilityChanged(boolean visible) {\n            super.onVisibilityChanged(visible);\n        }\n\n        @Override\n        public void onSurfaceDestroyed(SurfaceHolder holder) {\n           super.onSurfaceDestroyed(holder);\n        }\n        @Override\n        public void onOffsetsChanged(\n            float xOffset, float yOffset,\n            float xOffsetStep, float yOffsetStep,\n            int xPixelOffset, int yPixelOffset\n        ) {\n            super.onOffsetsChanged(\n                xOffset, yOffset, xOffsetStep,\n                yOffsetStep, xPixelOffset, yPixelOffset\n            );\n        }\n```\n\nAndroid 的动态壁纸实际上是一个 `Surface`（Android 的 `Surface` 你可以理解为画布……大概吧），系统调用你的 `Engine`，然后给你一个可以绘制的 `SurfaceHolder`，你只要往这个 `SurfaceHolder` 里面的 `Surface` 画东西就行了。`onSurfaceCreated()` 表示画布准备好了，`onVisibilityChanged()` 则表示画布看不见了或者又出来了，`onSurfaceDestroyed()` 表示画布没了（我不是你英语老师！），`onOffsetsChanged()` 则是桌面通知壁纸偏移量，通常是实现壁纸随桌面滚动的效果。\n\n不要把他们和 `onCreate()` 和 `onDestoryed()` 搞混了，那俩说的是 `Engine`，但我们做绘制工作时候操心的是画布。\n\n为什么说是个胶水代码呢……因为 Android 内建了一个播放器叫 `MediaPlayer`，它有个方法叫 `setSurface()`，可以把视频渲染到画布上，然后我们就美滋滋地看……到 bug。\n\n怎么设置 `MediaPlayer` 我就不讲了，因为网上有很多现成的，总之就是实例化设置静音设置来源再 `setSurface(getSurfaceHolder().getSurface())`（`getSurfaceHolder()` 是 `Engine` 的，可以获取当前的 `SurfaceHolder`），然后开始播放，你需要在 `onSurfaceCreated()` 的时候弄出个播放器，`onSurfaceDestroyed()` 的时候 `release()` 掉播放器，然后在由可见变成不可见的时候保存进度删掉播放器（其实暂停也行，但是暂停仍然占据着资源），在可见时候建立播放器并回复到之前的进度（如果看不见了还一直播，你手机的电池估计坚持不了几小时）。反正代码网上一大堆，我就不贴了。\n\n然后你就可以运行这个程序啦，如果你用的模拟器，你就美滋滋的发现，你的视频被硬生生压缩或拉伸成了桌面比例，视频比例没了。大部分视频应该都是横向更长一点，而手机竖向长，所以……\n\n如果你开始翻文档，你会发现一个 `setVideoScalingMode()` 的方法，可以设置为 `FIT_WITH_CROPPING`，你想着这不就是我们要的效果嘛：把视频放屏幕中间，然后裁出正中间最大的一块……当然不行啦！不然我写什么！\n\n很高兴告诉你这个其实是包装了系统的 `MediaCodec` 的参数，但这个实现及其不靠谱，比如在模拟器上这个功能根本就没实现！在我的 Galaxy S9+ 上虽然实现了，但在切换界面的时候（比如锁屏啦，打开应用界面啦），会突然变成没有剪裁的，总之你会看到一个奇怪的切换（这哪个程序员写的出来祭天）。\n\n所以如果你想正确剪裁视频的话……当然要自己动手！Android 的 `View` 是可以设置尺寸缩放没错，但是别忘了，这里只有 `Surface`，没有 `View`，所以没戏。用 CPU 剪裁视频的话（剪裁不是剪辑！）怕是你一帧剪完那边 30 帧都播完了，解决方案就是用 OpenGL ES 来进行这个操作。\n\n# 明明是杀鸡，还是得掏牛刀！\n\n如果你比较熟悉 OpenGL 的话，其实这个剪裁本身的难度比构建一个 OpenGL 环境的难度低的多……只要算一下比例做个缩放矩阵就行了，视频是矩形所以我们就先弄个正方形出来然后把每一帧解码的画面当成纹理贴上去。\n\n解码的工作我们可以交给 `MediaPlayer`，然后因为性能需要，我们不能每一帧都保存为图片然后再转读为 OpenGL 的纹理，Android 有一个 OpenGL 的扩展，可以把视频解码到的 `Surface` 作为一个纹理，大部分机型都支持，不支持的机型其实也可以告别动态壁纸了，啥都不支持，你还不给我钱，我为啥要给你写代码？\n\n但是这个过程需要一些 hack。\n\n显然系统不给你现成的 `GLSurfaceView`，而只是一个 `SurfaceHolder`，所以正常的思路是自己弄 `GLThread` 白手起家……并不，我们在 `Engine` 里插入下面的代码：\n\n```java\n        private class GLWallpaperSurfaceView extends GLSurfaceView {\n            private static final String TAG = \"GLWallpaperSurface\";\n\n            public GLWallpaperSurfaceView(Context context) {\n                super(context);\n            }\n\n            @Override\n            public SurfaceHolder getHolder() {\n                return getSurfaceHolder();\n            }\n\n            public void onDestroy() {\n                super.onDetachedFromWindow();\n            }\n        }\n```\n\n看到那个 `getHolder()` 了吗？没错！`GLSurfaceView` 似乎内部自己有个 `SurfaceHolder`，我们 hack 一下它，扩展出一个 `GLWallpaperSurfaceView`，因为它是个内部类，当它要往自己的 `SurfaceHolder` 上渲染时，我们偷梁换柱，返回它 `Engine.getSurfaceHolder()`，可怜的家伙还蒙在鼓里，自己内部的 `SurfaceHolder` 已经没用了，现在它画的实际上是桌面壁纸的 `Surface`。\n\n我也不知道谁先想出的这个套路，但第一个想出这个办法的老哥可真是个天才。\n\n至于你问 `Context` 从哪来？`Service` 就是个 `Context`，所以你改写一下 `Engine` 的构造函数把 `Service` 传进去，然后创建 `GLWallpaperSurfaceView` 时传给它就行了，基本操作基本操作。\n\n然后我们就可以实现 `GLSurfaceView.Renderer` 了，这是个已经包装好的 OpenGL Renderer，我们只要负责在里面画就行了。至于 GLES 的版本，如果你想省事，只用 v2 就好了，除非像我一样对 v3 很熟悉，当然我 v2 v3 都写了 Renderer，能支持 v3 的先调用 v3（除了模拟器不支持，手机基本都支持了）。我这里用 v3 做例子，你应该自己也会写 v2 吧？如果你只会写固定管线，请你不要说自己会 OpenGL。\n\n当然最好在 `AndroidManifest.xml` 声明一下你这个应用需要的 GLES 版本：\n\n```xml\n<uses-feature\n  android:glEsVersion=\"0x00020000\"\n  android:required=\"true\" />\n```\n\n如果你只支持 v3，就把 2 改成 3。\n\n（已经进入这个阶段了，打算拿这个当“我的第一个 Android App”的同学就自己退出吧。）\n\n我直接帖完整代码解释好了，因为实在是不好一点点讲了，反正会写 OpenGL 的人应该也能理解这种程度的代码了。\n\n我先把 Shader 代码贴上来，我是把它们放在 `res/raw` 下面的，Android 会自动生成 `R.raw.` 的 ID。\n\n- vertex shader\n\n```glsl\n#version 300 es\n\n// Some Android phone driver needs to put pre-processor in the first line. (e.g. Huawei Kirin)\n\nlayout(location = 0) in vec2 in_position;\nlayout(location = 1) in vec2 in_tex_coord;\n\nuniform mat4 mvp;\n\nout vec2 tex_coord;\n\nvoid main() {\n    gl_Position = mvp * vec4(in_position, 1.0f, 1.0f);\n    tex_coord = in_tex_coord;\n}\n```\n\n应该在你画三角形的时候就学会这玩意了吧？注意有些手机的实现要求第一行不能是注释，否则会报错。\n\n- fragment shader\n\n```glsl\n#version 300 es\n#ifdef GL_OES_EGL_image_external_essl3\n#extension GL_OES_EGL_image_external_essl3 : require\n#else\n#extension GL_OES_EGL_image_external : require\n#endif\n\n// Some Android phone driver needs to put pre-processor in the first line. (e.g. Huawei Kirin)\n\nprecision mediump float;\n\nuniform samplerExternalOES frame;\n\nin vec2 tex_coord;\nout vec4 frag_color;\n\nvoid main() {\n    frag_color = texture(frame, tex_coord);\n}\n```\n\n注意开头的判断！本来在 GLESv3 里面，对这种 Android 直接拿 `Surface` 当纹理的 flag 是 `GL_OES_EGL_image_external_essl3`，`GL_OES_EGL_image_external` 已经被废弃了，但有些支持 GLESv3 的手机只支持旧的表达方法，所以我们判断一下就好。GLESv2 则直接用后面那个，不要用前面的。\n\n同样，纹理类型也要换成 `samplerExternalOES`，别的都没关系了。\n\n编译和链接的过程我直接写成工具函数了，连同加载 `res/raw` 的代码，我贴上来：\n\n```java\nstatic int compileShaderResourceGLES30(\n    @NonNull Context context,\n    final int shaderType,\n    final int shaderRes\n) throws RuntimeException {\n    final InputStream inputStream = context.getResources().openRawResource(shaderRes);\n    final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n    String line;\n    final StringBuilder stringBuilder = new StringBuilder();\n    try {\n        while ((line = bufferedReader.readLine()) != null) {\n            stringBuilder.append(line);\n            stringBuilder.append('\\n');\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        return 0;\n    }\n    final String shaderSource = stringBuilder.toString();\n    int shader = GLES30.glCreateShader(shaderType);\n    if (shader == 0) {\n        throw new RuntimeException(\"Failed to create shader\");\n    }\n    GLES30.glShaderSource(shader, shaderSource);\n    GLES30.glCompileShader(shader);\n    final int[] status = new int[1];\n    GLES30.glGetShaderiv(shader, GLES30.GL_COMPILE_STATUS, status, 0);\n    if (status[0] == 0) {\n        final String log = GLES30.glGetShaderInfoLog(shader);\n        GLES30.glDeleteShader(shader);\n        throw new RuntimeException(log);\n    }\n    return shader;\n}\n\nstatic int linkProgramGLES30(\n    final int vertShader,\n    final int fragShader\n) throws RuntimeException {\n    int program = GLES30.glCreateProgram();\n    if (program == 0) {\n        throw new RuntimeException(\"Failed to create program\");\n    }\n    GLES30.glAttachShader(program, vertShader);\n    GLES30.glAttachShader(program, fragShader);\n    GLES30.glLinkProgram(program);\n    final int[] status = new int[1];\n    GLES30.glGetProgramiv(program, GLES30.GL_LINK_STATUS, status, 0);\n    if (status[0] == 0) {\n        final String log = GLES30.glGetProgramInfoLog(program);\n        GLES30.glDeleteProgram(program);\n        throw new RuntimeException(log);\n    }\n    return program;\n}\n```\n\n当然还是那个令人头疼的问题，你需要传个 `Context`，这个问题不大，`Engine` 创建 `Renderer` 的时候传给它就好了。\n\n`Renderer` 则是按下面的写：\n\n```java\npackage xyz.alynx.livewallpaper;\n\nimport android.content.Context;\nimport android.opengl.GLSurfaceView;\nimport android.support.annotation.NonNull;\n\npublic class GLWallpaperRenderer implements GLSurfaceView.Renderer {\n    private static final int BYTES_PER_FLOAT = 4;\n    private static final int BYTES_PER_INT = 4;\n    private Context context;\n    private FloatBuffer vertices;\n    private FloatBuffer texCoords;\n    private IntBuffer indices;\n    private float[] mvp;\n    private int program = 0;\n    private int mvpLocation = 0;\n    private int[] textures;\n    private SurfaceTexture surfaceTexture = null;\n    private int screenWidth = 0;\n    private int screenHeight = 0;\n    private int videoWidth = 0;\n    private int videoHeight = 0;\n    private int videoRotation = 0;\n    private float xOffset = 0;\n    private float yOffset = 0;\n    private long updatedFrame = 0;\n    private long renderedFrame = 0;\n```\n\n上面这部份的变量都是一会要用到的，一会再说。\n\n```\n    GLWallpaperRenderer(@NonNull final Context context) {\n        this.context = context;\n\n        // Those replaced glGenBuffers() and glBufferData().\n        final float[] vertexArray = {\n            // x, y\n            // bottom left\n            -1.0f, -1.0f,\n            // top left\n            -1.0f, 1.0f,\n            // bottom right\n            1.0f, -1.0f,\n            // top right\n            1.0f, 1.0f\n        };\n        vertices = ByteBuffer.allocateDirect(\n            vertexArray.length * BYTES_PER_FLOAT\n        ).order(ByteOrder.nativeOrder()).asFloatBuffer();\n        vertices.put(vertexArray).position(0);\n\n        final float[] texCoordArray = {\n            // u, v\n            // bottom left\n            0.0f, 1.0f,\n            // top left\n            0.0f, 0.0f,\n            // bottom right\n            1.0f, 1.0f,\n            // top right\n            1.0f, 0.0f\n        };\n        texCoords = ByteBuffer.allocateDirect(\n            texCoordArray.length * BYTES_PER_FLOAT\n        ).order(ByteOrder.nativeOrder()).asFloatBuffer();\n        texCoords.put(texCoordArray).position(0);\n\n        final int[] indexArray = {\n            0, 1, 2,\n            3, 2, 1\n        };\n        indices = ByteBuffer.allocateDirect(\n            indexArray.length * BYTES_PER_INT\n        ).order(ByteOrder.nativeOrder()).asIntBuffer();\n        indices.put(indexArray).position(0);\n\n        textures = new int[1];\n\n        mvp = new float[] {\n            1.0f, 0.0f, 0.0f, 0.0f,\n            0.0f, 1.0f, 0.0f, 0.0f,\n            0.0f, 0.0f, 1.0f, 0.0f,\n            0.0f, 0.0f, 0.0f, 1.0f\n        };\n    }\n\n    @NonNull\n    public Context getContext() {\n        return context;\n    }\n```\n\n这部份很好懂吧？先处理 `Context`，然后我们准备 OpenGL 需要的坐标，正方形的模型坐标，纹理坐标，以及一个索引 buffer，不同的是在 Android 里面不用写 `glGenBuffers`、`glBindBuffer` 了，我们用 java 的 nio 准备数组，然后 Android 可以直接加载这里面的 buffer。（但是 mvp 矩阵仍然是数组。）\n\n当然，这里是没有 OpenGL 的上下文的，所以我们现在不能处理 OpenGL 的设置，需要实现下面这些方法：\n\n```java\n    @Override\n    public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) {\n        // No depth test for 2D video.\n        GLES30.glDisable(GLES30.GL_DEPTH_TEST);\n        GLES30.glDepthMask(false);\n        GLES30.glDisable(GLES30.GL_CULL_FACE);\n        GLES30.glDisable(GLES30.GL_BLEND);\n\n        GLES30.glActiveTexture(GLES30.GL_TEXTURE0);\n        GLES30.glGenTextures(textures.length, textures, 0);\n        GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textures[0]);\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_MIN_FILTER,\n            GLES30.GL_LINEAR\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_MAG_FILTER,\n            GLES30.GL_LINEAR\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_WRAP_S,\n            GLES30.GL_CLAMP_TO_EDGE\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_WRAP_T,\n            GLES30.GL_CLAMP_TO_EDGE\n        );\n\n        program = Utils.linkProgramGLES30(\n            Utils.compileShaderResourceGLES30(\n                context, GLES30.GL_VERTEX_SHADER, R.raw.vertex_30\n            ),\n            Utils.compileShaderResourceGLES30(\n                context, GLES30.GL_FRAGMENT_SHADER, R.raw.fragment_30\n            )\n        );\n        mvpLocation = GLES30.glGetUniformLocation(program, \"mvp\");\n        // Position is set in shader sources.\n        GLES30.glVertexAttribPointer(\n            0, 2, GLES30.GL_FLOAT,\n            false, 0, vertices\n        );\n        GLES30.glVertexAttribPointer(\n            1, 2, GLES30.GL_FLOAT,\n            false, 0, texCoords\n        );\n\n        GLES30.glEnableVertexAttribArray(0);\n        GLES30.glEnableVertexAttribArray(1);\n    }\n\n    @Override\n    public void onSurfaceChanged(GL10 gl10, int width, int height) {\n        GLES30.glViewport(0, 0, width, height);\n    }\n\n    @Override\n    public void onDrawFrame(GL10 gl10) {\n        if (surfaceTexture == null) {\n            return;\n        }\n\n        if (renderedFrame < updatedFrame) {\n            surfaceTexture.updateTexImage();\n            ++renderedFrame;\n            // Utils.debug(\n            //     TAG, \"renderedFrame: \" + renderedFrame + \" updatedFrame: \" + updatedFrame\n            // );\n        }\n\n        GLES30.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);\n        GLES30.glUseProgram(program);\n        GLES30.glUniformMatrix4fv(mvpLocation, 1, false, mvp, 0);\n        GLES30.glDrawElements(GLES30.GL_TRIANGLES, 6, GLES30.GL_UNSIGNED_INT, indices);\n    }\n```\n\n这部份方法看名字就能看出来，需要注意的是那个 `gl10` 是 GLESv1 的用法，至于 v2 和 v3 都改成静态类了，所以我们用不到它。既然是 2D 贴图，就不需要深度测试和背面剔除了。然后设置纹理参数时需要用 `GLES11Ext.GL_TEXTURE_EXTERNAL_OES`，这个和 shader 里面是关联的。（哪个家伙把 GLESv2 和 v3 都支持的变量归属到 `GLES11Ext` 的，出来挨打！），别的地方会 OpenGL 的人都能看懂吧？最后，只有这三个函数有 OpenGL 上下文，其它的里面不能执行 OpenGL 操作。\n\n绘图时候 **设置 mvp 矩阵不要用 nio 的 ByteBuffer**，虽然有一个多态函数可以用，但似乎那个函数不能工作，所以我直接使用了 float 数组。\n\n下面是一些针对这个程序用到的方法。\n\n```\n    @Override\n    void setSourcePlayer(@NonNull final SimpleExoPlayer exoPlayer) {\n        // Re-create SurfaceTexture when getting a new player.\n        // Because maybe a new video is loaded.\n        createSurfaceTexture();\n        exoPlayer.setVideoSurface(new Surface(surfaceTexture));\n    }\n```\n\n这里是让播放器把解码的目标位置设置成 `Renderer` 里面和 OpenGL 纹理绑定的 `SurfaceTexture` 上，这个类是 Android 专门设置用来干这个的，可以阅读手册。\n\n为什么是把播放器给 `Renderer` 让 `Renderer` 设置呢？因为 `Engine` 的生命周期里只用了一个 `Renderer` 但会经常释放重建 `Player`，每次都要重新建立对应视频大小的 `SurfaceTexture`，所以不能让 `Renderer` 暴露 `SurfaceTexture` 出去。\n\n我这里没有用 `MediaPlayer`，而是用了 Google 的 `ExoPlayer` 这个项目，具体原因一会再说。\n\n```\n    @Override\n    void setScreenSize(int width, int height) {\n        if (screenWidth != width || screenHeight != height) {\n            screenWidth = width;\n            screenHeight = height;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set screen size to %dx%d\", screenWidth, screenHeight\n            ));\n            updateMatrix();\n        }\n    }\n\n    @Override\n    void setVideoSizeAndRotation(int width, int height, int rotation) {\n        // MediaMetadataRetriever always give us raw width and height and won't rotate them.\n        // So we rotate them by ourselves.\n        if (rotation % 180 != 0) {\n            final int swap = width;\n            width = height;\n            height = swap;\n        }\n        if (videoWidth != width || videoHeight != height || videoRotation != rotation) {\n            videoWidth = width;\n            videoHeight = height;\n            videoRotation = rotation;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set video size to %dx%d\", videoWidth, videoHeight\n            ));\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set video rotation to %d\", videoRotation\n            ));\n            updateMatrix();\n        }\n    }\n```\n\n因为要计算缩放，所以我这里设置了两个方法，分别获取屏幕尺寸和视频尺寸。然后只要在每次尺寸变化时候重新计算矩阵就行了，因为不是经常变化，所以就不用每次绘制都重新计算。\n\n```\n    @Override\n    void setOffset(float xOffset, float yOffset) {\n        final float maxXOffset = (1.0f - (\n            (float)screenWidth / screenHeight) / ((float)videoWidth / videoHeight)\n        ) / 2;\n        final float maxYOffset = (1.0f - (\n            (float)screenHeight / screenWidth) / ((float)videoHeight / videoWidth)\n        ) / 2;\n        if (xOffset > maxXOffset) {\n            xOffset = maxXOffset;\n        }\n        if (xOffset < -maxXOffset) {\n            xOffset = -maxXOffset;\n        }\n        if (yOffset > maxYOffset) {\n            yOffset = maxYOffset;\n        }\n        if (yOffset < -maxXOffset) {\n            yOffset = -maxYOffset;\n        }\n        if (this.xOffset != xOffset || this.yOffset != yOffset) {\n            this.xOffset = xOffset;\n            this.yOffset = yOffset;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set offset to %fx%f\", this.xOffset, this.yOffset\n            ));\n            updateMatrix();\n        }\n    }\n```\n\n桌面在滑动的时候会调用 `Engine` 的方法告诉它滑动的值，为了实现视频随桌面平移的效果，我们可以在 `Engine` 里把值传给 `Renderer`，但我们要限制一下，偏移的位置不能超出视频尺寸，否则就出黑边了。\n\n```\n    private void createSurfaceTexture() {\n        if (surfaceTexture != null) {\n            surfaceTexture.release();\n            surfaceTexture = null;\n        }\n        updatedFrame = 0;\n        renderedFrame = 0;\n        surfaceTexture = new SurfaceTexture(textures[0]);\n        surfaceTexture.setDefaultBufferSize(videoWidth, videoHeight);\n        surfaceTexture.setOnFrameAvailableListener(new SurfaceTexture.OnFrameAvailableListener() {\n            @Override\n            public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n                ++updatedFrame;\n            }\n        });\n    }\n```\n\n需要注意这个函数里面的回调，为什么要设置一个计数器，而不是直接在这里执行 `SurfaceTexture.updateTexImage()` 呢？因为后者要求必须有 OpenGL 上下文……有上下文的只有之前的几个方法，其它是没有的。所以为什么这里用了两个计数器而不是一个 bool 变量呢（请自己回看 `onDrawFrame()` 函数）？因为这个 `SurfaceTexture` 内部似乎有排队机制，然后如果队列里有内容的话是不会调回调的……假如某一次传来了多于一帧，用 bool 变量翻转的时候就只能解决第一帧，后续视频就会卡住（这都是什么神仙写的 bug 啊喂！）。\n\n```\n    private void updateMatrix() {\n        // Players are buggy and unclear, so we do crop by ourselves.\n        // Start with an identify matrix.\n        for (int i = 0; i < 16; ++i) {\n            mvp[i] = 0.0f;\n        }\n        mvp[0] = mvp[5] = mvp[10] = mvp[15] = 1.0f;\n        // OpenGL model matrix: scaling, rotating, translating.\n        final float videoRatio = (float)videoWidth / videoHeight;\n        final float screenRatio = (float)screenWidth / screenHeight;\n        if (videoRatio >= screenRatio) {\n            Utils.debug(TAG, \"X-cropping\");\n            // Treat video and screen width as 1, and compare width to scale.\n            Matrix.scaleM(\n                mvp, 0,\n                ((float)videoWidth / videoHeight) / ((float)screenWidth / screenHeight),\n                1, 1\n            );\n            // Some video recorder save video frames in direction differs from recoring,\n            // and add a rotation metadata. Need to detect and rotate them.\n            if (videoRotation % 360 != 0) {\n                Matrix.rotateM(mvp, 0, -videoRotation, 0,0, 1);\n            }\n            Matrix.translateM(mvp, 0, xOffset, 0, 0);\n        } else {\n            Utils.debug(TAG, \"Y-cropping\");\n            // Treat video and screen height as 1, and compare height to scale.\n            Matrix.scaleM(\n                mvp, 0, 1,\n                ((float)videoHeight / videoWidth) / ((float)screenHeight / screenWidth), 1\n            );\n            // Some video recorder save video frames in direction differs from recoring,\n            // and add a rotation metadata. Need to detect and rotate them.\n            if (videoRotation % 360 != 0) {\n                Matrix.rotateM(mvp, 0, -videoRotation, 0,0, 1);\n            }\n            Matrix.translateM(mvp, 0, 0, yOffset, 0);\n        }\n        // This is a 2D center crop, so we only need model matrix, no view and projection.\n    }\n}\n```\n\n最后是计算矩阵，这里也很简单，只要注意计算时候，要分别以视频和屏幕最长的一条边作为单位一，然后分别缩放两者的另一侧，只是数学计算而已。然后为什么会有旋转呢？如果你不写旋转而又使用手机拍摄的竖屏视频做壁纸，就会发现方向是旋转了 90 度的，所以宽和高也都错了。原因是一些设备录像时候不会旋转帧内容，而是以传感器原生的方向存放像素，然后在视频 Metadata 里面记录一下旋转角度，由播放器做旋转。`MediaPlayer` 自己直接输出是会旋转的，但由于我们这里用它做解码器，所以它传过来的帧是原样的。\n\n解决方法是在 `Engine` 加载视频的时候先读取一下元数据，从元数据里获取视频的尺寸旋转量设置给 `Renderer`：\n\n```java\n        private void getVideoMetadata() throws IOException {\n            final MediaMetadataRetriever mmr = new MediaMetadataRetriever();\n            switch (wallpaperCard.getType()) {\n            case INTERNAL:\n                final AssetFileDescriptor afd = getAssets().openFd(wallpaperCard.getPath());\n                mmr.setDataSource(\n                    afd.getFileDescriptor(),\n                    afd.getStartOffset(),\n                    afd.getDeclaredLength()\n                );\n                afd.close();\n                break;\n            case EXTERNAL:\n                mmr.setDataSource(context, wallpaperCard.getUri());\n                break;\n            }\n            final String rotation = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION\n            );\n            final String width = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH\n            );\n            final String height = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT\n            );\n            mmr.release();\n            videoRotation = Integer.parseInt(rotation);\n            videoWidth = Integer.parseInt(width);\n            videoHeight = Integer.parseInt(height);\n        }\n```\n\n当然 `WallpaperCard` 是我自己封装的类，关系不大。总之是使用 `MediaMetadataRetriever` 就可以了。至于你说视频元数据和实际内容不符怎么办？那是用户问题，用户自己处理不好视频为什么要我来解决？随便让他拿电脑上修改一下好了。\n\n这些实际上是这个应用的核心内容，其它的播放之类的都大同小异，总之如果你实现了 OpenGL 的剪裁功能，应该就可以正常播放壁纸了。其它部分直接参考我的代码或者网上的样例就可以了。\n\n顺便说一下，`SurfaceTexture` 似乎会给一个纹理矩阵，但我试着用了一下发现并不是需要的效果……所以还是自己处理吧。\n\n# 然后声音又不对劲了……\n\n就算你给 `MediaPlayer` 设置了静音，还是不太对劲！正常来说在桌面按音量键设置的是铃声音量，为什么变成了媒体音量！\n\n这当然是因为虽然 `MediaPlayer` 虽然静音了，但还是占据着音频通道，我们都知道 Android 分为媒体、铃声、系统等音量通道，如果 `MediaPlayer` 一直占着媒体通道，其它的媒体 App 比如音乐播放器一类的就没有办法播放。\n\n使用 `MediaPlayer` 是没有解决办法的，因为它没提供关闭音轨的接口，一开始我差点基于 `MediaCodec` 自己编写一个视频播放器，但始终没办法把解码器从主线程转移开，而且 CPU 占用率很高。后来发现 `ExoPlayer` 有办法关闭音轨，所以我换成了 `ExoPlayer`。\n\n具体怎么引入 `ExoPlayer` 请参照官方文档，只要引入 `core` 部分就可以了。\n\n我这里给出一段用于关闭音轨的代码，网上不太好找：\n\n```java\n            trackSelector = new DefaultTrackSelector();\n            exoPlayer = ExoPlayerFactory.newSimpleInstance(context, trackSelector);\n            exoPlayer.setVolume(0.0f);\n            // Disable audio decoder.\n            final int count = exoPlayer.getRendererCount();\n            for (int i = 0; i < count; ++i) {\n                if (exoPlayer.getRendererType(i) == C.TRACK_TYPE_AUDIO) {\n                    trackSelector.setParameters(\n                        trackSelector.buildUponParameters().setRendererDisabled(i, true)\n                    );\n                }\n            }\n```\n\n主要是创建 Player 时候单独给它一个 DefaultTrackSelector。然后关掉音轨。\n\n这样大概就可以运行了，剩下的一些问题都和视频渲染无关。\n\n# 写 UI 也很麻烦！\n\n虽然我知道你肯定不满足只使用内嵌视频，但如果你像我一样写了个可以设置其它视频的 UI，就会遇到各种各样的问题。写 UI 的时候，你不是在编写回调函数，就是在调用回调函数的路上。\n\n最令人恶心的是 `Context` 管理，很多地方都需要 `Context`，但很多地方都没法传 `Context`，比如 Android 推荐你用 `Uri` 而不是直接用文件路径，但所有使用 `Uri` 的地方都要求你传 `Context` 来解析 `Uri`！比如我添加视频，需要解析 `Uri` 并生成缩略图，为了不阻塞线程，必须开启一个 `AsyncTask`，但是，`AsyncTask` 不能直接拿走 `MainActivity` 作为自己的 `Context`！必须要传弱引用，总之没有一个优雅的解决方案。\n\n再比如你需要一些在各个位置都能访问到的数据，你可以自己写一个 `Application` 类并给它静态变量，但是静态和动态不能互相交叉，也就是说你不能封装一个操作数据的同时需要访问 `Context` 的方法，所以很多地方就只能拆开写，没办法封装。\n\n以及列表和数据的绑定写起来真的很麻烦，说实在的，HTML 和 JavaScript 写 UI 真的比 Android 和 Java 舒服的多……\n\n顺便，你可能会想在 UI 里调用系统的动态壁纸预览，然后根据它返回的结果来设置选中的视频，但这个真的很不靠谱，比如某些版本的 MIUI 修改的预览器即使你点击了应用，它仍然会返回一个取消的结果。明明是 MIUI 的问题，却需要我来解决，我大概可以理解为什么 sway 的开发者大骂 NVIDIA 用户了。你们给了小米钱买它的手机和系统，然后小米造成的问题要我来解决，我一分钱都没有拿到，哪里来的义务和责任解决？？？\n\n当然我最后还是想办法绕开了，添加了一个单独的应用按钮，用户点击这个按钮就是忽略预览，直接设置为壁纸。\n\n动态壁纸预览器调用你的壁纸服务的时候，你的 `Engine` 里 `isPreview()` 方法会返回 `true`，可以根据这个判断是不是在预览状态。因为我只有一个壁纸服务，所以我做了一些判断，对预览和桌面分别做了一些不同了逻辑，以便防止预览的结果影响到本来桌面上的壁纸效果。\n\n最后要注意：你可以在 `Service` 里面访问 `Application` 的静态方法，但似乎你不能一直依靠这个。比如当你设置壁纸以后重启了，`Service` 会被启动，但这时似乎没办法访问到 `Application` 里的变量。我解决的办法是将数据写入到 `SharedPreference`，如果从 `Application` 加载失败就去读取 `SharedPreference`，但总之我没找到有关 `Service` 和 `Application` 会不会一起创建的说明，所以这部份的代码写的很混乱（也包含上面说的不能封装的原因）。\n\n# 一杯咖啡都没有……\n\n如果你只是觉得市面上所有的视频动态壁纸程序都太臃肿太不可靠（包括抖音和火萤）而想自己写一个，我建议你还是放弃，因为遇到的坑比你想象的多，解决起来也很麻烦。而且实际上，你完全可以使用我写好的程序。\n\n这个程序只有 3.06M，支持加载本地壁纸，支持平板电脑，支持壁纸滑动，不显示时自动暂停播放节约电量，严格遵循 Android 规范，没有任何敏感权限（比如联网和操作外置存储），不请求文件真实路径，测试下来功能基本没有问题。如果你还不放心，所有的代码都在 GitHub 上，我不怕你说我代码写的不好，你大可以看一遍有没有后门。\n\n你可以分别从 [GitHub Release](https://github.com/AlynxZhou/AlynxLiveWallpaper/releases/latest)，[Google Play](https://play.google.com/store/apps/details?id=xyz.alynx.livewallpaper) 和 [酷安网](https://www.coolapk.com/apk/xyz.alynx.livewallpaper) 下载这个应用。\n\n为了上架 Google Play 我支付了 25 美元申请了开发者账户，应用是免费的，但我放置了捐赠页面。不过已经有几百个下载量（大部分是酷安）之后，我还没有从这个应用里得到一点回报，如果你觉得应用不错并且手头宽裕，可以打开 App 赞助我一杯咖啡。毕竟解决上面提到的所有的坑并不容易。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"在中国 Android 环境下传个 APK 有多难","url":"/posts/Hard-to-Transfer-APK-with-Chinese-Android/","content":"事情的起因是这样的，我写了 [一个 Android App](https://livewallpaper.alynx.xyz)，打算把它发给更多的人试用，发给同学什么的都好说，但我想发给我妈用的时候遇到了一系列问题。我觉得恰好可以说一下在国内用 Android 环境是多么痛苦。\n\n<!--more-->\n\n首先尝试最简单的方法，**不是所有人都有 QQ，但差不多所有人都有微信**，特别是一些中年的亲戚，所以直接在微信里传送 APK 文件，然后失败了。**微信自作聪明地给 APK 加了 `.1` 的后缀名，不用想都知道理由：“哎呀我们的用户都是可爱的啥都不会的小宝宝，要为了他们安全考虑呢”。**\n\n微信失败了，那就换个方式吧，发个网址去下载 APK，应该就不会被改名了，所以我直接复制了 GitHub Release 的链接，然后大家一概回复：“这个网址打不开”。\n\n行吧，开个 GitHub 都要折腾来折腾去的地方学习写代码有多艰难我就不哭诉了，那我们换个网站，我记得两个月前酷安网还是可以在电脑上下载 APK 的，我就把我上架之后的链接发了过去。不一会我妈说：“你这个链接让我 **下载他的那个市场**，然后 **微信里要下载还得装 QQ 浏览器**”，我妈还是有在这个艰难环境下使用手机电脑的知识的，所以看到要装这些乱七八糟的就放弃了。\n\n打开电脑一看，没想到啊没想到，酷安你这个浓眉大眼的家伙也叛变革命了。我不知道是哪个闲鱼用多了自己脑袋都咸了的产品经理一拍脑袋删掉了网站的搜索框，然后又关掉了 APK 的下载渠道。为了秉持优雅，我就不在这里问候这个经理的家人了。\n\n事已至此，总不能用百度云吧？靠百度云的限速估计能下载到猴年，我觉得百度除了竞价排名技术，网盘限速技术也是独步全球，而且似乎百度云稍微大一点的文件就让你下客户端？虽然我对我应用的体积很有信心，但也不想再趟混水了。\n\n我不知道别的开发者怎么分发他们的安装包，但我不想备案，也不想为了 APK 一直掏钱供着一个国内服务器，而且 **要想在微信能访问域名，还得给腾讯交保护费，否则说你不安全**，去哪说理去？\n\n后来我还是把文件传到服务器上然后用 IP 做了个链接，我自己的电脑能下载，但 **微信内置浏览器就是不行**。\n\n我可以教我妈怎么找到微信的下载文件然后修改后缀名，但是别人呢？我妈想把这个应用介绍给身边人试试，有些人连文件管理都没开过，总不能一个一个教他们吧？打包更不现实了，**什么是 zip 什么是 tar 和你七大姑八大姨的工作生活可能一点关系都没有，当然也不是所有人工作都用 Email**，大家都要恰饭，生活已经很艰难了。\n\n别说多提交几个商店，每次发新版本 GitHub Google Play 和酷安三个一起更新填表就已经花了好多时间了，每个品牌的手机都非得做一个自己的商店，用户量不大要求还不少，谁有那好心一个个提交去。\n\n这肯定不是 Android 的问题，毕竟如果能用 Google Play 问题就不存在了，或者如果能用 Telegram 这种聊天软件也行，但如果你是鸡群里的鹤，怕不是会被鸡群起而攻之。至于 Firefox Send 什么的估计在国内也没戏。这个时候我甚至开始怀念 QQ 了，虽然流氓，但是还是能传文件的。\n\n但说到 QQ，我又想起了几年前的事情，我相当佩服 QQ 的开发者这种在一个软件里打两个包的技术，当你用 QQ 点开一个网页链接，然后点菜单选“用 QQ 浏览器打开”的时候，你会发现 QQ 内嵌了一个 QQ 浏览器 —— 怪不得 QQ 浏览器有脸说自己装机量第一，以前我以为是很多人蠢瞎了用这种垃圾，后来发现我失算了 —— 当然最魔幻的不止于此，这个内嵌的 QQ 浏览器版本当然是很旧的，所以你打开了之后它第一件事是让你下载安装最新的 QQ 浏览器 —— 你看一个人能装两个 QQ 浏览器，**发明这个技术的产品经理真是个小天才**，他推动了手机存储空间上升！跟他比起来苹果算个什么东西！\n\n现在 QQ 的体积还是巨无霸，这个按钮也依然在那里，大概 QQ 浏览器仍然嵌在里面吧，而且估计版本一直都没变过，毕竟能变成俩鸡蛋的双黄蛋大家都喜欢。祝 QQ 未来能把其他所有腾讯的应用都嵌进去，早日突破 1 GB 大关。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"GNOME 的修改开发与测试","url":"/posts/GNOME-Develop/","content":"对于一些 GNOME 比较核心的程序比如 GNOME Shell，调试的时候没办法简单的运行，需要构建一个隔离的环境然后替代系统的 WM。GNOME 项目使用 JHBuild 构建这个环境。我的系统是 Arch Linux，介绍一下中间遇到的一些问题。\n\n<!--more-->\n\n`gitlab.gnome.org` 这个网站国内访问很慢，而且 jhbuild 使用 git clone 有时候不会遵循 git 的代理设置（指 `git config --global http.proxy 'socks5://127.0.0.1:1080' && git config --global https.proxy 'socks5://127.0.0.1:1080'`），经常不好用，我家里的网又不太好。我改 GNOME Shell 代码只用了一小时，但下载和编译环境来测试用了两天一夜。\n\n我调试的是 GNOME Shell，首先按照 [说明页面](https://wiki.gnome.org/action/show/Projects/Jhbuild/Introduction?action=show&redirect=Newcomers%2FBuildSystemComponent%2FJhbuild) 安装 JHBuild，将安装到的 `~/.local/bin` 加入 PATH，然后建立 `~/jhbuild` 目录，运行 `jhbuild build gnome-shell` 会自动下载编译所有需要的依赖（大概 80 个）。\n\nJHBuild 编译下载一些包的时候经常会出问题，一般编译一个包有四个阶段：\n\n- `checkout`：clone 仓库，设置 origin，然后 fetch。\n- `configure`：运行 `autogen.sh`，`configure` 或者 `meson`。\n- `build`：`make` 或者 `ninja`。\n- `install`：就是 `install`，目的地是 JHBuild 的环境。\n\n按了 Ctrl+C 之后会给几个选项，第一个通常是继续当前阶段，第二个是进行下一阶段，第三个是放弃当前的包，第四个是开一个 shell 子程序，第五个是刷新配置文件，对于 JHBuild 不走代理 clone 没速度的时候可以先 Ctrl+C，然后开启 shell，自己手动 clone，然后 Ctrl+D 退出 Shell 回到 JHBuild，这时候会继续让你选择，如果是 checkout 的话选择继续当前阶段，它会发现你同步好了。\n\n如果是某个包需要特殊操作，默认的参数配置不过去的话，建议也是 Ctrl+C 开 shell 手动运行 `./autogen.sh` 之类的，然后选择下一阶段（`configure` 的下一阶段是 `build`），如果继续的话它会再 `configure` 一遍，就覆盖了你的。虽然可以在 JHBuild 配置文件里添加某个包的参数，但是似乎我也搞不清楚 JHBuild 什么时候重新加载配置，经常选了 5 它没变化，把配置文件对应的行删掉它又加上了之前的参数。\n\n反正 JHBuild 搞不定的都手动搞定然后切换下一阶段基本都可以。\n\n`colord` 这个包的 man page 构建时候依赖 `docbook-xsl-ns`，这个包在 AUR 里，但是装上了它也检测不到，所以建议添加 `-Dman=false` 到 `autogen.sh` 的参数，关闭 man page 的生成，反正也用不到（所以 Arch 官方的打包姬怎么打包的啊！）。\n\n`webkitgtk` 不负众望是编译起来最慢的，几年前用 Gentoo 的时候轻松两小时（我当时 Skylake 移动版 Xeon E3-1505M 可是最强的笔记本 CPU），最近有改善了，但还是要半个小时多。\n\n`ibus` 配置的时候需要加 `--with-ucd-dir=/usr/share/unicode/` 不然它默认去 `/usr/share/unicode/ucd/` 找文件但 Arch 打包的路径不是这个。\n\n`libgdata` 不支持 `automake-1.16`，需要降级到 1.15 来 configure，但是生成的 Makefile 有一句没展开的宏（我这里是 4141 行的 `@CODE_COVERAGE_RULES@`）（开发者出来修 bug ！），需要注释掉，然后 `make` 就可以过了，似乎没啥不利影响。\n\n`uhttpmock` 的来源 URL 搞错了，现在指向的旧的是被废弃的仓库，新仓库是 [这个](https://gitlab.com/uhttpmock/uhttpmock/)，需要修改 `~/.config/jhbuildrc` 添加 `branches['uhttpmock'] = ('https://gitlab.com/uhttpmock/uhttpmock.git', 'master')`。\n\n都编译完就可以用 `jhbuild run gnome-shell --replace` 启动你编译的版本了，其他的 GNOME 程序编译的也可以 run 比如 `jhbuild run dconf-editor`。但是用 wayland 会话似乎既不能直接运行 `gnome-shell --replace` 也不能 `gnome-shell --nested` （像 weston 小窗口一样，但 gnome-shell 有 lock），所以我用的 x11 测试。测试时候不要锁屏不要看 lookingGlass，锁屏了回去就会没法输密码解锁，看了 lookingGlass 之后我卡住了……测试完最好重启，不然似乎没啥简单办法回到你系统的程序里。\n\n没搞清楚怎么修改 jhbuild 的仓库来源，也就是说它只会去 GNOME/gnome-shell clone 但没法改成你 fork 的仓库，我只能把改过的文件复制到 `~/jhbuild/checkout` 目录下面对应的仓库里，然后 `jhbuild buildone -n gnome-shell`，`buildone` 的意思是不管其他依赖，只重新编译后面的（用 `build` 会依次检查依赖，很慢的！），`-n` 是就算仓库被改了也不要重新 `checkout`，不然你的文件就被覆盖回去了……\n\n哦对了，GNOME Shell 有个单独的 `gnome-shell-sass` 的仓库存放样式表（CSS/SASS），但看说明这是个只读仓库，是从 `gnome-shell` 里分离出来给别的扩展用的，所以直接修改 `gnome-shell` 里面的就好了。还有一般跟顶栏有关的 GSettings 选项都在 `org.gnome.desktop.interface` 下面，但是这些 schema 对应的 XML 文件都在一个叫 `gsettings-desktop-schemas` 的仓库里，所以需要去那边改。\n\n最后狠狠地吐槽一下砍掉 GNOME Shell 顶栏透明的老哥，为了一点点边缘情况（有人说高对比度颜色壁纸下看不清顶栏文字，但大部分人都看得清并且实在不行换壁纸呗！）就砍掉这个好评如潮的功能。我提了个添加一个 GSettings 选项，让顶栏根据选项决定是透明还是纯黑（壁纸看不清就设成纯黑呗），结果被这个老哥拒绝了，还说添加个选项只会阻止其他人修 bug……大部分人都不觉得这是个 bug 好吗？我不觉得程序识别壁纸颜色改变顶栏会比用户自己调更准确，Android 的变色顶栏过了这么久，在许多壁纸上也不能正确识别颜色，添加一个让用户自己选择的功能才会更方便。但我又不想因为一个奇葩老哥就放弃我这么久的 GNOME 使用习惯，看来还是等等看能折腾出什么名堂吧！\n\n等到 GNOME 3.32 释出稳定版之后我尽量生成一个透明顶栏的 patch 就好了，反正主要的代码都是前人做的，大概 Arch Linux CN 的源愿意接受一个新包。不要和那个奇葩老哥一样说为啥不写扩展，就算是程序员家里养的猫也该知道 GNOME Shell 扩展 API 经常变还经常把整个桌面搞崩，真亏他们好意思提出来！\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Linux 下面常见的代理设置","url":"/posts/Proxy-Settings/","content":"通常情况下在 Linux 下面配置好的是 socks5 代理（你懂的），但是这个代理并不能让所有程序自动走它，需要手动的做一些转换。\n\n<!--more-->\n\n# proxychains\n\nproxychains 通过 hook libc 里面网络访问的函数实现劫持流量经过代理，配置时首先编辑 `/etc/proxychains.conf` 添加一行有关自己的代理的配置比如\n\n```\nsocks5 [IP 地址] [端口号]\n```\n\n然后就可以将你需要走代理的程序跟在 `proxychains` 后面比如\n\n```\n$ proxychains wget google.com\n```\n\n# 环境变量\n\n有些奇葩的语言设计时完全静态链接，不会调用 libc 的运行时库（说的就是那个叫 go 的），因此没办法使用 proxychains 进行 hook。但对于命令行程序，通常有个约定，如果用户设置了 `http_proxy` 和 `https_proxy`，程序就会使用这个作为代理。可以在这两个里设置 socks5 代理，比如 `export http_proxy=socks5://127.0.0.1:1080`，但问题不是所有程序都支持 socks5 代理，所以需要一些方案将 socks5 转换成 http 代理。当然如果你遇到一个 go 程序不读取这两个变量怎么办？当然是在心里问候一下开发者先人。\n\n# privoxy\n\n我个人比较习惯使用 privoxy 做代理转换，当然能实现这个功能的程序非常多，privoxy 是其中一个，安装好之后修改配置文件，添加一行\n\n```\nforward-socks5   /               [IP 地址]:[端口号] .\n```\n\n然后使用 `systemctl start privoxy` 启动即可。\n\n# 桌面环境\n\n诸如 GNOME 和 KDE Plasma 等都在网络设置里提供了代理选项，按表格填写即可，对于一些内建代理支持的也可以同理比如 Telegram Desktop，本地的 socks5 代理是不需要填写用户名和密码的。对于另外一些同学想要使用 Automatic 的选项的，你需要生成一个 pac 文件，这个文件里记录了哪些网站需要走代理，可以搜索 `你用的 socks5 代理协议的名字` + `pac` 得到更多相关内容，然后在这个选项里填写以 `file://` 开头的 URL，支持的程序就会使用这个 pac。\n\n# 浏览器\n\n通常大家使用插件来调用代理，但如果你上一步设置了桌面环境的代理比如 pac，可以直接走系统代理。\n\n# 端口转发\n\n有时候你的网络很奇葩，连接所有代理服务器都很慢，可以通过一个国内服务器做端口转发，需要在国内服务器执行下列命令。\n\n## 开启流量转发\n\n```\n# echo \"net.ipv4.ip_forward=1\" >> /etc/sysctl.conf\n# sysctl -p\n```\n\n## 配置转发规则\n\n```\n# iptables -t nat -A PREROUTING -p tcp --dport [端口号] -j DNAT --to-destination [代理服务器地址]\n# iptables -t nat -A PREROUTING -p udp --dport [端口号] -j DNAT --to-destination [代理服务器地址]\n# iptables -t nat -A POSTROUTING -p tcp -d [代理服务器地址] --dport [端口号] -j SNAT --to-source [国内服务器地址]\n# iptables -t nat -A POSTROUTING -p tcp -d [代理服务器地址] --dport [端口号] -j SNAT --to-source [国内服务器地址]\n```\n\n然后修改你本地的 socks5 配置，IP 改为国内的服务器的 IP。如果国内服务器默认有防火墙（安全组），添加规则放行该端口（TCP + UDP）。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"WireGuard 配置与使用","url":"/posts/WireGuard-Usage/","content":"# 需求\n\n本来想给内网的树莓派做 frp 一类的公网映射以便能够在外面访问 Samba 服务器，但是后来想想似乎把设备暴露在公网不太安全。换个角度想，其实没有必要把树莓派映射出去，只要能够连接进来就好了。所以选用 VPN 建虚拟专用网就好了，这里使用的 WireGuard 将我的各个设备连到一个子网内部。\n\n<!--more-->\n\nWireGuard 的原理是使用一个公网服务器做 Endpoint，内网的数据通过该服务器进行转发，因此子网的各个设备可以没有固定的 IP，只要都能连接公网服务器就好了。\n\n# 安装\n\n由于不同的系统安装方法不一样，建议参照 [WireGuard 官网的安装说明](https://www.wireguard.com/install/) 和各个系统的 Wiki，Android 手机可以搜索下载 WireGuard 的 APK 进行安装。\n\n# 配置\n\n<div class=\"alert-blue\">以下部分内容参考自 <a href=\"https://wiki.archlinux.org/index.php/WireGuard\">WireGuard - ArchWiki</a>。</div>\n\n首先需要生成公钥和私钥，建议将其设置为只有拥有者才能操作，我这里放在 `/etc/wireguard` 这个目录里面，这个目录应该是只有 root 才可以访问的。**服务器和客户端都需要分别进行这一步**。\n\n```\n# cd /etc/wireguard\n# wg genkey | tee privatekey | wg pubkey > publickey\n```\n\n## 服务端\n\n然后需要手写配置文件，这一步对于服务端和客户端不一样，先进行服务端的配置。\n\n首先在 `/etc/wireguard` 目录下面建立 `wg0.conf`（如果你已经有一个了就 `wg1`，依此类推），服务端的配置文件内容看起来像这个样子：\n\n```\n[Interface]\nAddress = 10.0.0.1\nListenPort = 7456\nPrivateKey = [服务器的私钥]\nPostUp   = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\nPostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE\nDNS = 8.8.8.8\n\n[peer]\nPublicKey = [客户端 1 的公钥]\nAllowedIPs = 10.0.0.2/32\n\n[peer]\nPublicKey = [客户端 2 的公钥]\nAllowedIPs = 10.0.0.3/32\n\n[peer]\nPublicKey = [客户端 3 的公钥]\nAllowedIPs = 10.0.0.4/32\n```\n\n然后我们依次分析每个字段的内容，首先是 Interface，这个部分指的是 WireGuard 在本机上面的接口，它是以内核模块的形式工作的，`Address` 指本机在子网内的私有 IP 地址，我这里分配了保留段 `10.0.0.0/24` 作为子网网段（看不懂的自己去复习计网），你也可以用 `10.0.0.0/8` 这个网段再进行划分，这个主机地址是你自己随意分配的，只要不冲突就行。`ListenPort` 是监听的服务器 UDP 端口，这个也是自己设置，只要不冲突就行。`PrivateKey` 则是刚刚 **服务端** 生成的 `privatekey` 这个文件的内容。`PostUp` 和 `PostDown` 是配置 iptables 的命令，建议直接复制即可，如果你服务器的公网网卡不是 `eth0` 则需要自己修改。`DNS` 则是解析域名用的 DNS，这里直接使用 `8.8.8.8`。\n\n然后每一个 Peer 字段对应了一个客户端（或其他服务端，WireGuard 实际上是 P2P 的），需要分别将该客户端的 `publickey` 文件的内容贴到 `PublicKey`，以及需要转发到该客户端的流量的 IP 地址范围贴到 `AllowedIPs`，我这里直接给每个客户端设置固定的 IP，因此就写了 `10.0.0.2/32`（看不懂的自己去复习计网），意思是该客户端对应的 IP 就是这个，所有向这个 IP 发送的流量都会被转发到这个客户端。\n\n**每添加一个新的客户端，就要在这个文件里添加一个 Peer 字段**，然后设置 `PublicKey` 和 `AllowedIPs`。\n\n然后在服务器的 `/etc/sysctl.conf` 最后加上一句 `net.ipv4.ip_forward=1`，开启 IPv4 流量转发，然后运行下面的命令加载新设置：\n\n```\n# sysctl -p\n```\n\n## 客户端\n\n客户端也需要在 `/etc/wireguard` 目录下面建立 `wg0.conf`（如果你已经有一个了就 `wg1`，依此类推），内容看起来是这样：\n\n```\n[Interface]\nAddress = 10.0.0.4\nPrivateKey = [客户端的私钥]\n\n[Peer]\nPublicKey = [服务端 1 的公钥]\nAllowedIPs = 10.0.0.0/24\nEndpoint = [服务端 1 的公网 IP]:[服务端 1 的端口]\nPersistentKeepalive = 25\n```\n\nInterface 字段自然是客户端本机的设置，`Address` 还是给本机分配的 IP，这里要和服务器在同一个子网，并且要和服务器配置文件里允许的 IP 段对上。`PrivateKey` 则是刚刚 **客户端** 生成的 `privatekey` 这个文件的内容。\n\n然后通过添加 Peer 字段来添加服务端，服务端作为这个网络的出口和转发点，首先需要填写对应的 **服务端** 的公钥，然后这里的 `AllowedIPs` 设置的是 **该客户端有哪些 IP 段的流量要通过该服务端进行转发**，由于我只希望内网的流量进行转发，自然设置的是内网的 IP 段 `10.0.0.0/24`（看不懂的你计网挂科了！），然后需要设置 `Endpoint` 以便能正确的在公网上找到服务器（虚拟专用网，连不上网还哪来的虚拟网啊？），格式就是 `服务器公网 IP:你设置的监听端口`。`PersistentKeepalive` 则是用来保持连接的参数，直接复制即可。\n\n**如果你有多个服务器，就在这里添加多个 Peer**，分别设置不同的 `AllowedIPs` 让他们转发，但 **不需要让客户端之间互相添加 Peer**，本来我们要解决的问题就是客户端之间不能互相连接，所有的流量是经由公网的服务端进行转发才可以到达，公网的服务器是各个不固定的客户端的接头地点。所以只需要保证服务端和所有的客户端认识就可以了。\n\n# 启动\n\n在分别配置好客户端和服务端之后就可以启动了，这一步两边都一样。注意把 `wg0` 换成你配置文件的名字。\n\n```\n# wg-quick up wg0\n```\n\n然后使用 `wg` 命令可以查看状态，由于这些涉及到网络配置，都需要 root 权限。服务端和客户端输出的结果是不一样的，下面这个是我的笔记本输出的结果。\n\n```plain\n# wg\ninterface: wg0\n  public key: [不给你看]\n  private key: (hidden)\n  listening port: 51676\n\npeer: [不给你看]\n  endpoint: [不给你看]\n  allowed ips: 10.0.0.0/24\n  latest handshake: 1 minute, 41 seconds ago\n  transfer: 38.36 KiB received, 141.71 KiB sent\n  persistent keepalive: every 25 seconds\n```\n\n建立成功的话，子网之间是可以使用内网地址互相 ping 的：\n\n```\n$ ping 10.0.0.11\nPING 10.0.0.11 (10.0.0.11) 56(84) bytes of data.\n64 bytes from 10.0.0.11: icmp_seq=1 ttl=64 time=30.1 ms\n64 bytes from 10.0.0.11: icmp_seq=2 ttl=64 time=30.4 ms\n64 bytes from 10.0.0.11: icmp_seq=3 ttl=64 time=30.5 ms\n64 bytes from 10.0.0.11: icmp_seq=4 ttl=64 time=30.4 ms\n64 bytes from 10.0.0.11: icmp_seq=5 ttl=64 time=30.5 ms\n^C\n--- 10.0.0.11 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 11ms\nrtt min/avg/max/mdev = 30.133/30.393/30.521/0.209 ms\n```\n\n如果你确定没有问题，就可以使用 Systemd 管理连接，首先关闭刚才的连接：\n\n```\n# wg-quick down wg0\n```\n\n然后启动现成的 Unit：\n\n```\n# systemctl enable wg-quick@wg0 --now\n```\n\n# 后记\n\n如果你需要在内网之间传递数据，建议选择一个访问较快的服务器，因为数据转发要通过这个服务器。\n\n但如果你想使用 WireGuard 访问一些被河蟹的内容也可以，首先需要一个在海外的服务器，然后设置客户端该服务器的 `AllowedIPs` 为 `0.0.0.0/0`（意思就是所有 IP 都经过这个服务器转发啦！或者你知道该设置某些网段也行！或者避开内网和本地地址！我不建议用这个番茄！所以就写个最蠢的！），就可以了！记得不用时候关掉，不然一些国内 App 也会走海外的！\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"使用 Moment 处理 JavaScript 与 YAML 的时区转换","url":"/posts/JavaScript-YAML-Timezone-Moment/","content":"开始之前先来一段惊喜：我是在中国标准时间 21 点写的这篇文章，但我在 front matter 写的是 21:00:00 并解析为东京时间。\n\n<!--more-->\n\n今天想给 Hikaru 添加文章时间显示时区的功能，本来以为只要无脑调用 Moment.js 就好了，但发现其中坑有很多，本来我就很不擅长计算时区转换，难度变得很大，好在后来处理完了，记录一下遇到的坑。\n\n首先 Moment 是不支持地区解析和时区显示的，需要安装 `moment-timezone` 这个扩展包才可以处理，文档在[这里](https://momentjs.com/timezone/docs/)。\n\n然后就是 js-yaml 开发者认为是标准但我觉得是 Bug 的[问题](https://github.com/nodeca/js-yaml/issues/91)。我在 front matter 里写的时间是不包含时区的，比如 `2018-12-31 16:00:00`，按照正常的解析方式（就是直接 `new Date(\"2018-12-31 16:00:00\")`），应当把这个时间当作 localtime 来看待，也就是 UTC+8h 的时间，但偏偏 js-yaml 的开发者认为按照 YAML 标准应当把这个时间当作 UTC 来处理（问题是他 **根本解析不了附加时区的表示方式啊！**）然后时间就错乱了，不过还好，JS Date() 对象内置的 `getTimezoneOffset()` 方法可以获取到 UTC 与 localtime 的分钟差（和标注的 UTC+8h 正好相反，这个是 -8h，在这里正好把这个错误的 UTC 换算回正确的 UTC）。具体的代码如下。\n\n```javascript\nconst yaml = require(\"js-yaml\")\nconst d = yaml.safeLoad(\"2018-12-31 16:00:00\")  // -> 2018-12-31T16:00:00.000Z\nnew Date(\"2018-12-31 16:00:00\") // -> 2018-12-31T08:00:00.000Z\nd.getTimezoneOffset() // -> -480\nnew Date(d.getTime() + d.getTimezoneOffset() * 60 * 1000) // -> 2018-12-31T08:00:00.000Z\n```\n\n接下来遇到另一个问题，Nunjucks 似乎对传递参数有很大限制，比如 `moment` 既是函数也有成员，我没办法在 Nunjucks 里面调用它的 `moment.tz.guess()` 成员，所以只能把设置地区单独做成文章参数传进去。\n\n然后发现这样有一个问题，比如我在日本写文章的时间是 21 点，回到中国发布，它解析时会当成东 8 区的 21 点来解析，然后使用 `moment(\"2019-01-01 21:00\").tz(\"Asia/Tokyo\").format()` 时进行转换，将东 8 区（中国）的 21 点转换成东 9 区（日本）的 22 点。然而实际上我觉得更常见的是一个人在国外写了一篇文章，自然标注的是国外时间（谁叫 js-yaml 不支持时区记号呢！），然后用另一个参数注明自己现在的地区，这样回到自己的国家之后，发布时仍然以外国时区解析时间。\n\n很显然解决方案是要改变解析时间的时区，但似乎 JavaScript 并没有什么好的修改时区的办法，使用 `moment.tz(时间，地区)` 似乎可以限定解析的时区，但是直接像下面这样做完全没用。\n\n```javascript\nconst yaml = require(\"js-yaml\")\nconst moment = require(\"moment-timezone\")\nconst d = yaml.safeLoad(\"2019-01-01 21:00:00\")  // -> 2019-01-01T21:00:00.000Z\nconst newd = new Date(d.getTime() + d.getTimezoneOffset() * 60 * 1000) // -> 2019-01-01T13:00:00.000Z\nmoment.tz(newd, \"Asia/Tokyo\").toISOString() // -> 2019-01-01T13:00:00.000Z\nmoment.tz(newd, \"Asia/Tokyo\").format(\"YYYY-MM-DD HH:mm:ss z\")  // -> 2019-01-01 22:00:00 JST\n```\n\n它仍然是将 21 点当作东 8 区转换为东 9 区的 22 点了，时区完全没变，不然应该是有一小时的变化（从东 8 到 东 9），原因是如果一个时间已经标注了时区（各种合法的格式，比如 `JST`、`CST`、`+0800` 等，单独的 `Z` 在 ISO 标准里就表示 UTC，因此也算标定），Moment 就不会用程序员给定的地区做解析，而是用作输出时的转换（等价于 `moment(时间).tz(地区)`）（这么设计 API 的人你出来我保证不打死你）（我觉得我应该去看一眼那个叫 `You-Dont-Need-Momentjs`）的项目。\n\n解决方案似乎没什么特别优雅的，既然你不肯去掉，那我自己造一个没时区的字符串然后再解析一次呗。\n\n```javascript\nconst yaml = require(\"js-yaml\")\nconst moment = require(\"moment-timezone\")\nconst d = yaml.safeLoad(\"2019-01-01 21:00:00\")  // -> 2019-01-01T21:00:00.000Z\nconst newd = new Date(d.getTime() + d.getTimezoneOffset() * 60 * 1000) // -> 2019-01-01T13:00:00.000Z\nmoment.tz(moment(newd).format(\"YYYY-MM-DD HH:mm:ss\"), \"Asia/Tokyo\").toISOString() // -> 2019-01-01T12:00:00.000Z\nmoment.tz(moment(newd).format(\"YYYY-MM-DD HH:mm:ss\"), \"Asia/Tokyo\").format(\"YYYY-MM-DD HH:mm:ss z\") // -> 2019-01-01 21:00:00 JST\n```\n\n这样结果就对了。至于接下来你想用什么地区的时间输出无所谓，反正内部的时间已经改变了，不再是你本机的时间。\n\n新年新 Bug：当我在研究为什么我的生成器没有在首页生成这篇新文章半小时之后，我发现问题的源头是我把 `2019-01-01` 写成了 `2018-01-01`。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"StackHarbor 的 2018 尾记","url":"/posts/2018-Tail/","content":"![](2B.jpg)\n\n还没有到月亮升起的时候呢。\n\n<!--more-->\n\n不是所有特殊的日子都能让人开心，特别是对于一个记性不太好的人来说。虽然距离上一个这样标题的已经过了一年，但我似乎想不起来这一年有什么值得开心的事情。我是指那种能维持很久的开心，但是很遗憾似乎让人难过的事情总是能持续的更久一点。\n\n今年大概保证了一个月一篇 post 的频率，虽然有些月份就懒的什么也不想干，但回头翻一翻之前还有存货，让人变懒的原因不是无事可做，往往是由于各种没什么意义还不得不做的事情，一旦沉迷在这些事情里太久，就容易让人忘记自己应该做什么事情。\n\n似乎这一年来就一直不清楚自己该做什么，虽然对于自己不想做什么有清晰的了解，但是说到做什么，似乎每一件事都不是很容易完成，特别是一些没接触过的东西。而且糟糕的是我觉得这个状态还会继续存在下去——我还没搞到该死的创新创业学分！\n\n说句实在话，我不想当韭菜，也没当韭菜的成本。我还有好多事情没有完成呢！大概对于一棵韭菜来说，长得和其他韭菜不一样就是错误。\n\n所以说实话，最近没有什么值得开心的事情，更远一些也没有。\n\n如果从最早开始说的话，今年大概从 *空之境界* 开始，然后是 *Fate/Stay Night*，然后是 *Fate/Zero*。第一遍看空之境界的时候还不知道整个在说什么，只是模糊地觉得十分喜欢，最近又拿起来重新看了一遍，才发现一些不一样的意思。\n\n话说回来，虽然是第一次看，但是却有十分熟悉的感觉，大概是因为里面一些插曲早就不知道循环了多少个深夜的原因。总有一些旋律是停留在记忆里面的，理解它们从来就没有什么困难。\n\n然后是 Fate，最开始只是因为把 *卫宫家今天的饭* 当成泡面番来看的，没想到一下子就点开了一年霸权（真·年番）。当然看过 Stay Night 之后和没看之前看这部的感觉是不一样的——一同经历过很多，怎么能不留下些痕迹呢——大概和所有人一样，只要看到他们还在一起就满足了。\n\n然后大概 Unlimited Blade Works 线的动画从音乐上整个就输给了 Fate 线动画，除了 LAST STARDUST 是确确实实的超水平，believe 和 ring your bell 表现实际很一般（这里一般的意思就是指没什么第一遍就吸引人的地方）。Fate/Zero 也是完完全全的超出 Unlimited Blade Works 的音乐（只要把满天拉出来就可以吊打了），至于 2019 年 1 月 11 日的 Heaven's Feel……我并不是樱厨，所以大概这条线不适合我吧。还有 *幻想嘉年华* 大概和卫宫家今天的饭是同一水平的作品，太严肃了也是很累的。至于 *Fate/Apocrypha*？这不是讲的莫德雷德和狮子劫界离的故事嘛？写的挺好的！就是 23 集就完结有点奇怪……后面还做两集多余的骗收视率嘛？（摸着良心说，阿福这个配角也挺可爱的。）\n\nFate 系列其他的作品就没看过了，我觉得也没有看的必要，FGO 从看完 Stay Night 开始玩，到现在也差不多没什么动力了（主要是懒），反正一年过去了，我还是没有抽到蓝呆毛。（93 连抽！279 个石头！一个五星都没有！）虽然金卡有了一大堆一般的本也都轻轻松松，但是我还是很想要蓝呆。（无独有偶，信用卡我也只拿到武藏的，没有蓝呆。）明年有第六七章的动画化，第七章我只是觉得故事性很好，但第六章的动画是我最期待的。\n\n导致不开心的大概是在我重新开始听 Kalafina 的时候听见了 Keiko 退出的消息，完全不愿意回想这件事发生的前后过程。无论希望还是失望也都已经过去了，那剩下的复杂的感情又是什么呢？与其空怀希望，不如让时间回到一切还没发生的时候，重来一遍的话，我应该不会错过那些不该错过的机会了吧。与已经得不到的相比，每天都在重复的无聊事情有什么意义吗？\n\n顺便一提，假期之前通关了 NieR: Automata，但现在的我恐怕没有再来一次的勇气。\n\n也许我可以有更多的事情可以做，但是实际上我只有两个作品，一个是现在正在用的主题 ARIA，某种程度上它和我的想法一样简单，本来就是非常简单的逻辑嘛。这个东西写的非常直白，样式也全部是我自己完成的，不会出现什么奇怪的乱七八糟的调用。也没有对一些历史垃圾进行没必要的适配，直接采用最合适的技术，去掉那些对内容没什么帮助还消耗资源的东西就好了。\n\n还有一个是 Hikaru，基于和上面类似的原因，我对 Hexo 也有一定的不满，虽然看起来其它的让我更没什么兴趣。于是大致按照逻辑设计了自己的生成器，并且给它起了我最喜欢的歌手的名字。这个程序也是一样的直白，反正只是生成一遍页面而已，没有必要搞什么乱七八糟的数据库嘛，就算有必要也可以直接上 SQLite（当然我没有，而是直接用对象引用了）。包括一些乱七八糟的模板里的工具，总之是把所有不符合自己习惯的地方都改了一遍。截至目前一切工作的都很良好，甚至一些我开始不知道怎么实现的地方也都工作了。我也并不觉得需要有多少多少人来用它，只要满足我自己用就行了，至于别人，随意。\n\n然后大概就是换手机，一加 3T 使用了两年已经是伤痕累累，但是看起来又没什么符合要求的手机，一加的后几代产品完全就是“不讲究”，MIX2S 看起来不错但没有耳机孔也没有防水，而且我并不是很喜欢 MIUI，Pixel 3 的性价比完全就是冲着“有种别买”去的，何况这个价格一旦出了问题没保修就要了命了。**反正我都是晚上充电，充的太快反而让我不放心，快充完全没什么需求**，所以最后考虑加钱买 Galaxy S9（因为 128G 的 S9+ 实在是超出预算了），但是看到 S9+ 有 64G 的版本（反正可以插存储卡），同时 4G 内存实在是太小，咬咬牙就 S9+ 了，反正有奖学金和上个月的结余。别问我 6k+ 为什么不买 iPhone，我考虑了一下，这东西我拿来完全不能用（**没文件管理** 怎么愉快的用 Samba 在 Arch 和手机之间交换文件，以及 Shadowsocks 处理起来也很麻烦，我也不可能因为一个 iPhone 迁移我整个生态和习惯，顺便还 **没有耳机孔**，以及 **被限制的 NFC**，也 **不能随便外接 U 盘**……），所以还不如当它不存在，不存在的东西就不考虑了，这样一来 Galaxy S9+ 就变成了第一档配置的选项。\n\n拿到 S9+ 以后才发现多出来的价格完全没有白花。对我来说这个手机唯一的缺点就是这个曲屏太难贴膜以及担心摔碎（所以想办法搞了碎屏险）。至于其它的完全 OK，防水是一个平时我不会故意去用（我不洗手机！）但总能让人很安心的功能，双摄也是到手了之后发现 2X 变焦在拍猫的时候很有用（不用担心追的太近猫猫跑掉了），指纹识别在后面总比没有要强（毕竟我很讨厌实体按压 Home 键），有 NFC，屏幕水平中规中矩（手机居然可以切换分辨率你敢信！平时用 1080P 就很清晰了。），可以插存储卡，耳机孔绝对是加分项目，特别是 **随包装送了 AKG 耳机、USB-C 到 MicroUSB 的转接头，USB-C 到 USB-A 的转接头（本来是换机助手用的，但完全可以用来接 U 盘）、透明手机壳甚至还有无线充电器（聊胜于无，对我来说只是多了一个充电的位置，角度什么的并不十分合适）**，甚至似乎还可以一边接收 WiFi 一边开热点（！！！）。另外软件上也和当初的 TouchWiz 有天壤之别，整个系统的动画很复杂，可配置项多到根本翻不完（对我来说这是优点），比如我喜欢返回键在左侧（OK），还可以设置桌面下拉通知栏，**不但可以设置是否显示二级菜单（二级菜单爱好者手动吐槽一众国产和 iPhone），甚至可以设置是手势开启二级菜单还是单独图标（可惜图标不能换位置，不过反正我用手势）**，桌面可以横屏……以及 Android P 的更新……顺便还有能解决毒瘤但是又不过分突出的智能管理器（真的好用，不是假的，实名推荐），连我这种原生党也非常满意。甚至在 Note 9 上用任意线缆就能开启 DeX 的特性也在 Android P 通过软件更新就实现了（在 S9 上 **不是硬件限制**！三星也 **没有强行要求你买他自家底座** 的意思！亲测完全没有阉割。），手动 @ 某没良心配件厂一下。\n\n最后一个月稍微有点安慰的就是又看了一部 9.8 分的番（上一个 9.8 的是卫宫家今天的饭），*青春猪头少年不会梦到兔女郎学姐*，真正的高情商男主和真正的高情商女主以及不狗血的爱情故事让人实名羡慕啊，顺便樱岛麻衣真可爱！回头再看看某些废物后宫男，整个的质量已经是在恶心人了，要不是为了明年的电磁炮，谁会花钱看这种东西啊喂！都不是小学生了，天天比这个强比那个强算战斗力有意思吗？\n\n总而言之，幸福的事情都是相似的，不幸的事情则各有各的不幸，某种程度上来说，**幸福的事情并不在于事情本身，而是在等待这件事情到来的过程中**，就像一个慢慢升起的气球，当它上升到看不见的时候，反而会有难以掩盖的失落感。反正天下没有不散的宴席，幸福的事情也总会结束，也许是如此人们才会给自己一个又一个理由让平凡的日子变的不平凡，好有下一个盼头支撑自己活下去。但是回过头来看，这些事情又留下了什么呢？\n\n已经是月亮升起的时候了，何等愚蠢而幸福的人啊！\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"C 语言学习 1","url":"/posts/Learning-C-1/","content":"\n这个是给 2018 级 C 语言辅导准备的文档，写来写去写了好多，索性在网站也发一份。有很多是我觉得老师不会讲，但一开始很难理解，不理解又听不懂的，有学 C 的可以看一看。\n\n<!--more-->\n\n# 基础中的基础\n\n计算机只能识别机器码，机器码对程序员不友好，肯·汤普森和丹尼斯·里奇为了能更容易编写 UNIX，设计和实现了 C 语言。\n\n## 从代码到程序\n\nC 语言本质上是纯文本（就是所谓的 txt 文本文件），使用扩展名 `.c` 和 `.h` 主要是为了能够让人从名字上识别这是 C 源码或头文件，你可以使用任何能够编辑文本的程序编辑 C 语言。\n\n编写 C 程序主要有下面几个步骤：\n\n1. 用任何你喜欢的文本 **编辑器** 编写代码（记事本也行，但很难用）。\n2. 调用 **编译器** 将程序员能看懂的代码翻译成机器码组成的程序。\n3. 运行程序，得到结果。\n\n## 名词解释\n\n- 编辑器：用来编写代码，可以是任何能编写纯文本文件的程序（Word 这类程序生成的并不是纯文本）。\n- 编译器：用来翻译代码到机器码，属于比较复杂的程序，通用的有微软的 MSVC，GNU 的 GCC 或者 LLVM 配套的 clang。\n- 集成开发环境（IDE）：一种集合了文本编辑和编译代码功能的程序，通常还会集合一些附加的功能比如调试等。其中编译代码的功能通常是调用上面提到的那几种编译器进行。\n\n**注意**：IDE 并不是编写代码的必需品，只要能编写文本又能调用编译器就可以写程序，因此不要问诸如“要用 VS 写 C 语言，那 VS 是用什么写的？写 VS 的公司是神吗？”这种 **弱智** 问题。没有 C 或者 C++ 很可能就不会有 VS，但是没有 VS 依然可以写程序。\n\n**注意**：不建议使用 VC++ 6.0 编写 C 程序，**这个程序的年龄比在座各位都大**，当时 C 语言还没有完整的标准，和我们现在的 C 相差很多。并且实际上这是个 C++ 的 IDE，而 C 和 C++ **并不完全一样**，应该视为两种语言。\n\n可以使用 VS 或者 Code::Blocks 编写 C 程序，苹果 macOS 用户可以使用 Xcode，这些程序对于最新的 C 标准有着非常好的支持。\n\n**注意**：对于 VS 用户需要注意默认 VS 会要求你使用它私有的一些函数而不是标准的 C 函数，这个需要在代码开始添加一行 `#define _CRT_SECURE_NO_WARNINGS` 来关闭。对于 Code::Blocks 用户请下载集成了编译器的安装包（简而言之，体积最大的），否则你下载下来以后会发现自己并没有编译器，没法编译代码。\n\n## 学习 C 语言的正确方法\n\n多写，多练，光动脑不动手什么语言都学不会，可以从模仿别人的代码开始：\n\n1. 首先对照别人的代码，自己完整的输入一遍程序，这里不是要你复制粘贴，当你能正确的输入程序的时候，说明你已经记住了 C 的结构，不会漏掉分号或者括号等。\n2. 然后阅读代码，并推测这段程序会得到什么结果。然后运行代码\n3. 如果和你预测的结果不一样，研究为什么不一样。\n4. 修改代码中的某一部分，然后重新进行 2 3 4 步，直到你已经完全掌握了这个程序的功能。\n5. 接下来你可以尝试自己从头写一份代码解决问题了。\n\n# 语法基础\n\n对于计算机最基础的功能自然是做计算，所以 C 语言需要有 **数字** 和 **符号**（必须是英文符号）两种组成成分。\n\n## 数字\n\n没什么好说的，你可以直接写十进制的数字，但是如果你想写十六进制的数字，只要以 `0x` 或 `0X` 开头就行，比如 `0x1F` 就是 31，八进制则是以 0 开头，比如 `076` 就是 62。\n\n## 运算符\n\n最基础的运算符自然是加减乘除，即 `+`、`-`、`*`、`/`。（除号这个方向叫斜杠，`\\` 这个叫反斜杠。）\n\n求余数又叫做取模，符号是 `%`，比如 `5 % 2` 结果是 1。\n\n还有位运算 按位与 `&`，按位或 `|`，按位异或 `^`，左移 `<<`，右移 `>>`，它们处理的是内存中的二进制。\n\n然后是赋值运算符 `=`，这个符号 **将右边的值赋给左边**，因此左边必须是变量，右边必须是有值的表达式（表达式的概念往后看），比如 `2 = 1 + 1;` 很显然不行，2 不是变量，这里也不是比较相等。\n\n还有一些整合的运算符，比如 `+=`、`-=`、`*=`、`/=`，`x += 1` 就等价于 `x = x + 1`。取模和位运算也可以这样和赋值结合起来。\n\n然后是一些用来比较关系的符号，比如 大于 `>`，小于 `<`，等于 `==`（判断相等用两个等号），不等于 `!=`，大于等于 `>=`，小于等于 `<=`。还有逻辑运算符号 与 `&&`（同真则真），或 `||`（同假则假），非 `!`（反转）。\n\n在说明之前，需要先了解在 C 语言里什么是真，什么是假，简单来说，0 和所有等于 0 的值都是假，其他所有值都是真。对于关系运算，真返回 1，假返回 0。\n\n需要注意比如数学上的 `1 < x < 2`，在 C 语言中是不成立的，因为按照 C 的处理顺序，会先处理 `1 < x`，这个式子只可能是 0 或者 1，最后就变成 `1 < 2` 或者 `0 < 2`，永远是真的了。正确写法是 `x > 1 && x < 2`，使用逻辑运算。\n\n`a != b` 就等价于 `!(a == b)`。\n\n`,` 逗号运算符表示按顺序进行用逗号分隔的子表达式。\n\n`()` 小括号就如同数学中的括号一般改变运算顺序。\n\n`[]` 中括号用于取数组元素，比如取 数组 `arr` 的第五个元素（如果有）就是 `arr[5]`。\n\n`&` 用于获取一个变量在内存中的地址，而 `*` 用于通过地址获取该位置的值。\n\n`.` 用于通过结构体变量名字访问结构体内容，比如对于 `struct point` 变量 `point` 取 `point.position_x`。而 `*` 用于通过结构体指针取结构体内容，比如有指向 `struct point` 变量 `point` 的指针 `ptr`，可以 `ptr->position_x`。\n\n`++` 和 `--` 分别是让变量自增 1 和自减 1。\n\n`sizeof` 这个运算符会给出后面变量的类型或类型本身的字节数，比如 `sizeof char` 或者 `sizeof(char)` 值为 1。\n\n`?:` 是唯一一个三元运算符，使用类似于 `条件 ? 表达式1 : 表达式2`，如果条件为真，运行表达式1，否则运行表达式2。\n\n运算符有非常复杂的优先级顺序，在这里列出表格，建议经常查阅，如果你在写程序的时候遇到不确定的地方，**给你想先算的式子加上小括号总没错**。\n\n| 类别 | 运算符 | 结合顺序 |\n| :------------- | :------------- | :------------- |\n| 后缀 | `() [] -> . ++ --`  | 从左到右 |\n| 一元 | `+ - ! ~ ++ -- (type) * & sizeof` | 从右到左 |\n| 乘除 | `* / %` | 从左到右 |\n| 加减 | `+ -` | 从左到右 |\n| 移位 | `<< >>` | 从左到右 |\n| 关系 | `< <= > >=` | 从左到右 |\n| 相等 | `== !=` | 从左到右 |\n| 位与 | `&` | 从左到右 |\n| 位异或 | `^` | 从左到右 |\n| 位或 | `\\|` | 从左到右 |\n| 逻辑与 | `&&` | 从左到右 |\n| 逻辑或 | `||` | 从左到右 |\n| 条件 | `?:` | 从右到左 |\n| 赋值 | `= += -= *= /= %=>>= <<= &= ^= \\|=` | 从右到左 |\n| 逗号 | `,` | 从左到右 |\n\n**注意**：C 并没有用于计算类似于 x<sup>y</sup> 这种乘方的运算符，而是需要调用函数计算，这里没有 `**`，`^` 也不是用来算这个的。\n\n## 标识符\n\n除数字和符号之外，我们还需要更多的词语来给 C 中的东西起名字，这些词语被称为标识符，合法（说人话就是有效）的标识符需要满足以下两条要求：\n\n- 组成成分是 **字母** `A-Za-z`（区分大小写），**数字** `0-9`，下划线 `_`（下划线不是连字符 `-`，因为这个是加减乘除的减）。\n- 第一个字符必须是字母或者下划线，不能是数字（如果以数字开头，判断这个词到底是数字还是标识符就会变得很麻烦，所以不支持）。\n\n比如 `if`，`areYouOK`，`Areyouok`，`Dota2_357` 甚至是 `_`（单个下划线）都是合法且 **不同** 的标识符。\n\n**注意**：尽量不要在程序里使用中文，如果你实在不知道某个词怎么翻译成英语，用拼音也可以勉强接受。**千万不要在程序里使用中文标点符号，它们和英文的标点符号是不同的字符，编译器不认识它们**。如果你经常分不清中文和英文标点符号，考虑更换你编辑器的字体。\n\n在大部分情况下，代码中连续的空白符（制表符 tab，换行符 newline 和空格 space）会被当作一个空白处理，因此写几个空格都是无关紧要的。\n\n## 关键字\n\n在合法的标识符的基础上，C 语言规定如下的标识符是它自己 **本身** 用到的词，这些词 **不能被用户或者其他的库用作名字**。最开始的 C 语言只有如下 32 个关键字：\n\n```\nchar        short       int        unsigned\nlong        float       double     struct\nunion       void        enum       signed\nconst       volatile    typedef    auto\nregister    static      extern     break\ncase        continue    default    do\nelse        for         goto       if\nreturn      switch      while      sizeof\n```\n\nC99 标准（就是 1999 年出来的标准）添加了这几个：\n\n```\n_Bool        _Complex        _Imaginary        inline        restrict\n```\n\nC11 标准（就是 2011 年出来的标准）添加了这几个：\n\n```\n_Alignas        _Alignof        _Atomic        _Generic        _Noreturn\n_Static_assert  _Thread_local\n```\n\n除去这些，其他都是用户可用的标识符，你可以给你的变量或者函数起任意满足标识符要求并且不是关键字的名字。\n\n**注意**：考试的时候看清楚题干要求，如果问的是 **标识符**，那么关键字也是正确的，如果问的是 **用户标识符、函数名或者变量名**，那就不能是关键字。\n\n## 关键字说明\n\n这次只说明一些基础的关键字，对于存储类别关键字暂时不做说明。\n\n### 数据类型关键字\n\n除了 `void` 这个特别的词用来表示“没有类型”，其它的类型关键字都有具体的指代。这些关键字用来标记内存中存储的数据类型是什么，基础的类型有下面几个:\n\n- `char`：长度为 1 字节，通常用来存储字符。\n- `short`：长度为 2 字节，用来存储短整数。\n- `int`：长度不确定，考试时候通常认为是 4 字节，通常用来存储整数。\n- `long`：长度不确定，通常用来存储长整数（大部分现代机器上，`int` 和 `long` 一样长）。\n- `long long`：长度为 8 字节，是 C 里最长的整数类型。\n- `float`：长度为 4 字节，存储单精度浮点数，通常精确度较低。\n- `double`：长度为 8 字节，存储双精度浮点数，精确度较高，开销略大。\n\n还有一些修饰这些类型用的关键字：\n\n- `signed`：这个数据可以表示带符号的数字，通常第一位用作符号位，总的数据范围一半正数一半负数（大部分数据类型默认就是带符号的）。\n- `unsigned`：这个数据表示的是不带符号位的数字，即只有 0 和正数，没有负数。例如 `unsigned int`。\n\n声明变量参照下面的 结构 部分。\n\n有关数据范围，对于整数，先把长度转成 bit 数，然后有多少 bit 范围就是 2 的多少次方，有符号数正负分别一半一半，负数比正数多一个数，无符号数则就是 0 到这个数。\n\n还有一个定义结构类型的关键字 `struct`，这个关键字用来定义结构体，结构体可以把一些数据打包在一起，构成一个独立的类型，比如\n\n```c\nstruct point {\n        int position_x;\n        int position_y;\n};\n```\n\n定义了一个结构体，以后就可以使用 `struct point` 作为一个新的数据类型。访问结构体使用 `.` 和 `->`。\n\n还有一个类型别名关键字 `typedef`，它用来给一个现有的数据定义一个别名，例如 `typedef float scalar;`，然后就可以用 `scalar` 作为一个类型，这个类型和 `float` 是一样的。\n\n有关数据类型还要注意一点，相同的数据类型进行运算，得到的类型还是原来的类型，如果是不同的数据，会向表示范围更大的数据类型转变。比如整数和短整数进行计算得到整数，整数和浮点数运算得到浮点数，双精度浮点数和单精度浮点数运算得到双精度浮点数。\n\n在将一个值赋给另一个值的时候类型会被转换成被赋值的数据类型，比如 `int a = 3.0;` 实际上 a 的值为 3。但上述的运算规则发生在赋值之前，因此就算你写 `float b = 5 / 2;`，b 的值也是 `2.0f` 而不是 2.5，因为首先 `5 / 2` 是整数除整数，得到的就是整数 2，2 转换成浮点数也是 `2.0f`，因此正确的写法是把 5 或者 2 中的一个改成小数比如 `float b = 5.0 / 2;`，此时是浮点数与整数运算，首先将整数 2 变成浮点数 2.0，然后得到 2.5。\n\n### 流程控制关键字\n\n#### 条件语句\n\n`if` `else` 的格式如下，如果条件为真，执行语句1，否则执行语句2，也可以不写 else 和语句2。\n\n```c\nif (条件)\n        语句1;\nelse\n        语句2;\n```\n\n嵌套的 `else` 会和最近的 `if` 匹配，除非使用大括号显式限制范围。\n\n```c\nif (条件)\n        if (条件)\n                语句1;\nelse\n        语句2;\n```\n\n上面这个 `else` 会和第二个 `if` 匹配，而不是第一个。\n\n```c\nif (条件) {\n        if (条件)\n                语句1;\n} else\n        语句2;\n```\n\n这个就和第一个匹配了。\n\n`switch` `case` 也可以用作条件判断，`switch` 后面必须接一个条件变量而不是条件语句（这个变量的值必须可以直接用 `==` 判断相等，很抱歉字符串不可以哈哈哈）。形式如下。\n\n```c\nswitch (条件变量) {\ncase 值1:\n        语句1;\ncase 值2:\ncase 值3:\n        语句2;\n        break;\ndefault:\n        语句3;\n        break;\n}\n```\n\n根据条件变量值的不同，会跳到不同的 `case` **向下执行**，重点是向下，也就是说如果匹配了值1，运行语句1后会向下运行语句2，只有在遇到 `break` 的时候才会跳出 `switch` 语句，同样不管匹配的是值2还是值3，都会运行语句2，如果没有匹配，会运行 `default` 标签下面的内容，当然也可以不写 `default`。\n\n#### 循环语句\n\n有三种循环语句，首先是 `while` 语句，语法如下。\n\n```c\nwhile (条件)\n        语句;\n```\n\n该循环会在条件为真时执行语句，条件为假则退出循环，每次循环都会先判断一次条件再决定是否循环。\n\n然后是 `for` 语句，语法如下。\n\n```c\nfor (循环开始前做一次; 条件; 每次循环结束都做)\n        语句;\n```\n\n该语句在循环开始前执行第一个分号前的内容 **一次**，然后判断条件决定是否进入循环，在每次循环中的语句结束后，都会做第二个分号之后的内容。如果不想做某一个部分，直接空着就可以，但要保留分号。比如下面的 `for` 循环就和 `while` 循环等价。\n\n```c\nfor (; 条件;)\n        语句;\n```\n\n最后是 `do` `while` 循环，用于需要先做一次循环内容再做判断的情况。\n\n```c\ndo\n        语句;\nwhile (条件);\n```\n\n```c\ndo {\n        语句1;\n        语句2;\n        语句3;\n} while (条件);\n```\n\n#### 跳转语句\n\n有四种跳转。\n\n`goto` 是无条件的基于标签的跳转。标签就是在某一句前写一个标识符然后加冒号。\n\n```c\n标签: 语句；\ngoto 标签;\n```\n\n这段代码会造成一个死循环，用于在这两句之间跳来跳去。**不建议使用 goto 语句，因为在程序里跳来跳去很容易让人逻辑混乱，从而无法调试**。\n\n`return` 语句通常用于在函数中返回一个值，比如 `return 0;` 返回整数 0，当函数返回之后，该函数就结束了，即使后面还有语句也会被忽略，如果不想返回值，直接 `return;`。\n\n剩余两种都是主要用于循环中的语句。\n\n`break` 用于打断一个循环，从循环中跳出来，比如下面的循环。\n\n```c\nfor (; 1; 语句)\n        break;\n```\n\n如果没有 `break` 这个语句是一个死循环并且每次都运行语句，但是有 `break`，第一次进入循环之后就跳了出来，不会执行语句。\n\n`continue` 用于跳过本次循环中的剩余部分，直接进行下次循环。\n\n```c\nfor (开始; 1; 语句1) {\n        语句2;\n        continue;\n        语句3;\n}\n```\n\n这个程序在执行完开始之后，每次循环都执行语句1，然后 `continue` 直接结束这次循环进入下一次，因此语句3就不会被执行，但对于 `for` 循环语句1会被执行。\n\n通常情况下，`break` 和 `continue` 都和 `if` 搭配使用，它们可以解决大部分情况而不需要 `goto`。\n\n## 结构\n\nC 程序主要包含以下部分：\n\n- 预处理器指令\n- 函数\n- 变量\n- 语句和表达式\n- 注释\n\n### 注释\n\n注释用于表示“这部份是给我自己看的，编译器并不需要这部份”，通常我们用它写一些提示自己的语句，编译器会忽略它们。写注释是个好习惯。\n\n第一种注释使用 `/*` 和 `*/`，凡是在这两个符号之间的都是注释，这种注释可以跨越多行。\n\n```c\n/*\n我是注释\n我是注释\n我是注释\n*/\n/*我是注释*/\n```\n\n第二种注释使用 `//`，它的范围是从 `//` 到这一行的结尾（换行符）。\n\n```c\n// 我是注释\n我不是注释\n```\n\n调试程序的时候也可以临时注释掉一部分问题代码，相比删除，这样可以随时恢复它们。\n\n### 语句和表达式\n\n表达式通常做一个动作并得到一个值（注意没有值也算是一种特殊的值），比如 `1 + 1` 是一个表达式，这个表达式的值为 2，表达式可以互相组合，比如 `(1 + 1) * 2`，这个表达式的结果为 4。\n\n需要注意一些特别的运算符表达式的值，比如我们令 `int i = 1;`。不管是 `i++` 还是 `++i`，执行结束后 i 都会变成 2，但是从表达式的值的角度来说，`i++` 这个式子的值是 1，而 `++i` 值是 2，`--` 同理。\n\n也就是说， `i++ == 1` 是 **真的**，`++i == 1` 是 **假的**，`++` 在前就先加后值，`++` 在后就先值后加。\n\n不要自作聪明，对于 C 语言标准，并没有规定诸如 `y=i+++++i`（其实就是 `y = i++ + ++i`）的运算过程。编译器可以认为这两个式子里的 i 都是 1，也可以认为一个是 1 一个是 2，还可以认为都是 2，那 y 就可能是 2 3 4 甚至是奇奇怪怪的不可预测的值。如果考试出现这种问题，建议直接告诉老师题有问题。\n\nC 语言规定语句以分号 `;` 结束而不是以换行符结束，因此你可以在一行里写多条语句，也可以在多行里写一条语句，编译器会阅读其中的分号。一个单独的分号也是一个语句——它什么也不做，我们叫它空语句。\n\n比如\n\n```c\n1 + 1; 2 + 2;\n```\n\n是两条语句。但是\n\n```c\n(\n        1 + 1\n) * 2;\n```\n\n是一条语句。\n\n对于 C 关键字中的流程控制关键字，通常它们的作用 **只能控制它们下面的一条语句**，大括号 `{}` 可以在文法上将几个语句结合成一个语句（说人话就是如果你想在这些关键字后面接两条或以上的语句，就要加大括号），例如\n\n```c\nif (true) {\n        do_one();\n        do_another();\n}\n```\n\n当然，一个空的大括号 `{}` 也是空语句。\n\n### 函数\n\n函数是 C 语言中最主要的组成部分，C 语言程序主要就是由各个函数组成。函数类似于数学中的函数，它们接受一些参数，然后做一些操作，最后返回 **一个** 值（C 限定函数只能返回单个结果或者不返回结果）。\n\n一个函数的结构通常是像下面这样\n\n```\n返回值的类型 函数名(参数类型 参数变量名, 参数类型 参数变量名)\n{\n        函数的内容\n}\n```\n\n返回值的类型限制了函数返回的数据的类型（说人话就是你前面写啥类型后面就得返回啥），如果没有返回值，这里使用 `void`。\n\n函数名则是一个用户标识符，然后在小括号 `()` 里放接受的参数列表，按照 `参数类型 参数变量名` 的格式，中间用逗号连接，如果不接受参数，这里使用 `void`。\n\n上面这一部分通常叫做 **函数头**。\n\n函数的内容放在大括号里面，这一部分也通常叫 **函数体**，在这里你可以写 C 语句。\n\n如果你指定了函数类型，函数内容里必须用 `return` 表达式返回一个对应类型的值，否则你会得到一个 Error。\n\n比如有一个限制为处理整数的数学函数 `f(x) = x * 2`，写成 C 的函数就是下面这样。\n\n```c\nint f(int x)\n{\n        return x * 2;\n}\n```\n\n### 变量\n\n变量对应着内存里的一块空间，里面存储着一些数据，必须 **先声明一个变量才能使用**，声明指定了变量的类型和名字。\n\n声明变量的时候使用类似这样的格式。\n\n```\n变量类型 变量名 = 初始值, 变量名 = 初始值;\n```\n\n首先是变量的类型，然后跟着变量名组成的列表，列表之间用逗号分割，也可以同时提供初始值，只需要使用 `=` 赋值，可以省略 `=` 和初始值，这时这个变量的值是 **不确定的**。\n\n例如 `int a, b, c = 2;`。\n\n题外话：建议给变量起个容易理解它是什么的名字，而不是一堆乱七八糟的字母，比如 `my_age` 就比 `x3` 更容易理解。在变量名里写上变量类型倒不是个好主意，因为稍微高级点的编辑器都能推导类型，这样写纯粹是浪费空间。\n\n变量是有作用域的，你不能在作用域外面调用作用域里面的变量，但反过来是可以的，也就是说作用域满足嵌套关系。\n\n同一个作用域里变量不可以重复声明，否则会得到一个 Error。但如果内层作用域声明了一个和外层重名的变量，内层的会暂时覆盖外层的，也就是说你暂时没办法访问外层的那个。\n\n通常来说，函数是一层作用域，然后则是对于每个判断或循环语句，它们的条件和它们控制的代码块（就是大括号里面）有一个单独的作用域。也就是说你在循环体里面声明的变量在外面是不能访问的。比如这段代码。\n\n```c\n// 你应该能看懂这个函数没有返回值也没有参数。\nvoid func(void)\n{\n        int x = 1; // 函数作用域。\n        int y = 2;\n        for (int x = 2; x < 10; ++x)\n                printf(\"%d %d\\n\", x, y);        // 这里会输出 2 2 到 9 2 共八行数。\n        printf(\"%d\\n\", x);        // 这里的 x 还是 1！\n}\n```\n\n如你所见，第一次我们声明的变量 x 和 y 属于函数作用域，随后 `for` 语句中声明的 x 就是循环代码块作用域了，这个 x 暂时掩盖了外面的 x，当离开循环之后，我们又访问到了函数作用域的 x。\n\n我们还可以一次批量分配多个元素，这种方式被称为数组，数组的声明方式通常是下面这样：\n\n```\n数据类型 变量名[数组长度] = {元素, 元素, 元素};\n```\n\n`=` 和后面的部分是为了进行初始化，当然你也可以不进行初始化。\n\n数组中的元素在内存中是连续的，当你想访问其中的某个元素，只需要使用 `数组名[元素序号]`。**这里的序号是从 0 开始的**！也就是说长度为 5 的数组，元素序号分别是 0、1、2、3、4。\n\n你可以写超出数组长度的序号，C 并不会阻止你这样做，但通常这样会触发一个错误，因为那个位置的内存并不一定让你访问。换句话说，C 语言相信你会限制访问的长度，所以它不进行限制。\n\n如果你在声明的时候没有进行初始化，那你以后就不能再像初始化元素一样给整个数组直接用 `=` 赋值了，具体的原因需要等讲过指针之后再进行说明。这个时候你可以给 `数组名[元素序号]` 进行单个的赋值。比如把 `arr` 的三个元素都设置成 0。\n\n```c\nint arr[3];\narr[0] = 0;\narr[1] = 0;\narr[2] = 0;\n```\n\n相比于在代码里书写多个变量如 `int a1, a2, a3;` 使用类似 `int arr[3];` 让我们有了在循环中处理它们的办法，你不能在循环中处理变量的名字（这可不是简单地拼字），但你却可以循环处理数组的下标。比如把 `arr` 的三个元素都设置成 0 还可以这样做。\n\n```c\nint arr[3];\nfor (int i = 0; i < 3; ++i)\n        arr[i] = 0;\n```\n\n### 预处理器指令\n\n严格来说，预处理器指令并不是 C 语言的一部分，它们在编译器最开始处理代码的时候进行工作，然后当编译器开始将代码翻译成机器码的时候，预处理器已经工作完毕了。\n\n预处理指令以 `#` 开头，每一行为一个语句，大部分预处理指令都是与文本替换有关。\n\n这里介绍几个简单的例子，复杂的后面会单独说明。\n\n`#include <文件名>` 表示将这个文件的内容插入到这一行的位置，一般用来引用头文件，`<` `>` 括起来的是系统的头文件名，如果引用的是自己项目里的头文件，则需要用 `#include \"文件名\"`。\n\n`#define 标识符1 标识符2` 表示在文件里所有出现的标识符2都会被替换成标识符1，比如下面的代码。\n\n```c\n#define PI 3.14\nint c = 2 * PI * 5;\nint s = PI * 5 * 5;\n```\n\n在编译器翻译代码到机器码的时候，它看到的代码其实是\n\n```c\nint c = 2 * 3.14 * 5;\nint s = 3.14 * 5 * 5;\n```\n\n# 示范\n\n## Hello world!\n\n好了，在介绍完这些复杂的东西之后，终于可以进行一个简单的程序示范了，现在书写一个 hello world 就不会遇到有哪里说不明白的情况。\n\n```c\n#include <stdio.h>\nint main(void)\n{\n        printf(\"Hello world!\\n\");\n        return 0;\n}\n```\n\n首先第一行的 `#include <stdio.h>` 表示我们把 `stdio.h` 这个头文件里的内容全部插入进来，`stdio` 表示 standard input output 即标准输入输出（这里的输入输出是从程序的角度）。C 语言自身标准规定了许多有用的内置函数给我们使用，但我们首先要在代码里声明它们，这个头文件就包含了一些函数的声明，后续会继续说明头文件的作用与内容。\n\n然后我们声明一个名称为 `main`，返回类型为 `int`，不接受参数的函数，这个函数是 C 语言规定的程序入口，也就是说操作系统运行你的程序，实际上是从调用 `main()` 开始的，这里需要注意的是在 C 语言标准中，`main()` 的返回值必须为 `int`，你可能见到过 `void main()` 或者干脆连 `void` 这种返回类型都不写的，这些都是错误写法，某些不标准的编译器可能支持，但实际上标准里没有它们，你在写代码的时候不能这么写。\n\n这个函数的内容只有两句，第一句 `printf(\"Hello world!\\n\");` 会在你的终端界面输出一句 `Hello world!` 并换行，在这个过程中我们调用了这个叫做 `printf()` 的函数，它是 C 标准库规定的格式化输出函数（f 可以理解成 format），但我们这次只是用它输出一条字符串，`\\n` 是一个转义字符，我们用它表示“回车”这个无法在代码里打出来的符号，如果你去掉它，然后再输出点什么，你会发现这两次的输出会出现在同一行里面——C 不会乱做任何你没让它做的事情。有关 `printf()` 和转义字符的更多内容，下次会进行介绍。\n\n对于字符串，你可以简单的理解为小说或剧本里面人物说的话，如果不用双引号，剧本里的文字就是叙述性的语句，并不会被观众得知，程序也是一样，不加双引号的均是程序代码，当你想跟用户交流，使用字符串吧。有关字符串的存储方式，也会在后续讲解。\n\n最后，`main()` 函数返回整数 0，这个返回值会被它上层的程序捕获（可以简单理解为操作系统），0 在这里约定是程序运行成功的意思，一个复杂的程序可能有多种多样的失败原因，这个时候我们可以用无数的非零值代表各种错误。\n\n还记得之前关于 `return` 的说明吗？如果我们把 `main()` 改写成下面这样。\n\n```c\nint main(void)\n{\n        printf(\"Hello world!\\n\");\n        return 0;\n        printf(\"老师永远也不会看见这句话。\");\n}\n```\n\n你有可能会得到编译器的警告，但它只是提醒你最后这句 `printf()` 不会被执行，如果你的老师不看源码，他/她永远也不知道这句话。（另外这句话输出之后并不会换行。）\n\n## 有关缩进\n\n缩进这个词有点陌生，程序员用它指代代码的排版格式，尽管 C 给了你把所有程序写在同一行里的能力，但我估计看过这种代码的人都想把作者打一遍出气。\n\n```c\n#include <stdio.h>\nint main(void){printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");return 0;}\n```\n\n当你写了一个复杂一点的程序的时候，有必要修理一下程序格式，让它变的更容易理解，我们在前面说过一个分层次的东西叫作用域，刚好可以利用它。我们可以在每一个作用域的内部语句的行首增加一定数量的空白，来突出层次感。比如在这段代码里指出一个错误\n\n```c\nvoid func(void)\n{\n        for (int i = 0; i < 10; ++i) {\n                for (int j = 0; j < 10; ++j) {\n                        for (int k = 0; k < 10; ++k) {\n                                if (0 = k % 2) {\n                                        printf(\"老师会看见很多次这句话。\");\n                                }\n                        }\n                        for (int k = 0; k < 10; ++k) {\n                                for (int l = 0; l < 10; ++l) {\n                                        if (l % 2 == 0) {\n                                                printf(\"老师会看见很多次这句话。\");\n                                        }\n                                }\n                        }\n                }\n        }\n}\n```\n\n就比在这段代码里\n\n```c\nvoid func(void){for(int i=0; i<10; ++i){for(int j=0; j<10; ++j){for(int k=0; k<10; ++k){if(0=k%2){printf(\"老师会看见很多次这句话。\");}}for(int k=0; k<10; ++k){for(int l=0; l<10; ++l){if(l%2==0){printf(\"老师会看见很多次这句话。\");}}}}}}\n```\n\n要容易的不止一点半点。\n\n通常这个空白是一个 Tab 按键，或者八个空格，或者四个空格，只要你的一份代码里选择其中一个就可以了，不要搞得参差不齐就行。\n\n通常还建议你只在一行里书写一个语句，因为你所看见的代码可能有误导性，比如\n\n```c\nif (条件) do_one();\n        do_another();\n```\n\n究竟哪个函数受到条件控制呢？现在也许你分得清，当你写了几百行代码后，可能你就感觉它开始辣眼睛了，建议你写成下面这样：\n\n```c\nif (条件)\n        do_one();\ndo_another();\n```\n\n还有一个建议是，虽然人们在左大括号放在上一行行尾还是单起一行的行首争论不清，但右大括号单独放一行总是没错的。左大括号的两种风格都是好的，你只需要坚持某一个风格就好了。\n\n```c\nif (条件) {\n        do_one(); }\n        do_another();\n```\n\n就不如\n\n```c\nif (条件) {\n        do_one();\n}\ndo_another();\n```\n\n二元运算符两侧建议加空格，比如 `int a = 1 + 1 * 3;` 就比 `int a=1+1*3;` 清晰。\n\n这些都只是建议，但当你写了一定数目的代码，它们能帮助你少犯乱七八糟的错误，别人读你的代码也会更容易。\n\n## 提问的艺术\n\n有时候你自己实在搞不清楚一个问题了，需要问别人。且慢！别人可能很忙，时间宝贵，在一大片代码里找出错的位置就像大海捞针一样愚蠢，特别是许多时候，编译器已经可以告诉你代码哪里错了的情况下。\n\n在 Google 上搜索“提问的艺术”能找到好多有用的东西，这里只说一条最重要的：**当你提问时，请贴上你完整的代码、编译器编译过程中输出的警告和错误（通常在 IDE 下面的小窗口里）以及你代码运行时的输出截图（如果程序通过了编译但运行出错了）**。\n\n最愚蠢的是只说一句没头没脑的“我代码错了！怎么办！”，你就是说一千遍，它还是错的。第二愚蠢的是说一句“我代码错了！我先干了什么什么后干了什么什么又怎么怎么样！”，你是要自己重新描述一遍？还是打算自己从嘴里重新发明个 C 语言？万一你犯的错误是漏了个分号或者括号，我不信你能用嘴描述一遍你代码里的所有分号的位置。\n\n贴上完整代码保证别人帮你除错的时候不需要回头问你然后等待回复，贴上编译器输出可以直接看到它提示的可能错误的位置（而不是一句一句去读去想），输出截图也是同样的道理。\n\n别人帮你是自愿花费他的时间，做到以上这一点至少能让别人帮你找错误更容易。\n"},{"title":"我们如何哭泣","url":"/posts/Too-Busy-for-Tears/","content":"![](1.jpg)\n\n九月的最后一天，我的网站突破了八万访问量。\n\n本来有好多可以随便写一点来掩盖自己“九月就要过去了我什么也没写”的恐慌感，比如接着写一篇有关怎么画立方体的 OpenGL 教程，比如还没有文档的 Hikaru 代码里有哪些奇怪的解决方案和奇怪的设定，比如我最近又写了什么乱七八糟的代码（没有）。\n\n但与其随便说说外界的事情，不如把自己随便想的东西写出来更加严肃。\n\n<!--more-->\n\n有时候常常因为太忙而忘记如何哭泣。尽管眼角的泪水会随着萧瑟的秋风流下，那里面有整个世界和它的影子，但却少了一些流泪的理由。\n\n是因为天边那抹如血般赤红而哭泣吗？\n\n我觉得自己常常陷入不该发生的慌乱之中。如果我有在事情伊始就洞察结局的能力，可能就不会如此慌乱。至少有些人的平静是因为他们预料到了所有可能的发展，而我不是，面对事情的平静往往只是外表而已，尽管有时候已经疲惫到无力，还是要装作一副一切尽在掌握的样子。\n\n能拯救自己的唯一途径也不过是不去回想而已，“随便你怎么样，过去了就好了”，是个万能的替代品。\n\n“如果一开始就能做到最好就好了。”\n\n“如果一开始就能发现问题及时退出就好了。”\n\n“如果一开始就能有最顺利的情况就好了。”\n\n反正这些都不可能，那有能够及时分辨现状并放弃的能力也是解药。与其在不擅长的事情里周旋，不如拿出勇气放弃掉，反正得不到什么，只要不失去什么就行了。\n\n所以你看我又在说一些没用的东西。它们完全没有让事情变的更清晰，反而让我的心情变的更佳糟糕。\n\n独居一室真是令人舒适。\n\n我又熬过了一个所谓“分别的季节”，真是万幸，不过话说回来，连分别都没有才是最难过的事情吧。想起那句话叫“十七岁有着七十岁的忧愁”，我已经过了这个年纪了啊。\n\n该如何才能有勇气在清晨的冷风中拥抱太阳。\n\n在晚上九点强说愁的人，只能写出这样糟糕的文章，那就是我。让人越来越忙是让他们闭嘴的好办法，因为他们闲下来就忘记了如何说话。反正什么都不能说，自然也没必要思考。\n\n技术文章会有的。\n\n希望在逐渐到来的冬季再次相遇，我们还有着尽情哭泣的能力。\n\nTears are our hardest word.\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"学习 OpenGL 1","url":"/posts/Learn-OpenGL-1/","content":"我花了好久来阅读和实践 [Learn OpenGL CN](https://learnopengl-cn.github.io/) 上面的 OpenGL 教程，尽管它是大家推荐的最容易懂也比较新的教程，里面一些东西还是会让人觉得一头雾水。我用了很长的时间来尝试那些教程没有写成文字的部分并确定它们是如何工作的。也许对于一个有足够经验的人来说这些看起来并不是什么大问题，但我觉得新人知道这些以后可以更快的继续学习，而不是花费时间在诸如“这段代码干了什么？”“为什么我的黑屏了？”“如果我想编写一个更复杂的图形程序，该怎么把这些复制过来的代码拆开？”的问题上。\n\n<!--more-->\n\n话先说在前面，虽然标题我写了 OpenGL，但是我实际上使用的是 OpenGL ES —— 你可以把它当作是 OpenGL 的一个子集，只包含基于可编程管线的部分 API，去掉了那些过时的旧模式。虽然 OpenGL ES 主要为移动设备设计，但是在电脑上也能正常使用。Wayland 和 Weston —— Linux 的下一代桌面协议以及它的简单实现 —— 为了去掉 Xorg 的依赖就使用了 OpenGL ES（Linux 下的 libGL 总会引入 X）。\n\n我使用的是 OpenGL ES 3，最新版本，而且我觉得这里的 OpenGL ES 程序只要做一点简单的改动就可以变成 OpenGL 的程序 —— 毕竟 OpenGL ES 使用的函数就是 OpenGL 的一部分。\n\n# OpenGL 是什么？\n\n简单来说，OpenGL 是一套 API（废话），它把你传输的三维坐标交给显卡运算并映射到显示器的二维平面上。实际上它仅仅做了这些 —— 和你的显卡交流。使用 OpenGL ES 3 的好处是它没有早期版本中 OpenGL 的立即渲染模式，通常来说这个模式很容易使用（就像 Canvas 绘图）但是效率低下。一些人不会使用核心模式（可编程管线）而是使用旧的模式也导致了所谓的 OpenGL 性能差，但实际上 OpenGL 只是一个规范，具体的性能很容易受到不同厂家实现不同编写人员的影响（给猴子一把磨得很快的斧头的直接后果很可能是猴子砍了自己的脚）。如果打开一份教程上面出现 `glBegin()`、`glEnd()` 我建议你立即关掉。\n\n# 创建窗口\n\n首先既然我们要绘图，需要先有窗口。窗口创建之后才可以创建一个 OpenGL 的 Context。对于这个需求不同的平台有不同的方案，比如 Windows 的 WGL，Xorg 的 GLX，以及为了独立于各个平台使用的 EGL（Wayland 为了摆脱 Xorg 使用的就是 EGL），但我们在这里使用一个简单高效的封装库 GLFW。\n\n首先需要你自己安装 GLFW 库到你的系统中，Linux 用户可以使用包管理解决这个问题，Windows 用户就需要自己下载并放置到你工具指定的位置了（注意头文件的位置并修改 IDE 的搜寻路径 —— 异常麻烦的事情）。\n\n对于 OpenGL 本身而言，如果你安装了 Mesa（Linux），你应该有一个开源的实现了。Windows 用户可能需要一些处理以保证自己用的是最新版本（据说微软为了推广 D3D 打压 OGL Windows 系统只包含旧的 OpenGL 库，不知道是不是真的），我没有在 Windows 下面编写过，不能给你建议。\n\n对于 OpenGL 大部分函数地址是运行时确定的（各个驱动的实现不一样），所以需要类似于 GLEW 或者 GLAD 之类的库来在代码中搜寻保存函数指针，但我这里使用 OpenGL ES 似乎是可以直接链接的，所以我没有使用（有错误请告诉我，我好改正）。\n\n然后我们打开一个 C 文件 —— OpenGL 库是用 C 编写再封装到其它语言的。\n\n```c\n#include <stdio.h>\n#include <stddef.h>\n#include <stdbool.h>\n#include <GLFW/glfw3.h>\n#include <GLES3/gl3.h>\n```\n\n这里很明显了。OpenGL 只是一个绘图 API，GLFW 同时帮你封装了有关键盘鼠标输入的部分，但是你需要给它实现一个回调函数。\n\n```c\nvoid key_callback(GLFWwindow *window, int key, int scancode, int action, int mode)\n{\n\tif (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS)\n\t\tglfwSetWindowShouldClose(window, true);\n}\n```\n\n只是简单实现了按 Esc 之后发送关闭窗口事件。然后我们编写 main 函数。\n\n```c\nint main(int argc, char *argv[])\n{\n\tglfwInit();\n\tunsigned int width = 800;\n\tunsigned int height = 600;\n\tGLFWwindow *window = glfwCreateWindow(width, height, \"learn-gles\", NULL, NULL);\n\tglfwMakeContextCurrent(window);\n\tglfwSetKeyCallback(window, key_callback);\n\n\t/* Code Here */\n\n\tglfwDestroyWindow(window);\n\tglfwTerminate();\n\treturn 0;\n}\n```\n\n先别急着编译它，因为你还没有正确链接。如果你编译好了，这个程序运行之后窗口一闪而过就会消失，但你已经完成了窗口创建。\n\n如果是 macOS 请在 `glfwInit()` 之后添加 `glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);`，并咒骂苹果为什么去掉了 OpenGL 支持。\n\n接下来我们进行 OpenGL 代码的编写。\n\n# 绘制三角形\n\n三角形是计算机图形学里基本的图元，更复杂的模型通常都是用三角形拼合的，这也是为什么人们会用 *每秒渲染多少个三角形* 来表示显卡性能。\n\n## 创建视口（Viewport）\n\n首先我们创建 OpenGL 的 Viewport，事实上不管你的窗口分辨率是多少，OpenGL 都会把这个平面映射到 `-1.0f` 到 `+1.0f`，你使用时候的坐标都是在这个范围内，而不是屏幕上的像素点数目。\n\n下面的代码需要插入到上面 `/* Code Here */` 的上面。\n\n```c\n\tglViewport(0, 0, width, height);\n```\n\n因为我们的程序太过简单，就不需要开启其它特性了，否则在这里你可以开启一些 OpenGL 的特性比如背面剔除（如果你玩 CS，你会发现死亡画面你的摄像机经常会穿进敌人体内，这时候敌人的后背变成了透明的，这就是背面剔除，可以减少绘制的图形的数量。\n\n## 大循环\n\n如果你对游戏引擎有所了解，应该知道整个流程就是一个大循环：引擎不断地绘制图案并把它更新到屏幕上，每一帧我们更新一些数据，就会形成动画。我们这里也是这样进行，在 `glViewport()` 和 `glfwTerminate()` 之间插入这个。\n\n```c\n\twhile (!glfwWindowShouldClose(window)) {\n\t\tglfwPollEvents();\n\n\t\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n\t\tglClear(GL_COLOR_BUFFER_BIT);\n\n\t\t/* Draw Here */\n\n\t\tglfwSwapBuffers(window);\n\t}\n```\n\n现在我们有一个大循环了，这个循环里首先拉取 GLFW 的事件以便响应（目前只有 Esc 退出），然后用黑色清除整个 Viewport（四个参数分别是 rgba，`0.0f` 是无色，`1.0f` 是满色），最后 GLFW 把绘制好的缓冲区交换到窗口上。\n\n现在你可以使用下面的命令编译并运行它了。会出现一个全黑的窗口。\n\n```\n$ cc -std=c11 -lglfw -lGLESv2 yourcode.c && ./a.out\n```\n\n![black.png](black.png)\n\nMesa 把 GLES 3 当作 GLES 2 的扩展，所以这里链接的是 `libGLESv2`。\n\n## 着色器（Shader）\n\n什么是 Shader？Shader 是一种运行在显卡上的小程序。首先你知道 CPU 一般是多核的，每个核心可以单独运行不同的程序。然而你的屏幕是由多个像素组成的，在运行游戏的时候每个像素的数据都需要单独计算，即使每个都是简单的乘法，CPU 也很难在短期内全部处理完毕（几十万个像素是很难由八个核心在 16ms 之内解决掉的），所以 GPU 为了解决这个问题，带有许多互相独立的小核心，每个核心的性能是远远不如 CPU 的，但它们处理的问题也没有 CPU 复杂，所以可以很快的处理掉屏幕上全部的像素。\n\n一般你的数据只会包含几个顶点的位置，这时候你可以编写小程序去处理这些顶点的数据，比如位移或者从数据中获取颜色，这一步的程序叫做 Vertex Shader（顶点着色器），然后 OpenGL 会把首先把这些顶点连接起来，再计算出中间的范围，对中间的部分进行插值，然后把它们映射到一个一个的像素点上，这个过程叫做 **光栅化**，然后接下来 GPU 中的每个小核心就开始单独处理一部分像素了，为了增加效率和创造更好地效果（光照效果之类的影响最终颜色的），你可以编写小程序交给这些小核心运行，这一步的程序叫做 Fragment Shader（片段着色器）（在 Direct3D 里面叫 Pixel Shader 像素着色器）。OpenGL 使用一种叫 GLSL 的语言编写着色器，在这一步你需要建立两个文件，首先是 `triangle.v.glsl`（名字可以随意）的顶点着色器。\n\n```glsl\n#version 300 es\nlayout (location = 0) in vec3 pos;\nlayout (location = 1) in vec3 color;\nout vec3 pass_color;\nvoid main()\n{\n\tgl_Position = vec4(pos, 1.0f);\n\tpass_color = color;\n}\n```\n\n第一行的预处理指令表明了我们使用的是 3.00 版本的 OpenGL ES，如果是 OpenGL 可以使用 `#version 330 core`，然后二三行声明了输入变量，前面的 `layout (location = 0)` 指定了它们的位置，也可以省略，但是就需要在程序里手动查找位置了。后面的 `in` 表明是输入变量，`vec3` 表明是由三个数字组成的向量，后面是变量名，我们用到了位置和颜色。然后下面 `out` 表明是输出变量，很明显 Vertex Shader 是不能控制颜色的，Fragment Shader 才控制颜色，所以我们在这里把传进来的颜色再输出，下一步传给 Fragment Shader。\n\n然后程序从 main 开始执行，这里 **不需要返回值**，`gl_Position` 是内置的变量，你需要把顶点的最终变换完的位置赋给它，这里我们没有变化，直接把三元坐标转换成四元的齐次坐标。然后把输入进来的颜色传出去。总之，如果你保证 Vertex Shader 输出的变量和 Fragment Shader 输入的变量名字一样，OpenGL 就会把它们连接起来。\n\n接下来我们建立 `triangle.v.glsl`，如下。\n\n```glsl\n#version 300 es\nprecision mediump float;\nin vec3 pass_color;\nout vec4 frag_color;\nvoid main()\n{\n\tfrag_color = vec4(pass_color, 1.0f);\n}\n```\n\n第二行表明的是设置精度为 `float`，OpenGL ES 要求 Fragment Shader 必须有这一条，标准 OpenGL 可以去掉，与 `gl_Position` 不同，为了满足多样化的需求，Fragment Shader 的输出变量需要自己声明，然后我们给输入的颜色加上 `1.0f` 的 Alpha 值输出。\n\n接下来类似于我们编译 C 程序的过程，不同的是我们要编写 C 代码读取文件，分别编译并链接为一个程序。我在这里直接给出我封装好的过程来简化代码量，具体说明参见注释。你可以把它们添加到 main 函数外面（上面）。\n\n```c\n#include <stdlib.h>\n#include <string.h>\n#define LINE_LENGTH 512\n\nGLuint make_shader(GLenum type, const char *const shader_src)\n{\n\tGLuint shader = 0;\n\tGLint compiled = 0;\n\t// 创建 shader。\n\tif (!(shader = glCreateShader(type))) {\n\t    fprintf(stderr, \"Shader Create Error.\\n\");\n\t    return 0;\n\t}\n\t// 加载 shader 内容。\n\tglShaderSource(shader, 1, &shader_src, NULL);\n\t// 开始编译。\n\tglCompileShader(shader);\n\t// 检查编译结果。\n\tglGetShaderiv(shader, GL_COMPILE_STATUS, &compiled);\n\t// 编译失败的话读取错误输出。\n\tif (!compiled) {\n\t    GLint info_len = 0;\n\t    glGetShaderiv(shader, GL_INFO_LOG_LENGTH, &info_len);\n\t    if (info_len) {\n\t\tchar *info = malloc(info_len * sizeof(*info));\n\t\tif (!info) {\n\t\t\tfprintf(stderr, \"Malloc Error.\\n\");\n\t\t\tglDeleteShader(shader);\n\t\t\treturn 0;\n\t\t}\n\t\tglGetShaderInfoLog(shader, info_len, NULL, info);\n\t\tfprintf(stderr, \"Compile Error: %s\\n\", info);\n\t\tfree(info);\n\t    }\n\t    glDeleteShader(shader);\n\t    return 0;\n\t}\n\treturn shader;\n}\n\nGLuint load_shader(GLenum type, const char *const shader_path)\n{\n\tGLuint result = 0;\n\tFILE *fp = NULL;\n\tsize_t file_length = 0;\n\tchar *file_content = NULL;\n\tchar temp_line[LINE_LENGTH];\n\t// 读取文件不用解释了吧……\n\tif (!(fp = fopen(shader_path, \"r\"))) {\n\t\tfprintf(stderr, \"Open file %s failed.\\n\", shader_path);\n\t\treturn 0;\n\t}\n\tfseek(fp, 0l, SEEK_END);\n\tfile_length = ftell(fp);\n\trewind(fp);\n\tif (!(file_content = malloc(file_length))) {\n\t\tfprintf(stderr, \"Malloc Error.\\n\");\n\t\tfclose(fp);\n\t\treturn 0;\n\t}\n\tfile_content[0] = '\\0';\n\twhile (fgets(temp_line, LINE_LENGTH, fp))\n\t\tstrncat(file_content, temp_line, LINE_LENGTH);\n\tfclose(fp);\n\tresult = make_shader(type, file_content);\n\tfree(file_content);\n\treturn result;\n}\n\nGLuint load_program(const char *const vshader_path, const char *const fshader_path)\n{\n\tGLint linked = 0;\n\tGLuint vshader = 0;\n\tGLuint fshader = 0;\n\tGLuint program = 0;\n\t// 加载类型为 GL_VERTEX_SHADER。\n\tvshader = load_shader(GL_VERTEX_SHADER, vshader_path);\n\t// 加载类型为 GL_FRAGMENT_SHADER。\n\tfshader = load_shader(GL_FRAGMENT_SHADER, fshader_path);\n\tif (!vshader || !fshader)\n\t\treturn 0;\n\t// 创建 Shader Program。\n\tif (!(program = glCreateProgram())) {\n\t\tfprintf(stderr, \"Program Create Error.\\n\");\n\t\treturn 0;\n\t}\n\t// 给 Program 添加 Shader。\n\tglAttachShader(program, vshader);\n\tglAttachShader(program, fshader);\n\t// 将两个 Shader 链接成 Program。\n\tglLinkProgram(program);\n\t// 链接完成可以删除 Shader 了。\n\tglDeleteShader(vshader);\n\tglDeleteShader(fshader);\n\t// 检查链接状态。\n\tglGetProgramiv(program, GL_LINK_STATUS, &linked);\n\t// 链接失败读取错误输出。\n\tif (!linked) {\n\t\tGLint info_len = 0;\n\t\tglGetProgramiv(program, GL_INFO_LOG_LENGTH, &info_len);\n\t\tif (info_len) {\n\t\t\tchar *info = malloc(info_len * sizeof(*info));\n\t\t\tif (!info) {\n\t\t\t\tfprintf(stderr, \"Malloc Error.\\n\");\n\t\t\t\tglDeleteProgram(program);\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tglGetProgramInfoLog(program, info_len, NULL, info);\n\t\t\tfprintf(stderr, \"Link Error: %s\\n\", info);\n\t\t\tfree(info);\n\t\t}\n\t\tglDeleteProgram(program);\n\t\treturn 0;\n\t}\n\treturn program;\n}\n```\n\n有了这个之后只需要在 `glViewport()` 和 `/* Code Here */` 之间调用 `load_program()` 生成 Shader Program。\n\n```c\n\tunsigned int program = load_program(\"triangle.v.glsl\", \"triangle.f.glsl\");\n```\n\n## 顶点数据\n\n接下来我们需要准备绘制的数据了，对于一个三角形来说，需要三个顶点来确定它的位置，每个顶点需要三个坐标，同时我们还要给它们创建不同的颜色，让我们的三角形变的多彩一点，所以需要像下面一样组织数据。把这段插入到之前 `/* Code Here */` 和 `glViewport(0, 0, width, height);` 之间。对于 3D 程序来说 float 的精度足够了，double需要更多的运算时间。\n\n```c\n\tconst float vertices[] = {\n\t\t// 坐标\t       颜色\n\t\t-0.5f, -0.5f, 0.0f, 1.0f, 0.0f, 0.0f,\n\t\t0.5f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,\n\t\t0.0f,  0.5f, 0.0f, 0.0f, 0.0f, 1.0f\n\t};\n```\n\nOpenGL 的坐标是这样安排的：\n\n- 从左到右对应 X 坐标 `-1.0f` 到 `1.0f`。\n- 从下到上对应 Y 坐标 `-1.0f` 到 `1.0f`。\n- 从外到里对应 Z 坐标从负到正，需要注意这个可能会被以后的数学变换改变。\n\n我们这里是平面的所以 Z 坐标都是一样的。\n\n现在我们把数据存储到了内存里面，但是很显然我们需要把数据传给显卡。这时候我们需要创建一个 OpenGL 的 Buffer 对象，并把数据写进去。也有人管这个叫 VBO，但是我觉得这个缩写还没有 Buffer 来的直观。\n\n```c\n\tunsigned int buffer;\n\tglGenBuffers(1, &buffer);\n\tglBindBuffer(GL_ARRAY_BUFFER, buffer);\n\tglBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n```\n\n这里的 `buffer` 只是一个符号，真正的空间分配我们是不能干预的。`glGenBuffers()`可以生成多个 Buffer，这里我们只生成一个，所以第一个参数设置为 1，第二个则是一个指针，我们这里只有一个所以没有使用数组，而是直接取了地址。\n\n接下来我们把这个 `buffer` 用 `glBindBuffer()` 绑定到 `GL_ARRAY_BUFFER` 表示这里是放置顶点的数组。`glBufferData()` 则会把数据写入到刚才绑定好的 `buffer`，所以要先进行绑定，这里第一个参数表示写入的目标，就是刚才的 `GL_ARRAY_BUFFER`，第二个则是写入数据的大小，第三个是写入数据的指针，第四个 `GL_STATIC_DRAW` 表示写入的数据是用来绘图的，不会经常改变。做完这一切我们取消绑定，把 `GL_ARRAY_BUFFER` 绑定到默认的 `0`。\n\n题外话：经常有人吐槽 OpenGL 这个状态机的设定，觉得绑来绑去很麻烦，但是你可以封装一下让它变的好用点。关键要记得处理完就解绑，避免状态混乱。至于 D3D 是什么样子的，我不知道，我也并不关心，就算 D3D 再好，不能让我在 Linux 下使用就是致命的，OpenGL 也许不完美，但它能用，我觉得也挺好。\n\n接下来还有个关键问题：显卡不知道我们传进去的数据是什么，怎么解释它。它不知道前三列是坐标后三列是颜色，甚至不知道这些数据是整数还是浮点数。所以我们需要使用 VertexArray 来解释 Buffer 中数据的含义，继续插入下面这部份。\n\n```c\n\tunsigned int vertex_array;\n\tglGenVertexArrays(1, &vertex_array);\n\tglUseProgram(program);\n\tglBindVertexArray(vertex_array);\n\tglBindBuffer(GL_ARRAY_BUFFER, buffer);\n\tglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void *)0);\n\tglEnableVertexAttribArray(0);\n\tglVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void *)(3 * sizeof(float)));\n\tglEnableVertexAttribArray(1);\n\tglUseProgram(0);\n\tglBindVertexArray(0);\n\tglBindBuffer(GL_ARRAY_BUFFER, 0);\n```\n\n首先我们还是创建一个标记符。然后使用 `glGenVertexArrays()` 生成，因为这里的数据要输入给 Program，在对 Program 操作之前先要绑定当前 Program，所以调用 `glUseProgram(program);`，接下来把 `vertex_array` 绑定到当前状态，然后我们要告诉 OpenGL 这个 VertexArray 对应的是哪个 Buffer，所以也要把刚才的 `buffer` 绑定到当前状态让它们关联。\n\n然后调用 `glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void *)0);` 传递坐标的信息，第一个参数表明这里的数据会被传递到 Vertex Shader 里面 `location = 0` 的地方，第二个参数表示一次传递三个数据（对应 `vec3`），第三个表示传进去的是 `float` 类型，第四个表示是否进行标准化（缩放到 0 和 1 之间），很显然我们不需要，第五个是步长，表示传递完一组数据之后 **从这一组数据开头跳过多长会到下一组数据的开头**，我们这里是三个坐标三个颜色，所以是六个 `float`，最后一个是偏移量 Offset，因为我们坐标是从第一个开始，所以是 `(void *)0`。最后用 `glEnableVertexAttribArray(0);` 启用位置 0。\n\n接下来用 `glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void *)(3 * sizeof(float)));` 传递颜色的信息，这次是位置 1，区别在于第一个颜色是在第四个数据开始的，所以偏移量设置为 `(void *)(3 * sizeof(float)))`。最后用 `glEnableVertexAttribArray(1);` 启用位置 1。\n\n最后不要忘记解绑。\n\n## 绘制三角形\n\n一切准备就绪，终于可以开始和绘制三角形了，下面我们进入循环，在 `/* Draw Here */` 那里插入如下代码。\n\n```c\n\tglUseProgram(program);\n\tglBindVertexArray(vertex_array);\n\tglDrawArrays(GL_TRIANGLES, 0, 3);\n\tglUseProgram(0);\n\tglBindVertexArray(0);\n```\n\n简单多了对不对！因为我们已经准备好了一切，所以这里只要加载你的 Shader Program，然后绑定你的 VertexArray，用 `glDrawArrays(GL_TRIANGLES, 0, 3);` 告诉 OpenGL 绘制当前 Array 即可，第一个参数 `GL_TRIANGLES` 表示我们要画三角形（还记得吗，大部分复杂图形都可以用三角形近似拼出来，所以这里有复数），第二个表示从第几个顶点开始，第三个则表示画几个顶点。然后 OpenGL就会按你的要求去画图。最后不要忘记解绑。\n\n# 清理\n\n在退出程序之前最好清理掉你分配的空间，所以在循环后面和 `glfwDestroyWindow(window);` 之间插入如下部分。\n\n```c\n\tglDeleteBuffers(1, &buffer);\n\tglDeleteVertexArrays(1, &vertex_array);\n\tglDeleteProgram(program);\n```\n\n![triangle.png](triangle.png)\n\n# 还有一件事……\n\n你可能会问“我还是不知道这些代码怎么拆分成各个部分！”，实际上我文章里的代码片段基本都是互相独立的部分，也就是说它们可以按照顺序放在程序的不同位置，而不必完全紧邻。产生 Buffer，产生 VertexArray 和 Shader Program 不是需要放在大循环里面的，你大可以把这些数据封装起来。\n\n虽然你成功画出了三角形，但是你可能还是不知道怎样画更复杂的图形，实际上你不需要修改你的顶点数据和 Shader 来改变图形位置。大部分复杂的模型由相应的建模软件导出顶点数据和贴图坐标，你也不需要手动安排这些模型在 OpenGL 坐标系中的位置，后面我会给出使用矩阵和向量运算处理坐标系统的样例。\n\n如果你觉得这样看代码只是管中窥豹，下面我给出完整的程序链接。\n\n- [main.c](./main.c)\n- [triangle.v.glsl](./triangle.v.glsl)\n- [triangle.f.glsl](./triangle.f.glsl)\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Automata: A Story of Love and Lives","url":"/posts/Automata/","content":"\n![](Automata.jpg)\n\n<blockquote class=\"centerquote\">我没有办法评价这款游戏<br>因为我觉得我被结结实实地折腾了一回</blockquote>\n\n<!--more-->\n\n> Everything that lives is designed to end.\n> 一切活着的事物，都注定要终结。\n> We are perpetually trapped ...\n> 我们被永远地囚禁……\n> ... in a never-ending spiral of life and death.\n> ……于永无止境的生死轮回之中。\n> Is this a curse?\n> 这是一种诅咒？\n> Or some kind of punishment?\n> 还是某种惩罚？\n> I often think about the god who blessed us with this cryptic puzzle ...\n> 我时常想起那用模糊的谜团祝福我们的神……\n> ... and wonder if we'll ever have the chance to kill him.\n> ……并猜想我们是否终有弑神的机会。\n\n我大概对动作游戏不感冒。在我最开始对 NieR: Automata 感兴趣的时候，是把它当作剧情游戏来看的，动作只是买剧情附赠的而已。\n\n一周目结束的时候，我以为这是个讲生命和进化的故事。\n\n二周目结束的时候，我以为它要说的是爱情。\n\n三周目开始，我才发现作者是要给玩家一个彻头彻尾的绝望。\n\n能写出这样的开场白的人，不可能做出一款糟糕的游戏。尽管整个游戏的游玩方式实在是逊色于剧情，整个游戏的玩法总结起来大概就是无穷无尽的跑打跑打跑打，伴随着优美或者说是诡异的配乐。然而排除掉动作和开放世界元素仍然可以维持形式完整，以视觉小说的形式，开放世界大概是由于经费限制并没有什么玩法，我又不是有闲情逸致跑来跑去做任务的人。\n\n以机械构成昆虫或者战车的形式确实很好的在震撼和恶心之间取得了平衡，随时出现的视角锁定也可以说是独树一帜的特色。\n\n原本以为一二周目就完整地讲述了进化与爱情，但是和后面的故事比起来，前面的打斗只是岁月静好罢了。\n\n前两周目是一个玩的人很累但看的人很爽的游戏，当然 PC 版就算了，毕竟 bug 太多，PS4 的优化和画质还是很不错的，特别是与巨型兵器战斗时的满天阴霾。至于配音，英语和日语一样优秀，有时反而是中文翻译失去了英文的特殊味道，第一次在 PC 上启动英文版之后许多表达方式就印在了脑海里。\n\n三周目则是让看的人和玩的人都感到痛苦。失去 Bunker，失去爱人，足以让人疯狂。机械都进化出了感情，人造人怎么会没有呢？\n\n故事有多绝望，剧情就可以有多荒谬。\n\n凌晨三点，经历过所有优秀的战斗场面和恰到好处的音乐之后，还是删掉了存档。一切的一切好像终于结束了，没有办法评价这个故事，没有办法评论其中各种可以说是鬼才的设计，没有办法评价这个游戏。它不像是会让你流出眼泪，只是会让你觉得，这次是结结实实地被横尾太郎折腾了一把呢。\n\n2B，9S 和 A2 都留下来了，还有什么需要留恋的吗？可惜缺乏的是再来一次的勇气。\n\n“如果没有战争，我们也不是士兵，是不是也能在这里像人类一样购物呢？”\n\n但愿是吧。\n\n> Everything that lives is designed to end.\n> 一切活着的事物，都注定要终结。\n> They are perpetually trapped ...\n> 我们被永远地囚禁……\n> ... in a never-ending spiral of life and death.\n> ……于永无止境的生死轮回之中。\n> However ... life is all about the struggle within this cycle.\n> 但是……生命的全部意义就在于这轮回中的挣扎。\n> That is what we believe.\n> 那正是我们所相信的。\n\n--------\n\n后记：在 NieR: Automata 原生音乐会“人形们的记忆”上的朗读剧里交待了 Pod 们修复好 2B 和 9S 身体后发生的事情，也就是 E 结局之后的真正结局。按照 [The Ark](https://theark.wiki/w/Farewell) 这个网站的记录，原本的台本是这样的（可靠性未知）（我在这里附上翻译）（看完伤心欲绝的往后看）：\n\n> （前情：2B 磨损了自己的手在「塔」的遗迹 40 米深处挖掘方舟留下来的结晶直到由于过载自动关机，然后使用结晶制作疫苗尝试修复 9S 但却失败了。）\n> Pod 042: Hypothesis: Unit 9S's personal data has been lost.\n> 辅助机 042: 猜测：机体 9S 的个人数据已经丢失。\n> 2B: His personal data ... is lost ...?\n> 2B：他的个人数据……丢失了……？\n> Pod 042: His personal data was wiped of his own accord, but there is the possibility it was moved to a different location.\n> 辅助机 042：他的个人数据被从他的个人记录中擦除了，但是也有可能是被移动到了别处。\n> Pod 042: According to unit A2's records, it is possible his data evacuated using the machine lifeforms' Ark.\n> 辅助机 042：按照机体 A2 的记录，他的数据有可能是通过机械生命体的方舟疏散到了别处。\n> Pod 042: Report: Possibility of recovering 9S's personal data extremely low.\n> 辅助机 042：报告：9S 的数据恢复可能性极低。\n> S.P.\n> （这个不知道是什么的缩写了……有人知道请教教我。）\n> 2B: No ...\n> 2B：不……\n> (Three beeps suddenly sound.)\n> （突然响起了三声蜂鸣。）\n> Pod 153: Report: Memory components discovered within traces of personal data.\n> 辅助机 153：报告：内存组件发现了个人数据的痕迹。\n> Pod 153: Partial playback possible of memory containing the reason behind his personal data's reparation failure.\n> 辅助机 153：可用的内存局部回放包含有他个人数据修理失败的原因。\n> Pod 153: Query: Does unit 2B feel it necessary to repair this memory component?\n> 辅助机 153：询问：机体 2B 是否认为有必要修复该内存组件？\n> 2B: ... Repair it.\n> 2B：……修复。\n> Pod 153: Understood.\n> 辅助机 153：了解。\n> Pod 153: Data repair complete.\n> 辅助机 153：数据修复成功。\n> Pod 153: Starting playback.\n> 辅助机 153：开始回放。\n> (9S's voice begins to play back with the sound quality of a radio.)\n> （9S 的声音开始以无线设备的音质回放。）\n> (He seems to be suffering.)\n> （他听起来很痛苦。）\n> 9S: I didn't ... get on the Ark created by the machine lifeforms.\n> 9S：我没有……乘上机械生物制造的方舟。\n> 9S: We YoRHa ... We don't deserve to be loved by this world ... We're just soldiers created to die ...\n> 9S：我们寄叶部队……我们不值得得到这个世界的爱……我们只是为了死去而制造出来的士兵而已。\n> 9S: But I ... I think I'm glad ... that I was born as myself ...\n> 9S：但是我……我很高兴……能够作为我自己而生……\n> 9S: My personal data, it ... it can't keep it's shape any longer.\n> 9S：我的个人数据…，它……它没办法再保持它的形式了。\n> 9S: I wonder if I'm about to disappear ...\n> 9S：我想我是该离去了……\n> 9S: But ... I'm okay with that ...\n> 9S：但是……我觉得还好……\n> (2B begins crying, without making a sound.)\n> （2B 开始无声地哭泣。）\n> 9S: Hey, 2B ... We're ... we're not immortal or anything.\n> 9S：嘿，2B……我们……我们不是不朽的也不是无所不在的。\n> 9S: Someday, we'll break down and return to the Earth.\n> 9S：终有一天，我们会损坏并归于尘土。\n> 9S: But, my existence ... It wasn't meaningless ...\n> 9S：但是，我的存在……并不是毫无意义……\n> 9S: Meeting you ... gave meaning to my birth ...\n> 9S：遇见你……给了我出生的意义……\n> 9S: Thank you ...\n> 9S：谢谢你……\n> 9S: Thank you ...\n> 9S：谢谢你……\n> (9S's voice becomes hidden behind static.)\n> （9S 的声音逐渐消失在静电声里。）\n> (2B begins weeping.)\n> （2B 开始抽泣。）\n> 2B: Nines ...\n> 2B：Nines……（抱歉我觉得“奈兹”这个翻译还不如不翻译……太糟糕了……）\n> Pod 042 (narration): 2B didn't move from where she was.\n> 辅助机 042（叙述）：2B 没有从她所在的地方移动过。\n> Pod 042 (narration): She remained there, unmoving ... forever.\n> 辅助机 042（叙述）：她留在那里没有移动……永远地。\n> Pod 042 (narration): It was a completely irrational act.\n> 辅助机 042（叙述）：这是个十分不合理的举动。\n> Pod 042 (narration): However, \"we\" can now understand the reason behind it.\n> 辅助机 042（叙述）：然而，“我们”现在可以理解这样做的原因。\n> Pod 042 (narration): Why it was that 2B didn't move.\n> 辅助机 042（叙述）：为什么 2B 不再移动。\n> Pod 042 (narration): Why it was that she didn't speak.\n> 辅助机 042（叙述）：为什么她不再说话。\n> Pod 042 (narration): Because \"we\" are now in that same place, feeling the same thing.\n> 辅助机 042（叙述）：因为“我们”如今也在相同的位置，感受着相同的事情。\n\n然而不知出于什么原因，最终公开的剧本里是 9S “不知出于什么原因” 在疫苗修复失败后醒过来了（“你还知道醒过来啊喂！”），推测可能是横尾老贼害怕继续虐 2B 小姐姐被玩家打死吧。下面附上 B 站带中文字幕的视频，一定要看完啊！\n\n<iframe src=\"//player.bilibili.com/player.html?aid=10344669&cid=17095298&page=1\" scrolling=\"no\" border=\"0\" frameborder=\"no\" framespacing=\"0\" allowfullscreen=\"true\" width=\"640\" height=\"480\"></iframe>\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"在 VPS 上用 Nginx 和 HTTPS 部署 Hexo 生成的页面","url":"/posts/Hexo-on-VPS-with-Nginx-and-HTTPS/","content":"昨天听说微软要收购 GitHub 了，对于我一个专业微软受害者，虽然它洗白了，但还是有着本能的不信任。同时软粉认软做父的样子我是断然接受不了的（“我微软爸爸天下第一！”“你怎么能不喜欢我微软爸爸呢！”“我微软爸爸什么时候坑过你！”），你自己喜欢就喜欢，我讨厌是我的事情，希望各位嘴下留情，不要给我喷成筛子。\n\n<!--more-->\n\n要说我受害的经历能说好几篇博客，最常见的比如说昨天答辩 PPT 轮到我时候就崩溃了（我可以确定不是我 PPT 的问题，因为关掉所有的 PowerPoint 再打开就没问题了）（“再碰这辣鸡玩意我就是狗！”）。再比如说那个出了名不靠谱的自动更新，你见过更新更新失败回滚回滚失败的嘛？合着我一小时只能对着电脑发呆看你自爆？（当然软粉肯定不承认：“我们更新都成功了！”，这玩意还心诚则灵？反正我被坑了）。倒不是说它收购 GitHub 罪大恶极了，只不过是我自己觉得不舒服就是了，至于普罗大众该干什么干什么，不要管我。\n\n然后我就把我还算有价值的东西——我的网站，搬到了 VPS 上面，搬迁过程相对简单，用 git 做这个同步肯定是不现实的，因为你想像 GitHub 一样可以直接用 `hexo-deployer-git` push 的话，你需要建立的是裸仓库，也就是正常的 `.git` 目录里面的东西，很显然这不是网站内容。看了一圈其他的同步方式，rsync 看起来是最合适的一个了，然后就尝试了一下。\n\n# 用 Rsync 上传 Hexo 生成的网页\n\n首先需要安装 `hexo-deployer-rsync`，另外也要在自己的电脑和 VPS 上面安装 `rsync`，首先进入你的 Hexo 站点目录，然后：\n\n```\n$ npm i -s hexo-deployer-rsync\n```\n\n根据发行版不同使用不同的命令安装 `rsync`：\n\nArchlinux / Manjaro / Antergos：\n\n```\n# pacman -S rsync\n```\n\nDebian / Ubuntu / LinuxMint / Deepin：\n\n```\n# apt install rsync\n```\n\nRed Hat / CentOS / Fedora（如果找不到 `yum` 就换成 `dnf`）：\n\n```\n# yum install rsync\n```\n\n接下来和很多网上的文章说的不一样，很多人把这里的设置理解成要在 VPS 上面开启一个 rsync 的服务器，实际上不是，rsync可以通过任意一个用户和 ssh 密钥连接到服务器然后复制文件。\n\n首先打开 **你自己的电脑** 上的 `~/.ssh/id_rsa.pub` 获取你自己的公钥（当然你可能用的不是 RSA，自己改），然后复制这个文件，添加到 **服务器** 里面你要使用的用户（不建议 root 敢死队，你平时的用户就可以了）的 `~/.ssh/authorized_keys` 文件里，每个密钥单独粘贴一行。如果你设置过 ssh 免密码登录的话，这一步应该做过了。\n\n然后打开 Hexo 站点的 `_config.yml`，修改 `deploy` 字段，如果没有设置过的话那就改成这样：\n\n```yaml\ndeploy:\n  type: rsync\n  host: YOUR VPS IP # 你的服务器的 IP 地址\n  user: YOUR USERNAME # 你刚刚复制密钥的那个用户\n  root: YOUR DESTINATION # 你想把文件上传到哪里，比如我的是 `~/stackharbor.alynx.xyz/`\n  port: 22 # 这是 ssh 默认的端口，如果你修改了，这里也要改\n  args: --progress # 额外的 rsync 参数，我这里添加了一个进度条参数，你也可以不设置\n  delete: true # 是否删除旧的文件\n  verbose: true # 是否同步时显示详细状态\n  ignore_errors: false # 忽略错误\n```\n\n当然很多人可能已经有一个 git 的部署设置了，那也很简单，设置成一个数组就行了，像这样：\n\n```yaml\ndeploy:\n  - type: git\n    repo: # 像这样设置多个 git 仓库，`名称: 地址,分支`，逗号后面没有空格。\n      github: git@github.com:XXXXXX/XXXXXX.git,branch\n      coding: git@git.coding.net:XXXXXXX/XXXXXXX,coding-pages\n    message: Site updated by Hexo at {{ now('YYYY-MM-DD HH:mm:ss') }}.\n  - type: rsync\n    host: YOUR VPS IP # 你的服务器的 IP 地址\n    user: YOUR USERNAME # 你刚刚复制密钥的那个用户\n    root: YOUR DESTINATION # 你想把文件上传到哪里，比如我的是 `~/stackharbor.alynx.xyz/`\n    port: 22 # 这是 ssh 默认的端口，如果你修改了，这里也要改\n    args: --progress # 额外的 rsync 参数，我这里添加了一个进度条参数，你也可以不设置\n    delete: true # 是否删除旧的文件\n    verbose: true # 是否同步时显示详细状态\n    ignore_errors: false # 忽略错误\n```\n\n这样就行了，运行 `hexo deploy` 应该就能看到 rsync 的同步状态了。如果你有其他的不使用 Hexo 的网页，可以用命令：\n\n```\n$ rsync -azv --delete SOURCE USERNAME@IPADDRESS:DESTINATION\n```\n<!-- Marked bug: cannot handle `\\)` in URL, use `%29` instead. Waiting hexo-renderer-marked update its dependents version. -->\n上传到服务器上，如果有 git 仓库最好用 `--exclude=.git` 排除掉，顺便 SOURCE 目录一般不要用 `/` 结尾，原因参见 [这里](https://wiki.archlinux.org/index.php/Rsync_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87%29#.E6.B3.A8.E6.84.8F.E5.B0.BE.E9.9A.8F.E4.B8.8B.E5.88.92)。\n\n这个时候我还没有把 DNS 从 GitHub Pages 转到我的服务器上，结果生米煮成了熟饭，只能往下继续了。\n\n# 用 Let's Encrypt 生成 SSL 证书\n\nHTTPS 需要有可信机构签发的证书，[Let's Encrypt](https://letsencrypt.org/) 就是一个免费提供这种服务的网站，不过官方推荐的步骤只能对每个域名单独生成证书，比如 `alynx.xyz` 和 `sh.alynx.xyz` 需要两个证书，这里介绍生成通配符证书的办法，比如对 `*.alynx.xyz` 生成一个证书，可以用在所有三级子域名：\n\n## 下载 certbot-auto\n\n`certbot-auto` 是用来验证生成证书的交互命令行工具，似乎一般软件源里的版本都不够高，不能生成通配符证书，这里手动下载新版：\n\n```\n$ wget https://dl.eff.org/certbot-auto\n$ chmod +x ./certbot-auto\n```\n\n## 手动生成证书\n\n生成证书的话需要我们手动操作，命令如下（用你的域名替换掉 `example.com`）：\n\n```\n# ./certbot-auto certonly --manual --preferred-challenges=dns --server=https://acme-v02.api.letsencrypt.org/directory -d *.example.com -d example.com\n```\n\n这里 `certonly` 表示我们只需要生成证书，我们不需要它帮我们改服务器配置。`--manual` 表示手动配置参数。生成证书需要你证明域名属于你，由于我们是通配符自然不能一个一个页面去放文件验证（默认的验证方法，类似 Google 的页面验证），所以用 `--preferred-challenges=dns` 设置为验证 DNS 记录。`--server=https://acme-v02.api.letsencrypt.org/directory` 表示使用第二版的 api 服务器，默认的第一版是不支持通配符证书的签发的。最后 `-d *.example.com -d example.com` 添加你的域名，需要注意的是只包含 `*.example.com` 的证书是不能用在 `example.com` 上的，所以我们把两个都写上，生成的证书就会同时包含两个域名。\n\n```\nSaving debug log to /var/log/letsencrypt/letsencrypt.log\nPlugins selected: Authenticator manual, Installer None\nEnter email address (used for urgent renewal and security notices) (Enter 'c' to\ncancel): YOUR EMAIL\n```\n\n这里会让你输入你的邮箱。\n\n```\n-------------------------------------------------------------------------------\nPlease read the Terms of Service at\nhttps://letsencrypt.org/documents/LE-SA-v1.2-November-15-2017.pdf. You must\nagree in order to register with the ACME server at\nhttps://acme-v02.api.letsencrypt.org/directory\n-------------------------------------------------------------------------------\n(A)gree/(C)ancel: A\n```\n\n这里输入 A 表示同意条款。\n\n```\n-------------------------------------------------------------------------------\nWould you be willing to share your email address with the Electronic Frontier\nFoundation, a founding partner of the Let's Encrypt project and the non-profit\norganization that develops Certbot? We'd like to send you email about EFF and\nour work to encrypt the web, protect its users and defend digital rights.\n-------------------------------------------------------------------------------\n(Y)es/(N)o: N\n```\n\n这里问你要不要把邮箱发给 EFF，我不想发就输入了 N。\n\n```\nObtaining a new certificate\nPerforming the following challenges:\ndns-01 challenge for alynx.xyz\ndns-01 challenge for alynx.xyz\n\n-------------------------------------------------------------------------------\nNOTE: The IP of this machine will be publicly logged as having requested this\ncertificate. If you're running certbot in manual mode on a machine that is not\nyour server, please ensure you're okay with that.\n\nAre you OK with your IP being logged?\n-------------------------------------------------------------------------------\n(Y)es/(N)o: Y\n```\n\n这里显示了需要验证的次数，因为我们有两个所以要验证两次，然后为了限制申请次数防止刷证书，这里它会记录你申请证书的 IP，输入 Y。\n\n```\n-------------------------------------------------------------------------------\nPlease deploy a DNS TXT record under the name\n_acme-challenge.alynx.xyz with the following value:\n\nYX3oQEVGxLolEVtiFDF4JCKe1tqB7B-9pwis8zuQZkc\n\nBefore continuing, verify the record is deployed.\n-------------------------------------------------------------------------------\nPress Enter to Continue\n```\n\n这里是第一次验证，先别急着回车，去你的 DNS 服务商那里添加一条到 `_acme-challenge` 的内容为 `YX3oQEVGxLolEVtiFDF4JCKe1tqB7B-9pwis8zuQZkc`（你的内容不一定和我的一样）的 TXT 记录，然后用 `dig -t txt _acme-challenge.example.com @8.8.8.8`，检查是否更新完成，最好多查几次，防止缓存导致失败。有消息说国内的 DNS 是访问不到的，我这里用的 CloudFlare。\n\n```\n-------------------------------------------------------------------------------\nPlease deploy a DNS TXT record under the name\n_acme-challenge.alynx.xyz with the following value:\n\nlKuF76a3GRy7y3M-FVDJ3kif0FQJJwZQUROc6cgG_lk\n\nBefore continuing, verify the record is deployed.\n-------------------------------------------------------------------------------\nPress Enter to Continue\nWaiting for verification...\nCleaning up challenges\n\nIMPORTANT NOTES:\n - Congratulations! Your certificate and chain have been saved at:\n   /etc/letsencrypt/live/example.com/fullchain.pem\n   Your key file has been saved at:\n   /etc/letsencrypt/live/example.com/privkey.pem\n   Your cert will expire on 2018-09-02. To obtain a new or tweaked\n   version of this certificate in the future, simply run certbot-auto\n   again. To non-interactively renew *all* of your certificates, run\n   \"certbot-auto renew\"\n - If you like Certbot, please consider supporting our work by:\n\n   Donating to ISRG / Let's Encrypt:   https://letsencrypt.org/donate\n   Donating to EFF:                    https://eff.org/donate-le\n```\n\n~~又是一次验证，把刚才的记录内容改成新的，~~ 按照评论的指正，这里是可以建立两个同名记录的，所以不需要修改两次，这里可以再添加一条同样名字但内容不同的记录，然后多 `dig` 几次再回车，如果没通过重新运行命令会从记录 IP 那里开始。\n\n需要注意 certbot 似乎会很弱智的用 Nginx 服务的目录的名字作为它认为的你的域名，所以最好在开启 Nginx 之前设置它，它每次都把我的域名当成 `stackharbor.alynx.xyz` 也是把我气个半死。\n\n# 设置 Nginx\n\n这里稍微复杂一点啦，因为我还有另一个页面。\n\n首先我们要安装 Nginx，我的习惯肯定是安装包管理里面的然后用 systemd 管理，我是 Debian9，你们看着来。\n\n## 强制 HTTPS\n\n首先我们要把所有的 HTTP 请求定向到 HTTPS 上，编辑 `/etc/nginx/nginx.conf`，在 `include /etc/nginx/sites-enabled/*;` 前面插入：\n\n```lua\n# Forward all HTTP requests to HTTPS.\nserver {\n\tlisten 80 default_server;\n\tlisten [::]:80 default_server;\n\treturn 301 https://$host$request_uri;\n}\n```\n\n这段表示所有 80 端口的请求都被 301 永久重定向到 https 的网址上面。\n\n## 配置虚拟主机\n\n然后在 `/etc/nginx/sites-available/` 下面创建一个文件，名字可以随意，我用的是我的域名，然后编辑它：\n\n```lua\n# Forward www domain to non-www domain.\nserver {\n\t# Must set ssl with a HTTPS request.\n\tlisten 443 ssl http2;\n\tlisten [::]:443 ssl http2;\n\n\tssl_certificate /etc/letsencrypt/live/alynx.xyz/fullchain.pem;\n\tssl_certificate_key /etc/letsencrypt/live/alynx.xyz/privkey.pem;\n\tssl_dhparam /etc/ssl/certs/dhparam.pem;\n\tssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';\n\tssl_prefer_server_ciphers on;\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_session_cache shared:SSL:50m;\n\tssl_session_timeout 1d;\n\tssl_stapling on;\n\tssl_stapling_verify on;\n\tssl_trusted_certificate /etc/letsencrypt/live/alynx.xyz/fullchain.pem;\n\tadd_header Strict-Transport-Security max-age=60;\n\n\tserver_name www.example.com;\n\treturn 301 https://example.com$request_uri;\n}\n\nserver {\n\t# SSL configuration\n\tlisten 443 ssl http2;\n\tlisten [::]:443 ssl http2;\n\n\tssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n\tssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem;\n\tssl_dhparam /etc/ssl/certs/dhparam.pem;\n\tssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';\n\tssl_prefer_server_ciphers on;\n\tssl_protocols TLSv1 TLSv1.1 TLSv1.2;\n\tssl_session_cache shared:SSL:50m;\n\tssl_session_timeout 1d;\n\tssl_stapling on;\n\tssl_stapling_verify on;\n\tssl_trusted_certificate /etc/letsencrypt/live/example.com/fullchain.pem;\n\tadd_header Strict-Transport-Security max-age=60;\n\n\t# Note: You should disable gzip for SSL traffic.\n\t# See: https://bugs.debian.org/773332\n\t#\n\t# Read up on ssl_ciphers to ensure a secure configuration.\n\t# See: https://bugs.debian.org/765782\n\n\troot /home/example/example.com/;\n\n\t# Add index.php to the list if you are using PHP\n\tindex index.html index.htm index.nginx-debian.html;\n\terror_page 404 404.html;\n\tserver_name example.com;\n\n\tlocation / {\n\t\t# First attempt to serve request as file, then\n\t\t# as directory, then fall back to displaying a 404.\n\t\ttry_files $uri $uri/ =404;\n\t}\n}\n```\n\n首先你看到的 ssl 那一大片都是用来加密的，总之你需要把 example.com 换成你的域名（因为 certbot 生成的证书所在的目录是域名的名字）。然后这里第一个 server 的作用是把 `www.example.com` 重定向到 `example.com`（因为 80 （HTTP）已经被强制转到 443 （HTTPS）了所以一定要写 443 和 ssl 的配置），如果你想反过来，那就把 `return` 那一句加上 `www.` 然后把上下两块的 `server_name` 那一行对调。\n\n`root` 选项设置成你要作为网页目录的路径，比如之前你 Hexo 上传到了家目录下的子目录这里要对应。\n\n接下来创建密钥，Nginx 默认的编码长度太弱，使用 2048 位的：\n\n```\n# openssl dhparam -out /etc/ssl/certs/dhparam.pem 2048\n```\n\n然后创建软连接使配置生效，并重启 Nginx：\n\n```\n# ln -s /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/\n# systemctl restart nginx\n```\n\n如果你还有其他的页面，放在另一个目录里，然后再创建一份配置文件，当然这次只要有第二个 server 字段就好了，修改路径，然后连接重启。\n\n# 自动更新证书\n\n安全起见，Let's Encrypt 签发的证书只有 90 天有效期，官方推荐使用自动定期刷新的方式更新证书，只需要建立一个定时任务运行 `/PATH/TO/certbot-auto renew --pre-hook \"systemctl stop nginx\" --post-hook \"systemctl start nginx\"`（如果你用的不是 systemd 管理 Nginx 记得换成其它的停止和启动 Nginx 的命令）。很大可能你知道怎么用 crontab 做这件事情，但我使用 systemd-timer 做。\n\n首先建立 `/lib/systemd/system/certbot-renew.service` 这个文件，内容如下：\n\n```ini\n[Unit]\nDescription=Updates cert file via certbot\n\n[Service]\nType=oneshot\nExecStart=/home/alynx/certbot-auto renew --pre-hook \"systemctl stop nginx\" --post-hook \"systemctl start nginx\"\n```\n\n然后建立对应的 timer `/lib/systemd/system/certbot-renew.timer`，内容如下：\n\n```ini\n[Unit]\nDescription=Updates cert files via certbot every week\n\n[Timer]\nOnBootSec=1min\nOnUnitActiveSec=1week\nUnit=certbot-renew.service\n\n[Install]\nWantedBy=multi-user.target\n```\n\n这个 timer 会在启动 1 分钟之后运行 certbot-renew.service，同时每周运行一次来确保你的证书会被刷新。\n\n启动它：\n\n```\n# systemctl enable certbot-renew.timer --now\n```\n\n然后更新你的 DNS 的 A 记录和 AAAA 记录，生效就可以了。\n\n有备无患咯！\n\n更新：我的 VPS 被墙了，算了，噗。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"无尽的咏叹回荡于伽蓝之世界中 —— 有关 ARIA","url":"/posts/Endless-ARIA/","content":"大约从我写好 ARIA （指把我自己的网站换成它做主题）到现在为止已经有一个月了，这一个月里它有了 [20 个 Star](https://github.com/AlynxZhou/hexo-theme-aria/stargazers)、[4 个 Issue](https://github.com/AlynxZhou/hexo-theme-aria/issues?q=is%3Aissue+is%3Aclosed) 和 [128 个 Commit](https://github.com/AlynxZhou/hexo-theme-aria/commits/master)（都是我自己，残念啊）。大概算是我现在最得意的项目，当然不排除以后也是。\n\n虽然这么说有点敷衍，但是我是和一些无聊的人进行了一点无谓的争执 —— 我讨厌辩论，所以尽可能把这种冲动压制在一点 —— 所以我现在来写这篇文章，聊聊那些代码里面没有告诉你的事情。写点经过脑子的思考总是有用处的，不仅是对自己而言。\n\n<!--more-->\n\n我已经不太记得当初自己选择 Hexo 的理由了，大概是因为 2016 年的时候比较热门的静态博客生成器就是 Jekyll、Octopress 和 Hexo 吧。我不太注意 Pelican 是什么时候出现的，至于 Hugo，没记错的话 Hexo 冲上 [staticgen](https://www.staticgen.com/) 前三的时候，Go 语言还是个尝鲜的状态，然后才有了 Hugo。那时候大概还没有 React.js，所以也就没有 Gatesby。\n\nHexo 当初打出的招牌就是它比 Jekyll 和 Octopress 快，当然现在 Octopress 已经式微了，Jekyll 作为 GitHub 钦定的生成器还是好好的。选择了 Hexo 才发现相比其他生成器，Tommy351 是台湾人这一点让它有更好的中文文档支持 —— 对一个新手来说还是很重要的。习惯了之后就没有必要换另一个的代价，何况它们并没有太大的吸引力。我对 Go 并不是很感兴趣，Hugo 的“第一快”和 Hexo 的“飞快”比起来也并不是一个充足的理由。至于 Gatesby —— 我还要学 React，然后 AJAX 获取数据更新页面然后突然换掉地址栏地址这种行为单纯的觉得不舒服。\n\n所以 Hexo 看起来完全够用，还要算上各种奇怪的插件，不同的模板和预处理器，另外我是因为 Hexo 才对 Node.js 产生好感的。\n\n那为什么要自己写一个主题呢，一部分的原因是已经用腻了 NexT，老实说我不是很喜欢这个名字，很想问问作者是不是在看了乔布斯传里面的 NeXT 才想了这么一个名字。它让我想起一个观点叫做“第一个把女人比作花的是天才，第二个把女人比作花的是庸材，第三个把女人比作花的是蠢材”，感谢语文老师。\n\n不过说到底起什么名字是人家的自由，也不能不说它是个不错的主题。然而人是一种不做点什么就不好感知自己存在的生物，因此做这个项目除了因为 NexT 几个 Scheme 和遗留代码混在一起让我觉得难以掌握，以及 Swig 已经被废弃了但这个主题却很难迁移的强迫症之外，还有“我做是为了证明我能做”的念头，最后就是深层次的“让痛苦来证明我还活着”（黑执事 1 的结尾？）。\n\n虽说如此，我一直没有足够的动力来写，最后只能是碌碌无为地做一些其他的事情。\n\n直到听说 Kalafina 要解散的时候，我觉得自己应该给她们做点什么，虽然自己好像什么也做不到，但是给自己的主题起个名字总是可以的吧。那张红色封面的 ARIA 是我至今听过的最出色的 LIVE，甚至超出录音室的版本。\n\n在写 ARIA 的时候我给自己定了几个目标，比如说我实在是受不了许多主题高喊着一个比一个简洁然后却很丑的状况（这个观点也是在别人那里看到的，一群人自以为是简洁，实际是简陋），所以就算做的复杂一点（并没有这个能力）也要让它看起来优雅（emm 如果大家觉得现在的样子符合这个标准的话）；再比如我也不想编辑一份超过 500 行的配置文件，在一大堆应该保持默认值的选项里找几个人人都想改的选项实在是太愚蠢了（“你为什么非要过那 1% 的生活？”）（前面只是玩梗），如果大家都这样设置，那就写死到代码里好了，如果人人都想改成另一种选项，那应该把那种设置成默认值；最后就是如果可能的话尽量不要用 `position: fixed;` 或者 `position: absolute;` 还有 `position: float;` 这种属性，即使用一些比较新的 CSS 属性（IE 10 以下的不配看我的网站！），因为它们对我来说太不直观又难以驾驭了。\n\n然后就是选择模板和预处理器了，ejs 这种又挫又丑的东西我是不会去用的，然后看起来 Hexo 的 Nunjucks 插件还算能用（当然并不好用，都没人更新了还占着最好的名字，于是我只能自己写了一个，这是后话），唯一对 Nunjucks 不满的地方大概是它的关键字是 Python 风格（我讨厌这两种叫做 Python 的语言）。CSS 预处理器看起来在 Sass 和 Less 之间有个更好的选择叫做 Stylus（也是 Node 社区比较喜欢用的），既然这次是自己写样式了，纠结了好久我还是没有添加 Bootstrap。\n\n参照的原型是 [hexo-theme-hueman](https://github.com/ppoffice/hexo-theme-hueman)，我很喜欢它的风格，但是看起来 Ppoffice 维护了好几个主题，但是哪个都不是很精细好用，当然随着我的设计进行 ARIA 和 Hueman 产生了不一样的设计，我比较喜欢现在的样子。\n\n在艰难地摸掉了 Hexo、hexo-renderer-nunjucks（就是这个坑货不更新还占着好名字） 和 Stylus 的一些坑之后，开始正式的进入到编写阶段，果然对于我而言 CSS 才是最难驾驭的语言，不过还是顶着各种困难把它做成了我想要的样子（优秀的前端工程师想要什么样就做成什么样，我是做成什么样就算什么样），其中的经历不太想多说，比如 Hexo 的中文文档没有告诉我 page.posts 是个什么类型（不是 Array，ejs （就是嵌入的 JavaScript）可以迭代，但是 Nunjucks 却不行），英文文档又出现了 Array of `???`，请问 `???` 是什么？点击链接又跳转到了 Hexo 的一个叫做 Warehouse 的子项目，这又是什么？后来终于我在 Issue 列表里找到了答案，这是个数据库，为了能让 Nunjucks 和 Swig 迭代，作者又添加了个 `toArray()` 方法。再比如 hexo-renderer-nunjucks 的版本卡在 Nunjucks 2，我又自己写了个插件支持 Nunjucks 3。还有自己差不多完全重写了一个用来搜索的 js。好在最后是做出来了。\n\n比起做加法，做减法看起来更难一点，首先由于翻转的 CSS 动画莫名的消耗了 chrome 的性能，让我把它改成了可选项。然后觉得按钮鼠标覆盖转两圈太花哨了，改成了阴影。然后踢掉了不必要的自定义不蒜子字符串的设置项。最后怎么看那个灰色的“阅读原文”按钮怎么觉得它和风格不搭，同时又和文章标题功能重复，终于下决心把它删掉了。大约是一边狂奔一边丢掉所有东西的人生的剪短缩影。\n\n这就是你现在看到的它的样子，没有什么文章头图这种设计，纯粹是因为这个写起来太不直观，文章的核心始终是在文字内容上，为什么非要花时间去找一张图片搭配给它做头图呢？比起这个，各种链接的变色的细节才是我想要的。说到底，还是为了在这个世界里留下一点自己独特（固执）的存在。\n\n如果说还有什么要加进去的话，短期内是自定义字体的设计，现在的字体顺序是我最喜欢的字体排在最前面，但看起来似乎大家有不一样的喜好。\n\n请务必记住我对这个世界无尽的咏叹，记住这个在深夜里写一点话的孤独的灵魂。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"GitHub Pages 自定义域名启用 HTTPS（非 CloudFlare）","url":"/posts/Custom-GitHub-Pages-Domain-with-HTTPS/","content":"在 GitHub Pages 支持自定义域名开启 HTTPS 之前，我是使用 CloudFlare 的 CDN 中转来启用 HTTPS 的，缺点也很明显，就是面对国内访问的时候 CloudFlare 的 CDN 简直是逆加速，还不如直连 GitHub 的速度呢。\n\nGitHub 在 2016 年开启了 `*.github.io` 域名的 HTTPS 访问，在今年的 5 月 1 日，终于开启了对自定义域名的 HTTPS 支持。这篇文章将会介绍一下开启的办法和中间容易踩的坑。\n\n<!--more-->\n\n有关为什么要启用 HTTPS 就不多说了，HTTPS 会对传输的内容进行加密，最常见的就是防止无良运营商拦截你的流量添加广告了，也能防止用户接触被劫持的页面而上当受骗，同时不会对浏览造成什么太大的代价。\n\n按照 [GitHub 给出的说明](https://blog.github.com/2018-05-01-github-pages-custom-domains-https/)，似乎我什么都不做就能开启 HTTPS 了，仔细尝试了却发现不是这样。\n\n首先如果你开启了 CloudFlare 的 CDN 和 HTTPS，建议把它们关闭。CloudFlare 的 HTTPS 加密在 *Crypto* 面板里，找到第一项 *SSL*，设置成 `Off`，然后如果你在 *Page Rules* 里面添加了 `Always HTTPS` 之类的选项，可以删除，因为我们可以用 GitHub 提供的 `Enforce HTTPS` 选项进行跳转。然后去到 *DNS* 面板，看到那几朵红色的云朵了吗？它们代表访问时候会首先使用 CloudFlare 的 CDN，考虑到受众，这里可以点击让它变成灰色的 `DNS Only`，从而加快访问速度……\n\n然后如果你是设置 A 记录来跳转到 GitHub Pages 的话，需要修改成新的 IP 地址，GitHub 提供了下面四个 IP，不过我是比较喜欢设置 CNAME 啦：\n\n- 185.199.108.153\n\n- 185.199.109.153\n\n- 185.199.110.153\n\n- 185.199.111.153\n\n如果是 CNAME 的记录就简单啦（虽然 GitHub 文档里推荐的是 ALIAS 或者 ANAME 不过大部分的 DNS 都只有 CNAME 吧），保持你之前 `你的用户名.github.io` 的模式就行啦，比如我是 `AlynxZhou.github.io`。\n\n由于 DNS 多级缓存的存在，DNS 有关的设置需要一定时间来生效，最长大概需要 24 小时，不过一般都是很快的。\n\n然后我们需要去到你开启 Pages 服务的仓库，点击 Settings 面板往下拉，找到 *GitHub Pages* 一节的 *Custom Domain* 选项，重点在这里啦！如果你什么都不做，会发现下面 *Enforce HTTPS* 的选项是灰色的，边上可能还写着说您使用了自定义域名不能开启，难道是虚假宣传？实际上你需要 **先去掉你的自定义域名，然后再添加回来，这里才能开启**，至于你问我为什么，我也不知道。\n\n所以首先我们把这个框里面的自定义域名删掉，然后 save，然后可以访问一下 `https://你的用户名.github.io/`（如果这不是用户主页的话后面要加上仓库名字）测试一下。然后回来再次添加自定义域名，保存。应该可以发现 *Enforce HTTPS* 边上的小字变成了 *正在处理您的 HTTPS 加密证书*（大意），因为这个是 GitHub 和 Let's Encrypt 这个授权验证机构合作推出的服务，证书需要进行处理，**大概一小时之内就可以完成**，然后这次访问 `https://你的自定义域名/`，地址栏里应该就会出现小锁头，表示已经加密，就可以放心的勾选 *Enforce HTTPS* 啦！\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"写给新手的 Linux 手册 1","url":"/posts/Linux-Manual-for-Newbies-1/","content":"恰如字面意思，这是一篇写给新人的 Linux 指南，当然，不要指望从我这里得到什么详细的配置教程，最起码我没有打算在这篇文章里把你能遇到的 Linux 配置情况全部说清楚。我想在这篇文章里讲述的是一种理解方法或者说是一种 Linux 思维，换个更简单的说法是——它能在 Linux 向你吐出一堆牢骚的时候明白它在说什么，以及一个有经验的 Linux 用户这个时候会做什么，有经验的 Linux 用户是如何学习他们没有接触过的 Linux 知识的。\n\n准备好了，就继续吧。\n\n<!--more-->\n\n# 开宗明义（开篇劝退）\n\n本页面不适用于如下类型人员：\n\n- 脑残微软粉丝\n\n  如果你觉得微软爸爸什么都是好的或者你已经完全被微软圈养，现在关闭还来得及，微软不会让你在 Linux 下运行 VS 或者 Office 的，没必要找不痛快。\n\n- 认为电脑应该听我的，或者说稍微有一点不一样就觉得是 Linux 的问题的人\n\n  我不想多说什么，如果你觉得程序员改一下按钮的样式你就不会用想骂人的话，我不想认识这样的蠢货。工具是听从你的命令去帮你解决问题的，如果它工作了，你应该感激它，如果出错了，很大程度上是你给的指令有问题。\n\n- 强行用 Windows 思维去使用 Linux 的人\n\n  你不能强行用一把十字花的螺丝刀去拧一字的螺丝对吧。**使用 Linux 就要有 Linux 的思维**，当然用你熟悉的东西去类比是可以的，事实上我经常这么做，但是在遇到不一样的时候应该以现实情况为准，否则同第二条。\n\n- 没事闲的/听说这东西很少人用/打算用这玩意装X的\n\n  如果你抱着这样的想法我劝你把这种精力放在打游戏上去，很显然你的学习动力是不长久的并且很容易演化成第二种。或者觉得这东西没有达到你想要的装X效果然后再装模作样的黑一通假装自己多么了不起——趁早滚开，Linux 用户们不是觉得 Linux 不能被批评，但前提是被批评的部分确实不好用。\n\n因此本手册适合于那些确实有实际需求——Linux 从被创造出来就是一个务实的项目——并且能够接受新事物的新手，如果你确实想要了解这个系统的方方面面，必读的读物是[鸟哥的 Linux 私房菜](http://linux.vbird.org/)，虽然它看起来很厚，但是语言风趣，读下去不是很困难。\n\n# 我该选择什么版本的 Linux？\n\n和你常见的桌面操作系统不一样，Linux 本身不是一个操作系统——它只是一个操作系统内核，可以操作计算机硬件资源。我们通常把基于 Linux 内核的，由内核和其他常见的一系列软件组成的操作系统也叫做 Linux。因为大部分的组件和内核一样都是开放源代码软件，所以任何有能力的人都可以组织他们自己的操作系统，这被称为 Linux 发行版。不同发行版之间可能存在着配置上的些微差异或者用等价的软件替换掉另一部分软件，当然，它们之间大体上是相似的，学到的知识也都通用。\n\n如果你需要从头选择一个发行版，选择的条件有以下几个：\n\n1. 尽量选择最新的版本，或者支持期较长的版本中的最新版本。\n\n  过于老旧的版本通常已经失去维护，继续向下看你会发现这是很恐怖的事情。\n\n2. 尽量选择用户比较多的发行版本。\n\n  使用的人数越多，代表你出现问题时可能寻找到解决方案的机率也越大。\n\n3. 尽量选择你更熟悉的发行版。\n\n  这个不用多说了吧。\n\n如果你打算在自己的电脑上使用 Linux，推荐的版本有 [Ubuntu](https://www.ubuntu.com/global)，[LinuxMint](https://www.ubuntu.com/global)，[Fedora](https://getfedora.org/)，[openSUSE](https://www.opensuse.org/)。\n\n如果你打算在远程服务器上使用 Linux，推荐的版本有 [Debian](https://www.debian.org/index.html)，[Ubuntu Server](https://www.ubuntu.com/server), [CentOS](https://www.centos.org/)。\n\n特别需要注意的是 Ubuntu 16.04 之前的版本，Debian 8 之前的版本，CentOS 7 之前的版本由于时间过久，不建议现在选择，同时有些网站使用的是这些系统的开发代号而不是版本号，可自行搜索对照。如果你需要接手一台比较旧的服务器，请自己上网搜索或者参阅鸟哥网站，本手册不加讲解。\n\nArch Linux 或者 Gentoo Linux 一类需要使用者有较强能力的高定制性发行版不建议新人使用，如果你对自己的学习能力有信心，希望随时使用最新版本的软件，并且能够判断互联网上的消息有效期，可以考虑使用 Arch Linux，但是请务必多阅读 [Arch Wiki](https://wiki.archlinux.org/)。\n\n以上安装镜像的唯一可靠下载渠道为官方网站（已给出）或者官方指定的镜像站，请务必不要在来历不明的位置下载。\n\n# 我该怎样连接到我的服务器？SSH 又是什么？\n\n有关 SSH 的介绍来自维基百科：\n\n> Secure Shell（安全外壳协议，简称 SSH）是一种加密的网络传输协议，可在不安全的网络中为网络服务提供安全的传输环境。SSH 通过在网络中创建安全隧道来实现 SSH 客户端与服务器之间的连接。虽然任何网络服务都可以通过 SSH 实现安全传输，SSH 最常见的用途是远程登录系统，人们通常利用 SSH 来传输命令行界面和远程执行命令。使用频率最高的场合类 Unix 系统，但是 Windows 操作系统也能有限度地使用 SSH。2015 年，微软宣布将在未来的操作系统中提供原生 SSH 协议支持。\n> 在设计上，SSH 是 Telnet 和非安全 shell 的替代品。Telnet 和 Berkeley rlogin、rsh、rexec等协议采用明文传输，使用不可靠的密码，容易遭到监听、嗅探和中间人攻击。SSH 旨在保证非安全网络环境（例如互联网）中信息加密完整可靠。\n\n简单说的话，SSH 是一个协议，在操作系统上有对应的实现软件，用来在你和服务器之间传递消息，SSH 也是 UNIX 世界里最常用的远程控制协议，如果你对命令行界面有所了解，SSH 实际上是把远程 Shell 的输出传送给你，然后把你的输入传递给远程 Shell（在这里传递命令行的原因是网络通常不足以满足传递图形界面的带宽，字符更节省数据流量）。\n\n需要注意的一点是 SSH 界面的回显是由远程计算机控制的，也就是说只有远程端收到了你的输入并返回给你确认信号之后你的屏幕上才会出现输入，这种设计避免了由于网络延迟带来的输入混乱，但也因此在网络不好的时候会产生延迟，不要认为是你的计算机卡住了。\n\nSSH 分为两个部分，客户端程序 `ssh` 和服务端程序 `sshd`，同样地在 Linux 下面也有两个配置文件 `/etc/ssh/ssh_config` 和 `/etc/ssh/sshd_config`，一般情况下不需要修改客户端的配置，你需要修改的是 **服务器端** 的 `/etc/ssh/sshd_config`。同时服务器端需要将 sshd 作为一个 daemon （守护进程，可以理解为 Windows 里面的服务，在特定的时候由操作系统启动并完成一定工作的程序）启动于后台。在较新的 Linux 发行版中统一使用 Systemd 作为启动管理程序，使用下面的命令将 sshd 添加到开机启动列表并现在启动它：\n\n```\n# systemctl enable sshd --now\n```\n\n`#` 是 Shell 提示符，不要复制它，不理解往后看。\n\n通常情况下你不需要修改 sshd 的配置，默认 sshd 会监听 22 号端口，如果你知道主机名称和主机上一个账户的名字/密码，就可以在客户机上运行：\n\n```\n$ ssh username@hostname\n```\n\n连接到远程主机。hostname可以是域名或者 IP 地址。\n\n最常见的配置更改是改变 sshd 监听的端口，需要你修改 `/etc/ssh/sshd_config`，找到 `#Port 22` 这一行，删除掉前面的 `#` 以取消注释，然后修改 `22` 为你想要的值（端口范围为 0 - 65535，需要注意的是一些常见端口已经有使用比如 80 是 http 服务的端口，如果你的服务器上有这些服务运行记得避开）。之后用 `systemctl restart sshd` 重启 sshd 服务。如果你要连接到一个不是使用 22 端口的 sshd，使用 `ssh -p xxx username@hostname`，`xxx` 是你服务器的端口号。\n\nssh 还带有一个叫做 sftp 的客户端程序，可以在本机和远程之间传递文件，具体用法请自行搜索。\n\n# Shell 和终端都是什么？为什么我输入密码没有反应？\n\nShell 是一个程序（废话），它接受用户的指令并传递给内核，以便完成交互，常见的 Shell 有多种，互相之间基本兼容，通常指的是文字界面的 Shell，用户通过 Shell 执行各种其他程序。\n\nLinux 是可以没有图形界面的（与 Windows 不同），没有桌面环境的情况下 Linux 会提供叫做 tty 的字符界面，但是字符界面毕竟功能有限（只能显示英文数字，不能显示中文等复杂字符），所以我们常用桌面环境下叫做终端模拟器的程序开启一个在图形环境下的字符界面模拟器来执行各种操作，这个程序简称终端 Terminal。之所以使用字符界面的原因是图形环境通常为了做到简单易用而限制了其功能，Shell 操作相对稳定高效并且能做到各种复杂的操作，并且在服务器上没有必要开启图形界面浪费资源，所以使用 Linux 务必要掌握 Shell 的用法。\n\n最常见的 Shell 叫做 bash，一般交互方式是这样的：\n\n```\nusername@hostname currentdir $ command --args filename\n```\n\n`username@hostname currentdir $` 是提示符，每次出现它就代表现在掌握权回到了 Shell 上，你可以输入指令了，其中 `currentdir` 表示了你当前的路径，`$` 在有些 Shell 里会显示为 `%`，但是当它是 `#` 的时候说明你现在不是一般用户而是 root 用户，需要注意的是这个提示符是可以改变样式的。\n\n在 Linux 下你可以直接在提示符后面输入指令来进行操作，通常第一个位置是指令名称，比如 `cp` 代表复制，第二个位置是参数，一般以 `-` 开头，比如 `-R` 表示递归地复制子目录和目录里的文件，多个参数可以合并写比如 `-Ri`, 最后一般会接操作的文件名，对于复制来说，第一个是被复制的文件的路径，第二个是复制到的目的地，如果是文件表示复制过后改成这个名字，如果是目录就是将这个文件复制到那个目录下。各个部分之间用空白符分割比如空格或者 Tab，对于 Shell 而言连续的空白符会被识别为一个，如果文件名里有空格，用反斜杠转义。\n\n常见的命令有很多，但是要介绍的是 `man` 这个指令，如果你不知道一个命令的用法，只需要运行 `man 指令名` 就可以获取到内置的帮助文件。\n\n`pwd` 输出当前所在的路径。`ls` 指令列出目录下的文件（如果不指定目录则列出当前目录），常见的用法是 `ls -alh`，表示列出隐藏文件（`-a`），显示文件权限、所有者等详细信息（`-l`），将文件大小显示为人类易读格式（`-h`）。`mv` 移动文件，用法类似 `cp`（Linux 下没有重命名命令，将一个文件移动到另一个名字即为重命名）。`rm` 删除文件，要注意这个命令没有二次确认，同时 `-rf` 参数表示递归强制删除，慎用！\n\n`cat` 输出一个文件的内容，当然这个文件最好是纯文本（和 猫 没有关系！），`less` 也会输出文件内容，但是它增加了翻页功能（`cat` 是一股脑倒出来，`less` 则是让你一页一页看）。\n\n当你运行一个程序的时候，Shell 需要获取到这个文件的位置，Shell 有一个 `$PATH` 变量，当你只输入一个程序的名字而不是完整路径时，Shell 会逐个搜索 `$PATH` 的目录，这些目录大部分是系统存放可执行程序的位置。同时注意当前目录不在这个变量里，你可以使用相对路径（`.` 表示当前目录，`..` 表示上一层目录，`~` 表示家目录（这个只有 Shell 支持））如 `./a.out` 运行当前目录下的文件，当然你也可以使用从根目录开始的绝对路径。\n\n有些程序可能需要在后台运行，但是用 Shell 启动的程序一般在父进程也就是 Shell 退出的时候就会结束。对于有些没有提供以 daemon 方式运行的程序，可以尝试 `screen` 或者是 `tmux` 这一类终端复用器，他们可以保存 Shell 会话到后台，具体用法请自行搜索。\n\nUNIX 哲学里面，如果一个程序不是以输出信息为目的或者需要显示进度信息，那么 “没有消息就是最好的消息”，没有输出是成功的，有输出一般是报错，复制粘贴谷歌一下。\n\n最后有关不显示密码的问题，Linux Shell 下输入密码就是不显示的！！！不会显示星号或者圆点！！！这样可以保证安全。\n\n# 我该如何编辑文件？怎样安装我需要的软件？\n\n首先我在这里不会介绍 vim，不仅仅是因为我是 emacs 用户，而是因为 vim 对于新人而言实在是太难以学习了（除非你想让新手产生一串随机字符串（“Q：如何产生一串随机字符串？A：让新手退出 vim”））。新人一般是没有接触过模式化编辑器的。如果你需要编辑配置文件，使用 `nano` 这个程序就好了，`nano filename` 编辑文件就像记事本一样简单，同时它的快捷键都会列在屏幕下方。\n\n有关安装软件，请把 Windows 安装包有关的思维全部忘掉。Linux 的软件包管理方式大概可以类比为应用商店，由于大部分的软件都是开源的，每个发行版都会维护自己的一个软件仓库，使用包管理程序就可以自动下载并安装到统一位置，安装的位置都是维护者写好的，并且在数据库里有所记录，所以不需要担心卸载的时候有残留（至于什么软件安装到系统盘会影响速度的说法更是无稽之谈）。也不太需要担心软件占用过多空间，Linux 下有良好的库共享机制，所以一般软件的体积远小于 Windows（由于 Windows 缺乏有效的包管理机制，开发者一般会将所有的依赖库打包到程序安装包，造成空间浪费）。\n\nLinux 下的包管理主要有两种常见软件，Debian、Ubuntu、LinuxMint 使用 Debian 的 `dpkg` 和 `apt-get`，CentOS、Fedora、openSUSE 使用 RedHat 的 `rpm` 和 `yum`，具体使用方法请自行搜索，简单用法比如安装 `nginx` 使用 `apt-get install nginx` 或者 `yum install nginx`，便会自动从镜像站下载安装（镜像站是为了加快下载速度在全球各地建立的软件仓库的克隆）。\n\n如果你需要一个软件，首先检查软件源里是否已经有这个软件，版本是否符合要求（有些发行版为了维持稳定，不会在软件源里使用最新版软件），如果没有，搜索你所使用的发行版是否有常见的第三方源包含这些软件。请把在官网下载的安装包作为最后选项使用，因为这些下载的安装包不会被包管理所管理，需要自行删除及检查残留，相比起来包管理是自动化并且可靠的。\n\n如果你使用一个停止维护的发行版本，通常软件源已经无人维护，也就是说没人可以保证你使用的软件是安全的（甚至可能是无法使用的）。另外有关系统升级，Linux 升级的主动权掌握在你的手里（没有被 Windows **强制更新** 然后 **更新失败** 然后 **回滚** 然后 **回滚失败** 所支配的恐惧了哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈哈这世界上还有什么东西比微软的更新更不靠谱的吗），并且你可以随时打断更新流程（在不影响系统的情况下）（除了内核及相关部分更新，大部份的安装操作 **不需要重新启动**）（服务器很少重启）。另外如果不是新版本软件有什么必须的功能，**最好不要** 更新服务器上的软件。如果你习惯了一个还在维护中的不是最新的软件，Linux 和开发者不会强迫你为了新功能而更新，因为这些新功能你可能不会用到，还可能影响到系统稳定性，当然，如果有安全更新比如修复了漏洞一类的最好更新一下。\n\n# root 是谁？权限是什么？为什么没有 CDDEFG 盘？\n\n简而言之，root 是一个 UID（User ID）为 0 的特殊用户，一般用于系统管理操作，它可以操作系统的任何部分即使这些部分不是属于它的（你的我的都是我的）。因此我们不建议在日常操作中使用 root，并且需要给 root 设置复杂的密码。否则一旦入侵者掌握了 root，你的机器就变成了他的。日常使用 root 则很容易对系统造成损坏（系统不控制 root 的行为）。平时我们使用自己的用户，需要进行高权限操作比如安装软件（Linux 下安装软件是全局的也就是说你要修改不属于自己的部分）时使用 `sudo` 命令，`sudo` 会以 root 权限运行后面的命令，同时要求你输入自己的密码。但是只有列在 `sudoers` 文件里面的用户可以使用 `sudo`，具体的用法阅读 [这里](http://linux.vbird.org/linux_basic/0410accountmanager.php#sudo)。\n\n权限则是用来管理用户对于文件的操作的。使用 `ls -alh` 的时候可以看到第一列都是文件的权限，一般看起来像是 `-rwxr-xr-x`，每一位是一个信息，内容如下：\n\n1. 第一位表示的是文件类型，`-` 表示这是一个普通文件，`l` 表示这是一个连接文件（link），`d` 表示这是一个目录（dir）。\n\n2. 第二到四位是文件所有者对于文件的权限（`ls -l` 的第三列是文件所有者），`r` 表示可以读，`w` 表示可以写，`x` 表示这个文件是可以运行的（当然能不能运行还要看文件内容，比如图片当然不能执行了）。如果没有某项权限，该位置为 `-`。\n\n3. 第五到八位是文件所属用户组对于文件的权限，含义同上。\n\n4. 最后三位是既不是所有者也不属于该用户组内的其他用户对于文件的权限。\n\n如果你需要修改一个文件的权限（前提是你对这个文件有写权限），使用 `chmod num file`，其中 `num` 对应原则如下：\n\n- `r` => 4，`w` => 2, `x` => 1\n\n- 每一组加起来获得一个和，第一位不考虑，例如 `-rwxr-xr-x` 除去第一位，换算成 `755`。\n\n如果想递归改变一个目录，使用选项 `-R`。\n\n任何情况下 **不要** 将文件权限设置为 `777` 虽然你可能看到网络上有些不会用 Linux 的蠢货为了方便这样做，这意味着任何人都有权限修改这个文件，一旦入侵者在其中加入恶意代码，而你使用 root 执行了它，那么恶意代码就有了 root 权限，可以破坏或窃取任何数据。\n\n有关目录结构：Linux 使用目录树组织目录结构，与 Windows 不同，如果你需要访问一个设备上的文件，你需要把设备挂载到某个目录（相当于把设备自己的树枝接到总树上的某一枝干上，当然接到哪里不一定是固定的），Linux 下有一些约定的结构，通常我们把 /（根目录）放在一个分区上（其他目录都是接在根目录下面），然后把 /home 放在另一个分区里（通常储存了用户们自己的文件），这样一旦需要重新安装，只需要清空根目录所在分区，保留用户数据文件（同时把自己的文件不放在自己的家目录也是不明智的）。更多复杂的解释参见 [这里](http://linux.vbird.org/linux_basic/0210filepermission.php#dir) 和 [这里](http://linux.vbird.org/linux_basic/0230filesystem.php)。\n\n# 如何管理系统？\n\n现在的发行版通常使用 Systemd 作为启动后的第一个进程，并且由它后台管理启动项，因此如果你使用的是我所列出的较新发行版本，一旦上网搜索到的说明让你使用 `rc.local`、`/etc/init.d/xxx start`，直接关掉，他们过时了。\n\n一般你所需的开机启动的程序比如 http 服务器 `nginx`，在打包的时候都会有一个 `service` 文件供 Systemd 使用，Systemd 主要通过 `systemctl` 这个指令来控制，常见用法如下：\n\n- `systemctl enable nginx` 表示将 `nginx.service` 添加到启动列表里（`.service` 可以省略），如果想同时立刻启动它，在后面附加参数 `--now`。\n\n- `systemctl start nginx` 表示立即启动 `nginx`（并不影响系统重启后的操作。）（这里的启动是指由 Systemd 管理，并不是 Shell，可以理解为后台服务）。\n\n- `systemctl stop nginx` 立即停止 `nginx`。\n\n- `systemctl disable nginx` 将 `nginx` 从开机启动列表里去除，也即下一次启动系统时不启动它。加上 `--now` 可以同时停止它。\n\n- `systemctl status nginx` 查看 `nginx` 当前的运行状态信息。\n\n如果要阅读日志，使用 `journalctl` 命令。更多详细介绍参见 [这里](https://wiki.archlinux.org/index.php/Systemd)。\n\n# 提问的艺术\n\nLinux 开发者们一般都是凭借兴趣和对写程序的热情进行开发的，或者说他们不像微软和苹果的员工拿了你的钱替你解决问题，唯一让他们解决问题的动力就是写出完美的程序。因此一旦你发现了问题求助于他们，请注意你的语气，这里没有人亏欠你什么，最好进行建设性的发言，并且给出足够的信息，方便其他人帮你解决。如果一上来就吐槽但是问题却是你自己的话，做好挨骂的心理准备。\n\n# 最后，有关 “世界上最好的两种语言” Python……\n\n<blockquote class=\"centerquote\">所有使用 Python 却不指明具体版本的人都是耍流氓！</blockquote>\n\n由于 Python2 和 Python3 语法任性的不兼容，而有些发行版默认的 `python` 链接到 `python3` 有些还抱着 `python2`，建议在运行有关指令时使用具体的 `python2` 或者 `python3` 而不是 `python`。同样，使用 `pip`（Python 的包管理器，安装 Python 一些库的时候尽量用这个）的时候也要指定 `pip2` 或者 `pip3`（Python 两个版本有不同的目录，装错了没人管你）。\n\n**不要修改系统默认的 Python 版本**，除非你想让用 Python 编写的系统软件崩溃！\n\n虽然我是不建议使用 Python2 这个即将停止支持的语言，但是只要你编写的时候加上文件头：\n\n```python\n#!/usr/bin/env python2\n```\n\n就不会造成太大问题（Python3 用户把 `python2` 换成 `python3`）。\n\n最后，Linux 下的文件请一律使用 无 BOM 的 UTF-8 编码（自己查这是什么！）。\n\n不懂的一定要多搜索！搜索引擎（谷歌，必应）是好工具，不搜索永远也学不会。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Kalafina, My Music Life","url":"/posts/Kalafina-My-Music-Life/","content":"美好的东西总是在结束的时候才更显珍贵。\n\n<!--more-->\n\n# 满天\n\n<blockquote class=\"centerquote\">满天思念化作繁星</blockquote>\n\n我想不是所有人都能理解我此刻的心情。消息来的很突然，但是却不出乎意料。\n\n从梶浦由纪退出事务所的时候，大家就知道会发生这样的事情了吧。\n\n可是我还没有去听过一场 Kalafina 的演唱会现场。\n\n明明想好了即使其他歌手的演唱会都不去，K 团的现场也要去。\n\nKalafina 不只是一个演唱动漫音乐的歌手组合，在我心里歌曲和音乐始终是有分别的，因为当我把 Kalafina 划分进音乐的时候，其他的无论怎样，都只能是歌曲了。\n\n-------\n\n# To The Beginning\n\n<blockquote class=\"centerquote\">奇迹还会最后降临一次吧</blockquote>\n\n梶浦由纪退出事务所的时候，我觉得自己的半个世界崩塌了。\n\n当然梶浦还是能继续作曲的，可是 K 团怎么办呢。Twitter 下面已经有粉丝评论“我不会听没有梶浦先生的 Kalafina 歌曲”。\n\n说到底，Kalafina 成立开始就是由梶浦由纪负责的，选拔歌手也好作词作曲也好。\n\n梶浦由纪是伟大的音乐家，Kalafina 则是有完美的和声和演唱能力。\n\n梶浦和 K 团就是天作之合。\n\n在我没有看过 Fate 的时候就这么认为，看了 Fate 以后更加坚定。\n\n-------\n\n# ARIA\n\n<blockquote class=\"centerquote\">没有你的未来 此刻刚刚开始</blockquote>\n\n我曾经一度失望。\n\n我以为没有歌手能够把 LIVE 做到和 CD 一样好。\n\n这很难吗？或者说难道不应该吗？\n\n一个乐器演奏者永远不懂，我从来不相信演奏者会把自己演奏需要修饰这一点暴露出来，如果现场演奏，就是做到最好，或者和录音一样。\n\n可是我听了一些在 CD 中有完美音色的歌手的 LIVE 之后放弃了。\n\n有些没有修正的版本连音调都是不准的，有些虽然准了或者修准了，但是其感情表达远远不能和 CD 相比。\n\n也许本来如此吧，也许在现场控制自己的嗓子是很困难的事情吧。我这样欺骗自己。\n\n直到我重新发现 Kalafina。\n\n如果你也如此绝望，我希望你去听现场版的 ARIA。\n\n最好的版本是在 5th Anniversary LIVE SELECTION 2009-2012 这张专辑里，LIVE 中夹杂的情感粒度，细节的强弱音色，甚至超过了原版的听感，原版的感情太柔和了，LIVE 淋漓尽致的表现了黑暗中的抗争感。当然 Kalafina LIVE THE BEST 2015 \"Red Day\" 是另一个让人震撼的版本，虽然这个版本 Hikaru 是感冒嗓子沙哑的时候，但是她对声音的控制已经让人觉得惊艳了，甚至说可以超过其他我听过的 LIVE 的一般水平。\n\n顺便说一下，Kalafina 最开始的时候只有两个人，Wakana 和 Keiko，Hikaru 是后来在参选者中选出来的，Maya 短暂的加入之后就单飞了，在 ARIA 原版发布的时候是四个人的版本，LIVE 的时候只有三个。\n\n三个人的版本能够超越四个人的版本，并且让我惊讶的是 Hikaru 对感情的表达，彻底让我爱上了这首歌，即使这些部分原本大概不是她的。\n\n我大概知道为什么梶浦由纪会把她从三万名参选者中选出来了。\n\n-------\n\n# 君が光に変えて行く\n\n<blockquote class=\"centerquote\">为了这份渺茫的信念 你将化作光芒将它们照亮</blockquote>\n\n在我爱上 Kalafina 的时候，我是没有看过空之境界的，也没有看过 Fate。\n\n那个时候我还不知道这些曲子是为了什么而写，我也不知道歌词是什么意思。\n\n即使现在我会把一首曲子的词放到很大比重，也不影响。\n\n真正的音乐不需要通过歌词来讲述曲子的内容，实际上我喜欢的这些曲子里，发音、以及伴奏和人声交替出现的时间才是令人着迷的地方，这大概也是梶浦语出现的原因。\n\n当我开始看空之境界的时候，也是许久之后重新听到这些曲子。还是那些熟悉的旋律，熟悉到即使是今天，我也可以跟着这些曲子发音。\n\n因为在开始的那些时候，也是这样的。\n\n大概就是过了这么久的时候，才发现自己兜了一个圈子，自己中间听的这么多，结果在一开始就遇上了自己的最爱，但是只有在期年之后，才能再次认识到她的美。\n\n君将化作光明。\n\n-------\n\n# 傷跡\n\n<blockquote class=\"centerquote\">我从寂静中迈步而出 走向未曾见过的爱情</blockquote>\n\n我还能多说什么呢？\n\n有些曲子在一开始是听不懂的，只有在经历了够多，回想起来的时候才懂。\n\n我相信她们分开，是被迫的而不是因为出现了裂痕。\n\n-------\n\n# Lacrimosa\n\n<blockquote class=\"centerquote\">想再一次爱上这眩目的世界</blockquote>\n\n镇魂曲。\n\n如果可以重来一次，我愿意用一切作为代价。\n\n那个时候我不知道什么是 Bilibili，唯一看过的动漫是黑执事，Kalafina 的曲子是我听过最初听过的 JPOP。\n\n天空上冷酷无情的众神啊！\n\n-------\n\n# 辉く空の静寂には\n\n<blockquote class=\"centerquote\">有多么爱 有多么狂 似如就像这胸膛即将要烧尽狂乱一样</blockquote>\n\n很抱歉，我真的很抱歉。\n\n想哭，但是却哭不出来。当我想写的时候，才发现自己语无伦次。\n\n没有人会看的吧，或者没有人会同意的吧，因为他们不理解啊。\n\n那个阳光明媚的、美好却又有着无尽哀伤的夏天。\n\n那些睡眠被梦魔偷走的夜晚。\n\n那时候少年还不知道，就像遇见初恋一样的，Kalafina 会如此的重新塑造了他的音乐风格，音乐审美。\n\n他会因为这个开始看动漫，开始把学会日语作为一个目标，开始深深地沉迷进音乐里，把演奏的爱好珍视如生命。\n\n他会在多年之后再次深深折服于 Kalafina 的曲子。\n\n这是他**最爱**的曲子。\n\n这**一直**是他**最爱**的曲子。\n\nKalafina 是他最爱的 Musician，不是 Singer。\n\nKalafina 和梶浦由纪是他**未来**最爱的 Musician。\n\n既然没有办法重来一次，那就当现在是最美好的结局吧。能够遇见 Kalafina 是最幸运的事情了，就像遇上了音乐。\n\n璀璨的天空，静寂中。\n\n*Alynx Zhou*\n\n*A Musician*\n"},{"title":"コラージュ（卫宫家今天的饭 ED）曲谱","url":"/posts/Emiya-Menu-ED/","content":"コラージュ TV动画 卫宫家今天的饭 ED 曲谱 扒谱 Alynx Zhou\n\n<!--more-->\n\n![コラージュ.png](コラージュ.png)\n\n数字谱：\n\n```\n35[1]4 6[1]4 #5[1]3 5[1]5\n35[1]4 6[1]4 #5[1]3 5[1]5\n35[1]4 6[1]4 #5[1]3 5[1]5\n35[1]4 6[1]4\n\n555432123 4321232 (66)1(7)12\n55567[1]121 123411(7)1\n\n555432123 4321232 (66)1(7)12\n55567[1]121 123411(7)1\n\n511 1511 1511 (55)21\n(76)32 265 67[1] 123431(6)122\n\n23#4 5[2#1] 77766 23#455#433#4#4\n23#45#43#1 #12365#4#2 #23#4522(7)233\n\n23#4 5[2#1] 77766 23#455#433#4#4\n23#45#43#1 #1236[#12] 23#4522#12 23#4522#12\n```\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"CoffeeScript 的静态方法和静态变量（类方法和类变量）","url":"/posts/Coffee-Static-Varible-Method/","content":"CoffeeScript 的静态方法和静态变量其实就是 ES6 里面的静态方法和静态变量，但是本身 ES6 应该只实现了静态方法，静态变量的定义方法并不直观，同时加上 CoffeeScript 的语法就更不好得知如何实现，[coffeescript.org](http://coffeescript.org/) 似乎也没有对这方面进行过多介绍。网上搜索到的办法大部分只介绍了如何创建静态变量和静态方法，但也就到此为止了，对于其应用的写法，比如如何在实例方法里操作静态变量和如何在静态方法里操作静态变量的区别并没有详细说明。这次打算把自己写 [coffee-telegram-bot](https://github.com/AlynxZhou/coffee-telegram-bot) 时尝试出的办法记录下来。\n\n<!--more-->\n\n# 静态变量\n\n很遗憾这里没有 `static` 这么简单的关键字，即使是在 EMCAScript 里 `static` 这个关键字也只是用来修饰静态方法，用 `static` 修饰变量仍然是个提案。首先还是来说如何在常规的 JavaScript 里使用静态变量（只考虑 ES6 之后的情况，因为多亏了 CoffeeScript，我也没有写过 ES5），它是如此的简单而又奇怪，简单是因为即使是我这样又笨又懒的人看过一遍也能在 Node 里完整地默写出来不报错，但是这是有原因的——因为它实在是太古怪了以至于你看一眼就忘不了它：\n\n```JavaScript\nclass Test {\n  constructor() {\n    ++Test.counter;\n  }\n}\nTest.counter = 0;\nlet t = new Test();\nconsole.log(Test.counter);\n// 输出 1\n```\n\n没错这段代码是如此的直观，以至于我都不需要写注释来解释每一句干了什么，我敢肯定你有任何一点面向对象的基础都能明白，如果你对任何一个部分表示不理解，我建议你仔细去学习一个面向对象的程序语言—— Java 是个好选择因为它很成熟，同时是个严格的面向对象的程序语言。\n\n当然，JavaScript 并不是那么纯粹的语言或者说它几乎什么都能做一点并且这个趋势越来越大，所以你并不需要深入的面向对象知识也能看懂上面那一段代码。在 ES6 中实现一个类变量或者叫静态变量就是这个简单地两步：第一在类定义的方法内直接使用类的名字来访问静态成员——你没看错，这里没有 `this` ——毕竟这里的 `this` 在上下文中大多数指的还是实例而不是类本身。第二在类定义的外部给你想要的变量进行一个初始化（赋初值）。\n\n我敢肯定对于 JavaScript 这样一门号称“一切能够用 JavaScript 实现的最终都会用 JavaScript 实现”的语言而言肯定不只这么一种实现类变量的方法，但是最起码对我而言这是最直观的一种，我相信对于一切有一点 JavaScript 基础的人而言这也都是最直观的一种，如果你想问为什么没有更直观的在类定义内部实现的像 Java 或者什么一样的写法，很抱歉，暂时没有，或许你可以等到 ES7 的时代再来学习 JavaScript，当然到那个时候你又会被这门语言其他的问题纠结到 ES8，这很现实，这是一个不完美但同时不断高速进化的语言，它越来越广泛的应用逼着它去填由于愚蠢的商业手段导致的停滞不前带来的坑，当然最起码——JavaScript 虽然出生仓促，但基础并不很糟，或者说它有着各种奇特的实现不断让人燃烧自己的脑细胞。\n\n好了是时候回到今天的主题了，我觉得我从来就不是一个合格的 JavaScript 程序员因为我喜欢 CoffeeScript——这大概是原罪，特别是在一群 TypeScript 的好战分子眼里——我没有说 TypeScript 不好，但是我只是很喜欢 CoffeeScript 的语法糖以及动态类型带来的天马行空或者乱七八糟的写法——你何必把一只泥沼里的乌龟拉去杀死放在庙里供奉呢？\n\nCoffeeScript 的官网虽然没有明说，但是它确实有简化这部份的语法糖：\n\n你只需要像写一个方法一样写一个变量，把它放在和方法一个层次上，然后要在开头加上 `@`，无论你使用 `: ` 还是 ` = ` 来赋值都没有关系。在实例方法中使用时的写法有点变化，你不应该用 `@` 因为它不属于当前实例这个 `this`，它属于 `this` 的 `constructor` 也就是说 `@constructor`，CoffeeScript 编译器会正确的把这个替换成类的名字——没办法，JavaScript 并没有代词指代这种情况。\n\n```CoffeeScript\nclass Test\n  @counter: 0\n  constructor: () ->\n    ++@constructor.counter\nt = new Test()\nconsole.log(Test.counter)\n# 输出 1\n```\n\n编译出来的结果是这样的，虽然有着浓浓的咖啡味道但是也不难懂：\n\n```JavaScript\n// Generated by CoffeeScript 2.1.1\n(function() {\n  var Test, t;\n  Test = (function() {\n    class Test {\n      constructor() {\n        ++this.constructor.counter;\n      }\n    };\n    Test.counter = 0;\n    return Test;\n  }).call(this);\n  t = new Test();\n  console.log(Test.counter);\n  // 输出 1\n}).call(this);\n```\n\n实际上如果你只是想 **创造** 一个属于类的变量还有一种写法，但是严格来讲它并不属于类变量而是访问原型上的一个变量（不要忘了 JavaScript 的原型链），这个变量仍然会实例化，之所以在这里提起是因为网上很多搜索结果把这个也称作类变量，我认为是不正确的。\n\n```CoffeeScript\nclass Test\n  counter: 0\n  constructor: () ->\n    ++@counter\nt = new Test()\nconsole.log(Test::counter)\n# 输出 0\n```\n\n不推荐这个写法并不是因为它用了一个 C++ 常见的符号 `::`，而是因为它只能让你访问到一个原型上的变量，最后仍然会被实例化，也没有直观的语法糖让你在方法里修改它（大概直接写 `Test::` 可行？）。\n\n# 静态方法\n\n有了前面的基础静态方法无论是在原生 JavaScript 里面还是 CoffeeScript 都变得相当直观——大概只需要一个例子：\n\n在 CoffeeScript 中和处理静态变量很类似，都是简单地在前面加上 `@`，当然如果你要在静态方法里操作静态变量不需要写 `@constructor` 而是直接写 `@`，因为这个时候上下文的 `this` 就是这个类本身——严格来说这也是不对的，能够绑定到这个上下文的原因是 CoffeeScript 编译的时候增加的函数作用域——这是个好东西，咖啡味。换句话说 ES6 这里根本就没有和 `this` 扯上关系，它只能傻乎乎的用类本名，CoffeeScript 在这里自己多搞了一点，用这个来变通，翻译成 JavaScript 的时候再替换掉文本。\n\n```CoffeeScript\nclass Test\n  @counter: 0\n  @printCounter: () =>\n    console.log(@counter)\n  constructor: () ->\n    ++@constructor.counter\nt = new Test()\nTest.printCounter()\n# 输出 1\n```\n\n编译成 JavaScript 之后是这样的，`static` 关键字终于出来刷存在感了：\n\n```JavaScript\n// Generated by CoffeeScript 2.1.1\n(function() {\n  var Test, t;\n  Test = (function() {\n    class Test {\n      static printCounter() {\n        return console.log(Test.counter);\n      }\n      constructor() {\n        ++this.constructor.counter;\n      }\n    };\n    Test.counter = 0;\n    return Test;\n  }).call(this);\n  t = new Test();\n  Test.printCounter();\n  // 输出 1\n}).call(this);\n```\n\n# 总结\n\n事实上到上面已经靠几个例子说明了正确的用法，但是由于还有交叉处理的部分，简单总结一下。\n\n1.把变量写在类定义里面属性的层次并且在变量名前面加上 `@` 会在 CoffeeScript 里产生一个静态变量。\n\n2.在方法名前面加 `@` 会在 CoffeeScript 里产生一个静态方法。\n\n3.在静态方法中操作静态变量只需要像在实例方法中操作实例变量一样使用 `this`，这个作用域就是类定义的上下文，CoffeeScript 自动把 `@` 替换成类的名字以便符合 ES6 语法。\n\n4.在实例方法中操作静态变量需要使用 `@constructor`，原因是这个时候的 `this` 是实例本身而不是类，类在 CoffeeScript 里绑定到了 `this.constructor`，编译时自动替换成类的名字（因为 ES6 只能这样访问类变量而不是用一个引用）。\n\n~~5.在静态方法中操作实例变量……**根本没有这样的用法好吧！！！**~~\n\n# 碎碎念\n\n明明是凑数的文章却偏偏写了这么多，反正大概是没有人看的，毕竟 CoffeeScript 是要凉了，就像那些激进分子希望的一样，光是喜欢又有什么用呢？他们是不会管你喜欢不喜欢的，他们不喜欢就得了。短期内倒是希望 Atom 能搞点什么大新闻，可以不要让 VSCode 激进分子在我这边黑 Atom，我就是喜欢用 Atom 不喜欢用 VSCode，就算你觉得 Atom 有很多缺点可是我觉得它足够合适乃至我可以接受它的缺点，在我这边吵除了生气以外还能有什么作用不成？所以我讨厌辩论，光是说，却没什么实际作用。或者这大概是软粉和微软受害者的冲突而已？最近没得东西写出来，还是去推一推 Fate/Stay Night 或者打一打 CSGO 好了。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"StackHarbor 的 2017 尾记","url":"/posts/2017-Tail/","content":"![NJU.jpg](NJU.jpg)\n\n回到住处，掀出电脑，拉开在超市买的一听可口可乐的拉环，还有一个半小时，现在该写2017年的年终总结了。时间刚刚好。\n\n<!--more-->\n\n一直拖一直拖，拖到最后却发现把想说的都丢在了路上。\n\n想起来才发现好久以来都是“你也牵过手，是左手牵右手”，无所谓，没人看的。\n\n今晚月色真美，你的学校也是，虽然从北京来到南京也没能逃过雾霾，河北省可以不背锅了这次。\n\n喝可口可乐也会醉吗？\n\n有好多事情没有做呢，明年再说吧。我又不是个精力充沛的人。\n\n其实很想做一个深情又优雅的人啊，可以唱深情的歌，但是总是做不到的吧，提速提的再快也只能发现优雅的人他的高贵大概是天生的，再努力的结果也只是让你更清楚的认识到这中间的差距不是靠努力就能实现的。\n\n我曾经如此觊觎日月的光辉。\n\n我曾经如此渴望爱情的甜美。\n\n我曾经如此在乎他人的感受。\n\n我曾经如此高估自己的才华。\n\n能怎么样呢，有时候样子是装给别人看的，还有时候样子是装给自己看的，要么改变样子成为自己想要的，要么坦然接受自己现在的样子，做到任何一个是勇气，做不到任何一个，只能是自己给自己笑话好了。\n\n爱一个人是那么容易的事情么？\n\n也许对于18岁的自己来说是的吧，但是毕竟没有人永远18岁啊。\n\n以前就想不明白，想恋爱怎么也会是负担。但是想多了就不敢了啊。\n\n做选择为什么这么难呢。\n\n世界说这世界并不像你想像的那么友好。\n\n世界说它总是对你带有敌意。\n\n世界说你所珍视的最后总是只对你自己有意义。\n\n世界说每个人都会投入生活的洪流，最后被生活碾碎。\n\n世界说生命不断进化，但是世界永远循环往复。\n\n世界说我爱你因为你就是世界。\n\n生命如此漫长，漫长到我们不得不寻找一些事情，给他们附加上别的意义。人类就是这样一种脆弱而又倔强的物种啊，我们提出了自己是谁的终极问题，然后发现这个问题并不能推导，我们必须通过实践，认识不同的人，建立重要的关系，给事物附上属于自己的意义。生命是漫长的，但它的漫长不过是让我们有机会做完所有自己要做的事情，才能更好的认清我们自己。\n\n哪怕前面五个悍匪端起P90 Rush B，也要握紧手里的M4A1-S。早就过了可笑的追逐最强的年龄，到现在才无可救药的开始喜欢超电磁炮，即使她不是最强，即使在剧情里出现了越来越多更强的人，可是我还是喜欢她啊。\n\n一个好故事比什么都值钱，一个会讲故事的人也是。对于StackHarbor而言，又增加了一年呢，又要开始讲述新的故事。\n\n请原谅我这个不熟练的讲述者吧，因为我爱这世界。我不仅爱它的每一次相聚，也爱每一次分离，我不但歌颂每一个新生命的诞生，我也歌颂每一个生命的离去。即使知道前面是洪流，我也要追逐爱情。\n\n2018，新的一年，请多指教，当然，请不要忘记先看[最新版的About Me](/about/)。\n\n我爱你，因为你就是世界。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"忧从中来，不可断绝","url":"/posts/Song-And-Sadness/","content":"![Sadness.jpg](Sadness.jpg)\n那个弹吉他的人在我的隔壁。\n\n<!--more-->\n\n老实说他弹的很一般，但却让在琴房待了一下午一晚上的我决定多待一会。开始他只是练音阶和唱音高，但是后来他唱了几首歌，有董小姐，有不再见，还有我没听过的。\n\n虽然中间不是很连贯，有的地方还要重来，而且还隔着琴房的隔音墙。但是在这个普通的周六晚上却让我有了想哭的冲动。\n\n也许歌者无意但听者有心。当一首歌被写出来的时候，它纪录的不过是创作者的故事，但是当它被人听到的时候，就不再是只属于作者的了。喜欢听歌不过是因为想从其中听到自己的故事。\n\n有些歌曲听过了才会明白。有些故事经历过了才会懂。\n\n在这个特殊的日子里听到一段段歌声。\n\n他不需要知道我为什么哭泣。\n\n不如永远不见。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"冬天来了","url":"/posts/Winter-is-Coming/","content":"生活好像脱缰的野马，你我都不是熟练的骑师。\n\n<!--more-->\n\n昨天在外面冻了一天，今天又搞了乱七八糟的代码，所以就头疼了一天。\n\n每天还是睡不醒的样子，12点睡7点起，真想找个时间好好睡他十二个小时。\n\n昨天从东区招新回来睡了两个小时又起来去写网站到晚上十一点，今天起来上课就听说有的社团招完新第一次例会都开过的，想想我连短信都没有发，强忍着头痛拉完了群，又开始想在哪里组织活动。人一多就很难找到共同的时间，也许是我本来就不适合做这些事情，回头看仅有的四个活动室又都被选了好时间，看来都是用的脚本，又得给自己加需求了。\n\n没什么比一次热水澡更治愈了。\n\n还有一周时间要看大物和模电，又头疼。\n\n总有乱七八糟的无聊事情。我的bot还没加功能呢。\n\n如果人也有发情期，我觉得是在冬天。\n\n不知道为什么寒冷的气温反而能激发人恋爱的欲望，比起暴露的夏天，在这个温度里互相拥抱更加舒适，即使彼此都穿的臃肿。\n\n这才是恋爱和失恋的季节。每到这个温度孤独就违背自然规律从坚冰融化成海浪，后一阵总来的比前一阵猛烈。\n\nWelcome to *the StackHarbor*, sir/madam, a unreal harbor which belongs to the void sea, here's your hot milk, hope the wave sound and cold rain won't distrub your dream, good night.\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"我生气了！！！","url":"/posts/I-Am-Angry/","content":"![Angry.jpg](Angry.jpg)\n\n<blockquote class=\"centerquote\">I AM ANGRY!!!</blockquote>\n\n这里多了一只发怒的猹喵。愤怒能抑制懒惰。\n\n<!--more-->\n\n我发现可能是我的C++老师有着过于清奇的脑回路，几条没头没脑的作业评语毁了人的好心情。\n\n算了，不值得。\n\n你本来就没什么好心情。\n\n既然见面了，人们往往还是要从天气谈起。\n\n很抱歉这里没什么好天气，先是雾霾又是下雨，霾里藏雨真是可怕。\n\n生活总是在极端之间摇摆，中音谱号露脸的机会总是最少的，又好比剪指甲，太长了刮键盘恶心，太短了又会按的手指疼。\n\n我刚刚剪的有点短。\n\n希望什么的总是 **不存在的**，一件事情并不会因为在脑海里排练多次就会完美发生。\n\n也有可能连发生这件事情的机会都消失了。\n\n没有脑子，僵尸是什么时候干掉小推车的？\n\n再次体会到没有分析清楚就做事情的痛苦（由于冲动选择更新StackHarbor，这一条痛苦\\*2）。\n\n反正烦恼会解决烦恼，新的刚来到，旧的就忘掉。\n\n有时候听懂一首歌真的是不开心的事情，你仔细一听，这歌词说的，哦不对骂的，不就是我吗？\n\n为爱情折腰确实是一直以来戒不掉的癖好。\n\n你那也配叫爱情。\n\n你那也配叫编程。\n\n你那也配叫音乐。\n\n你那也配叫文学。\n\n真嫉妒啊。\n\n说好听点活着就是要不断突破自己，说不好听就是你做了这么多最后还是觉得一事无成，你还是看着那些早就自我实现的人，一边安慰性的嫌弃他们，一边羡慕的等着自己的运气。\n\n想来想去，想了好多，最后决定什么也不做，这算是逃避吗？\n\n你可真是唯心主义啊。\n\n谁管他别人怎么说，反正自己认为自己漂亮地struggle。\n\n嘴上说着不相信命运，心里比谁都希望一切顺利，一切顺利不就是不需要自己努力的代名词。\n\n所谓的赏析有点多余，不就是心里想着“哎呀这个太好了一下就把我心里想的没想的都说清楚了长的都是一样的嘴可是我怎么就说不出这样的话呢”。\n\n愤怒过后也有空窗期。\n\n该睡觉了，晚安，我跟自己说。\n\n明天又是早八点到晚六点不停转。\n\n美好的一周又要从一节C++开始了。\n\n还是相信命运吧，毕竟除了明天我们一无所有。\n\n期待明天不是因为信心漫漫，也可能是因为别无选择。\n\n开始时捱一些苦，栽种绝处的花。\n\n幸得艰辛的引路甜蜜不致太寡。\n\n你说，这开始的苦怎么就这么长呢。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Be Brave","url":"/posts/Be-Brave/","content":"It's really hard for me to type something in this post, all I want but can't express is fearness.\n\n<!--more-->\n\n![Be-Brave_1.png](Be-Brave_1.png)\n\n![Be-Brave_2.png](Be-Brave_2.png)\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=503268&auto=0&height=66\"></iframe>\n\nDon't know how to express, I think if to express is a kind of ability, I must lose this for a long time.\n\nAll I am trying to do is just like a man who cannot swim but trying his best in water, you cannot say he did nothing to help himself, but in fact his work did nothing.\n\nI am really afraid of losing control of everything I can reach, I want everything go as my thought, even a little difference can drive me crazy.\n\nI have no time can express except the darkest night, everyone lives in everyday works so hard, I cannot give them a sad face.\n\nI give it to myself. I am trying to be the most perfect and attractive to other people. I know I always fail.\n\nI know I did things wrongly, but I need chance to redo.\n\nChances are expensive, but only you get chances can you make changes.\n\nAll things go like this must have reasons.\n\nSometimes I find myself boring.\n\nI did lots of things to find other interests to support life.\n\nI listen to music, but I find I got crazy and press next in 30 seconds for a song. I cannot keep listening to even one song, I just feel tired.\n\nI read books, sometimes I can read them quickly, but most I cannot read even one page.\n\nI cannot write even one line of code.\n\nI play games from day to day, but not so happy.\n\nI want to stay alone while I want someone can stay with me.\n\nI nearly get the one, I nearly lose the one, I don't want to lose the one, I must regain the one.\n\nBut how can I get a chance?\n\nWill there be a person from the future telling me that the result?\n\nI know no one can lives in his fifteen forever.\n\nI used to think little about the far future.\n\nNow I still think little, but a little bit further.\n\nTotally out of my control, the future.\n\nGirl inside.\n\nMaybe I can only write such boring things now.\n\nSorry.\n\nBe brave, just two simple words, but how can I keep brave while facing uncertainty?\n\nI still trying to make me seems perfect.\n\nI know only in this way can I regain chance.\n\nJust for a chance.\n\nLeave tears and fearness to myself, I won't let others see.\n\nBut who can wipe my tears when I wake from dream in midnight?\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Dirty Words","url":"/posts/Dirty-Words/","content":"<blockquote class=\"centerquote\">I'm so honor that I can speak another language when they ask me to shut up with their language.</blockquote>\n\nThere are some ways to fight against with them, but only when you have enough power, sadly.\n\nI feel so lucky, though I cannot speak English so good, but if you are with me, I believe you can feel what I wanna say.\n\n<!--more-->\n\nAnd it seems that they do not care about English essay.\n\nI don't know how to say in normal words, oh yes they won't let you say.\n\nWhat could let a man give up his native language speaking something?\n\nThere is examine everywhere, and what's more horrible, the people in this \"wonderful\" land developed a kind of \"self-examine\".\n\nBecause abnormal things happen every day.\n\nInside their border. some words even some people can disappear suddenly, just because they are something different from the main idea. Even the minority is correct.\n\nOut of the border, they cannot simply remove it, but they block their people from watching.\n\nI were able not to speak those, because I am a poor programing monkey(or cat)? I am so tiny so weak. The old saying goes that \"Being quiet will save your life\". I should just write my code and live my poor life.\n\nBut I can't.\n\nFirstly they blocked words negative to them, I said nothing, because I don't believe those words, partly they taught everyone those are fake.\n\nSecondly they blocked colorful hairs on TV, I said nothing, because I don't like colorful head.\n\nThirdly they said gay and lesbian are abnormal, I said nothing, because I am not one of them.\n\nBut finally when you want to say some words, they just disappear, like you never live.\n\nThat's interesting? You and many people before you developed tools, you wanna to build a dream world, you believe that every one in the world shoud be friendly, because we are all mankind, we should love each other and be brothers or sisters, aren't we?\n\nAnd what do you think when you see devil destroyed your world?\n\nConstructors are great, who can only make problems to others is shit.\n\nThat's when self-examine come into existance.\n\nWhat a strong life a man is!\n\nEven your mouth loses your voice, you eyes lose your vision, you ears can hear nothing but \"positive energy.\"\n\nIf the so-called positive energy is everywhere, where could negative energy be? Your heart? My heart?\n\nRemove the speaking function of your mouth and leave eating here, isn't it good?\n\nBut we are not born like these!\n\nThere are days we say everything we want on the Internet, but you see, a post with hundreds of thousands of reposts were removed, you find you are so tiny.\n\nTogether we stand but then get killed?\n\nOr most of the people have a hard mind and a soft heart? Just some cheap words can let people believe a bad man is for their peace.\n\nSorry I never eat chicken soup.\n\nIf you did something with a totally wrong direction and think your practice can let others respect you, you are a totally dog shit. If you asked a group of people doing wrong thing for you, you are totally a son of the bitch.\n\nIf not, what should we do for the people in the correct direction?\n\nDon't disturb me with these silly things you made. Do what you should do.\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"你的名字。","url":"/posts/Your-Name/","content":"老实说我也许是个对电影没什么品味的人，但是在看了这个之后总觉得要写点什么。\n\n不过参考现在的时间~~和我黑暗中可怜的盲打能力~~（最后想起来我的LED灯），这篇文章不会很长。\n\n<!--more-->\n\n某种意义上来讲，虽然我是属于认为“生活就是应该有情调”的那种人，但是我的生活却一直没什么情调。最好的例子就是在看电影上，我是个几乎没去过几次电影院的人，但是看完《你的名字。》之后，我最后悔的是当时没能和你一起去电影院看，当然考虑到时间和空间确实是没有可能性，所以改成寒假一起看了《爱乐之城》。\n\n没忍住在pt上找到了片源挂下来，然后一直看到深夜，这也是少有的让我看一遍就感触颇深的剧情。\n\n上一次听到这样的曲子是什么时候来呢？大概是未闻花名的片头，略带慵懒的男声，给人的感觉像是和煦的阳光照在身上。不同的是这一次我想流泪。\n\n前一小时欢乐而又离奇的叙事，和后四十分钟虽然长，但是却能让人一直保持紧张的高潮。\n\n看了整部电影，有情感共鸣的是三叶第一次看到东京的时候。\n\n没错我想说这和我一年前的感受是一样的。\n\n仿佛走进了Minecraft的巨大化地图，当然还有并行的轨道列车，以及复杂的道路。\n\n能把生活中最有特色的部分提取出来才是真正的艺术。\n\n当然，还有泷与三叶第一次在电车上见面，以及两人在错过之后的转身而遇。\n\n有人说是故弄玄虚，但我以为这是绝妙之处。\n\n有一些文化是只有东方人才能理解的，东方文化的含蓄，对宿命和缘分的看中。\n\n三叶站在泷的面前却因为第一句话受阻而脸红不敢开口。\n\n似乎一切都没有改变，却又遇见了系守的那对情侣，抬头只看见无法确认的背影。\n\n在电车上偶然看见，仿佛突然想起一切般寻找，明明就在对面，眼泪溢满眼眶又不敢确认而错过。\n\n最后仍旧是羁绊而回头。\n\n<blockquote class=\"centerquote\">“从你的前前前世开始，我便一直在寻找着你的踪迹。”</blockquote>\n\n**即使我不记得你的名字，那就让我再大声的问你一次吧。”**\n\n灯灭了呢。\n\n不知不觉，已经过了一个月，很长？很短？我是给自己定了永远的时间线呢。\n\n今晚月色真好。\n\n晚安。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Encrypted for the Update.","url":"/posts/Encrypt-for-the-Update/","content":"Encrypted.\n\n<!--more-->\n\n我纠结我的朋友呀。\n\n猹喵从来不想做一个不信守承诺的人，可是也许这次要说声抱歉了。\n\n之前你跟我说这次考完试希望我在外面等你，我答应了，你说有些事情只有我能帮你处理，我也答应了，即使我当时就想了也许我没办法做到。\n\n我觉得除了答应没有别的办法。我可能没法准确的理解别人心里怎么想的，可是我清楚朋友心里是怎样的敏感。特别是这样的特殊情况。\n\n作为朋友我知道你负担很大，作为朋友我也只能选择相信你。作为朋友我也希望一切都能顺利，都能如你所愿，如我所愿。\n\n我希望这次不再有意外，希望你能放开负担，可是我也知道这样说很苍白，没错，大家都在这样说，可是只有当事人本身知道这么简单的话对自己来说有多难。\n\n我希望自己说的不是这些。\n\n我想说的是无论如何，我都希望能一直做你的朋友，即使不能赶去你的身边，无论高峰低谷，我希望都能陪在朋友身边。希望这样微薄的情感，比起上面那句大多数人都在说的空话，能够多一点微小但实际的作用。\n\n我还是要自私的请求原谅，没能实现我的承诺，我确实有一些令我自己都讨厌的理由，比如我明知不可能实现还答应是为了安抚你当时的心情，可是我不想就这么简单地推掉责任，难以实现就是难以实现，我就该让自己为这件事情愧疚。\n\n但是我还是自私的希望在考试结束后，你能放开这一年内发生的一切，尽管我知道这不是你的一贯作风，也许像我这样情商低的爆炸的人反而更容易做到这一点。\n\n一切的一切都是我的不对，我太无能。但是还是希望能继续陪着你，高峰低谷，即使我是这样的愚蠢，这样的令人讨厌。\n\n如果你说不能，那尽情的责怪我吧，我全部都接受。如果让我承受你的离去能换来这次考试你的全部顺利，去掉全部不顺利，那也是好的结果呢，我就默默的留在愧疚之中吧。\n\n但愿一切都能安好，顺你心意，也顺我心意，我最好的朋友。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"突然更新","url":"/posts/An-Update/","content":"<blockquote class=\"centerquote\">谨以这篇没营养的更新表明我现在闲着。</blockquote>\n\n嘛，好久不见，我还是那只猹喵*Alynx*，本着我一向诚实的原则，丑话说在前头，这篇间隔许久的更新注定是没营养的，如果你珍惜你的流量的话——\n\nWindows用户/大部分Linux用户请按右上角X，macOS用户/Ubuntu用户/自己偏要把关闭按钮挪到左面的用户请按左上角X，Android/iOS用户请按home键并把您的浏览器从多任务界面除去。Windows Phone用户（如果有的话）请把手机摔掉，并感谢我（而不是微软爸爸）给了你一个冠冕堂皇换Android/iOS设备的理由。\n\n如果您还没有坚定您的决心，实验七写完了吗？实验七50页的坑爹说明都看懂啦？没看懂还不赶紧把你打印出来的实验七说明撕了，回去高中找你的语文老师承认没好好学习语文的错误！\n\n顺便补充一句把这种垃圾实验说明打印出来本身就是对树木的不尊重了，你看我知道我写的东西很垃圾，所以我从来不打印纸质版，都是放在网站上做电子版。\n\n<!--more-->\n\n如果你成功越过了上面的重重挑战，很好，~~和我一起打开Steam，来一盘紧张刺激的CS:GO/Dota2，今天的更新到此结束，谢谢大家。~~让我们往下继续。\n\n今天是（日期自己看发布日期！）多云转晴，空气还是凉爽的，难得的好天气，虽然走在外面还是会出点汗。\n\n杯子里的冰咖啡在冰块化开之后稀释成了红茶般的颜色。\n\n**“下面插播一条新闻，您正在阅读的这篇文章由于 1. 写作者播放器播放的音乐不对 2. 写作者困了想睡觉了 3. 写作者的输入法罢工了 而推迟更新日期到无限期。”**\n\n（搞什么啊！现在的新闻都这么没劲了啊！骗鬼呢！）\n\n可是也许我想说的本来就没什么想说的，或者说我能在这里写出来点什么东西真的该感谢从小学到高中的语文老师们，我知道我不是个什么有文学天赋的学生，如果有，也被我放到代码里面了。\n\n说正经的，从上一次更新到这次更新的漫长时间里我都做了什么呢？（观众：我们对你吃了啥喝了啥和机友搞了啥没兴趣！骗人呢这不是！我：说实话我对我吃了啥也没兴趣，毕竟东区食堂就剰那么两样能吃的了。）\n\n上个可怜的三天假期花了两天时间从pt上拖下了高清的EVA，占据了我相当可观的一块硬盘空间，然后把这个套着热血OP实际是导演作死的意识流神作看完了。TV + 旧剧场版（最后那个大白丽求导演别吓宝宝了行不） + 三部新剧场版。\n\n**“福音战士新剧场版:||，现已与 科学超电磁炮3/科学超电磁炮剧场版 一起加入您的有生之年套餐！”**\n\n具体内容不评价了，毕竟EVA的分析已经有好多了，我自觉没有那个水平，你说我的感受？上面那句还不够吗？\n\n这个可怜的假期则是昨天半夜看了下载好的攻壳机动队2017，又把可怜的宝宝吓得不轻（别嫌弃喵确实比看上去要胆子小，求抱抱）。好在看完这个没有让我产生补番的冲动。\n\n（难道你这么多天不更新除了看番看电影就没干别的嘛！！！）\n\n当然有啊，写那个该死的实验七嘛，虽然没写完呢还（懒）。\n\n还有准备口琴社团的建立啊，终于开始步上正轨了，建成的时候还需要人捧场呢。\n\n还有直播啊，初生牛犊不怕虎的在B站录C语言入门教程，具体的原因嘛，嘿嘿嘿嘿嘿不告诉你们。\n\n想看的点击[这里](http://space.bilibili.com/10034969/#!/)也许能访问到我的Bilibili主页。\n\n（所以你今天写这个更新到底是要干啥啊！）\n\n不干啥啊，表示我现在（仅仅是现在）很闲（其实就是心里想偷懒）啊。\n\n如果真的想看严肃的/文学性的/技术流的/音乐向的，放心，接下来我会督促自己往下写的，不会这么长时间断更了。\n\n哦对，快要高考了是吧。送给学弟学妹们一句话，考试放松点，报志愿谨慎点。\n\n毕竟你要考试紧张了没发挥好，报志愿再不上心，今年8月份你可能就在北交大军训咯（笑哭），虽然17届在学校军训不用去怀柔也没有散训（怨念啊！），可是你们还有月考啊！还有除了计算机与信息技术什么都学就是不学计算机与信息技术的计算机与信息技术学院啊（仅限大一大类招生）！还有我们假期少啊！\n\n玩笑归玩笑，该考虑的还是要好好考虑的，毕竟你活着不应该是只为了学习或者工作，相反，工作和学习是为了更好的生活。\n\n[可是我已经考完了啊，我还纠结什么呢？](/posts/2017/05/30/Encrypt-for-the-Update/)\n\n那么今天这个没营养的更新就这样结束了，饥饿的猹喵要去觅食并准备今晚的直播了。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"灰色情人节","url":"/posts/Grey-Valentine-s-Day/","content":"感冒 + 鼻炎 = 浪费纸张，另外也许大脑缺氧会导致胡思乱想，很疲惫又无法入睡。\n\n<!--more-->\n\n终于回到了温暖的季节，天气好的让人觉得继续躲在屋子里面就是浪费了大好时光。\n\n可是自己一个人走在温暖的阳光下却感觉像是暴露在射线下一样难以忍受。\n\n所有的人离预期似乎都有差距，接近预期的却又很难制造交集。\n\n比起跨越千里的车票，直达对方内心的车票更加贵重些吧。\n\n灰色的情人节，把黑色的爱给白色的你。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"使用 GDB 进行简单的 C 语言程序调试","url":"/posts/Using-Gdb/","content":"事实证明有时候无聊的东西反而变成了一篇博文，谁叫恶趣味的C语言作业非要求用word写实验报告，本猹宁可先写成Markdown再复制粘贴过去。\n\n<!--more-->\n\n首先按照惯例应该介绍下GDB，搭配GCC使用的调试器，也是众多使用GCC为编译器的IDE的默认调试器（大概？），虽然无聊的实验报告模板还很搞笑的写了一个部分叫XXX调试器和VC6.0的比较（看戏的内心：我看过两年学生出生时间比VC6还晚的时候这些课还怎么拿VC6讲）。\n\n所以掌握GDB的使用还是很有必要的，毕竟掌握某个使用GDB的IDE终究只是掌握了一个图形壳子，原理估计还是要深入一层到直接用GDB（强行接入正经模式）。\n\n这里只是按照实验报告的要求写一下断点调试和单步执行的用法（PS：Word实在是太难用了，字号缩进和标题序号就没有按照我想要的方式工作过。\n\n------------------------\n\n# 准备\n\n## 调试模式编译程序\n\n首先应该明确调试的实现方式，GDB能够暂时的停下程序操作程序其实是通过向编译过程中的二进制流中添加钩子（HOOKS）来实现的。但是对于一个正常的，打算释出给用户使用的程序而言不应该以调试模式编译，因为这些添加进去的钩子不但会增大文件体积，还会降低程序的运行效率。所以GCC默认编译程序的时候时不会添加这个钩子的，需要的时候以`-g`参数来启用调试模式。\n\n本例中以文件[Lab2.c](/posts/2017/03/15/Using-Gdb/Lab2.c)为例，使用命令\n\n````\n$ gcc -std=c11 -g -o lab Lab2.c\n````\n\n将它编译到可执行文件lab。\n\n## 用GDB打开程序。\n\n打开程序的命令很简单，就是`$ gdb lab`，但是有可能遇到的问题是程序要处理命令行参数，在使用GDB的时候是不能直接在命令行后面附加程序参数的，需要使用参数可以在打开GDB之后输入`set args 参数1 参数2 ...`附加上参数。\n\n用GDB打开程序之后是一个交互界面，显示了一些信息和`(gdb)`这个提示符，表示你现在是在和GDB进行交互而不是程序。这个时候程序是不会运行的。\n\n````\nGNU gdb (GDB) 7.12.1\nCopyright (C) 2017 Free Software Foundation, Inc.\nLicense GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>\nThis is free software: you are free to change and redistribute it.\nThere is NO WARRANTY, to the extent permitted by law.  Type \"show copying\"\nand \"show warranty\" for details.\nThis GDB was configured as \"x86_64-pc-linux-gnu\".\nType \"show configuration\" for configuration details.\nFor bug reporting instructions, please see:\n<http://www.gnu.org/software/gdb/bugs/>.\nFind the GDB manual and other documentation resources online at:\n<http://www.gnu.org/software/gdb/documentation/>.\nFor help, type \"help\".\nType \"apropos word\" to search for commands related to \"word\"...\nReading symbols from lab...done.\n(gdb)\n````\n\n# 调试\n\n## 设置断点\n\n首先使用`break`指令就可以添加一个断点，断点顾名思义就是程序运行到这个位置会暂停下来交给GDB，这样你才能够在程序运行到一半的时候查看一些可疑的变量，断点是针对函数使用的，比如我想在所有的printf()进入的时候暂停，可以使用：\n\n````\n(gdb) break printf\n````\n\n显示的是这样的：\n\n````\n(gdb) break printf\nBreakpoint 1 at 0x400540\n````\n\n当然接下来可以继续添加更多的断点。\n\n然后使用`run`就可以让程序跑起来：\n\n````\n(gdb) run\nStarting program: /home/alynx/Homework/实验材料（学生版）/实验2/lab\n[实验2说明]本练习运行一个三重for循环, 循环结构如下:\nint count = 0;\nfor(int i=0; j<LoopEnd1; i++)\n{\n\t//第一重循环体\n\tfor(int j=0; j<LoopEnd2; j++)\n\t{\n\t\t//第二重循环体\n\t\tfor(int s=0; s<LoopEnd3; s++)\n\t\t{\n\t\t\tcount++;//第三重循环体\n\t\t}\n\t}\n}\n\nBreakpoint 1, 0x00007ffff7a86e00 in printf () from /usr/lib/libc.so.6\n````\n\n这时候使用`print`指令可以打印任意的内容：\n\n````\n(gdb) print printf\n$1 = {<text variable, no debug info>} 0x7ffff7a86e00 <printf>\n````\n\n使用`bt`指令可以显示出程序的栈（Backtrace）：\n\n````\n(gdb) bt\n#0  0x00007ffff7a86e00 in printf () from /usr/lib/libc.so.6\n#1  0x0000000000400745 in main (argc=1, argv=0x7fffffffe078) at Lab2.c:26\n````\n\n输入`c`就是继续运行程序的意思。但是`step`指令的功能更加有用，顾名思义这个就是单步运行，每次只运行一行代码，这是个step-in的模式，即如果该行有函数则进入函数内一行一行运行，而`next`则是step-over的模式，即如果该行有函数会运行函数返回结果而不是进入函数内部。\n\n````\n(gdb) step\nSingle stepping until exit from function printf,\nwhich has no line number information.\nmain (argc=1, argv=0x7fffffffe078) at Lab2.c:27\n27\t    scanf(\"%d\", &LoopEnd1);\n````\n\n如果不输入指令直接回车，就是重复上一条指令，程序运行结束之后可以使用`quit`指令退出GDB。\n\n-------------\n\n好了本猹要去补作业了。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"口琴曲谱：sister's noise","url":"/posts/Sister-s-Noise/","content":"半音阶口琴，**sister's noise** 数字谱，喵自整理版，[txt下载点击这里](sister-s-noise.txt)，[读谱方式点击这里](Music-Score/)\n\n<!--more-->\n\n````\n;;sister's noise 半音阶口琴\n\n[#5#55#5 #6#7]{#1} [#7#755]\n[#3#3#2#3]{#1}[#7#6#6#5#6#7]\n[#7#6#5#35#55#5#2 5#5#35#5#3]\n[#35#5#35#5#7#7]{#1}[#7#6]\n[#5#5#5#5 #6#7]{#1} [#7#755]\n[#3#3#2#3]{#1}[#7#6#6#6]{#2}[#7]\n[#7#6#5 5#55]\n[5#2#6#55#5 #6#5#6#7 #6#7]{#25 544}\n\n{11}[4 34336] {11}[4 545#66]\n{11}[4 34335 45556 652#66]\n{11}[4 34336] {11}[4] {21}[#6#76]\n{11}[4 3431 5434 3322]\n[21] #6[12 234 3451]\n[123 345 5#664]\n[444 45#5 55#5#2]\n[#2#6#55#5#6 #5#6#6#7#755]\n\n[#5#55#5 #6#7]{#1} [#7#755]\n[#3#3#2#3]{#1}[#7#6#6#5#6#7]\n[#7#6#5#35#55#5#2 5#5#35#5#3]\n[#35#5#35#5#7#7]{#1}[#7#6]\n[#5#5#5#5 #6#7]{#1} [#7#755]\n[#3#3#2#3]{#1}[#7#6#6#6]{#2}[#7]\n[#7#6#5 5#55]\n[5#2#6#55#5 #6#5#6#7 #6#7]{#25 544}\n\n{11}[4 454336] {11}[4 545#66]\n{11}[4 34335 45556 652#66]\n{11}[4 54336] {11}[4] {21}[#6#76]\n{11}[4 3431 5434 3322]\n[21] #6[12 234 3451]\n[123 345 5#664]\n[444 45#5 55#5#2]\n[#2#6#55#5#6 #5#6#6#7#755]\n\n[#5#55#5 #6#7]{#1} [#7#755]\n[#3#3#2#3]{#1}[#7#6#6#5#6#7]\n[#7#6#5#35#55#5#2 5#5#35#5#3]\n[#35#5#35#5#7#7]{#1}[#7#6]\n[#5#5#5#5 #6#7]{#1} [#7#755]\n[#3#3#2#3]{#1}[#7#6#6#6]{#2}[#7]\n[#7#6#5 5#55]\n[5#2#6#55#5 #6#5#6#7 #6#7]{#25 544}\n\n;; 电吉他solo。\n\n;;#5 #35#5#65#2[#6]#2[#7] [#7]#25#6#7#2[#3] #7[#3#2#1]#7[#2#1]#7#6#7#5\n;;#65 #554545#554#2[#7]#2#3[#5#6#7]#2 #7#5#4#3  5#55452[7]4\n;;4[#7] 5#2 #7#6#55 #6[#2 /*5#55*/ 4]{#1}[#7#6#6 5#5#6]#1#7#6 [1235]\n\n[555 671 77#4#4]\n[3323]{1}[766567]\n[7653#45#452 #453#453]\n[3#453#4577#776]\n\n[#5#55#5 #6#7]{#1} [#7#755]\n[#3#3#2#3]{#1}[#7#6#6#5#6#7]\n[#7#6#5#35#55#5#2 5#5#35#5#3]\n[#35#5#35#5#7#7]{#1}[#7#6]\n[#5#5#5#5 #6#7]{#1} [#7#755]\n[#3#3#2#3]{#1}[#7#6#6#6]{#2}[#7]\n[#7#6#5 5#55]\n[5#2#6#55#5 #6#5#6#7 #6#55#5 544]\n[#3#7#6#5#6#7 #6#7]{#25 544}\n````\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"口琴曲谱：LEVEL5 -judgelight-","url":"/posts/LEVEL5-judgelight/","content":"半音阶口琴，**LEVEL5 -judgelight-** 数字谱，喵自整理版，[txt下载点击这里](LEVEL5-judgelight.txt)，[读谱方式点击这里](Music-Score/)。\n\n<!--more-->\n\n````\n;;LEVEL5 -judgelight- 半音阶口琴\n\n7#67[#1#2 #27#6#5#4#2 #4#2#4#5#2]\n[#23#4#57 #6#5#4#1 #23#2]\n7#67[#1#2 #27#6#5#4#2 5#5#6]{#1#1#2}[7]\n[7#6#5 7] {#1}[7#6#4 #67#5]\n\n[#2#2]7 7[#1#2#1#4#1] 77#5 #5#67[#1#1#2#2]\n[3#2#1] 7[#1#2]#6 [#1]7#67#5 #5#6 #67#67#5\n[#2#2]#5 [#2#23 #2#2]#6#6 [#4#4#4 #43#2] 77#1#2\n#5#67 7 #5#67 7[#1]7 [#1#1]7 [#1#13#2]\n\n7#67[#1#2 #27#6#5#4#2 #4#2#4#5#2]\n[#23#4#57 #6#5#4#1 #23#2]\n7#67[#1#2 #27#6#5#4#2 5#5#6]{#1#1#2}[7]\n[7#6#5 7] {#1}[7#6#4 #67#5]\n\n[1]7[123] [3]{1}[7653 53563]\n[3456]{1} [7652 343]\n[1]7[123] [3]{1}[7653 #567]{2231}\n{1}[76] {1} {21}[75 7]{1}[6]\n\n[#2#2]7 7[#1#2#1#4#1] 77#5 #5#67[#1#1#2#2]\n[3#2#1] 7[#1#2]#6 [#1]7#67#5 #5#6 #67#67#5\n[#2#2]#5 [#2#23 #2#2]#6#6 [#4#4#4 #43#2] 77#1#2\n#5#67 7 #5#67 7[#1]7 [#1#1]7 [#1#13#2]\n\n7#67[#1#2 #27#6#5#4#2 #4#2#4#5#2]\n[#23#4#57 #6#5#4#1 #23#2]\n7#67[#1#2 #27#6#5#4#2 5#5#6]{#1#1#2}[7]\n[7#6#5 7] {#1}[7#6#4 #67#5]\n\n[1]7[123] [3]{1}[7653 53563]\n[3456]{1} [7652 343]\n[1]7[123] [3]{1}[7653 #567]{2231}\n{1}[76] {1} {21}[75 7]{1}[6]\n{1}[76] {3} {21}[75 7]{1}[6]\n\n;; 下面是电吉他solo，再下面\n\n7#67[#1#2 #27#6#5#4#2 #4#2#4#5#2]\n[#23#4#57 #6#5#4#1 #23#2]\n7#67[#1#2 #27#6#5#4#2 5#5#6]{#1#1#2}[7]\n[7#6#5 7] {#1}[7#6#4 #67#5]\n\n7#67[#1#2 #27#6#5#4#2 #4#2#4#5#2]\n[#23#4#57 #6#5#4#1 #23#2]\n7#67[#1#2 #27#6#5#4#2 5#5#6]{#1#1#2}[7]\n[7#6#5 7] {#1}[7#6#4 #67#5]\n\n[1]7[123] [3]{1}[7653 53563]\n[3456]{1} [7652 343]\n[1]7[123] [3]{1}[7653 #567]{2231}\n{1}[76] {1} {21}[75 7]{1}[6]\n{1}[76] {3} {21}[75 7]{1}[6]\n````\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"口琴曲谱：only my railgun","url":"/posts/Only-My-Railgun/","content":"半音阶口琴，**only my railgun** 数字谱，喵自整理版，[pdf下载点击这里](only_my_railgun.pdf)，[txt下载点击这里](only_my_railgun.txt)，[读谱方式点击这里](Music-Score/)\n\n<!--more-->\n\n````\n;;Only My Railgun 半音阶口琴\n\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1} [#6#4]{3 #1 #1 #1 #2}\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1}[#5] [#5#67]{#1}[#6#4#2#4]\n[#4#5#5] [7#6#4#2#4] [#4#5#5]\n\n[#5] [#55#5#6#5] [#55#5#6#7]\n[#7]{#1}[#7#6#7#6#5]{#2}[#7]\n[#5] [#55#5#6#5] [#55#5#6#7#3] [#6#55#5544]\n[#7#7#7#7#7] [#7#6#55] [5]{#2 #2}\n{#2} {#2#1}[#7#6] {#1}[#7#6#5] [55#3#5]\n[#5#5#5#5#5] [#5#67#6#6#4#4]\n[#4#3#3#2#35#5]\n[#5#55#35]\n\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1} [#6#4]{3 #1 #1 #1 #2}\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1}[#5] [#5#67]{#1}[#6#4#2]\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1} [#6#4]{3 #1 #1 #1 #2}\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1}[#5] [#5#67]{#1}[#6#4#2#4]\n[#4#5#5] [7#6#4#2#4] [#4#5#5]\n\n[#5] [#55#5#6#5] [#55#5#6#7]\n[#7]{#1}[#7#6#7#6#5]{#2}[#7]\n[#5] [#55#5#6#5] [#55#5#6#7#3] [#6#55#5544]\n[#7#7#7#7#7] [#7#6#55] [5]{#2 #2}\n{#2} {#2#1}[#7#6] {#1}[#7#6#5] [55#3#5]\n[#5#5#5#5#5] [#5#67#6#6#4#4]\n[#4#3#3#2#35#5]\n[#5#55#35]\n\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1} [#6#4]{3 #1 #1 #1 #2}\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1}[#5] [#5#67]{#1}[#6#4#2]\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1} [#6#4]{3 #1 #1 #1 #2}\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1}[#5] [#5#67]{#1}[#6#4#2#4]\n[#4#5#5] [7#6#4#2#4] [#4#5#5]\n\n;; 小提琴solo，不适合口琴演奏。\n\n;;[#4 #2#2] 7[#1#2] [#1]7 #67#6#5 #4#5#4#5 #6#5#4#5 #4#2#1#2 #1{7 #5} #2#1{7 #5}#2 #1{7 #5 #6}#1{7 #5 #6} {7}#1#2#3#4 #3#2#3#4 #5#4#3#4 #3#2#3#2 #3#4#5#4 #3#4#3#2 #3#2#1#2 #1{7#5} {#6 7} #1 #2#4#5\n;;#5 7 [#2 #5 #2#5#67 #6 #4 #1 #4 #6 7] {#1 #1 #2 3 #4 3 #2 #1} [7 #6 #5 #4 #6 #6 #5 #4 #5] [#5]{#5} {#4 3 #2 #1 #2 3 #2 #1#2#1} [7]{#1}[7] [#6#5#6] [7]{#1}[7] [#6] [#3]{#3 #1}[#5]{#1}[#5#3#1#3#1]#5 #3#5#3#1 #2(#6) #25#6[#2]#6[#2 5 #6 5 #6]{#2}\n\n;; 简化过的口琴版本，仍然不适合演奏。\n;;[#4 #2#2] 7[#1#2#2] [#1]7 #67#6#5 #4#5#6#5#4#2 #1#2#1{7 #5} #2#1{7 #5}#2 #1{7 #5 #6}#1{7 #5 #6} {7}#1#2#3#4 #3#2#5#4#3#2 #1#2 #1{7#5} {#5} #2#4#5\n;;#5 7 [#2 #5 #2#5#67 #6 #4 #1 #4 #6 7] {#1 #1 #2 3 #4 3 #2 #1} [7 #6 #5 #4 #6 #6 #5 #4 #5] [#5]{#5} {#4 3 #2 #1 #2 #1} [7] [#6] [7] [#6] [#3]{#3 #1}[#5]{#1}[#5#3#1#3#1]#5 #3#5#3#1 #2(#6) #2#6[#2]#6[#2 #6]{#2}\n\n;;#2#5 #5#67#6#4#2#4 [#1 #1]7#67[#1 #1]7#67[#1 #2 #2]\n;;#57[#2 #2 #1]7#67[#1]#5 #3#4#5#5545\n\n\n[#664] [455] [4455] [4455]\n[556#6#7] [64]{#2 1 1 1 2}\n[#664] [455] [4455] [4455]\n[556#6#75] [56#6#7642]\n[#664] [455] [4455] [4455]\n[556#6#7] [64]{#2 1 1 1 2}\n[#664] [455] [4455] [4455]\n[556#6#75] [56#6#7]{2 #2 2}\n\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1} [#6#4]{3 #1 #1 #1 #2}\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1}[#5] [#5#67]{#1}[#6#4#2]\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1} [#6#4]{3 #1 #1 #1 #2}\n[7#6#4] [#4#5#5] [#4#4#5#5] [#4#4#5#5]\n[#5#5#67]{#1}[#5] [#5#67]{#1}[#6#4#2#4]\n[#4#5#5] [7#6#4#2#4] [#4#5#5]\n````\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"喵的曲谱说明以及目录","url":"/posts/Music-Score/","content":"**以十六孔琴、标准音高为准，非口琴常用音高，十二孔请自行移调！**\n\n**大部分乐谱经本人手动整理，如有不符合说明的情况请自行处理或者等待更新！**\n\n乐谱为逐句调整，无省略。\n\n\\(低音\\)    中音    \\[高音\\]    {倍高音}\n\n<!--more-->\n\n<blockquote class=\"centerquote\">目录</blockquote>\n\n-------\n\n<h1 style=\"text-align:center\"><a href=\"../Only-My-Railgun/\">only my railgun</a></h3>\n<h2 style=\"text-align:center\">科学超电磁炮 OP1 fripSide</h5>\n\n<h1 style=\"text-align:center\"><a href=\"../LEVEL5-judgelight/\">LEVEL5 -judgelight-</a></h3>\n<h2 style=\"text-align:center\">科学超电磁炮 OP2 fripSide</h5>\n\n<h1 style=\"text-align:center\"><a href=\"../Sister-s-Noise/\">sister's noise</a></h3>\n<h2 style=\"text-align:center\">科学超电磁炮S OP1 fripSide</h5>\n\n-------\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Linux下使Steam调用Bumblebee使用独显","url":"/posts/Steam-with-Bumblebee/","content":"买了个罗技G502，想想这鼠标狙击键要在fps游戏里才能发挥作用于是入了l4d2的坑，Steam购买，没想到P530核显实在是吃不动这货，FPS上30都很困难，于是研究了一下怎么样调用Bumblebee来使用独显。\n\n<!--more-->\n\n要使用独显首先你得保证你有个独显（这不是废话吗），我的独显是Nvidia Quadro M1000M，虽然是工作站显卡，但是玩游戏应该能达到GTX960左右的性能吧（这卡渲染视频才可怕，但是我不搞多媒体~话说现在新款Precision 5520直接用台式工作站显卡了更可怕），然后你得安装Bumblebee（我只弄过N卡的，A卡不清楚），但是不是简单的安装Bumblebee这个包，按照[ArchWiki](https://wiki.archlinux.org/index.php/Bumblebee_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))，需要安装的包有`bumblebee bbswitch primus virtualgl lib32-primus lib32-virtualgl mesa xf86-video-intel nvidia nvidia-settings lib32-nvidia-utils lib32-mesa`，各个包的作用在下面：\n\n- bumblebee\n\n主要的程序啦，用来建立一个独立的X服务器做渲染。\n\n- bbswitch\n\n用来切换nvidia卡的开关状态，有了它才能保证不用的时候关闭nvidia卡省电。\n\n- primus virtualgl\n\n这两个分别是不同的桥接器，可以二选一，也可以都用，ArchWiki介绍的是virtualgl的optirun，但是primus是未来的默认选项，性能更好，Steam也推荐用primus。\n\n- lib32-primus lib32-virtualgl\n\n这两个是32位库，因为Steam和大部分上面的游戏都是32位的。\n\n- mesa xf86-video-intel nvidia nvidia-settings lib32-nvidia-utils lib32-mesa\n\nmesa是开源的OpenGL标准实现，另外的则是I卡的驱动（官方开源）和N卡的闭源驱动（性能较好），N卡的设置，以及它们对应的32位库。\n\n接下来将你的用户加入bumblebee组，启动bumblebeed：\n\n````\n# gpasswd -a user bumblebee\n# systemctl enable bumblebeed --now\n````\n\n然后测试：\n\n- 64位`$ optirun glxspheres64`\n\n- 32位`$ optirun glxspheres32`\n\n需要独显运行的程序直接用`$ optirun %command%`就好啦，当然把optirun换成primusrun就是用primus啦。\n\n对于Steam单独的游戏设置，只要在游戏上右键点*Properties*，打开的窗口选择`SET LAUNCH OPTIONS`，输入`primusrun %command%`，运行游戏的时候就是用primusrun运行了。我这里l4d2可以稳定60FPS。\n\n但是还有一些需要启动器启动的，比如Minecraft，采用Hello Minecraft Launcher，用`$ optirun java -jar HMCL.jar`启动了启动器，但是启动器却不会用optirun去运行游戏本体，解决办法也很简单：\n\n首先`$ optirun bash`，在这个bash里面用`$ optirun java -jar HMCL.jar`启动启动器，再打开游戏就是独显啦！\n\n~~本来`$ optirun status`是应该能查看N卡状态的，但是Arch似乎没法运行这个命令，可以用`$ cat /proc/acpi/bbswitch`查看ON/OFF。~~这里是我记错了，应该是用`$ optirun --status`查看N卡状态。\n\n对于一些版本比较老的bumblebee，optirun开启了独显后没法自动关掉它，是一个bug，手动关闭需要：\n\n````\n# rmmod nvidia_modeset nvidia && sudo tee /proc/acpi/bbswitch <<<OFF\n````\n\n但是新版已经解决了这个bug。\n\n如果你想开启N卡的设置，不能简单地运行nvidia-settings，因为这时候N卡并没有开启，也没有连接到当前的桌面上，使用`$ optirun nvidia-settings -c :8`就可以开启了。\n\n参考了[Steam的说明](https://support.steampowered.com/kb_article.php?ref=6316-GJKC-7437)，现在剩余的问题就是玩游戏太热了。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"碎碎念","url":"/posts/Some-Words/","content":"<blockquote class=\"centerquote\">我还是会回头、注视，街上每一个像曾经的她的人，但即使我活在过去，心里也很清楚，她的打扮早已不是那时候原来的样子了。</blockquote>\n\n没有什么好说的，无非是些碎碎念，本猹发现自己似乎有了不用 HHKB 就没法安心写代码写网站的毛病。\n\n<!--more-->\n\n叫喊着假期要学新语言选择了 Node.js 作为新目标，当然有很大的原因是 Hexo，然后发现自己还是 Too young too simple, sometimes naive 面对这么一个硬骨头无从下口，想要搞懂 Node 看来必须了解 Javascript，而 Javascript 似乎是个非常广阔的东西自己并没有找到详尽的参考，回头又发现前端的 Javascript 好多地方是不能直接拿到后端的 Node.js 上用的，然后抱着瞧一瞧看一看的思维由掉进了 CoffeeScript 的坑，用了两天时间看完了 Coffee 官网上的教程之后觉得不甚了解又想用这货写点什么，昨晚玩着 UNO 就突发奇想开了个[新坑](https://github.com/AlynxZhou/uno-coffee/)想用 CoffeeScript 实现一个联机的 UNO 游戏，仔细想了想发现需要了解的还有很多，打算边走边看（弃坑什么的才不会呢！），好像似乎大概也就是自己写个 HTTP Server 用来交换信息再写个 HTML5 的界面然后可能还会有基于 Electron 的应用（神啊我再也不给自己立 Flag 了杀了我吧！）。\n\n然后说着上次的换编辑器，大概是用上了 Atom，好多地方还得适应，首先就是不像 Emacs 几乎一套快捷键全搞定了，然后模仿 Emacs 键位的插件多多少少有些问题，某个插件导致 CPU 占用率上升，这个还没排除，总之以后有时间会解决的，最近光是把 Gentoo 换回 Arch Linux 就够折腾的了。\n\n接下来是重点！电磁炮真是太可爱了！\n\n具体怎么掉进 **某科学的超电磁炮/科学超电磁炮** 的坑说来很离奇。考完思修的下午紧接着就是两天周末休息，于是舍友高喊着应该看番放松一下，又补充了一句不看柯南，然后我就想起来说看电磁炮怎么样我一直想看（其实最早知道超炮还是 Android吧 的帖子 安吧基佬眼中的世界，其中有一幅 安吧基佬听到电磁炮 上面就是炮姐），结果舍友拒绝了，我就说那我自己看好了，打开 Bilibili 看了一集，又看了一集，又看了一集，又看了一集……然后发现由于实在太过好看剧情连贯发现自己根本停不下来，从六点一直刷到晚上十二点半刷了1-17集（其实二周目的时候发现自己不小心漏掉了第四集所以是看了16集），第二天早上起床还是没忍住用了一上午刷完了超炮第一季觉得这大概就是所谓的发现了自己的本命番的感觉美琴是真爱啊，然后决定把超炮S缓存下来留到回家的火车上看。这之间因为不过瘾又把魔法禁书目录小说/动漫里面美琴出现的地方都刷了一遍，了解了剧情走向也有点失望，于是又把科学超电磁炮的漫画刷了一遍（我也不知道窝一个从来不看漫画的人为什么会破例！)。\n\n话说回来窝站得是坚定的黑琴党（毕竟黑琴党头顶青天脚踩类人猿），河马这直男癌+后宫小说的风格还是让人觉得黑琴的结局会是 Bad End…… 总之说到这一点还是要吐一大堆槽，超炮是神作，但是原作魔禁一点也不对我的胃口，当麻人确实很好，但这种嘴炮+右手的刷级开后宫+魔法侧大比重+各种乱七八糟的圣人魔神总感觉是进入了网络小说的套路（没错还有重要一点是窝炮姐后期居然被魔神和某新晋后宫男的恶心后宫吊打！而且也很不爽炮姐被作者划归到当麻的后宫里！美琴是黑子的！当麻快回家抱你的小黄书去！）。我还是喜欢看科学侧的事情多一点。反正这里我个人给入坑的人一点提示，如果你是魔禁入坑的话就把魔禁的小说和动漫看完就好了，但是你要是超炮入坑的建议按照超炮、超炮ova、超炮S的正常顺序看完超炮动漫然后追超炮的92话漫画连载，然后就可以等天国的魔禁三出了之后的超炮三了（魔禁小说最近几卷作的死导致销量下滑所以我觉得魔禁三是有希望的），千万别碰魔禁一点以防止你被恶心到！\n\n就算希望渺茫，我也坚信美琴对当麻并不是喜欢，只是因为遇到了力量比自己强的人，关系比较密切而已，美琴和黑子也并不是同性恋，只是恰巧最合适自己的人性别相同而已。黑子才是在美琴心中特别的存在吧。我宁可不要什么天国的魔禁三，也要黑琴的 Happy End。\n\n我们喜欢的不是什么科学侧的超电磁炮、常盘台的王牌、无敌的电击公主、被电子宠爱的天赐之子，这些都是御坂美琴这个特殊的形象的一个剪影而已，她既有这些优点，也是爱好幼稚、个性难以捉摸、有教科书式傲娇、为了别人不惜牺牲生命的人。\n\n千万句Bilibili也抵不上一句Ouneisama。\n\n自己整理的超电磁炮有关的歌单本来想贴上来的，但是由于版权原因无法生成外链播放器，那就贴这首吧。\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=33913797&auto=0&height=66\"></iframe>\n\n**你指尖跃动的电光，是我此生不变的信仰，唯我超电磁炮永世长存！**\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"一些想法","url":"/posts/Some-Thoughts/","content":"话是怎么说的来着，生命在于折腾。骑磨烤柿也不能阻止折腾党的决心。\n\n其实是排着的日程太多了，不得不记录一下。\n\n<!--more-->\n\n上次终于把用 tkinter 写的 GUI 程序搞出来了，打算有时间写一篇来记录一下基础用法，但是这很明显是个浩大的工程，怎么也得考完试在说。\n\n成功跳坑到 Atom，之前一直心水这货的设计理念，最近下载了尝试一下，成功掉进了这货的设计里（没错默认的 One Dark 主题就是好看极了我就是喜欢看脸来打我啊）。菜单卡顿的问题在我从源里安装了 electron（风扇在咆哮）之后就不见了，甚至比 Sublime 还要快。弃 Emacs 坑的原因主要是各种玄学问题没发解决，比如那个奇葩的 `C-g` 要按两次才会生效，另外我这里 Emacs 包多了以后启动比 Atom 还慢……以及那些跟我说应该回 vim 坑的……我有一句妈买批不知当讲不当讲，hjkl 实在是太反人类了本猹接受不能。\n\n嗯，所以 Atom 暂时看起来没有什么严重的问题，更新了这么久 bug 应该也修复了不少，接下来要是有什么紧要的事情，那就是给 Atom 搞一套 Emacs 风格的快捷键，鼠标操作比起键盘快捷键操作明显难受的多，默认的 Atom 走的是 Windows 风格的自带的快捷键，感觉实在是不怎么样，好在 Atom 的定制化直追 Emacs，应该不成问题，然后就是要学 js 啦（总给自己开新坑系列），前端的事情这里也用得上，假期有时间打算看一看 Node.js。\n\n能想起来的大概就是这些了，迫不及待的想要考完试回家玩……让本猹抽到个白骑士·月光好不好啊……\n\n哦对了，这篇是 Build with Atom, a hackable text editor for the 21st Century.\n\n[![Atom](./Atom.png)](https://atom.io/)\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"StackHarbor 的 2016 尾记","url":"/posts/2016-Tail/","content":"![2016-tail_fushishan.jpg](2016-tail_fushishan.jpg)\n\n<blockquote class=\"centerquote\">大象永远不会遗忘。</blockquote>\n\n转眼间时光飞逝，站在了2016的尾巴上（2016：好疼！），仔细想想似乎也没什么好说的，无非是考完了高考，上了大学，写了一堆乱七八糟的代码，比如[这个](https://github.com/AlynxZhou/namefight)，嘴上天天说要做的事情还是有不少没做，比如改一改Emacs配置（这种flag成本太高了立不得），还有根本就立不了的flag一大堆，说穿了也还是自己太弱了吧。\n\n<!--more-->\n\n**本文搭配音乐食用应该更佳，为了照顾流量党和用户体验，没有设置自动播放，请手动播放后继续！**如果你伴随着音乐看完了这篇文章觉得没有达到预期，那么我只能告诉你：**最终解释权归本人所有！**\n\n<iframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"//music.163.com/outchain/player?type=2&id=306719&auto=0&height=66\"></iframe>\n\n---------------\n\n有些事，每天挂在嘴边也还是做不到，比如脱单，当然，希望在新的一年里收获感情，不要再让我孤独地等下去了，反正都知道我自己没办法出手，这个障碍还是要靠别人帮我克服。\n\n有些话，即使在心里重复了无数遍，也没办法说出口。\n\n有些人，即使离的再远，再久没有联系，好像已经完全的脱离了生活，也能在不经意间触动你。\n\n大象永远不会遗忘。\n\n给这一年分一个词语的话，我觉得是“改变”。\n\n成长是一个自然的过程，但是成熟却常常意味着与自然相反，nature如果排序的话，肯定要排在mature的后面。\n\n不出意料地写了自己的第一个带GUI的程序，虽然还是一个随意的作品，仅仅在今年结束前几天才成型，但我还是愿意把它当作自己今年编程的一个标志吧，没有写过的人不会懂，没有自己摸索写代码经历的人也不会懂。\n\n都写了那么多程序了，这么一个玩具值得这么高兴嘛。\n\n当然值得。\n\n假如你在最忙的时间里依然保持着对编程的热爱，那你就能理解。当一个人在上学放学的路上在口袋里装着写满代码的本子，没有键盘拿手机ssh也要把程序写出来的时候，能够轻松的理解更多他还不能理解的代码和工具就是他的追求，GUI就是这个追求路上的里程碑。\n\n这个GUI编程不是像大部分一样，想当然地伴随着程序出现，也不是玩具积木一样在一些工具的指导下拼接出来的，在写这个程序之前，起码要做的准备是在CLI下理解一个语言，然后把GUI作为一个工具，让程序能跟大部分人更好交流的一个实现方案。\n\n扯远了，总之我很高兴自己摸索了一个新领域，在以前根本不敢想的。编码为的是一种热爱，是为了能够取悦自己，在一行行的代码里找到问题所在并去解决它本身就是一种愉悦，或者说是自然的反应，而不是为了实现别的目的去驱使自己。\n\n值得高兴的是提了[第一个有意义的PR](https://github.com/iissnan/hexo-theme-next/pull/1327)，给NexT主题的，但是现在还是没有被合并进去，这个东西对我而言主要的意义是为了添加这个脚本，我在短时间内大概理清了NexT所用语言的组织形式和实现的结构，在之前并没有深入理解过yaml和javascript、swig的前提下，把这个脚本加进了正确的位置，并给它添加了开关，虽然最后实现的代码很简单，但是理清问题也是我想要的能力之一。\n\n唉，说了这么多废话，又没有人给我稿费，要不还是多写点技术性文章吧，还能提高点逼格，作为一只猹，本猹还是要多学习。\n\n那些在某个晚上充满灯光的屋子里坐在窗边想到的话都去哪里了呢？有些自己也觉得没头没脑的，有些实在是本猹愚钝驾驭不了的，索性放出去玩好了，至于剩下灵光一现拍脑袋能写出来的，贴上来了也没有人看，看了也没有人说好，有人说好也不会说出来。\n\n但是我还是要再打一回脸了，如果有人看见上面那句感兴趣了，想说好了想留言了，我觉得不错，推荐你看的是**[这篇](../../../04/12/Corner-Tree/index.html)**，无所谓，我又不是老罗卖情怀，能打脸就自觉打咯，不过你要是吐槽或者灌水就算了。\n\n展望2017，还能期望什么呢？反正都是靠自己付出获得的，听英语作业到吐血，终于把自己听力提高一点了，写了好多行代码，终于让自己的能力又上升一级了，吐槽是要吐的，但是光吐槽不干活可不怎么样，浪费时间就更不好了。\n\n如果你热爱一样东西，就应该能够拼尽全力，否则就是不够热爱，丢掉也不可惜，送给有选择困难和疑似心理障碍的自己。\n\n庆幸这半年认识了好多对我很好的人，比如一直一起上课的战神，自己肯定是没有看上去那么强，甚至很脆弱，总是犯各种各样的毛病，也许没有人陪的话我自己是活不下去的。再比如对我特别好的曹学姐和森神，以及虎哥，真的不知道说什么来谢谢你们，还认识了许多关系不错的朋友，比如某熊和男神，不多说了你们都懂啦，反正我是蠢喵，猹不猹的先一边子去吧……不行我这里要说的还有一群dalao比如范神、博神和某HHKB大佬，本猹还是要给各位dalao递递猹，能得到dalao夸奖肯定是本猹很开心的事情啦。\n\n所以说呢，如果2017有什么好期待的事情的话……唉太羞耻了不能说。\n\n算了太羞耻了还是要说的，藏的太深维持两面人格实在是太累了本猹受不了啦。~~我作为一个多年没有经验的隐S，还是想要**一个合拍的抖M**啦！（必须是妹子！能拿绳子捆起来玩的！）（上面那句话不要误解，我对LGBT群体没有歧视，但是我觉得无缘无故的给性取向正常的人扣个不正常的帽子，硬要把人掰弯可不能接受了，平等可不是说Gay就能随便调戏直男的好吗……）~~\n\n心理年龄大了？反正现在是没有当初折腾刷机的精力了，一切都顺顺利利的就好了，实在不行就得降低点自己的期待，满足感是个好东西。\n\n新的一年，唯愿再无波澜。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"初雪","url":"/posts/First-Snow/","content":"2016年的第一场雪？仔细想想也许不对，实际意义上的第一场雪，在每年一月份还没开春的时候就应该下完了，这怎么能叫做第一场雪呢？\n\n<!--more-->\n\n索性人类是一种充满了双重标准的物种，或者说是一种以自我为标准的物种，所以他们任性的把自己觉得是第一场雪的雪叫做第一场雪。然而，这确实是我在北京经历的第一场雪，虽然它以雨的第一形态来到世界上，在众人熟睡的时候再变为雪在空中飞舞，也许是过于流恋世界上的景色，在人们都起床之后它却忘了收起自己的踪迹，留下漫天雪花随着风飘动。\n\n只是雪太小了，小的不足以吸收掉外界的声音，小的不足以覆盖一个个温暖的梦在雪层下生长发芽。\n\n听说家里那边也下雪了，下的很大，同样的地点不同的人在同样厚的雪面上做着相同的嬉笑打闹。\n\n傍晚昏暗的天空下，人们撑起伞阻滞被风吹起的雪花钻进眼睛里。低头看见路上一双双脚移动，不小心四只鞋子两两相对，每双鞋子都想要移动给对方避让，一个往左一个往右，却偏偏又撞在一起，只好抬开伞尴尬的说一句对不起。\n\n真的很累。\n\n还是想要曾经的大雪，一片一片的雪花飞舞，落在身上，可以不大伞，尽情的接纳着大雪。\n\n曾经以为埋在雪面下的梦，现在依旧在那片雪面下生长着，温暖而美好，让人想抛开现实，回到那个风雪不停息的夜晚，那个日光黯淡下来路灯亮起的时候，那份美好幸福的期待，迎着寒风生长。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"生活在BJTU","url":"/posts/BJTU-Life/","content":"# 闲扯\n\n每一次更新都仿佛时隔多年，当然这次不全是因为懒。之前大学第一个月并没有带来自己的电脑，靠着树莓派和机房的电脑怎么折腾也都觉得劳心费力。就算没有产出，到底也是把网站的域名转移到了[alynx.xyz](http://alynx.xyz/)。顺便还把多年不换的昵称从头到脚折腾着换了一遍，*Alynx* 这个名字看起来更像是一个正规的英文名了。\n\n天气转凉，我要去把阳台的门关好再回来继续。\n\n<!--more-->\n\n# 生活\n\n作为一只没有出过远门的、来自三线城市的学生喵，去帝都上学也许是一件大事。高考前心心念念要去魔都，高考后却阴差阳错全部选择了帝都。这自然要归功于 *[Hack Ghost](http://hackghost.com/)* 这只学霸（~~啥叫学霸？学霸就是拿了辽宁省理科状元、宅在清华还继续努力的Hack Ghost……~~应*Hack Ghost*要求，将上面部分删掉。）。\n\n当然帝都的生活也不完全是雾霾、拥挤，这里有着和家乡相似的气温，有着植满树和草地的学校（以至于让我对我的高中产生了深深的嫌弃……没有树荫的路也能叫人行道？？？），这里有最适合计算机专业发展的环境。也许我是一个天性容易满足的人，虽然宿舍很小很破，但我也没有觉得不适；学校的位置紧靠着西直门交通枢纽，加上学生卡交通卡二合一，可以让我无数次的跟城郊的同学开玩笑说“进城”是什么意思。同样也有一群性格各异的舍友，每天行走在不同课程的路上，也要作为一个除了Minecraft不玩其他游戏的人看着舍友一起打别的游戏，还要忍受不能理解的游戏激动时的叫喊。可能这样的生活并没有什么特别之处，但每一天都过着自己选择的生活，有什么不能满足的呢?\n\n值得说的还有热心的学长学姐，也许不能简单地把他们对我们的帮助归结于程序员圈子里的互帮互助，但是在陌生的环境，这种帮助更有着特殊的意义，也许我们没有办法把这些感情完全的还给你们，最好的办法就是像你们一样，帮助以后的学弟学妹了吧。\n\n# 学习\n\n没错，我爱学习，学习使我快乐！专业选的好年年像高考可不是说着玩的！能理解为什么计算机学院要学习工科化学工程制图大学物理吗？？？！！！可怕……当然最坑的还是作业……放了个假微积分线性代数作业像是打了鸡血一样！默默在汽车上写了一下午微积分的我眼泪留下来……\n\n当然说回来最激动人心的还是专业课了……计算机基础课现正式更名为听常老师谈人生……C语言课就是懂得人昏昏欲睡不懂的一脸懵逼……当然我是会点还得认真听课的那种，所以我现在最轻松的科目莫名的变成了专业课么……你们别怀疑，我来自一个只有数学物理化学竞赛的三线城市，计算机竞赛是个啥？能吃吗？我可以保证我玩这些都是为了兴趣不是为了竞赛！！！\n\n所以少年我们一起去明湖边讨论C语言吧！（此处应该有个梗）\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"会发说说报时的树莓派","url":"/posts/RPi-QZone-Bot/","content":"**由于WebQQ的验证码机制更新，QQLib的作者已于2016年8月17日更新源代码，本页也随之更新！请之前使用过的朋友用`# pip3 uninstall qqlib`卸载旧版，再重新安装最新版的QQLib，使用本页最新的Python脚本！**\n\n-----------------------------------------------------------------\n\nHello，最近好久没有更新博客了，因为一直没有发现什么好玩的东西来写（其实就是因为懒）。那么前天终于发现了一个好东西，就是这个[QQLib for Python](https://github.com/gera2ld/qqlib/)，可以通过Python在QQ空间发说说的库。\n\n<!--more-->\n\n说到找这个东西的原因嘛……由于一些你懂得的原因，[Telegram](https://telegram.org/)被封锁是日益严重啊。我以前写了个非常有用的[TeleBot](https://github.com/Alynx/telebot/)跑在树莓派上，无奈身边用Telegram的人太少（~~无法装X~~），所以最开始想在树莓派上跑一个微信公众号来玩。然后发现微信的Api要求你指定一个域名，可是我树莓派跑在家里电信是不会白给我一个固定ip的（555……），为了解决这个问题我还特地造了个轮子，用Python自己封装了一个CloudXNS的Api用来定期ddns更新A记录，脚本写好了之后上网搜了一下发现有人说你在自己家里跑httpd被抓到是会被电信查水表的……虽然没有法律明文规定，但是就是这样，嗯，~~这背后一定有肮脏的PY交易~~（和谐）。于是微信公众号的计划就这样流产了……正好[L Giki](http://lgiki.xyz/)说他和他的朋友实现了一个QQ的聊天机器人，然而他们是PHP党……而且实现方法很复杂，主要是腾讯丧心病狂的加密……还有webQQ协议已经被腾讯阉割的不成样子了。百般无奈之时发现了这个GitHub项目，本着有轮子就不要自己造的原则，我决定写一个定期发说说的程序运行在树莓派上，那就是这样。\n\n老规矩，这个脚本不是很长，下面贴上来吧，它的名字叫做`qclock.py`（2016-08-17更新）：\n\n```Python\n#!/usr/bin/env python3\n#-*- coding: utf-8 -*-\n\n### Filename: qclock.py\n## Created by Alynx Zhou\n# alynxzhou@gmail.com, http://alynx.xyz/\n\nimport os\nimport time\nimport qqlib\nfrom qqlib import qzone\n\nQQ_NUM = 1234567890\nQQ_PASSWD = \"MyPassWord.\"\n\nqz = qzone.QZone(QQ_NUM, QQ_PASSWD)\n\ntry:\n    qz.login()\nexcept qqlib.NeedVerifyCode as nvc:\n    # Get a verify code.\n    verifier = nvc.verifier\n    with open(\"verify.jpg\", \"wb\") as verify_jpg:\n        verify_jpg.write(verifier.image)\n    print(\"Saved verify photo to verify.jpg, please open it by yourself.\")\n    vcode = input(\"Enter verify code here: \")\n    try:\n        # Test verify code.\n        kw = verifier.verify(vcode)\n    except qqlib.VerifyCodeError as vce:\n        os.remove(\"verify.jpg\")\n        raise vce(\"Wrong verify code!\")\n    else:\n        # Finish login.\n        qz.login()\n        os.remove(\"verify.jpg\")\n\nprint(\"Login finished.\")\n\nunit = \"°C\"\n\ndef get_temp():\n    # Get internal CPU temperature.\n    with open(\"/sys/class/thermal/thermal_zone0/temp\") as temp_open:\n        temp = float(temp_open.read())/1000\n    return temp\n\n# Loop to get time and feed to qzone.\ntry:\n    while True:\n        tm = time.localtime()\n        if tm.tm_min == 0:\n            qz.feed(\"树莓派自动报时：\\n现在是%d年%d月%d日 %d时整。\\nCPU温度为%.2f%s。\"%(tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, get_temp(), unit))\n            print(\"Feeded at %d-%.2d-%.d %.2d:%.2d.\"%(tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min))\n        elif tm.tm_min == 30:\n            qz.feed(\"树莓派自动报时：\\n现在是%d年%d月%d日 %d时%d分。\\nCPU温度为%.2f%s。\"%(tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min, get_temp(), unit))\n            print(\"Feeded at %d-%.2d-%.d %.2d:%.2d.\"%(tm.tm_year, tm.tm_mon, tm.tm_mday, tm.tm_hour, tm.tm_min))\n        # Use 60 to keep only one feed in the minute.\n        time.sleep(60)\nexcept KeyboardInterrupt:\n    exit()\n```\n\n当然，下载链接在[这里](/posts/2016/08/14/RPi-QZone-Bot/qclock.py)（2016-08-17更新）。\n\n使用的时候先把`QQ_NUM`的值修改为你打算用来~~装X~~发说说的QQ号码，`QQ_PASSWD`的值则是你QQ的密码咯。这里建议各位不要使用自己用的QQ号做实验，而是另申请QQ号来作报时～不然谁知道腾讯哪天会不会找个什么理由关闭webQQ再冻结你的QQ号呢～\n\n然后就是一句话的……不对！你还需要先安装QQLib啊，就像下面这样：\n\n```bash\n# pip3 install git+https://github.com/gera2ld/qqlib.git\n```\n\n然后一句话运行起来：\n\n```bash\n$ python3 ./qclock.py\n```\n\n保持它不要关闭，最好的办法还是[GNU Screen](https://www.gnu.org/software/screen/)啊～\n\n每到整点和半点你的树莓派就会自动发一条说说报时并附上当前的CPU温度～如果你想做更多的话完全可以自己扩展我这个脚本。记住那个`time.sleep(60)`的60不是随便能改的，一分钟一次的循环不会特别耗资源，如果你改小了间隔，可能会导致一分钟内它走了两次循环，发了两条说说。时间的精确度保持在分钟级别。\n\n然后，我用来测试的QQ号是`3530795351`，这是它的[QQ空间](http://user.qzone.qq.com/3530795351)，欢迎围观效果。\n\n好啦，这个脚本就先介绍到这里了，我要去继续完善更多功能咯，首先还是要搞好我的Emacs，然后，我不是针对腾讯，我是说BAT这三个货都是辣鸡！\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"如果时光停滞三年","url":"/posts/Three-Years/","content":"> You know how the time flies.\n\n> Only yesterday was the time of our lives.\n\n> We were born and raised in a summur haze.\n\n> Bound by the surprise of our glory days.\n\n偶然看到朋友在空间里发出的一张图片，他突发奇想在自己高中的招生网站上输入了自己当初的准考证号，然后惊讶的发现弹出的消息是您已被XX市高级中学录取。\n\n<!--more-->\n\n也许，三年并不是很长？因为我翻遍了歌单，也没有找到一首以这段时间为主题的歌曲。人们总是追求长久，再久一点，十年都不够，偏要再加一个十一年。\n\n一切的一切仿佛停滞在了三年前的那个时刻。那个时刻我们又都在做什么呢？\n\n做着什么样的事，听着什么样的歌，玩着什么样的游戏，用着什么样的手机，和什么样的人做朋友，过着怎样的一种生活。\n\n有一个瞬间叫做往事历历在目，也有现在这个瞬间叫做难以记起。是因为时间太久，久的我们都忘记了？肯定不是。\n\n就像是海边拾贝壳的孩子，收获颇丰，但当大人让他介绍一下自己的收获的时候，他却挠了挠头。\n\n也许是每一块贝壳都带着大自然相同程度的鬼斧神工，带着它引人注目的闪光点，所以他并不知道从哪一个说起，太多的话想一起挤出来，于是就变成了哑口无言。\n\n三年前带着自己的迷惑走进接下来的人生，然后到了现在发现回忆起的只有三年前的迷惑。三年的时间改变了你我，却没能改变天边那一抹晚霞。\n\n有的人像断了线的风筝，走了就再也没办法追回来。三年前就觉得自己受到过最深的伤害的人，三年后再看也觉得只是那么回事。\n\n以后的路还长着呢，不能把跤都先跌够了。万一下一个修养地的风景更好呢，是吧。\n\n时间是最好的催眠药，有时候真担心自己突然醒来，发现做了一个好长好长的梦，梦里自己经历了三年时光，醒来却发现还是三年前那个早上，看着闹钟担心自己即将迟到。\n\n时间过得飞快，三年前还在说着今后的计划，回过头来看当初的话好像刚刚说完。就像是那个错觉，自己还是拿着三年前的录取通知，紧张的担心着自己被分到哪一个班级，里面有多少曾经认识的人。\n\n还好，这一切都过去了，噩梦也好美梦也罢。时间没有停滞，总之我们顺利的来到了下一个阶段，有失去也有收获，没什么嘛，人要学会知足。\n\n再多的代价也没有办法让时间停滞三年，没有办法换回三年的第二次经历。当然我想没有人愿意拿自己三年收获的友谊、知识和财富，去碰个运气来试试召回离开的那些人。\n\n怎样的痛苦也都化作了痛哭排出心灵。\n\n你看那陀螺即将停止。\n\n醒来吧。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"用OpenWrt将树莓派打造成一台便携无线路由器","url":"/posts/RPi-Router/","content":"呐，眼看就要过年，本喵决定将去年失败的树莓派路由器计划重新提上日程，因为本喵过完年之后总要去姥爷家里住几天，他家里有网络，但是却没有路由器，而每天开着电脑插着随身WiFi实在太不环保。去年受到垃圾网卡坑害没有成功，幸好本喵朋友今年推荐了一个pi上使用超稳定的网卡，决定一不做二不休，干脆用OpenWrt和一直在吃灰的一代Pi B\\+，组成一个易于配置和使用的路由器。来吧，带着你聪明的头脑和灵巧的双手，还有你的树莓派，我们来Happy Wi\\-Fi！\n\n<!--more-->\n\n介绍下OpenWrt，它是一个针对路由器的Linux发行版，具有功能灵活强大，美观易于配置等特点，许多智能路由的固件也是基于OpenWrt修改，比如小米路由器，极路由。\n\n工欲善其事，必先利其器，首先我们来准备下必要设备：\n\n- Raspberry Pi一个（理论各版本均可，但考虑到USB无线网卡，Pi Zero可能有些不方便，另外我示范中用的Pi B\\+，2B步骤相同，不过由于架构不同，下载的文件有区别。）。\n\n- 装有Linux的电脑一台，当然你也要能熟练运用Linux（**别他喵的说你他喵玩Pi玩的是他喵的Win10 IOT，他喵的你看我他喵打这么多他喵就知道那货他喵的是微软他喵的糊弄人的东西！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！**）。\n\n- MicroSD卡一张（用做OpenWrt的TF卡不需要太大容量，毕竟img本身只有76M，但是玩Pi的都知道要选择一张大品牌高速的卡保证兼容性和性能，我一直用三星的卡觉得很好，根据大家评价闪迪的比较常用。）。\n\n- 一台已经能正常使用的家用路由器，用于Pi的网线和电源（电源尽量选择5V 2A的，这样可以保证电流足够）。\n\n- 一张无线网卡（**他喵的不要上了一些商家的当买那个他喵的EDUP的树莓派专用网卡！** 根本就是噱头！这货 **根本不是树莓派专用，只是能够被Linux直接驱动起来的一个，一些商家就骗新手说是树莓派专用。如果你用这货开AP就等着5秒钟必挂吧！** 尽量先试验你手头的所有无线网卡，确定都不可以之后再购买！Pi的配件也都是玩家们自己试出来的。我用的是朋友推荐的网件Netgear WNA1100无线网卡，不但稳定还比EDUP便宜。有需要的朋友可以私信或评论要购买地址。）\n\n好啦，接下来介绍下正式过程：\n\n1. 下载并刷入镜像；\n\n   - Optional：调整分区大小；\n\n2. 连接电脑进行初次必要调试；\n\n3. 连接路由器进行主要调试；\n\n   - Optional：自己编译并安装Shadow（河蟹）Socks，China（河蟹）DNS；\n\n4. 建立AP并调节WiFi；\n\n5. 分离广域网WAN接口和局域网LAN；\n\n6. 连接ADSL开始工作！\n\n7. 已知小问题及解决办法。\n\n------------------------------------------------------------------\n\n下面正式开始：\n\n# 下载并刷入镜像\n\n首先，我们要去[OpenWrt的官网](https://downloads.openwrt.org/chaos_calmer/15.05.1/brcm2708/)获取官方编译好的img镜像。下面有两个子目录，pi1对应的是`bcm2708`，pi2对应的是`bcm2709`，点击进入之后点击 `openwrt-15.05.1-brcm2708-bcm2708-sdcard-vfat-ext4.img` 即可开始下载，pi2对应的只是把2708全部换成了2709。\n\nPS 请务必选择带有`sdcard-vfat-ext4`的镜像。\n\nPPS 由于国内网络的特殊性，可能导致下载奇慢，可以复制下载地址之后利用百度云的离线下载。\n\n![RPi-Router_1.png](RPi-Router_1.png)\n\n下载到本地之后呢，我们要用读卡器把MicroSD卡连接上电脑，用 `lsblk -f` 查看一下SD卡的设备名，一般是/dev/sdb，如果你的系统自动挂载了SD卡，请务必用umount卸载。\n\n![RPi-Router_2.jpg](RPi-Router_2.jpg)\n\n随后我们要用dd命令把img文件烧录进SD卡！命令如下：\n\n````\n# dd if=/你的/img文件/存放的/路径/openwrt-15.05-brcm2708-bcm2708-sdcard-vfat-ext4.img of=/dev/sd你的设备路径 conv=fsync\n````\n\n记住要用root用户或者sudo来执行才能具有权限！**Pi2用户记得把2708换成2709！**\n\nPS 不要在意下图中有一个bs=2M的参数，那个是可选的！\n\nPPS 好久之前B\\+用OpenWrt不能启动的bug在15\\.05里已经修复啦！如果你还遇到接电源后红绿灯都长亮不灭不能启动的话，可以试试重新刷写一次镜像，一般都会有效。\n\n![RPi-Router_3.png](RPi-Router_3.png)\n\n完事以后多执行几次sync是个好习惯：\n\n````\n# sync\n````\n\n下面可以把卡拔下来插到Pi里面啦！当然如果你想调整分区（可选）请往下看——\n\n## 调节分区\n\n为什么要调节分区呢？相信我，用一下\n\n````\n# fdisk -l /dev/sdb\n````\n\n你就明白了。。。\n\n![RPi-Router_4.png](RPi-Router_4.png)\n\n😂这磔磔磔磔这这。。。*这开发者是喝着冰啤酒吃着火锅唱着歌做的img吗？*（别看我！我写东西时候从来不吃东西不唱歌！！！别看我！！！真的没有……）这这这分区位置都是什么鬼！！！根本都不整齐强迫症不能忍！！！还有这么大点的根分区虽然绝对够用了但是怎么能体现本喵是用2GB存储卡的有钱人（*手动斜眼滑稽*）呢？\n\n好了扯淡结束，调节分区大小的方法很多种，最简单的是用gparted图形化界面调整。但是我在这里用了笨方法，即fdisk\\+tar。实际上会这个的人一定也会用gparted（“胡扯，你就没用过！”“嘘……我用Gentoo不想编译。”）。\n\n首先我们要把读卡器接上电脑，之后把其中的文件备份出来，调整好分区大小后在放回去。\n\n首先挂载boot分区并进入～\n\n````\n# mount /dev/sdb1 /mnt && cd /mnt\n````\n\n开始用tar备份～注意后面的几个参数，它们可以保证所有文件的属性不变之类的，我会告诉你我朋友把系统从hdd搬到ssd也用的这个命令？\n\n````\n# tar -cpvzf ~/opboot.tar.gz ./\n````\n\n之后回到家目录并卸载这个分区：\n\n````\n# cd ~ && umount /mnt\n````\n\n接着root分区也是一样：\n\n````\n# mount /dev/sdb2 /mnt && cd /mnt\n# tar -cpvzf ~/oproot.tar.gz ./\n# cd ~ && umount /mnt\n````\n\n![RPi-Router_5.png](RPi-Router_5.png)\n\n接下来就可以用fdisk了，这里我给boot分区分100M，root分区分768M（openwrt的软件都很小的，默认的分区大小就够用了。），剩下1G单独划分一个分区留着备用。\n\n````\n# fdisk /dev/sdb\n````\n\n首先按o新建一个分区表，之后按n新建分区，分区类型p，分区号1，起始位置默认，结束位置输入\\+100M回车，之后按t，c，将分区类型修改为FAT。\n\n再按n新建分区，分区类型p，分区号2，起始位置默认，结束位置输入\\+768M回车.\n\n最后再按n，一路回车默认即可。\n\n之后按a，选择1，将boot分区的可启动标志打开。\n\n按w退出并写入更改。\n\n![RPi-Router_6.png](RPi-Router_6.png)\n\n接下来我们用mkfs格式化分区～这里boot分区必须是vfat格式，root分区必须是ext4格式，第三个分区可以随意，但我也格式化成ext4。\n\n````\n# mkfs.vfat /dev/sdb1\n# mkfs.ext4 /dev/sdb2\n# mkfs.ext4 /dev/sdb3\n````\n\n接下来自然是把备份的文件放回去：\n\n````\n# mount /dev/sdb1 /mnt && cd /mnt\n````\n\n这次用`tar -x`：\n\n````\n# tar -xpvzf ~/opboot.tar.gz ./\n# cd ~ && umount /mnt\n# mount /dev/sdb2 /mnt && cd /mnt\n# tar -cpvzf ~/oproot.tar.gz ./\n# cd ~ && umount /mnt\n````\n\n![RPi-Router_7.png](RPi-Router_7.png)\n\n# 连接电脑进行初次必要调试\n\n先别急着把你的pi插到路由器上，op默认pi的ip是192\\.168\\.1\\.1，要知道大部分家里的路由器的ip也是这个，所以我们先把它用网线接到电脑上，开机后修改下ip。\n\n![RPi-Router_8.jpg](RPi-Router_8.jpg)\n\n关掉你的无线连接，给pi连上电源，打开浏览器输入192.168.1.1回车，你会看到luci登陆界面，点击Login登入。\n\n接着按照屏幕上指示，我们去设置路由器登陆的密码，点击`Go to password configuration`\n\n![RPi-Router_9.png](RPi-Router_9.png)\n\n进入密码设置页面，在password里输入两次密码，滚动到最下端点击`Save and apply`。\n\n接下来去调节接口的ip，因为一会要通过这个接口上网，同时也要设置下DNS和网关。在顶栏点击Network——Interface，点击页面中LAN后面的Edit。\n\n在进入的页面中设置IP，设为你路由器网段下的一个没有被占用的ip即可，我设置为 `192.168.1.234` ，之后下面的netmask选择 `255.255.255.0` ，gateway输入路由器地址 `192.168.1.1` ，DNS也输入 `192.168.1.1` 。\n\n![RPi-Router_10.png](RPi-Router_10.png)\n\n好啦，现在树莓派基本的设置已经完成了，接下来可以关机接到路由器上了。什么？你说OpenWrt没有关机？好吧没办法，因为我也不知道怎么办，我用OpenWrt一直都是拔电源，没什么问题。\n\n# 连接路由器进行主要调试\n\n现在我们把pi拿出来～*无线网卡插到pi上，pi插到网线上，网线插到路由器上，电源线插到pi上，开机！*\n\n![RPi-Router_11.jpg](RPi-Router_11.jpg)\n\n稍等一会绿灯熄灭，这时候通过家庭局域网应该能连接上Pi了，同样，打开浏览器 `192.168.1.234` （按照你刚才设置的ip来），输入密码点击Login。\n\n是不是觉得满屏英文很不爽呢？没关系，我们先来安装中文语言。切换到System——Softwave，点击该页面的 `Update list` ，当然你也可以 `ssh root@192.168.1.234` ，登入之后执行 `opkg update` ，效果是一样的，这个命令就等价于Linux里的 `apt-get update` ， `pacman -Syy` ， `emerge --sync` ，opkg就是openwrt的包管理。当然我比较偏好ssh，因为可以即时看到命令反馈，而**luci基于网页，命令执行过程会表现为刷新，会像卡住一样。**\n\n![RPi-Router_12.png](RPi-Router_12.png)\n\n执行完了之后会输出信息 。\n\n![RPi-Router_13.png](RPi-Router_13.png)\n\n接下来在Filter里面输入chinese，点击Find package，稍等一会点击下面的Available packages，就能看到所有包名含有chinese的包啦，我们要安装的是 `luci-i18n-base-zh-cn` 和 `luci-i18n-firewall-zh-cn` ，点击名字左侧Install，弹出框里点确定稍等即可。\n\n![RPi-Router_14.png](RPi-Router_14.png)\n\n![RPi-Router_15.png](RPi-Router_15.png)\n\n现在我们切换到System——System里，点击Language and style选项卡里面的Language，看看里面是不是有一个普通话的选项了？选中之后点击Save and apply，还没有变成中文就Logout一下看看！\n\n等进去以后我们再进入系统——系统里，第一个选项卡基本设置，把里面的时区改为Asia/Shanghai，再点击上面的同步浏览器时间，最后在主机名里给你的pi设置一个独特的名字！\n\n![RPi-Router_16.png](RPi-Router_16.png)\n\n下面开始安装一些必要的软件包！据我统计有 `kmod-usb2` 、 `kmod-usb-ohci` 、 `kmod-usb-ohci` 、 `kmod-ath9k-common` 、 `kmod-ath9k-htc` （ath9k这两个包是我的网卡对应的驱动，**你的网卡需要什么驱动要根据你的芯片来定！我真的不知道你用的什么网卡！**）、 `hostapd` 。什么？你问我怎么安？过滤器在那！都是中文难道还看不懂吗？自己搜索一下！\n\n当然我更喜欢ssh一条命令解决：\n\n````\n# opkg install kmod-usb2 kmod-usb-ohci kmod-usb-ohci kmod-ath9k-common kmod-ath9k-htc hostapd\n````\n\n## 编译安装Shadow（河蟹）Socks，China（河蟹）DNS以便愉快的番茄\n\n为什么要编译呢？因为pi是小众路由器，openwrt-dist没提供预编译版……\n\n首先我们要下载openwrt的sdk，就在你下载img的那个目录里，点击 `OpenWrt-SDK-15.05.1-brcm2708-bcm2708_gcc-4.8-linaro_uClibc-0.9.33.2_eabi.Linux-x86_64.tar.bz2` 下载这个压缩好的SDK，回来之后用 `tar -xpvjf` 解压之，进入解压后的目录。\n\nPS 老规矩，Pi2用户是bcm2709。\n\n![RPi-Router_17.png](RPi-Router_17.png)\n\n有关编译工具链的问题，我在Gentoo Linux下直接就能编译，所以我也不知道需要哪些依赖，据我所知包括但不限于gcc，git，ulibc。\n\n下面我们来获取所需软件包的源码，这一步用到git：\n\n````\n# git clone https://github.com/shadowsocks/openwrt-shadowsocks.git package/shadowsocks-libev\n# git clone https://github.com/aa65535/openwrt-chinadns.git package/chinadns\n# git clone https://github.com/aa65535/openwrt-dist-luci.git package/openwrt-dist-luci\n````\n\n![RPi-Router_18.png](RPi-Router_18.png)\n\n之后我们用menuconfig选择需要编译的软件包，熟悉Linux内核编译的人都会这个：\n\n````\n# make menuconfig\n````\n\n![RPi-Router_19.png](RPi-Router_19.png)\n\n首先进入LuCI——Network里选择上带有ChinaDNS和shadowsocks的行（按空格使前面出现M），之后左右方向键切换下面到Exit，按空格以退回到首页，再切换到下面为Select，再进入Network，选中 `ChinaDNS` 和 `shadowsocks-libev-spec` 到M，之后切换下面到Save，保存之后退出。\n\n![RPi-Router_20.png](RPi-Router_20.png)\n\n![RPi-Router_21.png](RPi-Router_21.png)\n\n退出之后就可以用\n\n````\n# make V=99\n````\n\n这条命令来编译啦，编译好的文件在bin/brcm2708/package/base/里，我们要想办法把它传到pi上，最简单的方法就是把pi关掉，卡接到电脑上，把文件随便拷到卡里的一个目录，之后再开机即可安装。\n\nPS Pi2用户请注意，由于Openwrt把Pi1和Pi2的架构统称为brcm2708，所以**编译出来的软件包显示有brcm2708是正确的**。\n\n![RPi-Router_22.png](RPi-Router_22.png)\n\n下面还是要ssh到你的pi上，进入你ipk文件存放的地方，先opkg update一下，因为一会需要连网安装依赖。（每次路由器开机都需要执行一次update。）\n\n之后用\n\n````\n# opkg install 你拷贝的ipk\n````\n\n把四个ipk都安装上。\n\n下面浏览器进入LuCI，在服务里你就能看见Shadowsocks和ChinaDNS啦！\n\n首先进入Shadowsocks，把全局服务器选为`127.0.0.1#1080`，再把下面的UDP服务器设置为与全局服务器相同。\n\n之后下面的服务器配置添上**你的ss服务器的配置**，UDP转发**勾选启用**，被忽略IP列表选择**ChinaDNS路由表**。保存应用。\n\n![RPi-Router_23.jpg](RPi-Router_23.jpg)\n\n![RPi-Router_24.png](RPi-Router_24.png)\n\n接下来切换到ChinaDNS，勾选启用和启用双向配置。上游服务器改为 114.114.114.114,127.0.0.1#5300`。\n\n![RPi-Router_25.png](RPi-Router_25.png)\n\n再切换到网络——DHCP/DNS，基本设置里的DNS转发填写`127.0.0.1#5353`，HOSTS和解析文件里**勾选忽略解析文件**。\n\n![RPi-Router_26.png](RPi-Router_26.png)\n\n现在ss部署完成！\n\n# 建立AP并调节WiFi\n\n安装完成之后我们来开启wifi！首先这个必须要ssh连接上去了，电脑就是\n\n````\n$ ssh root@你的pi的ip地址\n````\n\n手机可以用juicessh，良心软件。\n\n登陆进你的pi后执行\n\n````\n# wifi detect > /etc/config/wireless\n````\n\n建立wifi配置文件。\n\n接着还没完 ，\n\n需要用vi编辑这个文件，不然wifi默认是关闭的（不会用vi/vim的同学悲剧了。。。很简单进去之后按i才可以开始编辑，编辑完按\\[Esc\\]再输入:wq即可保存，另外反正我是Emacser～别打我！）。\n\n````\n# vi /etc/config/wireless\n````\n\n注释掉`option disabled 1`的那一行（注释的意思就是在那一行开头输入个‘#’！你要会用vim直接把光标定位到那里，按dd把那行删了也行！）。\n\n![RPi-Router_27.png](RPi-Router_27.png)\n\n现在系统——重启——执行重启，之后LuCI的网络里应该能看到无线了。点击`修改`来编辑一下。\n\n首先要注意wifi信道不能设置为auto，这是个bug。\n\n![RPi-Router_28.png](RPi-Router_28.png)\n\n下面的ESSID就是你的WiFi显示的名字，自己设定好。之后去无线安全，加密选择`WPA-PSK/WPA2-PSK Mixed Mode`，密码自然是你的密码咯～\n\n![RPi-Router_29.png](RPi-Router_29.png)\n\n接着就能搜索并连接到wifi了～\n\n![RPi-Router_30.png](RPi-Router_30.png)\n\n# 分离WAN口和LAN口。\n\n现在Wi\\-Fi和有线网卡都在LAN这个网段下，要做便携路由器自然要有个WAN口，首先你要通过Wi\\-Fi连接，再登陆LuCI，先去到网络——接口，点击添加新接口，接口名称输入`wan`，协议选择`pppoe`，之后再去修改LAN，把IP和WAN错开，比如我设置为`192.168.234.234`，再**把网关和DNS都清空**（因为接下来pi就是网关了喵～）之后在物理设置里**取消勾选eth0**，再把桥接也取消，保存！\n\n# 连接ADSL开始工作\n\n把Pi和ADSL Modem连接，开机，即可作为无线路由器使用！\n\n# 已知问题和注意事项\n\n- 调节完成后dropbear（轻量的ssh服务器端）不能开机自启动，需要在系统——管理权里保存应用一下。\n\n- wifi信道不能设置为auto。\n\n- WAN口ip和LAN口ip最好不要在一个网段下。\n\n- 2016-02-08:新bug！WiFi地区代码如果不是默认的00--World的话，可能导致无线网卡挂掉！我改成CN之后挂了2333～另dropbear的bug似乎一代二代都有。\n\n搬运自我的Lofter，转载请注明出处。\n\n原文写于2016-02-06\\_21:10:25\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"动态？静态？","url":"/posts/Dynamic-or-Static/","content":"本来hexo静态博客用的好好的，结果在静好的鼓动下又想试试动态站，选择困难又犯了……\n\n<!--more-->\n\n静态站相比动态站的优点就是资源消耗小（就是几个html也不用cpu运算啊）所以可以挂到pages上去，省了vps的开销，并且文件都是Markdown的文本文件，自从用了Gentoo我就更喜欢文本文件的管理方式了，对数据库没什么好感，在本地用Emacs写也很棒。而且我不会用PHP，所以还不如静态站简单粗暴来得好一点。\n\n但是静态站是不能交互的，这导致的最大的缺点就是没有自己的评论系统一类的。虽然Disqus做的很好但是国情需要啊喂，还有就是现在它默认变成了引导用户注册！考虑了一下受众我还是放弃了……多说比较接地气，但是它的服务质量始终不能让人放心……GitHub上有一个comment(it)，把评论直接作为commit推上去，不过目前仅支持jekyll……其他的动态服务比如不蒜子数据统计还是很可靠，搜索页有现成的Local Search让它变成静态的，所以最不靠谱的还是多说？\n\n如果换成动态站的话首先是模板的问题，hexo的NexT主题的动画实在是很精致，但整个主题有点太简洁了，其实并不符合我的预期。虽然typecho有一个足以以假乱真的移植版，但是还是有些细节不一样，一旦找到合适的新主题也许我会切换过去，但是这样就要放弃Markdown文本文件……同样的还要租vps……我是个穷人……\n\n但显然动态站可以更好地支持自建评论系统，不过为了这么一个特性见过去是否有点得不偿失？\n\n目前为止hexo都可以很好的满足需求，如果有了新的需求我想我会换成动态站？不过最好的办法也许是自己造轮子？把静态部分和动态部分分开？这样就可以保持hexo目前的特性？\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"批量改名——Hrit.py","url":"/posts/Hrit/","content":"### 起因\n\n记得以前读过一篇文章，大意说是懒人推动了社会进步，觉得言之有理。你想，要不是因为原始人懒得天天找吃的，怎么会出现培养出的农作物？要不是人们懒得自己搬庄稼走路，怎么会驯化马？要不是人们懒得自己养马，怎么会出现汽车？\n\n<!--more-->\n\n好了还是不要瞎扯了，总而言之对于我这么一个懒\\+强迫症晚期\\+半吊子程序员（？），当然在写网站的时候得把网站组织的有条理，所以肯定不能把所有的文章里的图片都堆到images/目录里就得了，幸好hexo提供了所谓的资源文件夹的方式，在新建Markdown文件的时候会自动建立同名的资源文件夹，只需编辑站点配置文件`_config.yml`开启如下项即可。\n\n````yaml\npost_asset_folder: true    #开启资源文件夹\n````\n\nOK\\!这时候我天真的觉得只要把图片按数字命名为1\\.jpg、2\\.png之类的丢到对应资源文件夹里即可！然而生活远没有这么美好……首先在资源文件夹里的图片如果想在文章和首页的摘要里都显示的话就不能简单的用Markdown引用图片的语法，必须要用hexo的`asset_img`标签。\n\n````\n![图片名称](图片名称)\n````\n\n我开始方了，难道要我自己一个个手动打成这个标签……\n\n还没完，如果你的访客想下载一些图片，如果恰好你不同资源文件夹里都有一个1\\.jpg，他下载这两个的时候就会都保存为1\\.jpg……那不就乱套了么……\n\n所以我想要是能一次性给某个文件夹下的文件改名为 *文件夹名\\_数字.扩展名* 并且还能自动输出成hexo标签该多好啊……本着Linux用户没有轮子自己造的精神我决定写个程序解决这个问题（Windows用户应该习惯于找别的东西解决吧……没有就自认倒霉一个一个手动改？想想就麻烦……）\n\n### 行动\n\n于是乎高三党为了珍惜劳动节唯一一天假期（**喵的一天也叫假期！！！**）果断决定写代码，开始想想这个简单工作适合shell script但是我不会写shell脚本也不会正则表达式……（观众：你说你一个不用Win只用Linux的人不会shell脚本和正则？！我：我真不会……别打我……）那似乎我会的剩下就是C和Python了……你叫我这么一个C语言水平已经退化到HelloWorld的家伙拿C写个程序处理字符串和文件？好吧刚才的观众们你们麻烦往死里打……所以只剩下Python比较熟练了。最后也是这么做的。\n\n### 成果\n\n那这样就轮到今天的主角登场了——hrit！\n\n为什么叫这个名字呢？因为它是Hexo Rename Images Tool！当然使用了os、time和argprase的它其实能给所有文件命名……（hrit：人家只是个不到100行代码的小脚本……我：嘘……观众：他在那！！！）\n\n所以先贴代码：\n\n````Python\n#!/usr/bin/env python3\n#-*- coding:utf-8 -*-\n\n### Filename:hrit.py\n## Created by Alynx Zhou\n# alynxzhou@gmail.com, http://alynx.xyz/\n\nimport os\nimport time\nimport argparse\n\n### Deal with the argument.\nparser = argparse.ArgumentParser(description=\"hrit -- Hexo Rename Images Tool.\")\nparser.add_argument(\"-f\",\"--forehead\",action=\"store\",type=str,help=\"The string will be added to the begin of the file name.Default is the directory name(dir).\")\nparser.add_argument(\"-m\",\"--middle\",action=\"store\",default='_',type=str,help=\"This will be put between the head and the tail.Default '_'\")\nparser.add_argument(\"-n\",\"--number\",action=\"store_true\",help=\"If this argument is set,the file name between the head and the last dot will be set as an increasing number.\")\n#parser.add_argument(\"dir\",action=\"store\",nargs='?',default=\"./\",type=str,help=\"The directory to work.\")\nparser.add_argument(\"dir\",action=\"store\",type=str,help=\"The directory to work.\")\nargs = parser.parse_args()\n\n### Remember the original path.\nopath = os.getcwd()\n\n### Change directory.\nprint(\"Entering directory %s …\"%(args.dir))\ntry:\n    os.chdir(args.dir)\nexcept FileNotFoundError:\n    print(\"ERROR!Can't find directory %s !\"%(args.dir))\n    print(\"Quiting…\")\n    exit()\ncurdir = os.getcwd()\n\n### Ask.\nprint(\"Now it is going to work in \")\nprint(\"=====================================================\")\nprint(\"%s\"%(curdir))\nprint(\"=====================================================\")\nprint(\"Please check weither it is the exact directory you want!\")\nprint(\"Work in other directories can be dangerous and hard to fix(For instance,/,/home,/usr,etc.)!\")\nanswer = input(\"Continue?[y/N] \")\nif answer != 'y' and answer != \"yes\":\n    print(\"Quiting…\")\n    os.chdir(opath)\n    exit()\n\nprint(\"Wating 5 seconds to regret…\")\nilist = [\"5…\",\"5 4…\",\"5 4 3…\",\"5 4 3 2…\",\"5 4 3 2 1…\"]\nfor i in ilist:\n    print(\"%s\\r\"%(i),end=\"\")\n    time.sleep(1)\nprint(\"5 4 3 2 1…Start!\\n\")\n\n### Get dir.\nif args.forehead == None:\n    forehead = curdir.split(os.sep)[-1]\nelse:\n    forehead = args.forehead\n\n### List files.\nfilelist = os.listdir(curdir)\nprint(\"Found files:%s.\\n\"%(filelist))\n\n### Rename.\nif args.number == True:\n    ## Number name.\n    number = 1\n    for file in filelist:\n        filel = file.split('.')\n        if len(filel) == 1:\n            ## Without extand name.\n            newname = forehead + args.middle + str(number)\n        else:\n            ## With extand name.\n            newname = forehead + args.middle + str(number) + '.' + filel[-1]\n\n        os.renames(file,newname)\n        print(\"Renamed %s to %s.\"%(file,newname))\n        number = number + 1\nelse:\n    for file in filelist:\n        newname = forehead + args.middle + file\n\n        os.renames(file,newname)\n        print(\"Renamed %s to %s.\"%(file,newname))\n\n### Get new file list.\nnewlist = os.listdir(curdir)\nprint(\"\\nNow you can copy the follow hexo tags to your markdown post.\\n\")\nfor new in newlist:\n    print(\"{%% asset_img %s %s %%}\\n\"%(new,new))\n\n### Go back to original path.\nos.chdir(opath)\n````\n\n好了亲爱的观众们我知道你们又要抱怨你们的Vim/Emacs设置了代码自动缩进粘贴Python很麻烦……（你说你用Sublime Text或者Notepad++？好吧自便。你说你用记事本？这我就不能忍了，哪凉快哪呆着去！→\\_→）我就大发慈悲把源文件传上来吧，右键点击[这里](/posts/2016/05/03/Hrit/hrit.py)另存为即可。然后拷贝到你的PATH中任意一个目录。\n\n接下来说用法～什么用法？直接执行hrit -h不就有用法了吗？\n\n总而言之hrit会以一个文件夹为单位把里面所有的文件按照指定的规则重命名，所以最后必须接一个文件夹参数比如\\./test/，没有设置默认\\./的原因是为了安全～hrit将文件名分为五部分操作，前缀、连接符、后缀、英文句点和扩展名。然后如果指定了 *-f 前缀* 的话文件都会被添加上同一前缀，没有-f则默认以当前目录名为前缀。 * -m 连接符* 指定连接符，默认是“\\_”。最后hrit会把原本的文件名（包括句点和扩展名）一起接上作为后缀。如果开启了 *-n* 它会用从1开始递增的数字作为后缀，并连接上句点和原本的扩展名（如果你非要把文件命名为aaa\\.bb\\.c那hrit只会把\\.c连接上……）。\n\n下面示范一下，进入我饱经摧残的test/目录。\n\n````\n$ cd test/ && ls -alh\ntotal 8.0K\ndrwxr-xr-x 2 shax shax 4.0K May  2 21:58 .\ndrwxr-xr-x 3 shax shax 4.0K May  2 11:44 ..\n-rw-r--r-- 1 shax shax    0 May  2 21:58 aaa\n-rw-r--r-- 1 shax shax    0 May  2 21:58 bb.b\n-rw-r--r-- 1 shax shax    0 May  2 21:58 c.c.c\n````\n\n下面执行下\n\n````\n$ hrit ./\nEntering directory ./ …\nNow it is going to work in\n=====================================================\n/home/shax/ProgramPractice/hrit/test\n=====================================================\nPlease check weither it is the exact directory you want!\nWork in other directories can be dangerous and hard to fix(For instance,/,/home,/usr,etc.)!\nContinue?[y/N] y\nWating 5 seconds to regret…\n5 4 3 2 1…Start!\n\nFound files:['aaa', 'c.c.c', 'bb.b'].\n\nRenamed aaa to test_aaa.\nRenamed c.c.c to test_c.c.c.\nRenamed bb.b to test_bb.b.\n\nNow you can copy the follow hexo tags to your markdown post.\n\n![test_c.c.c](test_c.c.c)\n\n![test_bb.b](test_bb.b)\n\n![test_aaa](test_aaa)\n````\n\n为了防止搞错了目录设置了一个确认和5秒反悔时间。\n\n下面试试 `-f`\n\n````\n$ hrit -f xxx ./\nEntering directory ./ …\nNow it is going to work in\n=====================================================\n/home/shax/ProgramPractice/hrit/test\n=====================================================\nPlease check weither it is the exact directory you want!\nWork in other directories can be dangerous and hard to fix(For instance,/,/home,/usr,etc.)!\nContinue?[y/N] y\nWating 5 seconds to regret…\n5 4 3 2 1…Start!\n\nFound files:['test_c.c.c', 'test_bb.b', 'test_aaa'].\n\nRenamed test_c.c.c to xxx_test_c.c.c.\nRenamed test_bb.b to xxx_test_bb.b.\nRenamed test_aaa to xxx_test_aaa.\n\nNow you can copy the follow hexo tags to your markdown post.\n\n![xxx_test_c.c.c](xxx_test_c.c.c)\n\n![xxx_test_aaa](xxx_test_aaa)\n\n![xxx_test_bb.b](xxx_test_bb.b)\n````\n\n最后 `-n`\n\n````\n$ hrit -n ./\nEntering directory ./ …\nNow it is going to work in\n=====================================================\n/home/shax/ProgramPractice/hrit/test\n=====================================================\nPlease check weither it is the exact directory you want!\nWork in other directories can be dangerous and hard to fix(For instance,/,/home,/usr,etc.)!\nContinue?[y/N] y\nWating 5 seconds to regret…\n5 4 3 2 1…Start!\n\nFound files:['xxx_test_c.c.c', 'xxx_test_aaa', 'xxx_test_bb.b'].\n\nRenamed xxx_test_c.c.c to test_1.c.\nRenamed xxx_test_aaa to test_2.\nRenamed xxx_test_bb.b to test_3.b.\n\nNow you can copy the follow hexo tags to your markdown post.\n\n![test_2](test_2)\n\n![test_1.c](test_1.c)\n\n![test_3.b](test_3.b)\n````\n\n不错吧，这样以后直接把所有图片拷贝到资源文件夹里用`hrit -n ./xxxx/`即可批量命名了～然后直接把输出的标签拷贝到Markdown文件～\n\n最后说一个小插曲，开始我设置了询问继续和五秒倒计时的时候其实并不觉得有什么用……直到某次调试时不小心在home下执行了hrit……幸好有5秒按Ctrl\\+C，顿时觉得自己真是太机智了。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Three Trees","url":"/posts/Three-Trees/","content":"![Three-Trees_1.jpg](Three-Trees_1.jpg)\n\n拍摄于2016年4月2日，三棵开放的树自左而右展现出红、绿、白三种不同的颜色。\n\n使用Moto X Style拍摄。\n\n<!--more-->\n\n![Three-Trees_2.jpg](Three-Trees_2.jpg)\n\n![Three-Trees_3.jpg](Three-Trees_3.jpg)\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"角落里的那棵树","url":"/posts/Corner-Tree/","content":"![Corner-Tree_1.jpg](Corner-Tree_1.jpg)\n\n如果不是因为角落里的那棵树又开了花，我也许不会意识到春天来了，而只任凭它悄悄从屋外溜过。\n\n那是一棵不知名的树。虽然是树，却并不比周围的灌木显眼几分，甚至直到它所有的花苞绽放时，人们的目光也只会被那两棵仍未开放的玉兰夺走。\n\n<!--more-->\n\n所以我一直怀疑，除了我以外，是不是只有它一个人孤芳自赏。但即使如此也不能让它辜负时光，这是它的春天，但不属于我。\n\n![Corner-Tree_2.jpg](Corner-Tree_2.jpg)\n\n所谓杏花春雨，雨确实是第一场春雨，但它是不是杏花却无人知晓。这场春雨把它的花瓣种到了它周围的每一片土地上－－不要担心，留在树上的更多一些。\n\n雨停了，天是蓝色的，极好极好的阳光又落在它身上，风一吹似乎能听见花朵歌唱的声音。似乎它没有花香，但对于我这么一个从来就不能欣赏花香的鼻子，这或许更是一种怜悯。\n\n![Corner-Tree_3.jpg](Corner-Tree_3.jpg)\n\n树，也会有前世今生吗？我固执地想。也许你的前世是一棵胡杨？它一如沉默。偏偏我总是认为沉默的人都是因为天机不可泄露，所以我想，答案是肯定的。\n\n那么它的前世就一定是一棵胡杨，对，就是那种生长在沙漠中一千年不死，死后一千年不倒，倒后一千年不朽的“神树”。那这些花瓣就是它的眼泪了？我想。孤单而耀眼地走完了三千年执着守候的前世，今生才甘心做一株角落里的小树，好让自己有足够的时间，把前世的眼泪一片片地流光。\n\n![Corner-Tree_4.jpg](Corner-Tree_4.jpg)\n\n我无数次地想象自己在树下，风一吹过，漫天的花瓣飘落。喂，你等了前世，又等了今生，等的又是什么呢？\n\n它不说，但我看到了它的倔强，无论是前世三千年的生命，还是今生。即使每片花只有三秒在风中飞舞，它也要让自己在有限的时光里尽情的灿烂。\n\n![Corner-Tree_5.jpg](Corner-Tree_5.jpg)\n\n夜晚的风吹来慵懒的凉意，如果有机会，我一定要坐在那里静静地想，从黄昏到天明，把天上的云朵化成繁星。或许冥冥之中自有定数，让每一个执着等待的人都成为了一棵树，这样才能一直等下去，好让等到的那一天恢复成青春年华，相守共度？又或许因为每对相互等待的人都变成了两颗相互守望的数，无法动身相见，所以才有了这世上的遍地繁荫？那么树，你所等待的树又在哪里呢？\n\n我不知道当年是怎样两个人怀着相思种下了这一堆树，但我痴痴地相信，假使我见到另一棵树，应该和它一样，亭亭如盖了。\n\n![Corner-Tree_6.jpg](Corner-Tree_6.jpg)\n\n写于2016年4月1日。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Title_Nil_1","url":"/posts/Title-Nil-1/","content":"![Title-Nil-1_1.png](Title-Nil-1_1.png)\nSay to me.\n\nWhy are you so tired?\n\nWhy are you so lonely?\n\nNo,No.\n\nThere's no need to say.\n\n<!--more-->\n\nWhat I need to konw is that you are really tired,really longly,really.\n\nYou said you wanna love,to be love.\n\nBut no one cares you every time every thing.\n\nWho cares you?Who cares?\n\nHowever,whenever I see your eyes,deep dark.\n\nI see,you mean you understand.\n\nYou mean you believe.\n\nYou mean you konw no one would love a silly man.\n\nYou mean it's true that no one loves a person who lives by computer,phone,harmonica.\n\nYou mean it's true that no one konws what you need.\n\nThey have already got and sent what you want from or to other one.\n\nYou consider them as everyting while they consider you as nothing.\n\nThe world is so hard,it makes you hard to find it.\n\nIt was hidden under the dirt,was hidden on the cloud,was hidden behind one's back,was hidden in one's heart.\n\nYou can feel the deeply bad of the world.\n\nThough your heart believe the future,your body say it can't wait.\n\nYour body can wait while your heart can't.\n\nHuman being is strange,you can't look through them via scanf,#define.\n\nSo many stories,some times they are pleasant,but most not.\n\nStories start,stories stop.\n\nEndless stories.\n\nIt seems that you can only tell the words to yourself,and your chair.\n\nYou wanna cry,but no tears.\n\nLet it out,let it go.\n\nI have the arms you want.\n\nWhy no snow comes after the cloud?\n\nWhy no death comes after the pain?\n\nWhy no love comes after the significant care?\n\nI konw you want to ask,being sorry for my poor head.\n\nYou have nothing but you want everything.\n\nTo the whole world,you maybe one person.\n\nBut to whom,you are the whole world?\n\nYou said you want it simple,for human beings are so complex.\n\nBut you can't.\n\nDon't cry.\n\nTo you,to me.\n\nTo yourself,to myself.\n\nYou are myself,I'm yourself.\n\nYou can get it one day,maybe.\n\n2016-01-10\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n\n*转载自我的LOFTER*\n"},{"title":"半音阶口琴杂谈（三）","url":"/posts/CHarmonica-Talk-3/","content":"好啦，琴也买了也试了，该谈谈五线谱了。\n\n别一提蝌蚪就头疼，半音阶吹简谱比认线谱还难，这里直接引用我在贴吧的回复：\n<!--more-->\n>半音阶是固定调乐器，和钢琴类似。简谱用的首调唱名，如果你按简谱吹半音阶遇到不是C调的曲子，只有两种办法，一个是分别练各常用调的音阶，很麻烦，而且每练一种就相当于新学一遍口琴，互相之间没帮助不说，还容易让你弄乱吹吸顺序。。。完全不适合半音阶，要不就把谱子转为C调，方便一点，不过需要一定乐理知识，搞不好会乱 ，我倒是自己做了个转调卡方便转换。而五线谱是首调，不同的调子也就是C调音升升降降，你读出来的音就是半音阶和钢琴上的音，一一对应，吹起来容易的多，而且半音阶经常吹古典乐曲，那些都是小提琴五线谱。所以学点乐理和五线谱还是有好处的，不然你找个C调的简谱吹吹，坑死人啊。。。五线谱就难在一开始读的很慢，需要大量练习（这个我也不行。。。），所以一开始学半音阶口琴就尽量接触五线谱，简谱基本是为以后提高设障碍。但是像十孔这种有不同调子的乐器和简谱一样用的是首调，用简谱可能比线谱还舒服，不过国外还是线谱用的多。\n\n还不明白？举个例子，宋冬野的《斑马，斑马》，是G调简谱，你用半音阶标准把位是不能直接上的，因为那是C调的，**你吹的do频率是C，la频率是A（口琴一般440-447Hz内，大部分443或444），而简谱是首调唱名，本例中do频率是G，所以不行，除非你再练一个G调的吹法，那十二个调就得十二种把位，加上口琴有吹吸半音阶有推键很麻烦，搞不好会乱套**，所以不适合。或者你把G调转换成C调（我就这么办），不过需要一定乐理知识和计算能力……\n\n那线谱就不一样了，它采用首调唱名，你读出来的就是半音阶上要吹的音，一招鲜吃遍天。\n\n所以学线谱有好处，虽然开始慢但是慢慢当成能力去提升，不必着急。\n\n口琴还有BD谱，不过不推荐常用，它像吉他六线谱，只记录奏法没有音高，而且人家六线谱可以记录时值，**BD谱不但不行而且不一样的口琴孔数不同都不通用……所以需要时拿它记一两个奏法（就像弦乐器里的指法符号）得了，别当正式谱用**。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n\n*搬运自我的LOFTER*\n"},{"title":"半音阶口琴杂谈（二）","url":"/posts/CHarmonica-Talk-2/","content":"唉懒真是没办法，这都隔好几天了。\n\n接着说吧，给新手的建议。你肯定得知道买什么琴去哪买吧。有同学会说了，我家边上小学对面有个琴行！好的在你出门之前把下面这句话念十遍。\n\n**不要在琴行买口琴！**\n<!--more-->\n（当然此句针对大陆，你说你住香港台湾日本德国出门就是谷口通利神马的自动忽视。）\n\n记住了吗？因为口琴在大部分琴行还只属于玩具，我们这一要口琴出来的都是敦煌小蜜蜂（东方乐器的业余和儿童用口琴），**半音阶只有天鹅1040-6，偏偏天鹅大家公认膜片超好其他超烂，而十孔的半音阶1040没膜片！！！**所以还是求助万能的淘宝吧。\n\n新手的话SUZUKI的SCX-64当然第一选择，可以培养正确的气息，换句话就是你能随心驾驭SCX-64就能差不多驾驭别的琴，最起码不会把别的琴吹坏，但是反之如果一开始吹粗旷的琴换成细腻型的肯定不适应。价格1110左右，实在不行就买SCX-48，800多应该就OK。**但是不管你以后喜欢几孔的口琴，准备一把16孔的肯定错不了 。**\n\n当然肯定有同学说一上来就这么贵的我接受不了啊。那千元以内的进口琴还有三款HOHNER的，270D大概900？270的升级版，圆孔交错式，据说是用螺丝固定？不过270D和270这种木格琴大家**打死也不会让你拆**就是了，木头磨着磨着就没了 ，我同学买了270，700多感觉不错，虽然HOHNER的做工没有SUZUKI好，但也很精致了，如果说SCX声音是甜美型，270的声音就是沧桑型，有点沙哑尖刻，估计硬汉会喜欢。500左右有D48，除了吹嘴是塑料的其他都不错，螺丝别上太紧。\n\n有人说这个价位还买不起？那我送你一个字**攒**……便宜点还能接受的国产琴就是东方的梦想者，国产里面最好的一把琴了大概，400以内，除了 *推键不太顺需要油声音发尖低音fa不好吹* 以外还可以，不像其他国产琴培养你毁琴气息，新手阶段你的问题绝对比这把琴的问题多，不用顾虑。再便宜就何来257，除了没吹嘴，大概200～300。\n\n之后是去哪买的问题，买梦想者就去**东方乐器专营店**，孔总人很好，东方售后也让你没有后顾之忧，毕竟厂家直销。接着其他琴就是海盗（**小海盗de口琴舰队**）鱼哥（**鱼哥口琴店**）二选一（似乎贴吧里还推荐一家叫**玛纳**？）但是鱼哥那主要卖铃木的，海盗比较全一点，如果两家都有实在不知道买哪家的就挑近的买（两家差价基本可以忽略），鱼哥在长沙海盗在大连（东方在江苏）。都是贴吧里口碑店，最好不要海淘或者去不知名的店，因为售后什么的可能没有。\n\n好了今天就说这么多，有人问为什么不推荐千元以上的琴，因为演奏级的琴不一定好控制，新手需要的是基本功，**等你玩到一定程度觉得琴不适合你了，肯定会换琴的**，那时候再说也不迟。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n\n*搬运自我的LOFTER*\n"},{"title":"半音阶口琴杂谈（一）","url":"/posts/CHarmonica-Talk-1/","content":"当然是随便谈谈自学半音阶口琴的体会，不对的欢迎指正。\n\n首先拿过来一把琴当然要试试有没有质量问题咯，先从中音（口琴上的中音是其他乐器的高音，就是5 6 7 8孔）C调#C调吹吸吹吸吹吸吸吹试一遍<!--more-->就是do，re，mi，fa，sol，la，si ，do，气流大小按照吹口哨再大一点，之后倍低音（如果有），这两个比较好吹。高音（9 10 11 12）需要你把气流加快，不然反而易啸叫（但啸叫不太可能是琴的毛病），至少我的SCX-64是，而SCX据说可以养成正确的气息。低音区（1 2 3 4）比较难搞，某些琴新手刚拿过来低音re，fa几乎是不响的，这时候放缓气流扩大口腔**捏住鼻子**一般都能响，不过以后不要捏鼻子，慢慢会好的。一些国产琴这个问题可能比较严重，先忍着，等你后期有动手能力了调大Gap会好一点（**新手不许拆琴！！！否则等于撕钞票！！！**）。等有资金了还是买把进口琴，一般会好很多，但半音阶的低音还是对气息要求很高，练习时多注意就好了。\n\n然后是练习，这个一定不能少，虽然它不能决定一切，但练习时间够了你自然会感觉有提高。鱼哥说练习应该是大块时间的，但我的经历是学习太紧，只能利用下课十分钟吹。而且我觉得口琴的优势就是小，方便随时练习。秘诀是练习时找好侧重点，比如吸气断音，不要没有目的瞎吹，还不如不练，然后心无旁骛，才会保证练习高质量，这也是大触的意思。另外要养成看五线谱和背谱的习惯，好处下次再说。\n\nPS 哪位朋友推荐下好用的电脑排五线谱的软件，我最近看许多吉他谱应该都是一个软件排的，很整齐，不知道有没有五线谱的，方便自己整理分享。另外我通常在Linux下，所以最好支持Linux，实在没有一个需要的库比较少的win程序也行，我试试wine。谢谢了。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n\n*搬运自我的LOFTER*\n"},{"title":"Words That I Couldn't Say","url":"/posts/Words-Say-1/","content":"## 2015.01.01\n\n### Play *輝く空の静寂には - Kalafina*\n\n又是新的一年呢。\n\n本来打算昨天弄这些，但是各种原因的不想动。\n\n那就今天吧，把这一年经过想说的一些精挑细选出来。\n\n<!--more-->\n\n### Play *深爱-水树奈奈*\n\n无故头疼，不舒服。\n\nIBus搞什么，乱七八糟。\n\n本来由于身体不舒服加上不愿意就决定不去漫展的，最后还是去了。\n\n人比想象的要多许多，去了之后才发现还有另一个不愿意去的理由——舍不得花钱，本来打算留着钱买树莓派的，但看见了好多喜欢的东西，还是要买。\n\n以上废话。\n\n买回来的东西全是黑执事有关的，异常的喜欢夏尔。\n\n一半因为本来就喜欢黑执事，另一半是因为突然理解了喜欢夏尔的理由。\n\n外表越坚强，就越是为了掩饰内心的脆弱。\n\n以前不明白。\n\n### Play *Lacrimosa-Kalafina*\n\n即使所有人都背叛了，还有执事君不会背叛。\n\n可是却不是所有人都有执事君呢。\n\n一次又一次的Ctrl+C终止音乐，然后去换成另一首。\n\n### Play *君が光に変えて行く-Kalafina*\n\n为什么。\n\n想看下雪，把一切都掩盖掉。\n\n全部化为静谧。\n\n可是却没有雪。\n\n肩膀又痛，不过不管它。\n\n没有雪，而且连星空都没有。\n\n手指敲打键盘，如同音符在琴键上跳动，习惯。\n\n### Play *Kiss The Rain*\n\n平安夜那天，我看着许许多多的人路过，各种各样的。\n\n眼睛只能看到别人，却不能看到自己。\n\n我站在那里等，但直到所有人走开，不得不离去，也没有等到一个主动和我说Merry Christmas的人。\n\n所以只能一遍一遍对自己重复。\n\n记得么，曾经总是读错Christmas，从来没有记过它该怎么Spell。\n\n但想说时它却自己正确的蹦了出来，是圣子显灵还是自动补全？\n\n在Shell里可以一直<TAB>下去，但当我在生活里迷茫的时候，我下意识的去按<TAB>却没有按到。\n\n生活不是zsh，连bash都不是。\n\n残缺的事情，残缺的灵魂永远都不能自动补全呢。\n\nMerry Christmas.\n\n他说他的名字是Merry。\n\nMerry，Merry.\n\n“你要告诉我什么事？”\n\n“那天，你走之后的事。”\n\n“吉尔伽美什为了你第一次违逆了他的父亲，他父亲从来不许外人到他家吃饭。”\n\n“吉尔伽美什为了你拔光了他家花园的花，他从格兰仕那里要来种子后就疯狂地种了整整一园的矢车菊，只是为了送你一盆纽约最好的花。”\n\n“吉尔伽美什每次到Merry只坐你坐的那个位子，只喝伏特加。”\n\n“吉尔伽美什经常盯着银头发的人看个不停，”\n\n“吉尔伽美什从那次之后就开始涉足政治，他越来越铁石心肠，越来越让人琢磨不透。”\n\n“你以为他为什么会变成这样？你以为他为你所做的一切都是理所当然吗？”\n\n“你为什么要糟蹋他的感情？”\n\n“他是爱你的啊，漆拉。”\n\n“他深爱着着你啊……”\n\nWords That We Couldn't Say.\n\n矢车菊的花语，遇见幸福。\n\n可是你真的只能让人遇见幸福么？\n\n花盆下的设计图，设计图下的照片，照片背后的那句话。\n\n没有弹孔，没有鲜血。\n\n### Play *不再见-陈学冬*\n\n既然从开始就知道会有这样的结局，那也一定要继续下去。\n\n既然以笑得最幸福的方式开始，那么即使以哭得最悲伤的方式结束也要继续下去吧。\n\n我累了。\n\n在那一刻。\n\n就算再不愿意，我也绝不允许你用那种口气来对我说话。\n\n还有，我的事情有我自己的打算，我的决定有我自己的审美。\n\n所以你最好不要发表意见。\n\nKeep sclient.\n\n### Play *時代を越える想い*\n\n总有一天会回头再看见这些东西，只有那时才能发现它们有多可笑。\n\n有时候，想象就该是想象，变成现实就失去了那份美好。\n\n### Play *风居住的街道-矶村由纪子*\n\n意思是说，成熟就是能明确在什么情况下该做什么事并且敢去做？\n\n抱歉，我一直都想，但一直都做不到，那种无力感。\n\n我累了，需要休息。\n\n我相信等我做到，还会再来一次的，没有失败。但不是现在。\n\n我有我的想法，行动。我可以忍受别人惹怒我但不能一次又一次的忍受别人打破我的底线但还装成自己是受害者一样。我不允许别人质疑否认背叛放弃，再也不会允许。\n\n所以2015，愿一切安好。\n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n\n*搬运自我的LOFTER*\n"},{"title":"Arch Linux安装手札","url":"/posts/Arch-Install/","content":"一入Arch深似海，不挂全需人品高～家里添了台联想昭阳E49,奔腾2020M,2G内存。早就想写一篇安装手札来做LOFTER的开篇了～我没那么多脑洞……代码还是有的……\n\nArch的安装出了名的难，没安过三次不要说你会Arch，但安装完你会对Linux有更好理解，如同打通任督二脉～我这次是第四次成功了～感谢好朋友Maxfan的帮助～另外LOFTER真的很不错～   \n\n<!--more-->\n\n下面正文开始～   \n\n到[Arch的下载页面](https://www.archlinux.org/download/)下载最新的镜像，Windows下用Win32diskmanager写入U盘，Linux下用   \n\n``` bash\n# dd if=~/archlinux-2014.07.03.iso of=/dev/sdb\n```\n\n写入U盘。   \n\n开机按<F12>选择U盘引导， *Boot Arch Linux(x86_64)* ，root自动登录。可以手机看[Arch Wiki新手指南](https://wiki.archlinux.org/index.php/Beginners%27_Guide_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)。~/有一份英文的install.txt，可以在tty2打开看。   \n\n首先   \n\n``` bash\n# iw dev\n```\n\n记下无线接口名。本例为 *wlp2s0*    \n\n``` bash\n# wifi-menu wlp2s0\n```\n\n选择无线网，两次ok，键入密码连接。   \n\n``` bash\n# ping -c 3 www.baidu.com\n```\n\n确定是否已联网。   \n\n``` bash\n# cfdisk\n```\n\n听说高手都用fdisk分区，我习惯cfdisk，反正不从头分，在末尾的空闲分区划分70G/dev/sda3作为/，3G/dev/sda4swap，都是主分区。由于Arch用pacstrap安装基本系统，所以单/分区也能保留/home重装～只要删掉其他目录即可。千万不要乱按Bootable！给我惹了好大麻烦……   \n\n``` bash\n# partprobe\n```\n\n让内核重新读取分区表。   \n\n``` bash\n# mkfs.brtfs /dev/sda3\n# mkswap /dev/sda4\n# swapon /dev/sda4\n```\n\n根目录用btrfs，由于btrfs不能用交换文件，所以分交换分区并启用。   \n\n``` bash\n# mount /dev/sda3 /mnt\n```\n\n挂载到/mnt。   \n\n``` bash\n# nano /etc/pacman.d/mirrorlist\n```\n\n安装前需要编辑 */etc/pacman.d/mirrorlist* , mirrorlist文件也会被pacstrap复制到新系统。到[镜像列表生成器](https://www.archlinux.org/mirrorlist/)生成中国源列表添加到前面。   \n\n``` bash\n# pacman -Syy\n```\n\n更新pacman数据。   \n\n``` bash\n# pacstrap -i /mnt base base-devel\n```\n\n安装基本系统到/mnt，sudo什么的都在base-devel里。   \n\n``` bash\n# genfstab -p -U /mnt >> /mnt/etc/fstab\n# nano /mnt/etc/fstab\n```\n\n生成fstab并检查一下。   \n\n``` bash\n# arch-chroot /mnt /bin/bash\n```\n\nchroot到新系统的bash shell，初步认为arch-chroot的特点是可以运行systemd。   \n\n``` bash\n# nano /etc/locale.gen\n```\n\n编辑本地化标准，去掉en_US.UTF-8和zh_CN.UTF-8前的#。执行   \n\n``` bash\n# locale-gen\n```\n\n应用更改。   \n\n``` bash\n# echo LANG=en_US.UTF-8 > /etc/locale.conf\n```\n\n设置LANG变量，在此设置中文会使tty乱码。   \n\n``` bash\n# ln -s /usr/share/zoneinfo/Asia/Shanghai /etc/localtime\n```\n\n设置时区，这里设为中国上海(UTC+8:00)。   \n\n``` bash\n# hwclock --systohc --utc\n```\n\n设置硬件时间为UTC，稍后再把Windows改为UTC。   \n\n``` bash\n# echo ShaX-Laptop > /etc/hostname\n```\n\n设置主机名为ShaX-Laptop。   \n\n``` bash\n# nano /etc/hosts\n```\n\n127.0.0.1一行最后按<TAB>键入ShaX-Laptop。   \n\n``` bash\n# pacman -S iw wpa_supplicant dialog\n```\n\n为新系统安装联网所需组件，第一次虚拟机安装时忘了配置网络，结果一pacman -S就满屏错误……   \n\n``` bash\n# pacman -S ntfs-3g vim zsh\n```\n\n安装必需软件，ntfs-3g可以让Linux读取NTFS。   \n\n``` bash\n# passwd\n```\n\n设置root密码。   \n\n``` bash\n# pacman -S grub\n```\n\n安装GRUB。为了能用Windows引导GRUB，选择安装到PBR。   \n\n``` bash\n# chattr -i /boot/grub/i386-pc/core.img\n# grub-install --target=i386-pc --recheck --debug --force /dev/sda3\n# chattr +i /boot/grub/i386-pc/core.img\n# grub-mkconfig -o /boot/grub/grub.cfg\n```\n\n为了防止由于硬盘文件移动导致找不到GRUB核心文件，给它添加i(不可动)标记。建立GRUB配置文件。   \n\n``` bash\n# mount /dev/sda1 /mnt\n```\n\n挂载C盘到/mnt。   \n\n``` bash\n# mkdir /mnt/NST\n# dd if=/dev/sda3 of=/mnt/NST/Linux.mbr bs=446 count=1\n```\n\n将前446字节的loader写到C:\\NST\\Linux.mbr。   \n\n``` bash\n# umount /mnt\n# exit\n```\n\n退出chroot。   \n\n``` bash\n# umount /mnt\n# reboot\n```\n\n不要忘了拔出U盘，进入Windows。   \n\n打开regedit，定位到HKEY\\_LOCAL\\_MACHINE\\\\SYSTEM\\\\CurrentControlSet\\\\Control\\\\TimeZoneInformation\\\\，新建DWORD值RealTimeIsUniversal，键值设为1。以应用UTC。   \n\n下载安装EasyBCD软件，添加启动项→GNU/Linux→选GRUB2，名称添Arch Linux，添加。然后去C:\\\\NST\\\\把生成的另一个文件名复制，删掉，把Linux.mbr重命名为那个，因为EasyBCD默认有bug不能正确识别，所以我们手动替换即可。   \n\n重启按<F1>进入BIOS，硬件时钟倒设8小时为UTC。   \n\n选择Arch Linux进入GRUB引导。   \n\n先用root登录，wifi\\-menu连接网络，创建用户shax并添加密码。   \n\n``` bash\n# useradd -m shax\n# passwd shax\n```\n\n参数-m的作用是自动在/home下建立以用户名为名的主文件夹。   \n然后   \n\n``` bash\n# visudo\n```\n\n修改可以提权的用户，光标定位到root ALL=\\(ALL\\) ALL一行，按i键进入编辑模式，将该行修改为root ALL=\\(ALL\\) NOPASSWD: ALL，以关闭密码保护，在这一行下面添加shax ALL=\\(ALL\\) NOPASSWD: ALL，给shax开放权限。按<ESC>键退出编辑模式，输入:wq回车以保存并退出。   \n\n``` bash\n# logout\n```\n\n以shax登录。执行   \n\n``` bash\n$ sudo pacman -S xf86-video-intel xorg-server xorg-server-utils xorg-utils xorg-xinit alsa-utils xf86-input-synaptics\n```\n\n安装显声卡触摸板驱动和X接口。   \n\n``` bash\n$ sudo pacman -S acpi\n```\n\n安装高级电源管理支持(?)。   \n\n```\n$ sudo pacman -S gnome gdm wqy-microhei\n```\n\n安装GNOME3桌面环境和它对应的登录管理器GDM以及好看的中文字体文泉驿微米黑。   \n\n``` bash\n$ cp /etc/skel/.xinitrc ~/\n```\n\n复制一份X样板文件到主目录，不要加sudo，否则所有者会变成root。   \n\n``` bash\n$ nano ~/.xinitrc\n```\n\n去掉exec gnome-session前的#。   \n\n``` bash\n$ sudo systemctl enable gdm\n```\n\n开机自动启动登录管理器。   \n\n``` bash\n$ startx\n```\n\n启动X会话。   \n\n在Settings→Language&Location里全部修改为汉语&中国。包括右上角的Login。   \n\n右上角点击用户名选logout重新登录。   \n\n登录后打开终端，输入   \n\n``` bash\n$ sudo pacman -S ibus-libpinyin\n```\n\n安装ibus-libpinyin中文输入法，之后去设置里添加即可。   \n\n``` bash\n$ sudo nano /etc/pacman.conf\n```\n\n添加如下以安装yaourt。   \n\n````\n[archlinuxcn]\n#The Chinese Arch Linux communities packages.\nSigLevel = Optional TrustAll\nServer = http://repo.archlinuxcn.org/$arch\n````\n\n\n``` bash\n$ sudo pacman -Syu yaourt\n```\n\n可以自动安装AUR工具yaourt。   \n\n再次感谢好友Maxfan。   \n\n欢迎关注[Arch Linux官网](https://www.archlinux.org/)   \n\n[中文官网](http://www.archlinuxcn.org/)   \n\n[中文wiki](https://wiki.archlinux.org/index.php/Main_Page_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87))   \n\n2014-07-28 17:00   \n\n*Alynx Zhou*   \n\n**A Coder & Dreamer**   \n\n*搬运于我的LOFTER*   \n"},{"title":"你好，世界。","url":"/posts/Hello-My-World/","content":"So， *喵's StackHarbor* 就算是正式开站了，当然在部署过程中有很多有趣的事情值得我专门写一篇日志来记录一下，不过在Coder的世界里面\"Every thing is based on Hello World\"，所以还是以后再说那个。   \n\n<!--more-->\n\n``` c\n#include <stdio.h>\nint main(void) {\n    printf(\"Hello World!\\n\");\n    return 0;\n}\n```\n\n说起建网站的想法还要追溯到中考刚刚结束的时候，好朋友 *Hackghost* 跟我说他要建立一个自己的网站用来写博客。当然当时的我什么都不知道，不过好歹或多或少参与了他网站的建设。再后来自己开始用Linux，对于建站自然也是略知一二。不过对于一个高中生而言租用域名和VPS的钱也不是很轻易就能负担的起的。直到今年的愚人节那天Google到GitHub Page服务可以用来托管静态网站，于是抑制不住的在GoDaddy上租用了一年期的 *sxshax.xyz* 这个域名（现在换成了三年期的alynx.xyz），折腾了一天把这个小站打造成了还比较满意的样子。   \n\n``` python\n#!/usr/bin/env python3\n#-*- coding: utf-8 -*-\n\nprint(\"Hello World!\")\n```\n\n但是就算你读到这里，朋友，你一定还是一直有一个疑问：“这个网站究竟是用来做什么的呢？”   \n\n简而言之，**这是一个名叫 *Alynx Zhou* 的人利用 *alynx.xyz* 这个域名及hexo和GitHub Page还有Spacemacs、Gentoo GNU/Linux建立的一个名叫 *喵's StackHarbor* 的网站，他在这里用他还很生疏的Markdown，记录下他生活中每天的迷茫与感慨、愉悦与忧伤。**   \n\n我知道你要问：“为什么要叫做这么一个拗口的名字呢？”   \n\n如果非要深究，大约有三点原因：  \n\n-   我在网易云音乐上的口琴电台叫做 *喵's Harmonica* 。\n\n-   Stack意为堆栈，计算机术语。\n\n-   Harbor意为港湾。   \n\n总是有人说有了社交圈就够了，没有必要自己建一个Blog用来写东西，但对我来说。QQ贴吧微博或多或少都是说给别人看的，但网站是属于自己的，我可以记录我自己的想法，喜不喜欢则是你的自由。   \n\n所以说，这个名字的寓意，无非是即使一个行走在漫漫星海边缘的小人物，也可以在互联网上拥有属于自己的一片避风港。   \n\nSo my friend, where's your harbor?   \n\n*Alynx Zhou*\n\n**A Coder & Dreamer**\n"},{"title":"Hello World","url":"/posts/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n<!--more-->\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n"}]