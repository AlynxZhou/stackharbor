<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喵's StackHarbor</title>
  <subtitle>Whisper to the World</subtitle>
  <icon>https://sh.alynx.one/images/Mikoto-Karon-White.webp</icon>
  <link rel="self" type="application/atom+xml" href="https://sh.alynx.one/atom.xml" />
  <link rel="alternate" type="text/html" href="https://sh.alynx.one/" />
  <updated>2025-04-24T09:44:17.158Z</updated>
  <id>https://sh.alynx.one/</id>
  <author>
    <name>Alynx Zhou</name>
    <email>alynx.zhou@gmail.com</email>
  </author>
  <generator uri="https://github.com/AlynxZhou/hikaru-generator-feed/" version="v2.5.2">Hikaru Generator Feed</generator>
  <entry>
    <title>东京之旅</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Journey-to-Tokyo/" />
    <id>https://sh.alynx.one/posts/Journey-to-Tokyo/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2025-04-16T04:47:00.000Z</published>
    <updated>2025-04-16T04:47:00.000Z</updated>
    <summary type="html">
      题外话：本来应该去年九月从东京回来就写的，但由于一些不是很众所周知的原因我很久没更新了。昨天回家看到影视飓风发了去东京拍的样片，又想起来之前拍的照片，所以决定还是写一下。 我其实是特别懒得出门的人，不是不想，只是嫌麻烦，而且其实我也没有特别想去的地方，除了日本。毕竟如果你也像我一…
    </summary>
    <content type="html">
      &lt;p&gt;题外话：本来应该去年九月从东京回来就写的，但由于一些不是很众所周知的原因我很久没更新了。昨天回家看到影视飓风发了去东京拍的样片，又想起来之前拍的照片，所以决定还是写一下。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;我其实是特别懒得出门的人，不是不想，只是嫌麻烦，而且其实我也没有特别想去的地方，除了日本。毕竟如果你也像我一样是个动漫爱好者的话你就很难不想去日本看看。所以董老师问我要不要一起去东京玩的时候，我做了足够久的心理建设。搞定签证机票住宿等等一系列麻烦的东西之后，我终于要进行人生第一次出国旅行了。在北京待了太久，早就想拍点不一样的东西，所以这篇主要是贴一些我出门玩拍的照片。&lt;/p&gt;
&lt;p&gt;买机票的时候没有买直飞，因为我也没有去过香港，所以买了中午到香港然后午夜飞东京的转机，到了香港凭护照和离开香港的机票就可以办进入香港的手续，并不需要港澳通行证。然后把在深圳的高中同学喊了过来一起吃了晚饭，我还是第一次见依山而建的城市。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;晚上两个人随便走走于是去拍了维多利亚港。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/2.jpg&quot; alt=&quot;2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于一些众所周知的原因，在香港坐地铁的时候感觉非常熟悉好像回到了北京地铁一样（或许应该说北京某些地铁像香港地铁才对）。&lt;/p&gt;
&lt;p&gt;然后午夜飞东京第二天早上落地成田机场，经过一系列入境手续之后坐电车去酒店，虽然我的日语远没到能日常交流的水平，但靠着比划和英语大概也没什么问题。而且很大概率你能碰到会中文的工作人员。由于前一天很早出发然后午夜才睡觉所以这一天根本没拍什么照片，下午到酒店能入住之后直接就躺了。董老师来东京的目的是去看魔法未来，所以我们前几天住了一个很偏的酒店，与其说离东京近不如说是离千叶近，而且主要是房间真的小啊！&lt;/p&gt;
&lt;p&gt;落地东京的第一天除了吃饭睡觉什么也没干，第二天起来我坐电车去了御茶水的乐器街（说起来知道这边是乐器街还是因为听丸之内虐待狂），虽然距离很远但感觉并没有花很久，也许是人在北京住久了就会对通勤变得宽容？虽然这边大部分卖的都是我不会弹的吉他贝斯类的，但还是看得眼花缭乱。这边有一家很出名的 ESP 店，我走到二楼的时候应该是有个店员看出来我是中国游客所以用中文问我“你想找什么？”，但我一下子就听出来他应该是会说中文的日本人，因为母语者发音不会这么刻意。同学想要一个国内还没上市的效果器，问了一下价格，比闲鱼代购便宜太多了，于是我非常乐意的帮他代购了一个。但我拍的不是乐器而是那个好像很著名的电车机位，铃芽之旅里面出现过的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/3.jpg&quot; alt=&quot;3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于台风要来，第一天和第二天都在下雨，虽然我是很喜欢下雨，但是鞋子湿透了还是很痛苦。&lt;/p&gt;
&lt;p&gt;第三天白天去了魔法未来的展览，因为很喜欢赛车初音于是买了一把 24 款赛车初音的雨伞，结果临走的时候人在去机场的电车上想起来把伞落在酒店了，于是赶紧给酒店发邮件，他们对于处理外国游客遗落的物品有成熟的流程，所以后面我付了邮费提交了地址他们把伞给我寄到了家里。以及因为发现酒店楼下的罗森有赛车初音的一番赏所以每天晚上都去抽两发还和便利店打工的中东小哥聊了几次。晚上我意识到这个酒店离海边很近于是就跑去海边，然后拍到了海边散步的情侣 T_T 作为内陆长大而又很少去海边的人，晚上走到海边的时候感觉非常空旷，如果有幽闭恐惧症的反义词的话，应该可以更好的描述我当时的体验。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/4.jpg&quot; alt=&quot;4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;第四天我决定把来拍照的目的贯彻到底，中午先去了川崎站进行了一个 Girls Band Cry 的打卡，结果在丸福咖啡店遇到了另外两个说中文的游客，全都是看了 GBC 来打卡的！可惜我在川崎站外面没有遇到什么弹吉他的大姐姐。买了下午天空树的门票，直接冲到最高进行一个俯瞰风景。天空树上面有个许愿台，可以买扭蛋然后把愿望写在里面的彩带上，于是我一边想着 &lt;em&gt;“把愿望写在离天空更近的地方实现的会不会更快一点”&lt;/em&gt; 一边买了两个扭蛋，不过现在想想感受还是很复杂。我这个时候还没看过龙族，看完了觉得还好当时临时决定去天空树，下次一定还会再去。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/5.jpg&quot; alt=&quot;5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/6.jpg&quot; alt=&quot;6.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;出来的时候又开始下小雨！这就是临海城市的感觉吗？但是我抬头向上看的时候发现云雾围绕的天空树于是拍下了绝佳的照片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/7.jpg&quot; alt=&quot;7.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/8.jpg&quot; alt=&quot;8.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;由于这里是地标性建筑，所以下面有一个购物中心有很多专门的周边店，方便来玩的游客，我在里面转了很久，但由于一些原因不是很开心。但是接下来在商场里吃了一份寿喜锅，很好吃！&lt;/p&gt;
&lt;p&gt;第五天我们换到了市区里的酒店，住在浅草桥附近去哪里都很方便！而且房间面积竟然比第一家酒店要大。这一天我去了东京塔！我这次来其实没有制定什么旅游计划，单纯是给出国玩做一次可行性验证，所以其实落地东京就算是阶段性胜利了。但如果有什么一定要拍的，那就是东京塔了，因为我喜欢红色！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/9.jpg&quot; alt=&quot;9.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;转来转去找了好久附近哪里的楼上有东京塔的倒影，结果我低头发现东京塔的倒影就在东京塔的底座上。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/10.jpg&quot; alt=&quot;10.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;第六天我好像没有拍什么照片，因为酒店离秋叶原只有一站路所以我就早起去了秋叶原，二次元怎么能不去秋叶原电器街呢！但是这里甚至走路都能听到人说中文，“你买的这个东西 90% 是 Made in China！&quot;。&lt;/p&gt;
&lt;p&gt;没记错的话中午吃了一家叫做 468 的寿司，这家的老板人很好很有意思，见到我们是外国人于是拿出一张纸在上面画一盘寿司和一碗汤然后写上价格，还问我们是哪里来的。汤是一种粘稠的淀粉汤，尝起来大概是用胡椒调味，中间有一颗炸过的土豆泥丸子，是他家的招牌菜“芋吸”，感觉就是明明是普通的食材普通的调味，但能想到这样做确实是别出心裁，从来没有在别的地方尝过类似的，非常喜欢于是跟老板说每人再点一份。&lt;/p&gt;
&lt;p&gt;晚上我们根据排行榜去吃了和牛烧肉！来日本怎么能不吃和牛烧肉呢！店很小所以排队花了一些时间，但是吃到的时候感觉确实是非常值得，缺点的话……大概只有因为是炭火烤肉所以如果有顾客没搞好肉被点着了屋里就会很大浓烟吧。&lt;/p&gt;
&lt;p&gt;第七天我们去了涩谷附近，先去了明治神宫但这里没有人举行婚礼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/11.jpg&quot; alt=&quot;11.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后在原宿买了一件我以前根本不会买的衣服，白色的衣服上面是各种蓝色的带子，当时莫名其妙的想到明日方舟的服装风格，然后店员小哥又很喜欢初音所以和我们聊了一会于是就买了（但是衣服很贵 T_T）。接着去了附近的稳田神社，好像设定上是平安名堇住在这里所以甚至有上面画着她的御守，所以我给列表里推平安名堇的 coser 带了一个。原宿这边有 Fender 的旗舰店，进去转了一圈，但我又不会弹这个。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/12.jpg&quot; alt=&quot;12.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;晚上去了涩谷，这里可能是这几天见过人最多的地方了。董老师跟我说有什么稀奇的感觉和西直门差不多，我说西直门哪有这么多人，董老师想了一会说那三里屯，三里屯倒是稍微有点这个意思。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/13.jpg&quot; alt=&quot;13.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/14.jpg&quot; alt=&quot;14.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/15.jpg&quot; alt=&quot;15.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;第八天去了之前在上野的时候去了一次的矢先稻荷神社，当时只是在地图上看到附近有神社就想去看看，结果一路上很想去厕所又找不到，走到神社门口发现有牌子说最近的厕所在哪里，感觉非常有缘分，但是第一次去身上没有多少硬币，所以又去了一次。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/16.jpg&quot; alt=&quot;16.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;中午本来想吃排行榜靠前的拉面店，结果到了门口发现老板给自己放了十天假，于是我们去了另一家高分的 らーめん 改，我以前吃过的日式拉面都是酱油或者猪骨汤的，这家的面是类似手擀面的粗面，汤是一种海鲜加盐的清汤，和我之前吃过的全都不一样，非常喜欢。&lt;/p&gt;
&lt;p&gt;下午又去了秋叶原，拍到一张很好看的逆光照片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/17.jpg&quot; alt=&quot;17.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;傍晚的时候从酒店窗户看出去云很好看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/18.jpg&quot; alt=&quot;18.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;这次其实没安排去富士山的计划，但想去东京的一个理由是因为富士山下这首歌，回程的飞机特地选了能看见富士山的一侧。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Journey-to-Tokyo/19.jpg&quot; alt=&quot;19.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最奇妙的感受其实是以前只在动漫里听过的地名突然有了实感，去过之后再看到这些地名，就会想起当时的感觉。它们不再是几个音节的排列组合，而是变成了无数个真实的细节。&lt;/p&gt;
&lt;p&gt;我其实很想多录一些视频，但是一个人暴走的结果就是没有什么体力拿出相机了……最后还是用拍到的一些片段剪了个 vlog 出来。&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;amp;aid=113162573585735&amp;amp;bvid=BV1VCtneGE3g&amp;amp;cid=25918505203&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot; width=&quot;640&quot; height=&quot;480&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;还会再去的。&lt;/p&gt;

    </content>
    <category term="摄影" label="摄影" scheme="https://sh.alynx.one/categories/%E6%91%84%E5%BD%B1/" />
    <category term="生活" label="生活" scheme="https://sh.alynx.one/tags/%E7%94%9F%E6%B4%BB/" />
    <category term="摄影" label="摄影" scheme="https://sh.alynx.one/tags/%E6%91%84%E5%BD%B1/" />
    <category term="东京" label="东京" scheme="https://sh.alynx.one/tags/%E4%B8%9C%E4%BA%AC/" />
  </entry>
  <entry>
    <title>GNOME 和 IBus 和 Wayland 输入法</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/GNOME-IBus-Wayland-IME/" />
    <id>https://sh.alynx.one/posts/GNOME-IBus-Wayland-IME/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-06-20T09:19:55.000Z</published>
    <updated>2024-06-25T06:52:35.000Z</updated>
    <summary type="html">
      长久以来，用户对于 GNOME 的输入法是怎么实现的有着各种各样的误解，比如误以为 IBus 掌控从界面到引擎的全部逻辑。而我最近尝试给 GNOME 添加了 text-input-v1 支持，以便用户可以在运行于 Wayland 下的 Chromium/Electron 程序中使…
    </summary>
    <content type="html">
      &lt;p&gt;长久以来，用户对于 GNOME 的输入法是怎么实现的有着各种各样的误解，比如误以为 IBus 掌控从界面到引擎的全部逻辑。而我最近尝试给 GNOME 添加了 text-input-v1 支持，以便用户可以在运行于 Wayland 下的 Chromium/Electron 程序中使用输入法（Chromium 只支持 text-input-v1，而不是大部分其它程序都在用的 text-input-v3），这个过程中我阅读了大量和输入法相关的代码，打算把具体的结构写下来，这样如果有人想尝试修改，可以从我这里参考，而不是阅读错误的资料，找不到应该修改的位置，同时也防止自己某天想重新改的时候想不起来是怎么回事（实际上在我打算写这篇文章的时候发现自己已经开始忘记了，好恐怖）。&lt;/p&gt;
&lt;p&gt;Wayland 下面标准的输入法结构分为三个部分，应用程序和混成器和输入法，其中应用程序通过 text-input 协议和混成器交换数据，混成器通过 input-method 协议和输入法交换数据。但假如你简单地把混成器对应成 GNOME Shell，输入法对应成 IBus，那就大错特错了。实际上 GNOME Shell 和 IBus 共同组成了这个结构里的“输入法”，而 Mutter 则实现了 text-input 和应用程序通过 Wayland 交互，也就是“混成器”，GNOME Shell 和 Mutter 则通过 ClutterInputMethod 这个接口交换数据，而不是 input-method 协议。下面我逐个解释具体的细节。&lt;/p&gt;
&lt;p&gt;首先是“输入法”部分，IBus 本身是可以当作完整的输入法使用，也就是既包含界面又包含引擎，但实际上的运行方式是 IBus 只负责引擎部分，和界面有关比如候选词提示框和切换输入法的逻辑全部是在 GNOME Shell 里面实现的。这样做的原因是在 Overview 模式下所有客户端的窗口都会被重定向，GNOME Shell 抢占了输入焦点，而 IBus 自己绘制界面时也被认为是客户端窗口之一，目前的设计不会对输入法客户端窗口做什么特殊处理，所以这里是 GNOME Shell 负责界面逻辑，然后通过 D-Bus 和 IBus 通信，获取到输入法的数据填充到输入法的界面里。题外话就是经常有人吐槽为什么 GNOME 要使用 IBus 提供的 D-Bus 协议而不是使用 Wayland 标准的 input-method 协议，但实际上 GNOME Shell 和 IBus 之间的 D-Bus 连接传输的是“输入法内部的数据”，而 input-method 协议传递的是“输入法和混成器之间的数据”，这两者显然不是一个东西。&lt;/p&gt;
&lt;p&gt;因此，如果你想修改 GNOME 下面输入法的界面，那需要修改的可能不是 IBus，而是 GNOME Shell 下面的 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/main/js/ui/ibusCandidatePopup.js&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;&lt;code&gt;js/ui/ibusCandidatePopup.js&lt;/code&gt;&lt;/a&gt;，这个文件包含候选框界面，或者 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/main/js/ui/status/keyboard.js&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;&lt;code&gt;js/ui/status/keyboard.js&lt;/code&gt;&lt;/a&gt;，这个文件包含输入源选择框。&lt;/p&gt;
&lt;p&gt;然后 GNOME Shell 需要和 Mutter 交换数据，这样才能通过 text-input 协议把数据从 Mutter 传送到应用程序里。如果打算实现 input-method 协议，你应该整个替换掉 GNOME Shell 和 IBus 组合起来实现的“输入法”，而非拿着输入法内部的 D-Bus 连接大做文章。实现起来并不困难，Mutter 本身使用 Clutter 作为图形库，Clutter 有 ClutterInputMethod 这个接口管理输入法，无论你是什么来头，最后都要回到这个接口，只有这样才能保证对 GNOME Shell 自己的 UI 也能实现文本输入（因为它们最后都是使用 Clutter），因此主要工作是把 input-method 的接口和 ClutterInputMethod 的接口连接起来。但这是理想情况，实际为什么没人这么做呢……因为 Wayland 实际上提供的是进程间通信，input-method 协议说到底只是给输入法和混成器两个不同进程提供一个通过 Wayland 进行进程间通信的方案而已……但 Mutter 是个库而不是单独的进程，GNOME Shell 和 Mutter 直接链接，属于同一个进程，因此完全没必要再绕一圈进程间通信啊……所以你可以看到 GNOME Shell 直接继承了 ClutterInputMethod 接口然后在里面对接 IBus 的 D-Bus 协议传过来的数据……&lt;/p&gt;
&lt;p&gt;如果你对这一部分有兴趣，可以直接查看 GNOME Shell 下面的 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/main/js/misc/inputMethod.js&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;&lt;code&gt;js/misc/inputMethod.js&lt;/code&gt;&lt;/a&gt;。如果你仍然坚持应当实现 input-method 协议的话，你可以尝试按我说的去改，但我仍然认为这样收益不大，因为只是解决了输入法从混成器获取数据的问题，也就是说是让 GNOME 支持 IBus 以外的输入法的方案之一，为什么说是之一呢，因为实际上目前 Linux 的输入法也只剩 IBus 和 Fcitx 两个，而 &lt;a href=&quot;https://www.csslayer.info/wordpress/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@CSSlayer&lt;/a&gt; 已经通过在 Fcitx 里实现 IBus 和 GNOME Shell 之间的 D-Bus 协议的方式解决了这个问题……因此我选择对他心怀感激然后接受现状。&lt;/p&gt;
&lt;p&gt;但除此之外你还需要解决输入法自己绘制界面在 Overview 下面会被 GNOME Shell 忽略的问题，如果你仔细阅读过 &lt;a href=&quot;https://www.csslayer.info/wordpress/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@CSSlayer&lt;/a&gt; 关于 Fcitx 开发的博客文章，你就会意识到最大的限制是在 Wayland 下面一个客户端程序没办法决定自己的全局坐标，而输入法也只是个普通的客户端窗口，解决这个需要混成器对输入法的窗口进行特殊处理，因此你需要在 Mutter 里面给 input-method 专门打洞来实现单独处理输入法窗口的 &lt;code&gt;wl_surface&lt;/code&gt; 这部分。但对于 GNOME 来说，输入法界面已经是在混成器进程里实现的了，所以你可能需要从头写一大堆代码来处理这个并且和现有的输入法界面代码没有任何地方能复用，上游也自然没有很强烈的意愿合并这个，而对于 Fcitx 来说也可以通过 kimpanel 的 GNOME 扩展把 Fcitx 的界面嵌入到混成器进程里，这实际上和 GNOME Shell 对于输入法界面的处理方式是类似的……已经有可用的解决方案，实现 input-method 我觉得是有点吃力不讨好，至少你不能要求我去做这个……&lt;/p&gt;
&lt;p&gt;至于程序和混成器之间就没那么多事情了，这里就是通过标准的 text-input 协议进行，对于 Mutter 来说，仍然是把 ClutterInputMethod 的接口和 text-input 协议的接口对接起来，我做的主要是这一部分的工作。&lt;/p&gt;
&lt;p&gt;当然还有一种办法是 IM Module，因为说到底 text-input 和 input-method 只是为了想办法在程序和输入法之间交换数据，而你也可以绕过 Wayland，绕过混成器，IM Module 就是这样的方式，应用程序的图形库使用 IM Module 通过 D-Bus 直接和输入法交换数据，告诉输入法应该在哪里显示界面，有哪些按键事件，输入法再把候选词传回来。对于 GNOME，这个情况下只是用到了 GNOME Shell 里面关于输入法界面的部分，和 Mutter 以及 Wayland 就关系不大了。&lt;/p&gt;
&lt;p&gt;最后如果你还是看不懂，那我画了几个框图：&lt;/p&gt;
&lt;p&gt;你想象中的唯一的 Wayland 输入法架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GNOME-IBus-Wayland-IME/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;可能实际正在运行的架构：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GNOME-IBus-Wayland-IME/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;GNOME 只是在上面的基础上进行了一点点点点点变化：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GNOME-IBus-Wayland-IME/3.png&quot; alt=&quot;3.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;至于你问我 GNOME 为什么这么设计输入法结构？这不是我能回答你的问题，也许是历史原因，也许是特殊结构（毕竟 Clutter 这个图形库一开始是个客户端的图形库），我这篇文章只是讲述现状，希望能减少一些以讹传讹。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    <category term="输入法" label="输入法" scheme="https://sh.alynx.one/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" />
  </entry>
  <entry>
    <title>十年过去了，我买了台 MacBook</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/10-Years-Passed-and-I-Bought-MacBook/" />
    <id>https://sh.alynx.one/posts/10-Years-Passed-and-I-Bought-MacBook/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-06-10T10:46:35.000Z</published>
    <updated>2024-06-10T10:46:35.000Z</updated>
    <summary type="html">
      我其实已经很久没有属于自己的笔记本了。毕业之后公司发了一台 Precision 5530 作为工作电脑，我就把我自己的 Precision 5510 留给家里人用了，再加上为了打游戏我分别在自己住处和家里装了台式机，用笔记本的场景就更少了。想来想去，需要笔记本的场景只有一个，就是…
    </summary>
    <content type="html">
      &lt;p&gt;我其实已经很久没有属于自己的笔记本了。毕业之后公司发了一台 Precision 5530 作为工作电脑，我就把我自己的 Precision 5510 留给家里人用了，再加上为了打游戏我分别在自己住处和家里装了台式机，用笔记本的场景就更少了。想来想去，需要笔记本的场景只有一个，就是出远门拍照的时候，可能需要把相机存储卡里的数据复制到移动硬盘里，然后可能顺便快速修图发朋友圈。虽然我之前尝试过平板电脑也能满足这些需求，但平板电脑供电的能力有限，连接移动硬盘还需要外接供电，而且 Android 版的 Lightroom 导入的速度也太慢了，只能说勉强能用。&lt;/p&gt;
&lt;p&gt;当然我可以直接带着公司的 Precision 5530 出门的时候用，但是实在是太重了，而且在 Linux 下面电池顶多能用两小时。有了台式机之后我对笔记本的需求产生了一些变化，比如笔记本可以不需要处理所有的任务，复杂的工作可以在台式机上解决，所以我对笔记本的需求变成了轻便和长续航。这样一看苹果的 M1 变成了最合适的选项：续航可以和平板电脑相比，但是又是实打实的电脑，同时对于剪视频修图这种媒体编辑非常合适。当然这都是马后炮，我一开始只是因为在二手频道刷到有人出售 M1 的 MacBook Air 只要 3000 块出头，感觉这个价格就算是买一个回来玩玩也很合适。不过这个价格是丐版，8G 内存对我来说等于不能用。但我看了一下 16G M1 的 MacBook Air，价格要贵 1500 左右，又有点下不去手。&lt;/p&gt;
&lt;p&gt;我恰好有一个朋友在苹果实习，她告诉我苹果有员工优惠计划，可以以 85 折给家人或者朋友购买 MacBook，不过仅限于官网有卖的产品，于是我开始思考要不要干脆加钱正经买一台笔记本给自己用，这中间反复的纠结过程就略过不提，总之我最后两千块钱卖掉了一千块钱购入的万世权杖（当时工作之后打算买一个玩玩，没想到涨了一倍），又两千块钱卖掉了很久没用过的尼康大 F，然后本着买新不买旧不行挂闲鱼的逻辑买了 M3 的 MacBook Air，毕竟有个在苹果工作的朋友可不容易！&lt;/p&gt;
&lt;p&gt;一开始我是想买 16G + 256G 的版本的，但是发现 16G + 512G 可以直接去 Apple Store 提货，思考再三还是买了 512G，甚至还加了 AppleCare+。然后看到午夜黑的配色虽然我知道肯定会粘指纹但我还是义无反顾的选了，然后直奔朝阳大悦城的 Apple Store 提了电脑本体和苹果购物袋。&lt;/p&gt;
&lt;p&gt;这个过程中当然有朋友质疑我一个 Linux 桌面程序员为什么会买 MacBook 自己用，除了上面那些比较理性的原因之外，还有个原因是就算是 &lt;strong&gt;Linux 桌面程序员也不是一出生就是 Linux 桌面程序员&lt;/strong&gt; 的吧！大概十年以前我还不是 Linux 桌面程序员（甚至不是程序员）的时候，我对 Retina MacBook Pro 的宣传片印象深刻：&lt;/p&gt;
&lt;iframe src=&quot;//player.bilibili.com/player.html?isOutside=true&amp;amp;aid=799187626&amp;amp;bvid=BV19y4y1Y7rc&amp;amp;cid=296995197&amp;amp;p=1&quot; scrolling=&quot;no&quot; border=&quot;0&quot; frameborder=&quot;no&quot; framespacing=&quot;0&quot; allowfullscreen=&quot;true&quot;&gt;&lt;/iframe&gt;

&lt;p&gt;我买电脑确实是看脸的，因此不管别的 Linux 爱好者有多喜欢 ThinkPad，我都对那玩意嗤之以鼻：您能先让自己看起来像是一整块东西吗？不过我看到这个宣传片的时候可能还在上初中，距离我能买得起五位数电脑看起来不能说是遥遥无期，也可以说是希望渺茫。至于上大学之前花了两万块买了 Precision 5510 则是后话了，原因也很简单，单纯是 XPS 15 那个时候看脸比 MacBook 更酷，而且我那个时候已经开始用 Linux 了。所以如果没有 XPS 15，我可能就会买 MacBook Pro，不过再回想一下 2016 年到 2020 年苹果在 MacBook 产品线上做了多少愚蠢的决策（我会把我这辈子见过最蠢的笔记本电脑的称号颁给 New MacBook……真是只有外观设计完全不考虑能不能用的顶峰啊）……可能没有买苹果反而是幸运。&lt;/p&gt;
&lt;p&gt;但把时间拨回到 2012 年，Retina MacBook Pro 确实看起来很棒，用起来也很棒。考虑到使用 M 系列芯片的 MacBook Air 确实在续航和性能之间找到了平衡点，并且苹果确实逐渐从当年制造愚蠢笔记本的顶峰退下来，所以我觉得是时候买一台了，就算是为了延迟满足十年前的自己。就像选择午夜黑的颜色也很简单，它很像十年前我用的蓝黑墨水，不像碳素墨水那么无聊，也不像蓝墨水那么肤浅。我也没打算考虑买 Windows 笔记本装 Linux 的选项，因为显然续航上难以和 MacBook 相比，而且按我看脸的标准能买的 Windows 笔记本也奔着五位数去了……&lt;/p&gt;
&lt;p&gt;拿到手之后确实也是比较满意吧，除了内存和硬盘卖金子价格还是让我很不爽，以及刘海……虽然一个写插件恶搞过这个刘海的人买了刘海笔记本这件事有点讽刺吧，但我想问既然因为刘海加高了顶栏，为什么要特意把顶栏做的比刘海高一点点！就算是为了告诉用户刘海两侧是联通的，这个设计也足够逼死强迫症了。&lt;/p&gt;
&lt;p&gt;我自己的博客生成器因为是 Node.js 写的所以直接就可以在 macOS 上运行，Emacs 则一直以来对 macOS 支持都好得过分，简单修改了 Ansel 的脚本之后我也成功在 macOS 上运行了，DaVinci Resolve 也是跨平台的，所以我期望在笔记本上做的任务都还比较方便，我甚至也跑了 Tailscale 方便我随时远程连接到 Linux 设备上。虽然别人可能觉得我打肿脸充胖子但我还是要说我觉得 GNOME 桌面的使用体验比 macOS 桌面要好，我在自己的博客里写自己的主观看法不是很过分吧！其它的当然可以适应（比如我在 GNOME 里把关闭按钮改到左边了，我不是很在乎这个，然后在 macOS 里面用 Loop 实现了窗口靠边贴放），但为什么 macOS 不能自己调整输入法顺序！我想要一个固定的自己设置的输入法列表是什么大逆不道的事情吗？&lt;/p&gt;
&lt;p&gt;当然少不了去星巴克当气氛组，比如这篇博客就是在星巴克写的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/10-Years-Passed-and-I-Bought-MacBook/starbucks.jpg&quot; alt=&quot;starbucks&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于买这台笔记本还有个很有意思的插曲是一开始和在苹果的朋友对需求对了半小时结果她以为我要买的是 iPad Pro，特别是我还说了我要跑 Node.js 要写博客 iPad Pro 太蠢了之后，我不知道这个对话是怎么进行下去的，我们跨频道聊天一直聊到她以为我要花两千块钱买妙控键盘——我曾经无数次的批评过这个破玩意，毕竟 HHKB 这种顶级的静电容键盘我也才花了两千块……我真的有思考要是最后她给我买了 iPad Pro 和妙控键盘我是掏钱还是不掏钱……&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="MacBook" label="MacBook" scheme="https://sh.alynx.one/tags/MacBook/" />
  </entry>
  <entry>
    <title>Module 的意思不是 Module，Module 的意思是 Config</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Module-Does-Not-Mean-Module-Module-Means-Config/" />
    <id>https://sh.alynx.one/posts/Module-Does-Not-Mean-Module-Module-Means-Config/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-06-05T12:02:37.000Z</published>
    <updated>2024-06-05T12:02:37.000Z</updated>
    <summary type="html">
      如果有得选，在开始一个新项目之前我是无论如何也不会选择 CMake 做构建系统的，我不信有任何人觉得 CMake 的语法很友好很容易读，Meson 相比之下更容易读写，而且按我的经验也更好用。但最大的问题是 Meson 出来的很晚，于是有大量的项目在 CMake 已经流行而 Me…
    </summary>
    <content type="html">
      &lt;p&gt;如果有得选，在开始一个新项目之前我是无论如何也不会选择 CMake 做构建系统的，我不信有任何人觉得 CMake 的语法很友好很容易读，Meson 相比之下更容易读写，而且按我的经验也更好用。但最大的问题是 Meson 出来的很晚，于是有大量的项目在 CMake 已经流行而 Meson 还没出现的时间里把基于 Autotools 的构建系统换成了 CMake（剩下没有更换的那些多数在 Meson 稳定之后更换到了 Meson）。显然把所有 CMake 项目重写成 Meson 是不现实的，最大的困难其实是 CMake 虽然难用，但在“跨平台的构建系统”这一点上已经足够用了，所以对于已有的 CMake 项目，我选择还是凑合用。&lt;/p&gt;
&lt;p&gt;实际需要我本人亲手调整 CMake 的项目很少，Ansel 是其中一个，因为当初从 Darktable fork 出来的时候我几乎是完全地整理了一遍它的构建系统，而我今天打开 Element 发现法国老哥在群里 @ 我说是 MSYS2 的 cURL 更新到 8.8.0 导致我们的 CI 构建不了了让我帮他看看，虽然我自己也不是很想写 CMake，但为了避免他一言不合就把依赖复制到项目源码里面我早就跟他说过这种事情我替他处理，所以还是说到做到。&lt;/p&gt;
&lt;p&gt;报错就是一堆 undefined reference，我直接去 Google 搜了一下没有搜到什么有用的资料。去 MSYS2 的 issue 搜索 curl 倒是搜到了 &lt;a href=&quot;https://github.com/msys2/MINGW-packages/issues/21028&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/msys2/MINGW-packages/issues/21028&lt;/a&gt;，下面有人说把 &lt;code&gt;CURL_LIBRARIES&lt;/code&gt; 这个变量换成 &lt;code&gt;CURL::libcurl&lt;/code&gt; 这个 target 就可以了。我倒是理解这是什么意思，但我想知道这是怎么回事。这中间的过程可以说是曲折离奇。&lt;/p&gt;
&lt;p&gt;首先是在这里看到有维护者说这个可能是因为他们把 cURL 从 Autotools 构建换成 CMake 构建导致的，但我其实不是很理解，因为我印象里 CMake 查找 package 是调用 &lt;code&gt;Find&amp;lt;PackageName&amp;gt;.cmake&lt;/code&gt;，我去看了我们项目本身没有提供这个文件，那应该调用的就是 &lt;code&gt;/usr/share/cmake/Modules/FindCURL.cmake&lt;/code&gt; 这个由 CMake 本身提供的文件了，但抛开 CMake 这种 Find 模块谜一样的语法不谈，这个文件明确设置了 &lt;code&gt;CURL_LIBRARIES&lt;/code&gt; 变量，那也就是说这个文件根本没有生效？这时候我去翻了 CMake &lt;code&gt;find_package()&lt;/code&gt; 的文档，好家伙，这玩意除了有基础和扩展两种语法，还有 Module 和 Config 两种查找模式（内心一万匹草泥马飞奔而过）……如果是 Module 模式，就会用 &lt;code&gt;FindCURL.cmake&lt;/code&gt; 这个模块，但如果是 Config 模式，就会去调用 &lt;code&gt;CURLConfig.cmake&lt;/code&gt; 这个配置……而后面这个配置里面只写了 CMake 的 target，没有定义 &lt;code&gt;CURL_LIBRARIES&lt;/code&gt; 这个变量。&lt;/p&gt;
&lt;p&gt;但这样又有两个疑问，首先是为什么会有后面这个 Config 文件呢？毕竟以前一直用的是 Module，我比较了 Arch 的 curl PKGBUILD 和 MSYS2 的 curl PKGBUILD 得出结论：这个文件是 CMake 构建项目的时候自动基于当前所有的 target 生成的，因为 Arch 使用 Autotools 构建的包没有这个文件。但为什么默认会使用这个 Config 呢？按照 CMake 的文档，Config 似乎是 Module 的 fallback，也就是说只有没有 Module 的时候才会使用 Config，我百思不得其解。但总之解决方案很简单，对于 Ansel 自己，我使用了下面的代码：&lt;/p&gt;
&lt;figure data-raw=&quot;find_package(CURL REQUIRED)
if(TARGET CURL::libcurl)
  set(CURL_LIBRARIES CURL::libcurl)
endif()
&quot; data-info=&quot;language-cmake&quot; data-lang=&quot;cmake&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-cmake&quot;&gt;find_package(CURL REQUIRED)
if(TARGET CURL::libcurl)
  set(CURL_LIBRARIES CURL::libcurl)
endif()
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这样可以保证对不同版本的兼容性，而对于我们自己构建的 exiv2 依赖，我一开始打算直接 &lt;code&gt;find_package(CURL MODULE REQUIRED)&lt;/code&gt;，毕竟按照文档这样可以强制它忽略 Config 嘛，但结果我推到 CI 上仍然报错。我不是很理解，直到我看了一眼 log 发现它仍然是用的 Config，我当时真的骂人了，我不是写的很清楚要强制 Module 吗？这到底是怎么回事？&lt;/p&gt;
&lt;p&gt;当然实际上解决方法是有的，只要使用前一种方法就可以了。但我咽不下这口气，不按照文档说的顺序先尝试 Module 就算了，我强制 Module 了还是给我用 Config 是什么意思？你猜我最后在哪找到了解释，是在 &lt;a href=&quot;https://cmake.org/cmake/help/latest/module/FindCURL.html#curl-cmake&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;&lt;code&gt;FindCURL.cmake&lt;/code&gt; 的文档页面&lt;/a&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If CURL was built using the CMake buildsystem then it provides its own CURLConfig.cmake file for use with the find_package() command&#039;s config mode. This module looks for this file and, if found, returns its results with no further action.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我觉得任何一个脑子正常的程序员都该骂做出这个改动的人，首先你改变了默认的加载顺序也就算了，我可以理解成这是你们 CMake 用户的某种隐性约定我新来的我不知道。你用 Config 的时候不遵守 &lt;code&gt;Find&amp;lt;PackageName&amp;gt;.cmake&lt;/code&gt; Module 约定的导出变量我也忍了。但是请问为什么我在 &lt;strong&gt;显式指定&lt;/strong&gt; 了 &lt;code&gt;MODULE&lt;/code&gt; 关键字的情况下，仍然会被不知不觉的改变行为？这个说明藏在这么小的专题页面里，是生怕用户搞清楚为什么代码和实际行为完全相反吗？写这个逻辑的人有没有意识到自己是在好心办坏事？&lt;/p&gt;
&lt;p&gt;这个 &lt;code&gt;FindCURL.cmake&lt;/code&gt; 是 CMake 官方提供的 module 之一，所以也没必要试图甩锅给其他人。总之我在使用 CMake 的过程中除了迷惑到难以阅读的拼写习惯，反人类且可能混杂不同时期或者不同风味（比如 &lt;code&gt;find_package()&lt;/code&gt; 就有两种语法）的 API，写起来弯弯绕绕的约定习惯（比如 &lt;code&gt;Find&amp;lt;PackageName&amp;gt;.cmake&lt;/code&gt; 约定导出 &lt;code&gt;&amp;lt;PackageName&amp;gt;_LIBRARIES&lt;/code&gt; 然后经常会看到什么 &lt;code&gt;set(&amp;lt;PackageName&amp;gt;_LIBRARIES &amp;lt;PackageName&amp;gt;_LIBRARY)&lt;/code&gt;）之外，现在又多了个就算你显式指定参数还是会偷偷做出相反行为的体验。我不反对 CMake 确实能用，但和 Meson 的使用体验比起来，写 CMake 确实不能算是什么令人享受的事情。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/tags/%E7%BC%96%E7%A8%8B/" />
    <category term="CMake" label="CMake" scheme="https://sh.alynx.one/tags/CMake/" />
  </entry>
  <entry>
    <title>Pango 中的 Ink 和 Logical 矩形</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Ink-and-Logical-Rectangles-of-Pango/" />
    <id>https://sh.alynx.one/posts/Ink-and-Logical-Rectangles-of-Pango/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-05-27T03:50:22.000Z</published>
    <updated>2024-05-27T03:50:22.000Z</updated>
    <summary type="html">
      如果你尝试过自己在程序里绘制一段字符串，你就会发现你得到的 buffer 的高度并不总是你设置的字号大小，特别是英文。这个现象的原因是英文在书写的时候并不像汉字一样高矮都一样，而是有上有下，比如 g 这个字符的尾巴总是向下伸出来一点，这些字符通常是基线对齐的，也就是说主体部分会躺…
    </summary>
    <content type="html">
      &lt;p&gt;如果你尝试过自己在程序里绘制一段字符串，你就会发现你得到的 buffer 的高度并不总是你设置的字号大小，特别是英文。这个现象的原因是英文在书写的时候并不像汉字一样高矮都一样，而是有上有下，比如 g 这个字符的尾巴总是向下伸出来一点，这些字符通常是基线对齐的，也就是说主体部分会躺在一条基线上，尾巴和头发则可能会伸出来。而就算是方块造型的汉字，字体也可能会在上下留下一定的空间，导致实际排版的尺寸比设置的字号要大。（我不是专业的排版工作者或者字体设计师，如果说错了希望大家指正。）&lt;/p&gt;
&lt;p&gt;通常来说这种多占用一点空间的行为不会有什么问题，因为只有这样渲染一排字符的时候看起来才会比较自然。但假如你像我一样希望在字符串周围绘制边框的话，事情就变得麻烦起来了，如果你只是按照你设置的字号大小去绘制边框，你会发现这个字号大小被 Pango 这样的排版库当作基线以上的高度，所以字母的尾巴会出现在边框外面，这是绘制下划线的方式而不是绘制边框的方式。当然你可以从 Pango 获取一些有用的数据，有两个矩形尺寸可以获得，一个是 logical，这个是 Pango 用来排版的矩形，它是按照基线安排的，所以你使用这个绘制会保证字符主体都在一条直线上，多个字符串绘制出来的效果比较接近书写的习惯，也因此它的 x 和 y 坐标总是 0，是绘制的基准点。另一个是 ink，这个是“着墨”区域，也就是说把所有字符包进去的最小矩形，由于字符书写的时候是错落有致的，x 和 y 坐标并不总是 0，而是相对 logical 基准点的 offset，比如一个斜体的字符的 x 坐标很可能是负数，因为书写的时候它是倾斜到左边的字符下面的。&lt;/p&gt;
&lt;p&gt;对于这两个矩形，官方文档基本没有解释，而网上查到的很多解释是错的，实际上可以用下面的程序把它们绘制出来：&lt;/p&gt;
&lt;figure data-raw=&quot;#include &lt;gtk/gtk.h&gt;

static void draw(GtkDrawingArea *drawing_area, cairo_t *cr, int width, int height, gpointer user_data)
{
    PangoLayout *layout = pango_cairo_create_layout(cr);
    pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_NONE);
    PangoFontDescription *font = pango_font_description_new();
    pango_font_description_set_family(font, &amp;quot;serif&amp;quot;);
    pango_font_description_set_style(font, PANGO_STYLE_ITALIC);
    pango_font_description_set_absolute_size(font, 200 * PANGO_SCALE);
    pango_layout_set_font_description(layout, font);

    PangoRectangle string_ink;
    PangoRectangle string_logical;
    pango_layout_set_text(layout, &amp;quot;g&amp;quot;, -1);
    pango_layout_get_pixel_extents(layout, &amp;amp;string_ink, &amp;amp;string_logical);
    g_print(&amp;quot;Logical: x is %d, y is %d, width is %d, height is %d.\n&amp;quot;, string_logical.x, string_logical.y, string_logical.width, string_logical.height);
    g_print(&amp;quot;Ink: x is %d, y is %d, width is %d, height is %d.\n&amp;quot;, string_ink.x, string_ink.y, string_ink.width, string_ink.height);

    cairo_set_source_rgb(cr, 0.3, 0.3, 0.3);
    cairo_paint(cr);

    const int x = 100;
    const int y = 100;
    cairo_move_to(cr, x, y);
    cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 1.0);
    pango_cairo_show_layout(cr, layout);

    cairo_set_line_width(cr, 5);
    cairo_set_source_rgba(cr, 1.0, 0.0, 0.0, 1.0);
    cairo_rectangle(cr, x + string_logical.x, y + string_logical.y, string_logical.width, string_logical.height);
    cairo_stroke(cr);

    cairo_set_source_rgba(cr, 0.0, 0.0, 1.0, 1.0);
    cairo_rectangle(cr, x + string_ink.x, y + string_ink.y, string_ink.width, string_ink.height);
    cairo_stroke(cr);
}

static void on_activate(GtkApplication *app, gpointer user_data)
{
    GtkWidget *window = gtk_application_window_new (app);
    gtk_window_set_title(GTK_WINDOW(window), &amp;quot;Test Pango Extents&amp;quot;);
    gtk_window_set_default_size(GTK_WINDOW(window), 500, 500);
    GtkWidget *area = gtk_drawing_area_new();
    gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(area), draw, NULL, NULL);
    gtk_window_set_child(GTK_WINDOW(window), area);
    gtk_window_present(GTK_WINDOW(window));
}

int main(int argc, char *argv[])
{
    GtkApplication *app = gtk_application_new(&amp;quot;one.alynx.test-pango-extents&amp;quot;, G_APPLICATION_DEFAULT_FLAGS);
    g_signal_connect(app, &amp;quot;activate&amp;quot;, G_CALLBACK(on_activate), NULL);
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);
    return status;
}
&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &amp;lt;gtk/gtk.h&amp;gt;

static void draw(GtkDrawingArea *drawing_area, cairo_t *cr, int width, int height, gpointer user_data)
{
    PangoLayout *layout = pango_cairo_create_layout(cr);
    pango_layout_set_ellipsize(layout, PANGO_ELLIPSIZE_NONE);
    PangoFontDescription *font = pango_font_description_new();
    pango_font_description_set_family(font, &quot;serif&quot;);
    pango_font_description_set_style(font, PANGO_STYLE_ITALIC);
    pango_font_description_set_absolute_size(font, 200 * PANGO_SCALE);
    pango_layout_set_font_description(layout, font);

    PangoRectangle string_ink;
    PangoRectangle string_logical;
    pango_layout_set_text(layout, &quot;g&quot;, -1);
    pango_layout_get_pixel_extents(layout, &amp;amp;string_ink, &amp;amp;string_logical);
    g_print(&quot;Logical: x is %d, y is %d, width is %d, height is %d.\n&quot;, string_logical.x, string_logical.y, string_logical.width, string_logical.height);
    g_print(&quot;Ink: x is %d, y is %d, width is %d, height is %d.\n&quot;, string_ink.x, string_ink.y, string_ink.width, string_ink.height);

    cairo_set_source_rgb(cr, 0.3, 0.3, 0.3);
    cairo_paint(cr);

    const int x = 100;
    const int y = 100;
    cairo_move_to(cr, x, y);
    cairo_set_source_rgba(cr, 1.0, 1.0, 1.0, 1.0);
    pango_cairo_show_layout(cr, layout);

    cairo_set_line_width(cr, 5);
    cairo_set_source_rgba(cr, 1.0, 0.0, 0.0, 1.0);
    cairo_rectangle(cr, x + string_logical.x, y + string_logical.y, string_logical.width, string_logical.height);
    cairo_stroke(cr);

    cairo_set_source_rgba(cr, 0.0, 0.0, 1.0, 1.0);
    cairo_rectangle(cr, x + string_ink.x, y + string_ink.y, string_ink.width, string_ink.height);
    cairo_stroke(cr);
}

static void on_activate(GtkApplication *app, gpointer user_data)
{
    GtkWidget *window = gtk_application_window_new (app);
    gtk_window_set_title(GTK_WINDOW(window), &quot;Test Pango Extents&quot;);
    gtk_window_set_default_size(GTK_WINDOW(window), 500, 500);
    GtkWidget *area = gtk_drawing_area_new();
    gtk_drawing_area_set_draw_func(GTK_DRAWING_AREA(area), draw, NULL, NULL);
    gtk_window_set_child(GTK_WINDOW(window), area);
    gtk_window_present(GTK_WINDOW(window));
}

int main(int argc, char *argv[])
{
    GtkApplication *app = gtk_application_new(&quot;one.alynx.test-pango-extents&quot;, G_APPLICATION_DEFAULT_FLAGS);
    g_signal_connect(app, &quot;activate&quot;, G_CALLBACK(on_activate), NULL);
    int status = g_application_run(G_APPLICATION(app), argc, argv);
    g_object_unref(app);
    return status;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;下面是编译命令：&lt;/p&gt;
&lt;figure data-raw=&quot;$ gcc -o test-pango-extents `pkg-config --cflags --libs gtk4` test-pango-extents.c
$ ./test-pango-extents
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ gcc -o test-pango-extents `pkg-config --cflags --libs gtk4` test-pango-extents.c
$ ./test-pango-extents
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;输出的尺寸是这样：&lt;/p&gt;
&lt;figure data-raw=&quot;Logical: x is 0, y is 0, width is 113, height is 265.
Ink: x is -1, y is 102, width is 122, height is 151.
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;Logical: x is 0, y is 0, width is 113, height is 265.
Ink: x is -1, y is 102, width is 122, height is 151.
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;得到的结果是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Ink-and-Logical-Rectangles-of-Pango/screenshot.png&quot; alt=&quot;test-pango-extents&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是这两个都不符合我的需求，因为我希望字符串按照边框对齐而不是按照基线对齐，同时边框看起来都一样高，直接绘制 logical 矩形实际仍然是基线对齐，比我想要的大了很多。而按照 ink 绘制不能保证边框一样高。最后的做法是使用 ink 的宽度绘制边框的宽度，然后利用 ink 的高度重新计算绘制位置将字符放在底边上，这里要注意的是因为默认绘制是以 logical 矩形左上角作为基准点，需要减去 ink 矩形的左上角 offset 才能从 ink 的左上角开始绘制。具体的修改在 &lt;a href=&quot;https://github.com/AlynxZhou/showmethekey/commit/f1a2a5a995d6c224700b376b287c7aaff512d365#diff-295efe2fde895e5fedc8e4194f1be7ba064dc9787643139520f7913541aee1f6&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/showmethekey/commit/f1a2a5a995d6c224700b376b287c7aaff512d365#diff-295efe2fde895e5fedc8e4194f1be7ba064dc9787643139520f7913541aee1f6&lt;/a&gt;，这里就不赘述了。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/tags/%E7%BC%96%E7%A8%8B/" />
    <category term="字体" label="字体" scheme="https://sh.alynx.one/tags/%E5%AD%97%E4%BD%93/" />
  </entry>
  <entry>
    <title>构建和运行 Xen HVM 和 PV</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Xen-HVM-PV/" />
    <id>https://sh.alynx.one/posts/Xen-HVM-PV/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-03-07T15:19:19.000Z</published>
    <updated>2024-03-12T09:59:48.000Z</updated>
    <summary type="html">
      &lt;div class=&quot;alert-red&quot;&gt;请注意本文并不是推荐读者使用 Xen 作为虚拟化方案，相反，KVM 才是目前更合适大部分读者的方案。&lt;/div&gt;

&lt;h1 id=&quot;%E7%AE%80%E4%BB%8B&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Xen-HVM-PV/#%E7%AE%80%E4%BB%8B&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;
&lt;p&gt;由于工作需要，最近我需要搞一个 Xen PV 来进行测试，在此之前我一直使用 qemu/KVM，只是听说 Xen 是 KVM 之前流行过的虚拟化方案。比起几乎什么都不需要做交给 libvirt 包办就可以的 KVM，Xen 的设置相对要复杂一点。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;div class=&quot;alert-red&quot;&gt;请注意本文并不是推荐读者使用 Xen 作为虚拟化方案，相反，KVM 才是目前更合适大部分读者的方案。&lt;/div&gt;

&lt;h1 id=&quot;%E7%AE%80%E4%BB%8B&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Xen-HVM-PV/#%E7%AE%80%E4%BB%8B&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;
&lt;p&gt;由于工作需要，最近我需要搞一个 Xen PV 来进行测试，在此之前我一直使用 qemu/KVM，只是听说 Xen 是 KVM 之前流行过的虚拟化方案。比起几乎什么都不需要做交给 libvirt 包办就可以的 KVM，Xen 的设置相对要复杂一点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;首先 Xen 分为 HVM 和 PV 两种常见的虚拟方案（PVH 我也没用过），HVM 依赖于硬件虚拟化，和常见的虚拟机没什么区别，而 PV 并不依赖硬件虚拟化，是通过虚拟机 Linux 内核中特殊的驱动，将请求转给宿主机的内核代为操作，但配置起来也更加复杂。目前 PV 所需的代码已经并入 Linux 内核上游，你能安装的发行版大部分都可以直接作为 PV 的虚拟机运行。&lt;/p&gt;
&lt;p&gt;无论是 HVM 还是 PV，Xen 都用 domU（domain 的缩写，U 可以是 1、2、3……）代表虚拟机，然后用 dom0 代表宿主机，当然文档里也会叫宿主机 Hypervisor，这里我也可能直接将虚拟机叫做 VM。&lt;/p&gt;
&lt;h1 id=&quot;%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C-dom0&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Xen-HVM-PV/#%E6%9E%84%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C-dom0&quot;&gt;&lt;/a&gt;构建和运行 dom0&lt;/h1&gt;
&lt;div class=&quot;alert-blue&quot;&gt;温馨提示：根据我的经验，在 Xen Hypervsior 上运行的 GNOME 桌面会由于未知原因在未知操作时卡住，建议不要用你平时使用的开发机作为 Xen Hypervisor，而是另找一台机器作为服务器运行 Xen Hypervisor，然后远程连接上去操作。&lt;/div&gt;

&lt;p&gt;和 KVM 不需要什么操作就能用不一样，Xen 需要你构建一个单独的 boot loader，在加载 Linux 内核之前先加载它，从而实现 Xen 的支持。我这里用的 Arch Linux，需要构建 &lt;code&gt;xen&lt;/code&gt; 这个 AUR 包，根据 wiki 所说推荐用下面的指令构建：&lt;/p&gt;
&lt;figure data-raw=&quot;$ build_stubdom=true efi_dir=&amp;quot;/boot&amp;quot; makepkg -si
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ build_stubdom=true efi_dir=&quot;/boot&quot; makepkg -si
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我这里直接把 ESP 挂载到 &lt;code&gt;/boot&lt;/code&gt;，你可能需要按情况修改。&lt;/p&gt;
&lt;p&gt;你还需要 &lt;code&gt;xen-qemu&lt;/code&gt; 这个 AUR 包提供 qemu 前端对 Xen 的支持，但和一般的 AUR 包不同的是如果你直接构建这个包，得到的包很可能和你已经安装的 qemu 文件冲突。这是我遇到的唯一一个必须在 clean chroot 才能构建的包。然后由于它依赖 &lt;code&gt;xen&lt;/code&gt; 这个 AUR 包，你必须手动操作。&lt;/p&gt;
&lt;p&gt;首先安装 &lt;code&gt;devtools&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S devtools
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pacman -S devtools
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后创建一个用于构建 clean chroot 的目录：&lt;/p&gt;
&lt;figure data-raw=&quot;$ mkdir ~/chroot
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ mkdir ~/chroot
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后在里面安装基础依赖：&lt;/p&gt;
&lt;figure data-raw=&quot;$ mkarchroot ~/chroot/root base-devel
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ mkarchroot ~/chroot/root base-devel
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;一般这时候 chroot 里面应该已经是最新的了，但也可以用下面的命令更新：&lt;/p&gt;
&lt;figure data-raw=&quot;$ arch-nspawn ~/chroot/root pacman -Syu
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ arch-nspawn ~/chroot/root pacman -Syu
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后切换到你包含 &lt;code&gt;xen-qemu&lt;/code&gt; 的 &lt;code&gt;PKGBUILD&lt;/code&gt; 的目录，你可能需要的两个依赖是 &lt;code&gt;xen&lt;/code&gt; 和 &lt;code&gt;numactl&lt;/code&gt;，前者我们刚刚构建过，后者我们可以直接从官方仓库通过 &lt;code&gt;pacman -S numactl&lt;/code&gt; 安装，然后在命令行参数里指定这两个文件的位置：&lt;/p&gt;
&lt;figure data-raw=&quot;$ makechrootpkg -c -r ~/chroot -I ../xen/xen-4.18.1pre-1-x86_64.pkg.tar.zst -I /var/cache/pacman/pkg/numactl-2.0.18-1-x86_64.pkg.tar.zst
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ makechrootpkg -c -r ~/chroot -I ../xen/xen-4.18.1pre-1-x86_64.pkg.tar.zst -I /var/cache/pacman/pkg/numactl-2.0.18-1-x86_64.pkg.tar.zst
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后用 &lt;code&gt;pacman -U xen-qemu-*.tar.pkg.zst&lt;/code&gt; 安装你刚刚构建好的包，此时应该没有文件冲突了。&lt;/p&gt;
&lt;p&gt;你还需要安装下面的包提供虚拟机内的 BIOS 和 UEFI 引导支持：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S seabios edk2-ovmf
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pacman -S seabios edk2-ovmf
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后你需要加载构建好的 Xen boot loader，让它在 Linux 内核之前启动，我使用的 systemd-boot，所以下面就简单写 systemd-boot 的配置方式，逻辑上是完全一致的，如果你使用 GRUB，建议参考 Arch Wiki。&lt;/p&gt;
&lt;p&gt;首先添加一个 systemd-boot 启动项文件，我这里使用 &lt;code&gt;/boot/loader/entries/xen.conf&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;title Xen Hypervisor
sort-key xen
efi /xen.efi
&quot; data-info=&quot;language-conf&quot; data-lang=&quot;conf&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-conf&quot;&gt;title Xen Hypervisor
sort-key xen
efi /xen.efi
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你也用 systemd-boot，这个文件对你来说应该非常简单，构建 &lt;code&gt;xen&lt;/code&gt; 包的时候已经将支持 EFI 的 Xen boot loader 也就是 &lt;code&gt;xen.efi&lt;/code&gt; 这个文件安装到了 ESP，只要引导它就可以。&lt;/p&gt;
&lt;p&gt;接下来我们编写 Xen 的配置文件让它可以正确找到你的 initramfs 和内核，并传递内核参数，配置文件 &lt;code&gt;xen.cfg&lt;/code&gt; 需要和 &lt;code&gt;xen.efi&lt;/code&gt; 位于同一个目录，这里就是 &lt;code&gt;/boot/xen.cfg&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;[global]
default=xen

[xen]
options=console=vga loglvl=all noreboot
kernel=vmlinuz-linux root=&amp;quot;UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&amp;quot; rootfstype=&amp;quot;btrfs&amp;quot; rootflags=&amp;quot;rw,defaults,noatime,compress=zstd:3,ssd,space_cache,subvolid=257,subvol=/@&amp;quot; rw add_efi_memmap threadirqs nvidia_drm.modeset=1
ramdisk=initramfs-linux.img
ucode=amd-ucode.img
&quot; data-info=&quot;language-conf&quot; data-lang=&quot;conf&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-conf&quot;&gt;[global]
default=xen

[xen]
options=console=vga loglvl=all noreboot
kernel=vmlinuz-linux root=&quot;UUID=XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX&quot; rootfstype=&quot;btrfs&quot; rootflags=&quot;rw,defaults,noatime,compress=zstd:3,ssd,space_cache,subvolid=257,subvol=/@&quot; rw add_efi_memmap threadirqs nvidia_drm.modeset=1
ramdisk=initramfs-linux.img
ucode=amd-ucode.img
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;以上的内核参数是我所用的，你可以从你当前的 boot loader 启动项文件里复制出你正在用的内核参数。如果你复制了 &lt;code&gt;xen&lt;/code&gt; 包自带的示例文件而不是我的，需要注意里面包含限制宿主机可用内存的参数，这是为了避免在创建虚拟机时再限制宿主机内存，影响宿主机各种缓存的策略，默认的值给的很小，可能导致无法正常启动桌面，你可能需要改大一点。不过对于我们这种简单 debug 用，可以直接忽略此参数，影响不大。&lt;/p&gt;
&lt;p&gt;然后你需要让 Xen 所需的一些守护进程开机启动：&lt;/p&gt;
&lt;figure data-raw=&quot;# systemctl enable xenconsoled.service xen-init-dom0.service xen-qemu-dom0-disk-backend.service xendomains.service
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# systemctl enable xenconsoled.service xen-init-dom0.service xen-qemu-dom0-disk-backend.service xendomains.service
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后重启系统，选择名字是 &lt;code&gt;Xen Hypervisor&lt;/code&gt; 的启动项，你应该就有一个可以运行 Xen 的环境了。&lt;/p&gt;
&lt;h1 id=&quot;%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BF%90%E8%A1%8C-domU&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Xen-HVM-PV/#%E9%85%8D%E7%BD%AE%E5%92%8C%E8%BF%90%E8%A1%8C-domU&quot;&gt;&lt;/a&gt;配置和运行 domU&lt;/h1&gt;
&lt;p&gt;然后按道理说既然 Xen 和 KVM 都是用 qemu 作为前端，那完全可以交给我常用的 virt-manager 操办一切，但我尝试构建了带 Xen 支持的 libvirt，结果运行起来发现由于某个 bug，它并不能真的支持 Xen，所以只能全手动操作了。&lt;/p&gt;
&lt;h2 id=&quot;%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%94%A8%E7%9A%84-NAT-%E7%BD%91%E7%BB%9C&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Xen-HVM-PV/#%E6%9E%84%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%94%A8%E7%9A%84-NAT-%E7%BD%91%E7%BB%9C&quot;&gt;&lt;/a&gt;构建虚拟机用的 NAT 网络&lt;/h2&gt;
&lt;p&gt;virt-manager 会帮我自动创建一个 NAT 网络使得虚拟机之间可以互相联系并且通过宿主机访问外网，我相信大部分人都需要让虚拟机联网，但只能我自己解决这件事了。&lt;/p&gt;
&lt;p&gt;具体的操作包含以下几步：添加一个桥接接口；然后给它分配一个 IP；再开启系统的 NAT 转发（包含 &lt;code&gt;sysctl&lt;/code&gt; 和 &lt;code&gt;iptables&lt;/code&gt; 两部分，我自己也不是 &lt;code&gt;iptables&lt;/code&gt; 高手所以我也不能给你解释）；然后在这个接口上启动 DHCP 服务器，给虚拟机提供 IP 地址和 DNS 服务器。这样就完成了宿主机的部分，Xen 可以根据虚拟机的配置文件自动把虚拟机添加到你刚才创建的桥接接口上。&lt;/p&gt;
&lt;p&gt;为了简化这个操作我编写了一个脚本：&lt;/p&gt;
&lt;figure data-raw=&quot;#!/bin/bash

set -x

OUT_IF=&amp;quot;${1}&amp;quot;
BR_IF=&amp;quot;${2}&amp;quot;
BR_IP=&amp;quot;192.168.123.1&amp;quot;
BR_IP_RANGE=&amp;quot;192.168.123.100,192.168.123.200&amp;quot;
BR_DNS=&amp;quot;1.1.1.1,8.8.8.8&amp;quot;

[[ -z &amp;quot;${OUT_IF}&amp;quot; ]] &amp;amp;&amp;amp; exit 1
[[ -z &amp;quot;${BR_IF}&amp;quot; ]] &amp;amp;&amp;amp; BR_IF=&amp;quot;vmbr0&amp;quot;

ip link add name &amp;quot;${BR_IF}&amp;quot; type bridge
ip link set dev &amp;quot;${BR_IF}&amp;quot; up

ip address add dev &amp;quot;${BR_IF}&amp;quot; &amp;quot;${BR_IP}/24&amp;quot;

# Enable NAT, so VMs can accept Internet.
FORWARD=$(sysctl --values net.ipv4.ip_forward)
# See &lt;https://www.karlrupp.net/en/computer/nat_tutorial&gt;.
sysctl net.ipv4.ip_forward=1
iptables -t nat -A POSTROUTING -o &amp;quot;${OUT_IF}&amp;quot; -j MASQUERADE

# Start DHCP server so we don&#039;t need to manually assign IP addresses for VMs.
# `--no-daemon` starts dnsmasq in debug mode, so it won&#039;t overload SIGINT.
# It is hard to prevent `dnsmasq` from listening `127.0.0.1:53` as a DNS server,
# so just disable its DNS server, and send DNS server to VMs via DHCP.
# It seems you need to set `--bind-interfaces` with `--interface` to make it
# bind to a interface only, otherwise it will try to bind to other interfaces
# and conflict with other dnsmasq instance (if exists).
dnsmasq --no-daemon \
    --port=0 \
    --interface=&amp;quot;${BR_IF}&amp;quot; \
    --bind-interfaces \
    --dhcp-range=&amp;quot;${BR_IP_RANGE}&amp;quot; \
    --dhcp-option=&amp;quot;option:dns-server,${BR_DNS}&amp;quot;

iptables -t nat -D POSTROUTING -o &amp;quot;${OUT_IF}&amp;quot; -j MASQUERADE
sysctl &amp;quot;net.ipv4.ip_forward=${FORWARD}&amp;quot;

ip link set dev &amp;quot;${BR_IF}&amp;quot; down
ip link delete &amp;quot;${BR_IF}&amp;quot;
&quot; data-info=&quot;language-bash&quot; data-lang=&quot;bash&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;#!/bin/bash

set -x

OUT_IF=&quot;${1}&quot;
BR_IF=&quot;${2}&quot;
BR_IP=&quot;192.168.123.1&quot;
BR_IP_RANGE=&quot;192.168.123.100,192.168.123.200&quot;
BR_DNS=&quot;1.1.1.1,8.8.8.8&quot;

[[ -z &quot;${OUT_IF}&quot; ]] &amp;amp;&amp;amp; exit 1
[[ -z &quot;${BR_IF}&quot; ]] &amp;amp;&amp;amp; BR_IF=&quot;vmbr0&quot;

ip link add name &quot;${BR_IF}&quot; type bridge
ip link set dev &quot;${BR_IF}&quot; up

ip address add dev &quot;${BR_IF}&quot; &quot;${BR_IP}/24&quot;

# Enable NAT, so VMs can accept Internet.
FORWARD=$(sysctl --values net.ipv4.ip_forward)
# See &amp;lt;https://www.karlrupp.net/en/computer/nat_tutorial&amp;gt;.
sysctl net.ipv4.ip_forward=1
iptables -t nat -A POSTROUTING -o &quot;${OUT_IF}&quot; -j MASQUERADE

# Start DHCP server so we don&#039;t need to manually assign IP addresses for VMs.
# `--no-daemon` starts dnsmasq in debug mode, so it won&#039;t overload SIGINT.
# It is hard to prevent `dnsmasq` from listening `127.0.0.1:53` as a DNS server,
# so just disable its DNS server, and send DNS server to VMs via DHCP.
# It seems you need to set `--bind-interfaces` with `--interface` to make it
# bind to a interface only, otherwise it will try to bind to other interfaces
# and conflict with other dnsmasq instance (if exists).
dnsmasq --no-daemon \
    --port=0 \
    --interface=&quot;${BR_IF}&quot; \
    --bind-interfaces \
    --dhcp-range=&quot;${BR_IP_RANGE}&quot; \
    --dhcp-option=&quot;option:dns-server,${BR_DNS}&quot;

iptables -t nat -D POSTROUTING -o &quot;${OUT_IF}&quot; -j MASQUERADE
sysctl &quot;net.ipv4.ip_forward=${FORWARD}&quot;

ip link set dev &quot;${BR_IF}&quot; down
ip link delete &quot;${BR_IF}&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;你可以把这个脚本保存成 &lt;code&gt;mkvmbr0.sh&lt;/code&gt;，然后 &lt;code&gt;chmod +x mkvmbr0.sh&lt;/code&gt;，然后用 &lt;code&gt;ip a&lt;/code&gt; 查看你当前联网所用的端口名，比如我的是 &lt;code&gt;wlp5s0&lt;/code&gt;，就可以 &lt;code&gt;sudo ./mkvmbr0.sh wlp5s0&lt;/code&gt; 创建一个运行在 &lt;code&gt;vmbr0&lt;/code&gt; 端口上的 NAT 网络，脚本会启动 &lt;code&gt;dnsmasq&lt;/code&gt; 作为 DHCP 服务器并通过 DHCP 服务器给虚拟机下发 DNS 服务器地址，如果你已经用完了虚拟机，&lt;code&gt;Ctrl+C&lt;/code&gt; 打断 &lt;code&gt;dnsmasq&lt;/code&gt; 它就会进行后续的清理工作并退出。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BC%96%E5%86%99-HVM-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Xen-HVM-PV/#%E7%BC%96%E5%86%99-HVM-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&quot;&gt;&lt;/a&gt;编写 HVM 配置文件&lt;/h2&gt;
&lt;p&gt;HVM 实在是没什么复杂的，这么说是相对于 PV 而言，比如说构建一个 openSUSE Tumbleweed 的 HVM 可以写一个叫做 &lt;code&gt;hvm-tumbleweed.cfg&lt;/code&gt; 的文件：&lt;/p&gt;
&lt;figure data-raw=&quot;name = &#039;hvm-tumbleweed&#039;
builder = &#039;hvm&#039;
memory = 2048
vcpus = 4
disk = [ &#039;file:/home/alynx/xen/disk-tumbleweed.img,xvda,rw&#039;, &#039;file:/home/alynx/xen/openSUSE-Tumbleweed-DVD-x86_64-Current.iso,sdb:cdrom,r&#039; ]
vif = [ &#039;mac=00:16:3e:00:00:02,bridge=vmbr0&#039; ]
vnc = 1
vnclisten = &#039;0.0.0.0&#039;
vncdisplay = 1
&quot; data-info=&quot;language-conf&quot; data-lang=&quot;conf&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-conf&quot;&gt;name = &#039;hvm-tumbleweed&#039;
builder = &#039;hvm&#039;
memory = 2048
vcpus = 4
disk = [ &#039;file:/home/alynx/xen/disk-tumbleweed.img,xvda,rw&#039;, &#039;file:/home/alynx/xen/openSUSE-Tumbleweed-DVD-x86_64-Current.iso,sdb:cdrom,r&#039; ]
vif = [ &#039;mac=00:16:3e:00:00:02,bridge=vmbr0&#039; ]
vnc = 1
vnclisten = &#039;0.0.0.0&#039;
vncdisplay = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这里没什么要注意的，无非是 &lt;code&gt;bridge=&lt;/code&gt; 后面接你 NAT 网络的桥接端口。以及你在配置文件里写 &lt;code&gt;xvda&lt;/code&gt; 在虚拟机里会变成 &lt;code&gt;sda&lt;/code&gt;，所以不要再写另一个叫做 &lt;code&gt;sda&lt;/code&gt; 的设备了。如果你有多个虚拟机，记得修改 MAC 地址和 VNC 端口。&lt;/p&gt;
&lt;p&gt;创建磁盘文件可以用下面的命令：&lt;/p&gt;
&lt;figure data-raw=&quot;$ truncate -s 20G disk-tumbleweed.img
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ truncate -s 20G disk-tumbleweed.img
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后用下面的命令就可以启动这个虚拟机：&lt;/p&gt;
&lt;figure data-raw=&quot;# xl create hvm-tumblweed.cfg
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# xl create hvm-tumblweed.cfg
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;其他的命令可以直接 &lt;code&gt;man xl&lt;/code&gt; 查看手册。可以使用 &lt;code&gt;vncviewer YOUR_HOST_IP:1&lt;/code&gt; 连接虚拟机。关于这个配置文件的具体语法可以参考 &lt;a href=&quot;https://xenbits.xen.org/docs/unstable/man/xl.cfg.5.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h2 id=&quot;%E7%BC%96%E5%86%99-PV-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Xen-HVM-PV/#%E7%BC%96%E5%86%99-PV-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6&quot;&gt;&lt;/a&gt;编写 PV 配置文件&lt;/h2&gt;
&lt;p&gt;PV 比起 HVM 可就复杂太多了，最痛苦的一个问题是由于它不是硬件虚拟化，所以你没有办法运行虚拟机磁盘上的 boot loader！解决方案有两个，要么是直接在配置文件里写好内核和 initramfs 的路径（这样你就得想办法把虚拟机的内核和 initramfs 搞到宿主机磁盘上），要么是在宿主机上构建一个 GRUB 镜像，然后让这个 GRUB 去找虚拟机磁盘里的 &lt;code&gt;grub.cfg&lt;/code&gt; 并执行，然后引导虚拟机里面的内核（这都哪跟哪啊）。&lt;/p&gt;
&lt;p&gt;当然，如果你虚拟机的系统并不使用 GRUB 作为 boot loader，那你就只能使用第一种方案了。对于 openSUSE Tumbleweed，我摸索通了后面的方案，因此我在这里介绍这个方案如何操作。&lt;/p&gt;
&lt;p&gt;首先你需要克隆 GRUB 的源码，因为你得专门构建一个能在 Xen 虚拟机里运行的 GRUB：&lt;/p&gt;
&lt;figure data-raw=&quot;$ git clone git://git.savannah.gnu.org/grub.git
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ git clone git://git.savannah.gnu.org/grub.git
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后构建（如果你的 Xen 是 32 位机器上的，把 &lt;code&gt;amd64&lt;/code&gt; 换成 &lt;code&gt;i386&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;$ ./autogen.sh
$ ./configure --prefix=/opt/grub-xen --target=amd64 --with-platform=xen
$ make
# make install
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ ./autogen.sh
$ ./configure --prefix=/opt/grub-xen --target=amd64 --with-platform=xen
$ make
# make install
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这会将 Xen 版本的 GRUB 安装到 &lt;code&gt;/opt/grub-xen&lt;/code&gt;，接下来我们需要利用 GRUB 可以将一个 tar 作为 memdisk 的特性，在里面写一个 &lt;code&gt;grub.cfg&lt;/code&gt; 让 GRUB 去按我们指定的路径搜索实际的 &lt;code&gt;grub.cfg&lt;/code&gt; 并加载它（别问我为什么，这鬼东西简直太邪门了）。&lt;/p&gt;
&lt;p&gt;首先写一个 &lt;code&gt;grub-bootstrap.cfg&lt;/code&gt;，这个文件的唯一作用就是让 GRUB 加载 memdisk 里面的 &lt;code&gt;grub.cfg&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;normal (memdisk)/grub.cfg
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;normal (memdisk)/grub.cfg
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后写一个 &lt;code&gt;grub.cfg&lt;/code&gt;，下面关键的问题来了，你怎么知道要搜索的真正的 &lt;code&gt;grub.cfg&lt;/code&gt; 的路径呢，当然是想办法挂载出来自己看了，我这个文件里写了常见的安装好的系统的 &lt;code&gt;grub.cfg&lt;/code&gt; 的位置和我自己看到的 openSUSE 安装 iso 里面的 &lt;code&gt;grub.cfg&lt;/code&gt; 的位置，所以可以同时支持安装和启动系统：&lt;/p&gt;
&lt;figure data-raw=&quot;if search -s -f /boot/grub/grub.cfg ; then
    echo &amp;quot;Reading (${root})/boot/grub/grub.cfg&amp;quot;
    configfile /boot/grub/grub.cfg
fi

if search -s -f /boot/grub2/grub.cfg ; then
    echo &amp;quot;Reading (${root})/boot/grub2/grub.cfg&amp;quot;
    configfile /boot/grub2/grub.cfg
fi

if search -s -f /grub/grub.cfg ; then
    echo &amp;quot;Reading (${root})/grub/grub.cfg&amp;quot;
    configfile /grub/grub.cfg
fi

if search -s -f /grub2/grub.cfg ; then
    echo &amp;quot;Reading (${root})/grub2/grub.cfg&amp;quot;
    configfile /grub2/grub.cfg
fi

if search -s -f /EFI/BOOT/grub.cfg ; then
    echo &amp;quot;Reading (${root})/EFI/BOOT/grub.cfg&amp;quot;
    configfile /EFI/BOOT/grub.cfg
fi
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;if search -s -f /boot/grub/grub.cfg ; then
    echo &quot;Reading (${root})/boot/grub/grub.cfg&quot;
    configfile /boot/grub/grub.cfg
fi

if search -s -f /boot/grub2/grub.cfg ; then
    echo &quot;Reading (${root})/boot/grub2/grub.cfg&quot;
    configfile /boot/grub2/grub.cfg
fi

if search -s -f /grub/grub.cfg ; then
    echo &quot;Reading (${root})/grub/grub.cfg&quot;
    configfile /grub/grub.cfg
fi

if search -s -f /grub2/grub.cfg ; then
    echo &quot;Reading (${root})/grub2/grub.cfg&quot;
    configfile /grub2/grub.cfg
fi

if search -s -f /EFI/BOOT/grub.cfg ; then
    echo &quot;Reading (${root})/EFI/BOOT/grub.cfg&quot;
    configfile /EFI/BOOT/grub.cfg
fi
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后把它打包成 tar：&lt;/p&gt;
&lt;figure data-raw=&quot;$ tar -cf memdisk.tar grub.cfg
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ tar -cf memdisk.tar grub.cfg
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后创建一个支持 Xen 的包含所有 GRUB 模块的 GRUB 镜像，我们将把它当作真正的虚拟机的 boot loader 运行，使用如下命令：&lt;/p&gt;
&lt;figure data-raw=&quot;$ /opt/grub-xen/bin/grub-mkimage -O x86_64-xen \
       -c grub-bootstrap.cfg \ 
       -m memdisk.tar \
       -o grub-x86_64-xen.bin \
       /opt/grub-xen/lib/grub/x86_64-xen/*.mod
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ /opt/grub-xen/bin/grub-mkimage -O x86_64-xen \
       -c grub-bootstrap.cfg \ 
       -m memdisk.tar \
       -o grub-x86_64-xen.bin \
       /opt/grub-xen/lib/grub/x86_64-xen/*.mod
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后你就可以编写一个 &lt;code&gt;pv-tumbleweed.cfg&lt;/code&gt; 的配置文件：&lt;/p&gt;
&lt;figure data-raw=&quot;name = &#039;pv-tumbleweed&#039;
memory = 2048
vcpus = 4
kernel = &amp;quot;grub-x86_64-xen.bin&amp;quot;
disk = [ &#039;file:/home/alynx/xen/disk-tumbleweed.img,sda,rw&#039;, &#039;file:/home/alynx/xen/openSUSE-Tumbleweed-DVD-x86_64-Current.iso,sdb:cdrom,r&#039; ]
vif = [ &#039;mac=00:16:3e:00:00:01,bridge=vmbr0&#039; ]
vnc = 1
vnclisten = &#039;0.0.0.0&#039;
vncdisplay = 1
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;name = &#039;pv-tumbleweed&#039;
memory = 2048
vcpus = 4
kernel = &quot;grub-x86_64-xen.bin&quot;
disk = [ &#039;file:/home/alynx/xen/disk-tumbleweed.img,sda,rw&#039;, &#039;file:/home/alynx/xen/openSUSE-Tumbleweed-DVD-x86_64-Current.iso,sdb:cdrom,r&#039; ]
vif = [ &#039;mac=00:16:3e:00:00:01,bridge=vmbr0&#039; ]
vnc = 1
vnclisten = &#039;0.0.0.0&#039;
vncdisplay = 1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;没错我们这里把我们刚刚生成的 boot loader 作为内核首先拉起来，然后不出意外你应该就能看到安装程序启动了，但是如果你火急火燎的一路下一步安装，你就会掉进下一个坑：openSUSE 默认使用 snapper 管理 btrfs 快照，默认的配置方案把 &lt;code&gt;/boot&lt;/code&gt; 也放在 btrfs 子卷上。而上游的 GRUB 会从 btrfs 的根子卷而不是默认子卷开始访问，我是没能搞清楚该如何简单直接的访问 snapper 最新的快照所在的子卷，openSUSE 的 GRUB 则是打了一大堆 patch 让 GRUB 支持查找和加载默认的 btrfs 子卷。总之你直接安装之后我们的 &lt;code&gt;grub.cfg&lt;/code&gt; 是查找不到真正的 &lt;code&gt;grub.cfg&lt;/code&gt; 的，最简单的方案就是安装时干脆不要用 btrfs 从而不用 snapper，或者把 &lt;code&gt;/boot&lt;/code&gt; 单独分区单独格式化单独挂载。&lt;/p&gt;
&lt;p&gt;然后你应该可以用下面的命令启动并链接到虚拟机的终端了：&lt;/p&gt;
&lt;figure data-raw=&quot;# xl create -c pv-tumblweed.cfg
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# xl create -c pv-tumblweed.cfg
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;关于这个配置文件的具体语法可以参考 &lt;a href=&quot;https://xenbits.xen.org/docs/unstable/man/xl.cfg.5.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;官方文档&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;%E8%BF%99%E4%B8%80%E5%88%87%E5%80%BC%E5%BE%97%E5%90%97%EF%BC%9F&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Xen-HVM-PV/#%E8%BF%99%E4%B8%80%E5%88%87%E5%80%BC%E5%BE%97%E5%90%97%EF%BC%9F&quot;&gt;&lt;/a&gt;这一切值得吗？&lt;/h1&gt;
&lt;p&gt;在经历这一系列不知道是什么鬼东西的操作之后你终于有了一个可以用的 Xen PV，也许它唯一的优势就是可以在没有硬件虚拟化的机器上跑虚拟机，为此你付出的代价是一个没法用桌面的宿主机，一个说不定哪个新系统就没法引导的虚拟机 boot loader。但现在的设备有几个没有硬件虚拟化支持呢？这就意味着对于大多数人你可以简单地使用 qemu/KVM 几乎不需要任何额外的配置，并且还有 virt-manager 这样的程序全程帮你图形化配置虚拟机和 NAT 网络。&lt;/p&gt;
&lt;p&gt;而比如你想用上面的办法手动构建网络并启动一些 SLES Minimal OS 或者 openSUSE JeOS，这个过程也更简单，首先在 &lt;code&gt;/etc/qemu/bridge.conf&lt;/code&gt; 里加入一行 &lt;code&gt;allow vmbr0&lt;/code&gt;，然后用之前的 NAT 网络脚本 &lt;code&gt;sudo ./mkvmbr0.sh wlp5s0&lt;/code&gt;，再用下面的 qemu 命令：&lt;/p&gt;
&lt;figure data-raw=&quot;$ qemu-system-x86_64 \
    -enable-kvm \
    -m 1G \
    -smp 1 \
    -drive if=virtio,format=qcow2,file=SLES15-SP5-Minimal-VM.x86_64-kvm-and-xen-GM.qcow2 \
    -nographic \
    -netdev bridge,id=eth0,br=vmbr0 \
    -device virtio-net,netdev=eth0
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ qemu-system-x86_64 \
    -enable-kvm \
    -m 1G \
    -smp 1 \
    -drive if=virtio,format=qcow2,file=SLES15-SP5-Minimal-VM.x86_64-kvm-and-xen-GM.qcow2 \
    -nographic \
    -netdev bridge,id=eth0,br=vmbr0 \
    -device virtio-net,netdev=eth0
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;它会调用 &lt;code&gt;qemu-bridge-helper&lt;/code&gt; 自动将虚拟机加入你构建的桥接 NAT 网络，和 Xen 比起来简单很多，也不需要额外的配置。因此如果你只是需要一个自己的虚拟化平台，完全没有必要使用已经不再流行且可能存在更多问题的 Xen，使用 KVM 就足够了。这篇文章仅仅是为了在读者不得不需要构建一个 Xen 环境 debug 时作为参考。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="虚拟化" label="虚拟化" scheme="https://sh.alynx.one/tags/%E8%99%9A%E6%8B%9F%E5%8C%96/" />
    <category term="Xen" label="Xen" scheme="https://sh.alynx.one/tags/Xen/" />
  </entry>
  <entry>
    <title>kmsvnc 但是无头</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Headless-kmsvnc/" />
    <id>https://sh.alynx.one/posts/Headless-kmsvnc/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-03-06T09:38:48.000Z</published>
    <updated>2024-03-06T09:38:48.000Z</updated>
    <summary type="html">
      由于 Wayland 并不存在像 X11 一样一个单独管理用于最终显示的 framebuffer 的进程，因此远程桌面需要各个桌面做自己的实现。而因为登录界面和用户会话一般是两个会话，远程登录过程中的会话切换就变得非常复杂，虽然 GNOME Remote Desktop 已经有了…
    </summary>
    <content type="html">
      &lt;p&gt;由于 Wayland 并不存在像 X11 一样一个单独管理用于最终显示的 framebuffer 的进程，因此远程桌面需要各个桌面做自己的实现。而因为登录界面和用户会话一般是两个会话，远程登录过程中的会话切换就变得非常复杂，虽然 GNOME Remote Desktop 已经有了一个初步实现，但我对那个的逻辑不是很满意，而且他们目前依赖 RDP 的 server rediection，所以并不支持 VNC。&lt;/p&gt;
&lt;p&gt;按照当初我做 Show Me The Key 的逻辑，如果一样东西在混成器层面上不好实现，那应该考虑在下一层更统一的层面上实现，&lt;a href=&quot;https://github.com/isjerryxiao/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@Jerry Xiao&lt;/a&gt; 老师做了一个叫做 &lt;a href=&quot;https://github.com/isjerryxiao/kmsvnc/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;kmsvnc&lt;/a&gt; 的项目，通过 DRM/KMS 获取 framebuffer 并转给 VNC 服务器，虽然它也有一些自己的小问题，但我很喜欢这个方案。&lt;/p&gt;
&lt;p&gt;实际上我需要用到远程桌面的场景不多，毕竟 ssh 大部分时候更可靠也更高效，不过有时候需要修改 NAS 上一些桌面设置的时候会用到。但此时就有第一个问题，我的 NAS 是无头（就是没接显示器）的，没有显示器的情况下桌面没有输出，也就获取不到 framebuffer。请教了 &lt;a href=&quot;https://github.com/isjerryxiao/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@Jerry Xiao&lt;/a&gt; 老师之后得知可以通过内核参数实现强制让内核以为我们有个显示器，就可以解决这个问题。&lt;/p&gt;
&lt;p&gt;这个目的需要两个内核参数，分别是 &lt;code&gt;video=&lt;/code&gt; 指定强制开启哪个显卡输出端口，和 &lt;code&gt;drm.edid_firmware=&lt;/code&gt; 给这个端口指定一个 EDID 从而指定分辨率，正常的显示器会通过端口汇报自己的 EDID，而我们这里没有，所以需要手动指定。&lt;/p&gt;
&lt;p&gt;具体这两个参数都支持什么我就不细说了，因为很复杂，建议自己看文档。首先我们得选择一个显卡已经有的输出端口用来做这个，可以用下面的命令：&lt;/p&gt;
&lt;figure data-raw=&quot;$ for p in /sys/class/drm/*/status; do con=${p%/status}; echo -n &amp;quot;${con#*/card?-}: &amp;quot;; cat $p; done
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ for p in /sys/class/drm/*/status; do con=${p%/status}; echo -n &quot;${con#*/card?-}: &quot;; cat $p; done
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;它会列出端口和它们的连接状态，比如我这里有三个：&lt;/p&gt;
&lt;figure data-raw=&quot;DP-1: disconnected
HDMI-A-1: connected
HDMI-A-2: disconnected
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;DP-1: disconnected
HDMI-A-1: connected
HDMI-A-2: disconnected
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;很神奇的是我的主板上实际只有一个 DP 和一个 HDMI（我的是核芯显卡），经过我的测试主板的 HDMI 输出是 &lt;code&gt;HDMI-A-2&lt;/code&gt;，至于 &lt;code&gt;HDMI-A-1&lt;/code&gt; 到底在哪我不清楚，可能是 USB-C，但如果它并没有物理输出，那就更好了，所以我这里选择它。另外我建议不要选择 DP 输出，因为内核内置的 EDID 固件似乎并不支持 DP，导致无法指定分辨率。&lt;/p&gt;
&lt;p&gt;然后我们通过 &lt;code&gt;video=&quot;HDMI-A-1:D&quot;&lt;/code&gt; 强制开启这个 HDMI 端口，一般你可能会查到用 &lt;code&gt;e&lt;/code&gt; 表示强制启用一个端口，不过 &lt;code&gt;D&lt;/code&gt; 表示强制启用一个数字输出端口，应该用哪个都无所谓。然后我们用 &lt;code&gt;drm.edid_firmware=&quot;HDMI-A-1:edid/1920x1080.bin&quot;&lt;/code&gt; 给这个端口指定一个 EDID 固件，这里我们使用内核内置的 &lt;code&gt;1920x1080&lt;/code&gt; 分辨率的固件，你也可以选择其它内置的，可以在内核源码 &lt;code&gt;drivers/gpu/drm/drm_edid_load.c&lt;/code&gt; 文件中找到它们的名字和内容。&lt;/p&gt;
&lt;p&gt;然后重新启动系统，再用上面的命令，应该就像我一样有一个 &lt;code&gt;connected&lt;/code&gt; 的输出了。然后我们启动 kmsvnc：&lt;/p&gt;
&lt;figure data-raw=&quot;# kmsvnc -p 5901 -b 0.0.0.0 -4 -d /dev/dri/card0
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;# kmsvnc -p 5901 -b 0.0.0.0 -4 -d /dev/dri/card0
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;再从另一台机器上访问：&lt;/p&gt;
&lt;figure data-raw=&quot;$ vncviewer YOUR_SERVER_IP:5901
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ vncviewer YOUR_SERVER_IP:5901
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;应该就能看到登录界面了。不过如果你也用 GDM，你可能会发现登录之后屏幕一直是 GDM 的背景色没有切换到用户会话，这个其实是因为 GDM 会选择另一个空闲的 tty 启动 GNOME，而 &lt;a href=&quot;https://github.com/isjerryxiao/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@Jerry Xiao&lt;/a&gt; 老师表示还没有找到一个普适的方案检测 tty 切换，所以这时候需要你手动 &lt;code&gt;Ctrl+C&lt;/code&gt; 打断 kmsvnc，然后再重新运行上面的命令，应该就会选择 GNOME 桌面所在的 plane 了。&lt;/p&gt;
&lt;p&gt;如果你不是刚开机就启动 kmsvnc，可能会发现它报告找不到 plane 就退出了，这个目测是因为 GDM 检测不到用户输入就会自动停止显示器输出，只要 &lt;code&gt;systemctl restart gdm&lt;/code&gt; 重新启动一下 GDM 就可以了。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="远程桌面" label="远程桌面" scheme="https://sh.alynx.one/tags/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/" />
    <category term="VNC" label="VNC" scheme="https://sh.alynx.one/tags/VNC/" />
    <category term="kmsvnc" label="kmsvnc" scheme="https://sh.alynx.one/tags/kmsvnc/" />
    <category term="NAS" label="NAS" scheme="https://sh.alynx.one/tags/NAS/" />
  </entry>
  <entry>
    <title>谁动了我的 DNS 解析？（重制版）</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Who-Moved-My-DNS-Resolving-Remastered/" />
    <id>https://sh.alynx.one/posts/Who-Moved-My-DNS-Resolving-Remastered/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-02-06T03:53:30.000Z</published>
    <updated>2024-02-06T03:53:30.000Z</updated>
    <summary type="html">
      &lt;p&gt;这一篇是之前 &lt;a href=&quot;/posts/Who-Moved-My-DNS-Resolving/&quot;&gt;谁动了我的 DNS 解析？&lt;/a&gt; 的重制版，因为那一篇杂糅了关于设置 Zeroconf 的 mDNS 的需求和关于 Linux 下面 DNS 解析到底是怎么工作的描述，我怀疑大部分读者对前者不感兴趣（因为我自己后来也发现这玩意不是很可靠），而更想了解后者，所以打算拉出来单写一篇。&lt;/p&gt;
&lt;p&gt;标题显然是化用自《谁动了我的奶酪？》，即使我并没有读过这本书。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;这一篇是之前 &lt;a href=&quot;/posts/Who-Moved-My-DNS-Resolving/&quot;&gt;谁动了我的 DNS 解析？&lt;/a&gt; 的重制版，因为那一篇杂糅了关于设置 Zeroconf 的 mDNS 的需求和关于 Linux 下面 DNS 解析到底是怎么工作的描述，我怀疑大部分读者对前者不感兴趣（因为我自己后来也发现这玩意不是很可靠），而更想了解后者，所以打算拉出来单写一篇。&lt;/p&gt;
&lt;p&gt;标题显然是化用自《谁动了我的奶酪？》，即使我并没有读过这本书。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;long-long-ago&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving-Remastered/#long-long-ago&quot;&gt;&lt;/a&gt;long long ago&lt;/h1&gt;
&lt;p&gt;一般要讲故事，开头都是“很久很久以前……”，不过计算机领域也没什么太古老的故事可讲，毕竟公认的互联网前身 ARPANET 也就是二十世纪的事情。那个时候能互联的机器一共也就那么几个，所以解决的办法简单粗暴：我们每个机器都保存一个文件，里面记录所有人对应的域名和 IP 不就行了？这个优良传统一直留了下来，也就是现在所有系统里都有的 hosts 文件——不管你写的对不对，它的优先级都比后来出现的 DNS 查询要高。&lt;/p&gt;
&lt;p&gt;然后随着加入网络的机器越来越多，这个办法不好用了，毕竟每来一个新人就要所有人更新自己的文件，这复杂度也太高了。所以干脆我们搞一个集中的服务器专门放这个列表，其它机器都向它查询就好了，这就是 DNS 服务器的原理。然后在局域网里，一般路由器和 DNS 服务器以及 DHCP 服务器都是同一台机器，因为很自然的所有设备都会连到路由器上，而 DHCP 服务器恰好知道它分配出去的 IP 地址，所以如果你输入内网设备的主机名恰好能解析，那通常是你的路由器做了这些工作。&lt;/p&gt;
&lt;p&gt;但既然有了 DNS 服务器，那问题就变得复杂起来，比如我该将我的 DNS 服务器设置成哪一个？特别地，你可能会发现有很多不同的程序在试图修改你的 DNS 服务器设置，导致你打开某些网站本该秒开却不停地转圈圈，事情为什么会这么复杂？&lt;/p&gt;
&lt;h1 id=&quot;chattr-+i--etc-resolv-conf&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving-Remastered/#chattr-+i--etc-resolv-conf&quot;&gt;&lt;/a&gt;chattr +i /etc/resolv.conf&lt;/h1&gt;
&lt;p&gt;很多 Linux 用户都知道修改 DNS 服务器可以通过编辑 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 实现，很多 Linux 用户也被 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 困扰，一些人发现自己的这个文件是个软链接，而另一些人发现这个文件总被 Network Manager 覆盖，还有些人的发行版让他们用一个叫 &lt;code&gt;resolvconf&lt;/code&gt; 的工具处理，然后现在 systemd 又搞了个叫 systemd-resolved 的东西来插一脚……我说的这些已经足够让一些不想学新东西同时又神经紧张的人开始大喊“fuck systemd, fuck network manager, fuck desktop environment and fuck the whole modern world”然后执行 &lt;code&gt;chattr +i /etc/resolv.conf&lt;/code&gt; 了。不过别着急小炸药包们，也许这个世界上新出现的各种东西目的并不只是惹恼你们这群大笨蛋，哦是的，没错，我说，大笨蛋，恐龙勇士（停停停不要翻译腔了），你不需要的功能并不意味着别人也不需要。总之，不要觉得世界都围着你转，至少读一下这些东西的文档，会告诉你怎么阻止它们修改你的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 的。&lt;/p&gt;
&lt;p&gt;在 DNS 服务器设置这件事上并不是一个 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 搞定所有，有关这个的故事也是 long long ago，但毕竟是 UNIX 纪元之后的事情，没有太久，大概确实上古时代的程序都是直接读这个获取 DNS 服务器然后再做 DNS 解析的，但实际上这也不一定 OK，比如像之前说的 hosts 文件也需要考虑。所以就有了更复杂的解决方案，大部分程序做 DNS 解析实际上是调用 glibc 里面 &lt;code&gt;getaddrinfo&lt;/code&gt; 这个 API，所以在它后面我们就可以做一些工作。一个叫做 Name Service Switch 的东西发明出来就是干这个的，它是基于插件的，我们可以通过阅读 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; 里面的 &lt;code&gt;hosts&lt;/code&gt; 这一行来理解，比如我这里默认是这样的：&lt;/p&gt;
&lt;figure data-raw=&quot;hosts: mymachines resolve [!UNAVAIL=return] files myhostname dns
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;hosts: mymachines resolve [!UNAVAIL=return] files myhostname dns
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;简单翻译一下的话意思就是查询一个域名的时候首先看看是不是 systemd-machined 的容器（&lt;code&gt;mymachines&lt;/code&gt; 模块），不是的话再问问 systemd-resolved 能不能解析（&lt;code&gt;resolve&lt;/code&gt; 模块），如果 systemd-resolved 可用，那到这也就完事了，后面的就不管了（&lt;code&gt;[!UNAVAIL=return]&lt;/code&gt;），至于为什么我一会解释，然后 &lt;code&gt;files&lt;/code&gt; 模块会读 hosts 文件，所以它优先级总是高于 DNS 服务器，然后看看是不是本机（&lt;code&gt;myhostname&lt;/code&gt; 模块），然后再读 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 里面的 DNS 服务器进行查询。&lt;/p&gt;
&lt;p&gt;按照这个顺序，如果你处在一个极其简单的网络环境：只有一个网络连接（这里包含各种有线无线 VPN 隧道在内都只能有一个）并且完全不会移动到其它网络连接下使用，那确实只要在 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 里面写死一个公开的 DNS 服务器就可以满足你的所有查询需求。但可惜并不是所有人的使用环境都这么简单，所以每个工具都有额外的策略并试图修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;%E5%BD%93%E4%BD%A0%E6%98%AF%E4%B8%AA%E9%9C%80%E8%A6%81%E6%9D%A5%E5%9B%9E%E8%B7%91%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E6%88%B7%E2%80%A6%E2%80%A6&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving-Remastered/#%E5%BD%93%E4%BD%A0%E6%98%AF%E4%B8%AA%E9%9C%80%E8%A6%81%E6%9D%A5%E5%9B%9E%E8%B7%91%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E6%88%B7%E2%80%A6%E2%80%A6&quot;&gt;&lt;/a&gt;当你是个需要来回跑的笔记本用户……&lt;/h1&gt;
&lt;p&gt;下面让我们考虑一个比那些觉得自己手搓一个 DHCP 客户端就能联网的大脑皮层极其光滑的只要 &lt;code&gt;chattr +i /etc/resolv.conf&lt;/code&gt; 就能解决问题的小笨蛋们的场景稍微复杂一点的场景：你是一个背着笔记本来回跑的上班族，公司 WiFi 和家里 WiFi 的网段并不一样，而你需要在公司的时候将 DNS 服务器设置为公司的路由器，在家的时候将 DNS 服务器设置为家的路由器（什么水晶室女），以便在两地都可以通过内网设备的主机名访问对应的内网设备，显然你不可能靠 &lt;code&gt;chattr +i /etc/resolv.conf&lt;/code&gt; 解决问题。&lt;/p&gt;
&lt;p&gt;这就是为什么 Network Manager 需要修改你的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;（其它网络管理器我就不考虑了因为我没用过，而且对于所有这种可以帮你自动连接 WiFi 的网络管理器而言，设置 DNS 服务器的逻辑都应该是相同的），对于每个不同的网络连接，它都会记录或者自动获取该局域网的 DNS 服务器，然后根据你当前激活的连接把这个 DNS 服务器写入 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，保证无论是使用 &lt;code&gt;getaddrinfo&lt;/code&gt; 的程序还是自己读取 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 的老古董程序都可以获取到正确的局域网 DNS 服务器从而访问内网里的设备。&lt;/p&gt;
&lt;h1 id=&quot;%E5%BD%93%E4%BD%A0%E6%98%AF%E4%B8%AA%E9%9C%80%E8%A6%81%E6%9D%A5%E5%9B%9E%E8%B7%91%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E6%88%B7%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87-VPN-%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%E2%80%A6%E2%80%A6&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving-Remastered/#%E5%BD%93%E4%BD%A0%E6%98%AF%E4%B8%AA%E9%9C%80%E8%A6%81%E6%9D%A5%E5%9B%9E%E8%B7%91%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E6%88%B7%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87-VPN-%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%E2%80%A6%E2%80%A6&quot;&gt;&lt;/a&gt;当你是个需要来回跑的笔记本用户，同时你还需要通过 VPN 远程办公……&lt;/h1&gt;
&lt;p&gt;如果你完全理解了上面那一段，恭喜你已经脱离了草履虫进化成了脊椎动物了！但你又遇到了更复杂的场景：你的工作要求你连接公司的 VPN，从而通过内部的 DNS 服务器解析一些内网才能访问的网站，当你打开了 VPN 下载一些内网才能下载的工具时你想同时放一些音乐打发时间，但你最爱的音乐网站现在要转 3 秒的圈才能访问！Network Manager 可以帮你解决这个问题吗？答案是在某些情况下可以！&lt;/p&gt;
&lt;p&gt;尝试分析这个新的需求，你会发现问题在于 VPN 服务也要设置一个 DNS 服务器，如果你的 VPN 服务尝试自己覆盖 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，那么 Network Manager 之前按照你的连接帮你设置的“正常的”的 DNS 服务器就会消失，你所有的 DNS 解析就会全部绕到公司内网的 DNS 服务器上跑一圈，导致所有网站的解析都变得很慢。这个时候你可能又打算大喊 &lt;code&gt;chattr +i /etc/resolv.conf&lt;/code&gt; 退化成草履虫，但这样你就没办法解析公司内网的域名了，也许更好的办法是只让 Network Manager 管理 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;。因为大部分的 VPN 都已经有 Network Manager 的插件了，所以你只要在 Network Manager 里添加你的 VPN 连接，它就会像管理 WiFi 一样管理这个连接，此时你会发现你的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 里已经同时有了家里路由器的 DNS 服务器和 VPN 的 DNS 服务器。&lt;/p&gt;
&lt;p&gt;理想状态下，你的 VPN 应该会自动通知客户端对于哪些域名使用这个 VPN 的 DNS 服务器查询，如果你勾选了“仅对此网络上的资源使用此连接”的话。这样访问不在内网上的网站就不会到这个 DNS 服务器上转一圈，而是直接跑到“正常”的 DNS 服务器上查询。但如果不幸这个自动配置的过程出了问题，你可以通过 &lt;code&gt;nmcli&lt;/code&gt; 修改这个 VPN 连接的 &lt;code&gt;ipv4.dns-search&lt;/code&gt; 项，把需要在内网查询的域名列表手动设置好。&lt;/p&gt;
&lt;p&gt;对于绝大部分用户，这样的配置应该已经可以满足他们了！但实际情况永远只有更复杂，所以我们还要继续！&lt;/p&gt;
&lt;h1 id=&quot;%E5%BD%93%E4%BD%A0%E6%98%AF%E4%B8%AA%E9%9C%80%E8%A6%81%E6%9D%A5%E5%9B%9E%E8%B7%91%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E6%88%B7%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87-VPN-%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%EF%BC%8C%E4%BD%86%E4%BD%A0%E7%9A%84-VPN-%E5%B9%B6%E6%B2%A1%E6%9C%89-Network-Manager-%E7%9A%84%E6%8F%92%E4%BB%B6%E2%80%A6%E2%80%A6&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving-Remastered/#%E5%BD%93%E4%BD%A0%E6%98%AF%E4%B8%AA%E9%9C%80%E8%A6%81%E6%9D%A5%E5%9B%9E%E8%B7%91%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E6%88%B7%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87-VPN-%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%EF%BC%8C%E4%BD%86%E4%BD%A0%E7%9A%84-VPN-%E5%B9%B6%E6%B2%A1%E6%9C%89-Network-Manager-%E7%9A%84%E6%8F%92%E4%BB%B6%E2%80%A6%E2%80%A6&quot;&gt;&lt;/a&gt;当你是个需要来回跑的笔记本用户，同时你还需要通过 VPN 远程办公，但你的 VPN 并没有 Network Manager 的插件……&lt;/h1&gt;
&lt;p&gt;欢迎刚刚进化完成的灵长类！坐稳了！我们要向现代人的方向冲刺了！现在我有一个更加复杂的需求：我给自己的各种内网设备搭建了一个 VPN，这样我即使身在外面也能访问我家里的服务器，但这个 VPN 使用 Tailscale，Network Manager 并没有相关的插件，于是 Tailscale 也来试图覆盖我的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，听个音乐又需要转 3 秒的圈，怎么办？&lt;/p&gt;
&lt;p&gt;最好在那边手握 &lt;code&gt;chattr +i /etc/resolv.conf&lt;/code&gt; 的草履虫嘲笑之前堵上他的嘴，因为这同样会导致我失去解析 VPN 内网域名的能力，我们是现代人，我们要用 systemd-resolved 解决这个问题。&lt;/p&gt;
&lt;p&gt;systemd-resolved 并不仅仅是一个管理 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 的工具，实际上它本身是一个自带缓存的 DNS 服务器，然后向上接管各种不同的 DNS 查询逻辑，向下为各种需要设置 DNS 服务器的工具提供接口。因此如果你的各种网络连接工具都支持 systemd-resolved 的接口，那它们就不需要自己修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，而是改为配合 systemd-resolved 工作，恰好 Network Manager 和 Tailscale 都支持 systemd-resolved。&lt;/p&gt;
&lt;p&gt;在接管 DNS 查询这个目的上 systemd-resolved 提供了三种不同的接口：首先是自己实现了一个 D-Bus 接口，其它程序可以通过这个接口来实现。然后是在 Name Service Switch 里添加了属于自己的模块以接管 &lt;code&gt;getaddrinfo&lt;/code&gt;，如果检测到 systemd-resolved 已启用，那它的缓存 DNS 服务器就会接管所有的处理，包括 hosts 和 hostname，以及如果没有缓存到，就会主动向上级 DNS 服务器查询，因此在 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; 里面写了如果检测到 systemd-resolved 就直接返回，跳过后面的模块。最后对于那些自己读取 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 的老古董，它也会修改这个文件接管这类程序，这时这个文件只是个软链接，里面只有一句就是把 DNS 服务器设置为 systemd-resolved 自己的 DNS 缓存服务器。&lt;/p&gt;
&lt;p&gt;如果你要启用 systemd-resolved，务必保证你的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 是指向 systemd-resolved 管理的文件的软链接：&lt;/p&gt;
&lt;figure data-raw=&quot;# ln -sf ../run/systemd/resolve/stub-resolv.conf /etc/resolv.conf
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# ln -sf ../run/systemd/resolve/stub-resolv.conf /etc/resolv.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这样如果 Network Manager 和 Tailscale 启动时检测到 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 是软链接，就会知道自己需要配合 systemd-resolved 工作（如果你正在配置这个，那就手动重启它们！）。此时执行 &lt;code&gt;resolvectl status&lt;/code&gt;，应该能看到对于不同的网络接口，都配置了不同的 DNS 服务器，以及需要通过这个服务器查询的域名（如果你配置过的话！）。&lt;/p&gt;
&lt;p&gt;当然，你也可以通过 systemd-resolved 的配置添加一个全局的 DNS 服务器。systemd-resolved 支持 unicast，也就是说如果你查询的域名不符合任何一个网络接口设置的要通过这个接口的 DNS 服务器查询的域名的话，它就会通过所有网络接口的 DNS 服务器查询（也包含你设置的全局 DNS 服务器），然后取最快返回的结果。&lt;/p&gt;
&lt;h1 id=&quot;%E5%BD%93%E4%BD%A0%E6%98%AF%E4%B8%AA%E9%9C%80%E8%A6%81%E6%9D%A5%E5%9B%9E%E8%B7%91%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E6%88%B7%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87-VPN-%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%EF%BC%8C%E4%BD%86%E4%BD%A0%E7%9A%84-VPN-%E5%B9%B6%E6%B2%A1%E6%9C%89-Network-Manager-%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%AE%83%E4%B9%9F%E4%B8%8D%E6%94%AF%E6%8C%81-systemd-resolved%E2%80%A6%E2%80%A6&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving-Remastered/#%E5%BD%93%E4%BD%A0%E6%98%AF%E4%B8%AA%E9%9C%80%E8%A6%81%E6%9D%A5%E5%9B%9E%E8%B7%91%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%94%A8%E6%88%B7%EF%BC%8C%E5%90%8C%E6%97%B6%E4%BD%A0%E8%BF%98%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87-VPN-%E8%BF%9C%E7%A8%8B%E5%8A%9E%E5%85%AC%EF%BC%8C%E4%BD%86%E4%BD%A0%E7%9A%84-VPN-%E5%B9%B6%E6%B2%A1%E6%9C%89-Network-Manager-%E7%9A%84%E6%8F%92%E4%BB%B6%EF%BC%8C%E5%AE%83%E4%B9%9F%E4%B8%8D%E6%94%AF%E6%8C%81-systemd-resolved%E2%80%A6%E2%80%A6&quot;&gt;&lt;/a&gt;当你是个需要来回跑的笔记本用户，同时你还需要通过 VPN 远程办公，但你的 VPN 并没有 Network Manager 的插件，它也不支持 systemd-resolved……&lt;/h1&gt;
&lt;p&gt;我们的口号是不做草履虫！实际上这种场景已经非常非常少见了，绝大多数的场景都能被 Network Manager + systemd-resolved 覆盖，这也就是为什么越来越多的通用发行版都使用这一套进行网络管理和 DNS 解析的原因。但如果你真的遇到了，也许你听说过一个叫做 &lt;code&gt;resolvconf&lt;/code&gt; 的工具，在以前某些发行版会预装它。它的逻辑似乎就是有各种程序都打算自己修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，那你们干脆都别管了，我来管，听我的（现在有 N + 1 种解决方案了）。至于它到底是怎么工作的，如何配置，这些都别问我！因为我也没有用过！我觉得你不如去建议不支持 systemd-resolved 的项目支持 systemd-resolved 比较实际……&lt;/p&gt;
&lt;p&gt;总之无论如何如果你搜到一篇老旧的教程告诉你设置这个 &lt;code&gt;resolvconf&lt;/code&gt;，那你都该留个心眼查一下，万一你这个需求已经可以用 Network Manager 的插件或者它已经支持 systemd-resolved 了呢？&lt;/p&gt;
&lt;h1 id=&quot;%E5%A4%AA%E9%95%BF%E4%B8%8D%E7%9C%8B%EF%BC%81&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving-Remastered/#%E5%A4%AA%E9%95%BF%E4%B8%8D%E7%9C%8B%EF%BC%81&quot;&gt;&lt;/a&gt;太长不看！&lt;/h1&gt;
&lt;p&gt;我准备了一张图，让你知道 DNS 解析在 Linux 上都发生了什么，以及 Network Manager 和 systemd-resolved 各自都扮演什么角色……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Who-Moved-My-DNS-Resolving-Remastered/dns.png&quot; alt=&quot;dns.png&quot;&gt;&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="网络" label="网络" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/%E7%BD%91%E7%BB%9C/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    <category term="网络" label="网络" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%BB%9C/" />
    <category term="DNS" label="DNS" scheme="https://sh.alynx.one/tags/DNS/" />
    <category term="resolv.conf" label="resolv.conf" scheme="https://sh.alynx.one/tags/resolv.conf/" />
    <category term="Network Manager" label="Network Manager" scheme="https://sh.alynx.one/tags/Network%20Manager/" />
    <category term="systemd-resolved" label="systemd-resolved" scheme="https://sh.alynx.one/tags/systemd-resolved/" />
  </entry>
  <entry>
    <title>使用 Headscale 和 Tailscale 构建虚拟专用网</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Build-VPN-with-Headscale-and-Tailscale/" />
    <id>https://sh.alynx.one/posts/Build-VPN-with-Headscale-and-Tailscale/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-02-04T11:39:26.000Z</published>
    <updated>2024-02-04T11:39:26.000Z</updated>
    <summary type="html">
      需求 很多在家里装了 NAS 的人都有一个相似的需求，那就是出门在外如何访问内网的 NAS 上运行的服务。很多人会选择公网 IP + 端口映射把需要的服务直接暴露到公网上，或者通过公网的 VPS 进行反向代理。但这些我都不放心，首先我的目的只是自己访问，而不是给别人访问，其次对于…
    </summary>
    <content type="html">
      &lt;h1 id=&quot;%E9%9C%80%E6%B1%82&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Build-VPN-with-Headscale-and-Tailscale/#%E9%9C%80%E6%B1%82&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;
&lt;p&gt;很多在家里装了 NAS 的人都有一个相似的需求，那就是出门在外如何访问内网的 NAS 上运行的服务。很多人会选择公网 IP + 端口映射把需要的服务直接暴露到公网上，或者通过公网的 VPS 进行反向代理。但这些我都不放心，首先我的目的只是自己访问，而不是给别人访问，其次对于一些简易的 WebUI，暴露在公网上也容易被无聊的人扫端口并尝试入侵。实际上这个需求更倾向于 VPN（这里指的是它本来的意思也就是虚拟专用网，而不是佛跳墙），我曾经尝试过使用 WireGuard 和公网 VPS 构建一个简单的 VPN，但效果并不好，首先是我的 VPS 并不在国内，作为所有流量的中继实在是太不合适，实际使用起来几乎卡到不能自理，其次是 WireGuard 用作 VPN 服务器的话需要把其它所有 peers 都添加到服务器里，实在是太过麻烦。&lt;/p&gt;
&lt;p&gt;第一点我其实没想到什么好的解决办法，能想到最好的也就是利用家里有公网 IP 的特点把 VPN 服务器改到家里。而第二点我差点就想改成自建 OpenVPN 了，但这时我偶然找到一些资料，说不应该手动组建 WireGuard 网络，而是使用一些基于 WireGuard 的工具帮你自动组网。比较之后我决定使用 Tailscale。&lt;/p&gt;
&lt;p&gt;Tailscale 能做的并不仅仅是帮你建立一个 VPN 服务器然后自动添加客户端，在此之上它有一些更妙的功能，比如 WireGuard 实际上并不是服务端/客户端架构，peers 之间是对等的，于是 Tailscale 可以尝试通过 NAT 穿透建立点对点的 WireGuard 连接，如果无法穿透才会通过服务端中继（Tailscale 官网有一篇关于如何实现较为可靠的 NAT 穿透的文章，至少我是没怎么看懂），这听起来很适合我的需求并且在实际使用中极大的提升了我的体验。但 Tailscale 本身只是客户端，它们通过销售自己的服务提供服务器供用户连接，客户端是开源的但服务端是闭源的。而我显然更希望自己搭建服务端，幸好有 Headscale 这个开源项目自己实现了一个 Tailscale 服务端，可以自己搭建。但 Headscale 自己的文档非常的简陋，所以我决定写篇博客记录一下具体配置的过程。&lt;/p&gt;
&lt;h1 id=&quot;Headscale&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Build-VPN-with-Headscale-and-Tailscale/#Headscale&quot;&gt;&lt;/a&gt;Headscale&lt;/h1&gt;
&lt;p&gt;首先在公网能访问到的服务器上安装 Headscale，Arch Linux 的官方仓库里已经打包了：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S headscale
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pacman -S headscale
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后需要修改配置文件 &lt;code&gt;/etc/headscale/config.yaml&lt;/code&gt;，里面需要修改的只有几处，我这里简单介绍一下：&lt;/p&gt;
&lt;p&gt;首先第一个要修改的是 &lt;code&gt;server_url&lt;/code&gt;，这个就是客户端连接服务器时使用的地址和端口，Headscale 使用的是 HTTP 协议，如果你不想明文在公网上裸奔，那可以在后面添加 HTTPS 证书和密钥使它支持 HTTPS。&lt;/p&gt;
&lt;p&gt;同样还需要修改 &lt;code&gt;listen_addr&lt;/code&gt;，控制 Headscale 监听的网段和端口，这里端口要和上面的一致。&lt;/p&gt;
&lt;p&gt;下面其它的控制数据库和 gRPC 都保持默认即可，然后你可以修改想要给子网设备分配 IP 的网段，只要修改 &lt;code&gt;ip_prefixes&lt;/code&gt; 就可以，要注意的是并不是所有网段都可以用，Tailscale 本身已经限制了一部分，你只能选择这个网段的子网段。我这里注释掉了 IPv6 因为我不需要。&lt;/p&gt;
&lt;p&gt;如果你想设置 HTTPS，Headscale 本身支持通过 ACME 帮你自动申请证书，这当然是最好的，但它并不支持通过 DNS 的方式验证域名所有权，也就意味着需要你能够监听 80 或者 443 端口，如果你是公网 IP 的家宽，这基本等于被 ISP 查水表，而如果是 VPS，你也大概率可能在这些端口上运行了其它的 HTTP 服务，所以我没有用这个功能。但它下面还提供了手动指定证书和密钥的选项，你可以使用 certbot 或者 acme.sh 之类的功能帮你处理好证书（和 certbot 搏斗实在是太痛苦了所以我省略了），然后将 &lt;code&gt;tls_cert_path&lt;/code&gt; 设置为 &lt;code&gt;fullchain.pem&lt;/code&gt; 所在的路径，&lt;code&gt;tls_key_path&lt;/code&gt; 设置为 &lt;code&gt;privkey.pem&lt;/code&gt; 所在的路径就可以。（需要注意 certbot 放置证书的路径只有 root 能读写，而 Headscale 并不是以 root 用户运行的，所以你还需要写 hooks 把文件复制出来并修改权限……）&lt;/p&gt;
&lt;p&gt;然后还有一个关于 DNS 的部分需要修改，Tailscale 提供了一个叫做 MagicDNS 的机制，当你连接上这个网络之后，就可以像在家用路由器后面一样通过主机名直接访问对应的设备，或者使用主机名 + 你定义的域名后缀，MagicDNS 会帮你解析到正确的 IP。但这里有一个问题，Headscale 默认的配置会让你运行 Tailscale 的设备将自己的 MagicDNS 服务器设置为 systemd-resolved 对所有域名使用的默认服务器（对没错 Tailscale 客户端上的 DNS 逻辑是被 Headscale 服务端控制的，什么奇怪的脑回路），这其实很不方便，特别是对于国内的一些网站比如 B 站会解析很慢并解析到离你比较远的 CDN 上，所以需要关闭这个功能，只优先对 Tailscale 的域名使用 MagicDNS 服务器。只要将 &lt;code&gt;dns_config&lt;/code&gt; 下面 &lt;code&gt;override_local_dns&lt;/code&gt; 设置为 &lt;code&gt;false&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;然后你还需要修改 &lt;code&gt;dns_config&lt;/code&gt; 下面 &lt;code&gt;base_domain&lt;/code&gt; 这一项，这个是 MagicDNS 里内部域名的后缀。&lt;/p&gt;
&lt;p&gt;解决了这些之后你就可以启动守护进程：&lt;/p&gt;
&lt;figure data-raw=&quot;# systemctl enable --now headscale
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# systemctl enable --now headscale
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Headscale 的进程和相关配置都属于 &lt;code&gt;headscale&lt;/code&gt; 用户和 &lt;code&gt;headscale&lt;/code&gt; 组，因此如果你想直接修改相关配置，可以将自己加入 &lt;code&gt;headscale&lt;/code&gt; 组：&lt;/p&gt;
&lt;figure data-raw=&quot;# gpasswd -a alynx headscale
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# gpasswd -a alynx headscale
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后你需要创建一个 Headscale 的 user，说是 user 其实更像是 namespace：&lt;/p&gt;
&lt;figure data-raw=&quot;$ headscale users create azvpn
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ headscale users create azvpn
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;上面提到的内部域名的逻辑就是 &lt;code&gt;主机名.用户名.内部域名后缀&lt;/code&gt;，比如我设置的 &lt;code&gt;base_domain&lt;/code&gt; 是 &lt;code&gt;alynx.one&lt;/code&gt;，那 timbersaw 这台主机的内部域名就是 &lt;code&gt;timbersaw.azvpn.alynx.one&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;后面我们会把设备添加到这个 namespaces，添加的时候自然需要验证权限，一般是 Tailscale 发起请求，Headscale 返回一个链接，打开链接之后是一条指令，你需要将里面的 USERNAME 换成你想要的，然后在 Headscale 所在的机器上运行这个指令。当然如果你不方便 ssh 连到 Headscale 所在的服务器，你也可以创建 preauthkey，直接在 Tailscale 连接时提供即可：&lt;/p&gt;
&lt;figure data-raw=&quot;$ headscale preauthkeys create --user azvpn --reusable --expiration 12h
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;$ headscale preauthkeys create --user azvpn --reusable --expiration 12h
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;h1 id=&quot;Tailscale--Linux-&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Build-VPN-with-Headscale-and-Tailscale/#Tailscale--Linux-&quot;&gt;&lt;/a&gt;Tailscale (Linux)&lt;/h1&gt;
&lt;p&gt;这个同样也在 Arch Linux 的官方仓库，直接安装即可：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S tailscale
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pacman -S tailscale
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;稍微复杂的一个部分是 DNS，显然 MagicDNS 会修改你的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 设置为自己的 DNS
服务器，但如果你和我的配置相同，那应该这个文件也是由 NetworkManager 管理的。如果你已经理解了 Linux 下面 DNS 解析的逻辑，你应该清楚无论何时都只应该有一个进程管理这个文件。解决方法要么是使用 NetworkManager 的插件来运行 Tailscale 从而只让 NetworkManager 管理 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;（并没有这样的插件），要么是两者全部放弃自己管理 DNS，交给第三者管理。&lt;/p&gt;
&lt;p&gt;无论是 Tailscale 还是 NetworkManager 都能自动检测 systemd-resolved 并配合它工作，所以我们启用这个代替 NetworkManager 管理 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，过程很简单也很好理解。&lt;/p&gt;
&lt;p&gt;首先把 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 链接到 systemd-resolved 的 stub 文件，这个文件的作用只有一个就是把 DNS 服务器设置成 systemd-resolved 运行的 DNS 服务器，这样所有的 DNS 查询就都被传给 systemd-resolved 进行处理：&lt;/p&gt;
&lt;figure data-raw=&quot;# ln -sf ../run/systemd/resolve/stub-resolv.conf /etc/resolv.conf
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# ln -sf ../run/systemd/resolve/stub-resolv.conf /etc/resolv.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后启动 systemd-resolved：&lt;/p&gt;
&lt;figure data-raw=&quot;# systemctl enable --now systemd-resolved
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# systemctl enable --now systemd-resolved
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;接下来重启 NetworkManager，当它启动时检测到 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 是指向 systemd-resolved 的 stub 文件的软链接，就不会尝试修改该文件而是自动配合 systemd-resolved 工作：&lt;/p&gt;
&lt;figure data-raw=&quot;# systemctl restart NetworkManager
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# systemctl restart NetworkManager
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后启动 Tailscale 的守护进程：&lt;/p&gt;
&lt;figure data-raw=&quot;# systemctl enable --now tailscaled
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# systemctl enable --now tailscaled
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;接下来就可以尝试连接到 Headscale 服务器：&lt;/p&gt;
&lt;figure data-raw=&quot;# tailscale up --login-server https://YOURSERVER:YOURPORT
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# tailscale up --login-server https://YOURSERVER:YOURPORT
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你不想进行上面的手动验证流程，这一步可以直接附加上刚才创建的 preauthkey：&lt;/p&gt;
&lt;figure data-raw=&quot;# tailscale up --login-server https://YOURSERVER:YOURPORT --auth-key YOURPREAUTHKEY
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# tailscale up --login-server https://YOURSERVER:YOURPORT --auth-key YOURPREAUTHKEY
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;此时运行 &lt;code&gt;ip a&lt;/code&gt;，应该可以看到多了一个叫 &lt;code&gt;tailscale0&lt;/code&gt; 的网络接口。使用 &lt;code&gt;resolvectl status&lt;/code&gt; 则可以看到这个接口有自己的 DNS 服务器，并且对 &lt;code&gt;azvpn.alynx.one&lt;/code&gt; 的域名使用此服务器查询。此时已经可以使用 Tailscale 内网分配的 IP 或者 MagicDNS 提供的域名像在物理路由器后面一样访问内网的各种设备。&lt;/p&gt;
&lt;h1 id=&quot;Tailscale--Android-&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Build-VPN-with-Headscale-and-Tailscale/#Tailscale--Android-&quot;&gt;&lt;/a&gt;Tailscale (Android)&lt;/h1&gt;
&lt;p&gt;Tailscale 也有开源的 Android 客户端并且已经上架了 Google Play Store，但你安装之后可能会发现没有自定义服务器的选项，你需要点开并关闭右上角三个点菜单多次，然后菜单里就会多出一项 Change Server，设置成你自建的 Headscale 服务器，然后就可以使用主界面第二个登录选项进行交互登录了。目前似乎 Android 客户端还不支持使用 preauthkey 登录。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="网络" label="网络" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/" />
    <category term="网络" label="网络" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%BB%9C/" />
    <category term="Tailscale" label="Tailscale" scheme="https://sh.alynx.one/tags/Tailscale/" />
  </entry>
  <entry>
    <title>Node 的 http.request() 需要对 response 进行错误处理</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Node-HTTP-Request-Needs-to-Handle-Response-Error/" />
    <id>https://sh.alynx.one/posts/Node-HTTP-Request-Needs-to-Handle-Response-Error/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2024-01-03T07:21:05.000Z</published>
    <updated>2024-01-03T07:21:05.000Z</updated>
    <summary type="html">
      &lt;p&gt;我发现有些时候 Telegram bot 很适合用来 host 一些我自己要用的服务，因为只要通过手机上的聊天框就可以控制了，不需要我自己写一些什么后台页面。为了让构建和安装一个新 bot 的过程尽量简单，我自己用 Node 写了一个 &lt;a href=&quot;https://github.com/AlynxZhou/azbot-telegram/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;没有外部依赖的 Telegram bot 框架&lt;/a&gt;。完全使用 Node 自带的模块比较麻烦的一点就是你需要自己基于 &lt;code&gt;http.request()&lt;/code&gt; 进行封装，因为原版基于 &lt;code&gt;EventEmitter&lt;/code&gt; 的接口写起来实在是太复杂了。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;我发现有些时候 Telegram bot 很适合用来 host 一些我自己要用的服务，因为只要通过手机上的聊天框就可以控制了，不需要我自己写一些什么后台页面。为了让构建和安装一个新 bot 的过程尽量简单，我自己用 Node 写了一个 &lt;a href=&quot;https://github.com/AlynxZhou/azbot-telegram/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;没有外部依赖的 Telegram bot 框架&lt;/a&gt;。完全使用 Node 自带的模块比较麻烦的一点就是你需要自己基于 &lt;code&gt;http.request()&lt;/code&gt; 进行封装，因为原版基于 &lt;code&gt;EventEmitter&lt;/code&gt; 的接口写起来实在是太复杂了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;把 &lt;code&gt;http.request()&lt;/code&gt; 封装成 Promise 比一般的 API 要难一点，但也不是完全做不到，比如 &lt;a href=&quot;https://nodejs.org/api/http.html#httprequestoptions-callback&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;官方文档上的示例代码&lt;/a&gt; 是这样写的（复制这么长一段不是我要占字数而是我真的被它坑了）：&lt;/p&gt;
&lt;figure data-raw=&quot;import http from &#039;node:http&#039;;
import { Buffer } from &#039;node:buffer&#039;;

const postData = JSON.stringify({
  &#039;msg&#039;: &#039;Hello World!&#039;,
});

const options = {
  hostname: &#039;www.google.com&#039;,
  port: 80,
  path: &#039;/upload&#039;,
  method: &#039;POST&#039;,
  headers: {
    &#039;Content-Type&#039;: &#039;application/json&#039;,
    &#039;Content-Length&#039;: Buffer.byteLength(postData),
  },
};

const req = http.request(options, (res) =&gt; {
  console.log(`STATUS: ${res.statusCode}`);
  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
  res.setEncoding(&#039;utf8&#039;);
  res.on(&#039;data&#039;, (chunk) =&gt; {
    console.log(`BODY: ${chunk}`);
  });
  res.on(&#039;end&#039;, () =&gt; {
    console.log(&#039;No more data in response.&#039;);
  });
});

req.on(&#039;error&#039;, (e) =&gt; {
  console.error(`problem with request: ${e.message}`);
});

// Write data to request body
req.write(postData);
req.end();
&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;import http from &#039;node:http&#039;;
import { Buffer } from &#039;node:buffer&#039;;

const postData = JSON.stringify({
  &#039;msg&#039;: &#039;Hello World!&#039;,
});

const options = {
  hostname: &#039;www.google.com&#039;,
  port: 80,
  path: &#039;/upload&#039;,
  method: &#039;POST&#039;,
  headers: {
    &#039;Content-Type&#039;: &#039;application/json&#039;,
    &#039;Content-Length&#039;: Buffer.byteLength(postData),
  },
};

const req = http.request(options, (res) =&amp;gt; {
  console.log(`STATUS: ${res.statusCode}`);
  console.log(`HEADERS: ${JSON.stringify(res.headers)}`);
  res.setEncoding(&#039;utf8&#039;);
  res.on(&#039;data&#039;, (chunk) =&amp;gt; {
    console.log(`BODY: ${chunk}`);
  });
  res.on(&#039;end&#039;, () =&amp;gt; {
    console.log(&#039;No more data in response.&#039;);
  });
});

req.on(&#039;error&#039;, (e) =&amp;gt; {
  console.error(`problem with request: ${e.message}`);
});

// Write data to request body
req.write(postData);
req.end();
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;那对于一个 POST 请求，我就可以这样封装：&lt;/p&gt;
&lt;figure data-raw=&quot;import * as http from &amp;quot;node:http&amp;quot;;
import {Buffer} from &amp;quot;node:buffer&amp;quot;;
const post = (url, body, headers = {}) =&gt; {
  const opts = {
    &amp;quot;method&amp;quot;: &amp;quot;POST&amp;quot;,
    &amp;quot;timeout&amp;quot;: 1500,
    &amp;quot;headers&amp;quot;: {}
  };
  for (const [k, v] of Object.entries(headers)) {
    opts[&amp;quot;headers&amp;quot;][k.toLowerCase()] = v;
  }
  if (!(isBuffer(body) || isString(body))) {
    body = JSON.stringify(body);
    opts[&amp;quot;headers&amp;quot;][&amp;quot;content-type&amp;quot;] = &amp;quot;application/json&amp;quot;;
    opts[&amp;quot;headers&amp;quot;][&amp;quot;content-length&amp;quot;] = `${Buffer.byteLength(body)}`;
  }
  return new Promise((resolve, reject) =&gt; {
    const req = http.request(url, opts, (res) =&gt; {
      const chunks = [];
      res.on(&amp;quot;data&amp;quot;, (chunk) =&gt; {
    chunks.push(chunk);
      });
      res.on(&amp;quot;end&amp;quot;, () =&gt; {
    resolve(Buffer.concat(chunks));
      });
    });
    req.on(&amp;quot;error&amp;quot;, reject);
    req.write(body);
    req.end();
  });
};
&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;import * as http from &quot;node:http&quot;;
import {Buffer} from &quot;node:buffer&quot;;
const post = (url, body, headers = {}) =&amp;gt; {
  const opts = {
    &quot;method&quot;: &quot;POST&quot;,
    &quot;timeout&quot;: 1500,
    &quot;headers&quot;: {}
  };
  for (const [k, v] of Object.entries(headers)) {
    opts[&quot;headers&quot;][k.toLowerCase()] = v;
  }
  if (!(isBuffer(body) || isString(body))) {
    body = JSON.stringify(body);
    opts[&quot;headers&quot;][&quot;content-type&quot;] = &quot;application/json&quot;;
    opts[&quot;headers&quot;][&quot;content-length&quot;] = `${Buffer.byteLength(body)}`;
  }
  return new Promise((resolve, reject) =&amp;gt; {
    const req = http.request(url, opts, (res) =&amp;gt; {
      const chunks = [];
      res.on(&quot;data&quot;, (chunk) =&amp;gt; {
    chunks.push(chunk);
      });
      res.on(&quot;end&quot;, () =&amp;gt; {
    resolve(Buffer.concat(chunks));
      });
    });
    req.on(&quot;error&quot;, reject);
    req.write(body);
    req.end();
  });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;反正流程无非是创建 request，然后在 response 里面收集 data 到 buffer，然后处理 request 的 error，再把 body 写到 request 里面。看起来很简单毕竟官方文档也这么写的对吧！然后就掉进坑里了。&lt;/p&gt;
&lt;p&gt;我的 Telegram bot 设置是要不停通过 HTTP 轮询获取更新，为了保证能一直轮询下去，就要在遇到错误的时候 catch 住简单处理，然后继续进行下次轮询。但明明我已经在可能出现错误的时候都处理了，bot 还是会在跑了几天以后遇到错误（通常是 &lt;code&gt;read ETIMEOUT&lt;/code&gt;）然后完全停住，只能手动重启。我对此绞尽脑汁，但是想不出哪里有问题，同时因为这个要 bot 跑一段时间才能复现，也很难 debug，我甚至手动打了 log 来看是轮询停住了还是轮询没有停但却一直得到空的结果，实际证明是遇到错误停住了，但我不是已经进行错误处理了吗？&lt;/p&gt;
&lt;p&gt;这个问题实在是找不到什么参考，我尝试了一些没有意义的办法，最后差点去翻什么 axios 之类的代码看他们如何解决的了。不过我在此之前想了一下，会不会是因为不仅要写 &lt;code&gt;req.on(&quot;error&quot;, reject);&lt;/code&gt;，还要写 &lt;code&gt;res.on(&quot;error&quot;, reject);&lt;/code&gt; 来处理 response 的错误，否则 Node 就会直接把相关的错误抛出来停掉？其实我心里觉得不太可能，毕竟 &lt;strong&gt;示例代码里根本都没有写这句&lt;/strong&gt;，但我还是本着没办法的办法写上去了：&lt;/p&gt;
&lt;figure data-raw=&quot;diff --git a/azbot-telegram/bot-utils.js b/azbot-telegram/bot-utils.js
index 42e002e..f90a8eb 100644
--- a/azbot-telegram/bot-utils.js
+++ b/azbot-telegram/bot-utils.js
@@ -360,13 +360,13 @@ const post = (url, body, headers = {}) =&gt; {
   return new Promise((resolve, reject) =&gt; {
     const req = https.request(url, opts, (res) =&gt; {
       const chunks = [];
+      res.on(&amp;quot;error&amp;quot;, reject);
       res.on(&amp;quot;data&amp;quot;, (chunk) =&gt; {
         chunks.push(chunk);
       });
       res.on(&amp;quot;end&amp;quot;, () =&gt; {
         resolve(Buffer.concat(chunks));
       });
     });
     req.on(&amp;quot;error&amp;quot;, reject);
     req.write(body);
&quot; data-info=&quot;language-patch&quot; data-lang=&quot;patch&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-patch&quot;&gt;diff --git a/azbot-telegram/bot-utils.js b/azbot-telegram/bot-utils.js
index 42e002e..f90a8eb 100644
--- a/azbot-telegram/bot-utils.js
+++ b/azbot-telegram/bot-utils.js
@@ -360,13 +360,13 @@ const post = (url, body, headers = {}) =&amp;gt; {
   return new Promise((resolve, reject) =&amp;gt; {
     const req = https.request(url, opts, (res) =&amp;gt; {
       const chunks = [];
+      res.on(&quot;error&quot;, reject);
       res.on(&quot;data&quot;, (chunk) =&amp;gt; {
         chunks.push(chunk);
       });
       res.on(&quot;end&quot;, () =&amp;gt; {
         resolve(Buffer.concat(chunks));
       });
     });
     req.on(&quot;error&quot;, reject);
     req.write(body);
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后问题就神奇的解！决！了！我的 bot 连续跑了十天半个月也没有挂，我心里这个气啊，为什么官方文档里的示例一点没提到要对 response 的 error 事件进行处理呢？甚至在网上也很难找到相关的信息，我推测是大部分人并不从头自己封装 HTTP 模块而是直接使用现成的库比如 axios，然后可能有人发现过这问题就简单地给 axios 提了这么一个 fix，就再也没人提起过这件事了。总之还是希望官方文档能更新一下示例代码吧。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/JavaScript/" />
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/tags/JavaScript/" />
  </entry>
  <entry>
    <title>2023 年的 Arch Linux 安装指南</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/2023-Arch-Install/" />
    <id>https://sh.alynx.one/posts/2023-Arch-Install/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-07-28T12:42:53.000Z</published>
    <updated>2023-07-28T12:42:53.000Z</updated>
    <summary type="html">
      在安装 Arch Linux 之前，首先要准备 Arch Linux 的安装媒介。如果你打算安装在虚拟机里，那你并不需要一个实体的存储介质，因为虚拟机可以直接加载 iso 文件。但不管你在哪里安装，你都需要获取这个 iso 文件，引导进入其中的临时系统才能继续安装。 Arch L…
    </summary>
    <content type="html">
      &lt;p&gt;在安装 Arch Linux 之前，首先要准备 Arch Linux 的安装媒介。如果你打算安装在虚拟机里，那你并不需要一个实体的存储介质，因为虚拟机可以直接加载 iso 文件。但不管你在哪里安装，你都需要获取这个 iso 文件，引导进入其中的临时系统才能继续安装。&lt;/p&gt;
&lt;p&gt;Arch Linux 的安装镜像每月更新一次，如果你点开官网的下载页面，你会发现没有直接的下载链接，而是推荐你使用种子下载或者镜像站下载。这是一个非常有必要的要求，因为官方的服务器不能承受世界各地所有的请求流量，以上两种方法通过将单一的下载来源转换为多个下载来源有效的减轻了官方服务器的压力。&lt;/p&gt;
&lt;p&gt;考虑到当今种子下载并不是一个流行的下载方式，对于部分读者而言可能难以掌握，我们这里就选择镜像站下载。所谓的镜像站就是将官方服务器上的文件原样下载到自己的服务器上，然后给别人提供下载服务的服务器。有了镜像站，世界各地的用户就不必连接相对较远较慢的官方服务器，而可以就近选择镜像站，获取到完全一样的文件。&lt;/p&gt;
&lt;p&gt;我们可以打开某个镜像站同步 &lt;code&gt;archlinux&lt;/code&gt; 的目录，然后找到 &lt;code&gt;iso/latest&lt;/code&gt; 目录，里面的 &lt;code&gt;archlinux-x86_64.iso&lt;/code&gt; 就是我们需要的，以清华大学的镜像站为例，链接就是 &lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-x86_64.iso&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-x86_64.iso&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;注意！Arch Linux 官方只对 x86-64 架构提供支持，如果你的设备不是该架构（可能性很低，如果你不是该架构，你应该已经有足够的经验自己解决问题了），可能需要使用其它分支项目并参阅相关的文档。&lt;/p&gt;
&lt;p&gt;当下载好 iso 文件之后，需要准备对应的安装媒介，这需要一个实体的存储介质，光盘是最传统的安装媒介，这也导致了各种系统的安装程序都以光盘镜像（iso）的格式打包。但想必当今的用户寻找光盘和光驱可能有些难度，所以 U 盘成为了更流行的安装媒介，找出一个你没有使用的 U 盘，备份好原本的数据，然后连接到你下载了安装镜像的电脑上。&lt;/p&gt;
&lt;p&gt;如果你的电脑上已经运行了 Linux，那你可以通过 &lt;code&gt;dd&lt;/code&gt; 命令将 iso 文件写入到 U 盘里，Arch Linux 的安装镜像经过特殊处理，可以支持这样的 U 盘引导。首先通过 &lt;code&gt;lsblk -f&lt;/code&gt; 查看你的 U 盘对应的设备文件是什么，然后使用 &lt;code&gt;dd if=/PATH/TO/archlinux-x86_64.iso of=/dev/sdX&lt;/code&gt;，记得把 iso 和设备文件的路径改成你的实际路径，并且不要使用 U 盘分区的设备文件，而是使用代表整个 U 盘的设备文件。然后执行 &lt;code&gt;sync&lt;/code&gt;，让内核把内存里缓冲的数据写回磁盘，保证安装镜像完全写进 U 盘里面。&lt;/p&gt;
&lt;p&gt;但你也可能会说如果我有 Linux，我为什么要装 Linux？这种情况下我们推荐 Windows 用户使用 Rufus 创建安装 U 盘，这个软件下载即可运行，不需要安装，然后在软件里分别选择 iso 文件的位置和 U 盘设备，点击写入即可获得一个安装 U 盘。&lt;/p&gt;
&lt;p&gt;无论你使用哪种方式，接下来弹出 U 盘，准备重启电脑。不过要保证重启的时候 U 盘仍然在你的电脑上。现在的电脑应该都支持 UEFI 引导，你需要搜索你的主板型号得知你的电脑应该按什么按键进入启动设备选单，反正无非是 F8、DEL、Enter 中的一个，在显示主板 logo 的时候狂按，直到出现一个让你选择的菜单，使用键盘上的方向键选择你刚刚做好的安装 U 盘，然后按下 Enter 选择。等屏幕上走完启动流程，你应该就会自动登录进一个 Arch Linux 的环境。如果你开启了安全启动，那你需要关掉，因为 Arch Linux 的安装镜像并没有进行安全启动需要的签名，这里就不介绍具体如何关闭了，因为各家主板的界面都不一样，建议搜索引擎搜索自己的主板型号+关闭安全启动。&lt;/p&gt;
&lt;p&gt;Arch Linux 的安装环境是没有桌面的，你需要在命令行里自己调用各种命令完成一系列安装相关的操作，这样看起来比较难，但是也很灵活，可以根据自己的需要调整。首先你要做的是确定自己已经联网了，最简单的就是从路由器插一根网线到你的电脑上，这样应该就能上网了。如果你没有网线——那现在就该去买一根，比起现在给你讲清楚怎么在命令行下面连接无线网络，买网线更简单，真的。&lt;/p&gt;
&lt;p&gt;然后你应该使用 &lt;code&gt;date&lt;/code&gt; 命令查看系统时间是否重要，许多加密方式依赖时间正确，比如 https，因此如果它不正确，你应该改正它，不过大部分情况都是正确的。&lt;/p&gt;
&lt;p&gt;接下来你应该准备安装系统的磁盘分区，首先你得通过 &lt;code&gt;lsblk -f&lt;/code&gt; 找到要安装的硬盘，如果是 SATA 硬盘，它可能是 &lt;code&gt;/dev/sda&lt;/code&gt; 或者 &lt;code&gt;/dev/sdb&lt;/code&gt; 之类，如果是 NVMe 硬盘，那可能是 &lt;code&gt;/dev/nvme0n1&lt;/code&gt;，一般来说根据容量判断是不会错的。你的目标磁盘上应当留有一定的未分配空间给新系统使用。注意如果分区和格式化时操作错误，可能会让你丢失已有的重要数据，因此在进行操作前务必仔细确认。&lt;/p&gt;
&lt;p&gt;UEFI 引导的机器大部分都使用 GPT 分区表，当然这其实主要是 Windows 的限制，因此我们使用 &lt;code&gt;gdisk&lt;/code&gt; 进行分区，如果你使用的不是 GPT 分区表，那你可能需要自行了解一些相关知识。当你不知道该做什么的时候，输入 &lt;code&gt;?&lt;/code&gt; 可以显示帮助，输入 &lt;code&gt;p&lt;/code&gt; 可以打印当前的分区表，输入 &lt;code&gt;q&lt;/code&gt; 可以退出 &lt;code&gt;gdisk&lt;/code&gt;，只有输入 &lt;code&gt;w&lt;/code&gt; 才会真正修改硬盘上的分区表，所以如果你不确定就不要输入 &lt;code&gt;w&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;p&lt;/code&gt; 打出当前的分区表之后，你应该首先找到一个小的 FAT32 分区，一般会在磁盘的开头，容量不会超过 1G，这是你的 ESP 系统分区，UEFI 要求把引导文件放在这里。然后你应该按 &lt;code&gt;n&lt;/code&gt; 新建一个分区，一般它会自动计算未分配空间的开头，不过你也可以手动输入来纠正，然后输入新分区的结尾位置，也可以用 &lt;code&gt;+100G&lt;/code&gt; 的方式表示从开头位置创建一个 100G 的分区。一般只要分一个分区做 Linux 的根分区就好了，不过你有需要也可以创建更多的分区，比如你可能需要一个 swap 分区，那就用相同的办法创建一个。创建完你需要的分区之后，输入 &lt;code&gt;p&lt;/code&gt; 确认一下新的分区表，然后按 &lt;code&gt;w&lt;/code&gt; 写入分区表。&lt;/p&gt;
&lt;p&gt;接下来你需要在分好的分区上创建文件系统也就是格式化，因为分区表只是标记“从哪里到哪里属于哪个分区”，并没有在对应的位置创建实际的结构。比如你可以用 &lt;code&gt;mkfs.ext4 /dev/sdXY&lt;/code&gt; 格式化你刚创建的根分区，然后用 &lt;code&gt;mkswap /dev/sdXY&lt;/code&gt; 格式化你刚才创建的 swap 分区。记得在执行命令之前确认你使用的设备文件正确。然后你需要挂载你创建的分区到 &lt;code&gt;/mnt&lt;/code&gt;，稍候会向里面写入系统文件。首先用 &lt;code&gt;mount /dev/sdXY /mnt&lt;/code&gt;，把根分区挂载上，然后你需要创建其它分区的挂载点，比如 EFI 系统分区，对于这个如何挂载有很多种说法，不过我一般直接把它当作 boot 分区挂载，这样内核也会被安装到这个分区，有些预装 Windows 系统的电脑可能会分一个极小的 EFI 系统分区以至于放不下内核，那你可能需要查找更多资料，这不在这篇文章的讨论范围之内。总之先 &lt;code&gt;mkdir /mnt/boot&lt;/code&gt; 然后 &lt;code&gt;mount /dev/sdXY /mnt/boot&lt;/code&gt;。最后可以用 &lt;code&gt;swapon /dev/sdXY&lt;/code&gt; 启用你刚才创建的 swap 分区，这样记录新系统挂载点的时候就会记录这个 swap 分区。&lt;/p&gt;
&lt;p&gt;然后需要修改镜像站列表，和之前下载 iso 一样，系统需要的各种软件包也依靠镜像站提高分发效率。你需要用一个编辑器编辑 &lt;code&gt;/etc/pacman.d/mirrorlist&lt;/code&gt;，如果你没有熟悉的编辑器，那 &lt;code&gt;nano&lt;/code&gt; 应该是个适合新手的选择，因为各种操作需要的快捷键都会显示在屏幕底部，&lt;code&gt;^&lt;/code&gt; 代表 Ctrl，&lt;code&gt;M&lt;/code&gt; 代表 Alt，在列表里找到离你地理位置比较近的几个镜像站，然后删除对应的 &lt;code&gt;Server = &lt;/code&gt; 前面的 &lt;code&gt;#&lt;/code&gt; 来启用这个镜像站，一般启用两三个就足够了。&lt;/p&gt;
&lt;p&gt;然后就可以正式安装软件包到创建的分区了！使用 &lt;code&gt;pacstrap -K /mnt base base-devel linux linux-firmware&lt;/code&gt; 安装软件包到 &lt;code&gt;/mnt&lt;/code&gt;，你可以在后面附加更多你需要的软件包以便一并安装，甚至如果你不想第一次启动新系统还是命令行的话，也可以在这一步直接附加桌面环境进去。这里我贴一个基于我常用软件总结的列表作为参考：&lt;/p&gt;
&lt;figure data-raw=&quot;base base-devel linux linux-firmware man-db man-pages btrfs-progs vim nano git rsync gnome gdm networkmanager firefox meson ninja efibootmgr haveged ibus-rime ffmpeg noto-fonts noto-fonts-cjk noto-fonts-emoji ntfs-3g btop p7zip parallel tree ttf-roboto unrar unarchiver wget usbutils bind
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;base base-devel linux linux-firmware man-db man-pages btrfs-progs vim nano git rsync gnome gdm networkmanager firefox meson ninja efibootmgr haveged ibus-rime ffmpeg noto-fonts noto-fonts-cjk noto-fonts-emoji ntfs-3g btop p7zip parallel tree ttf-roboto unrar unarchiver wget usbutils bind
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你和我有不同的偏好，你应该已经清楚如何安装你需要的软件，我在这里只以我自己使用的软件作为例子。为了方便使用，我在这一步直接安装了桌面环境，但桌面环境需要有可用的显卡驱动，对于 Intel 和 AMD，它们的开源驱动已经足够好用，应该会自动引入 &lt;code&gt;mesa&lt;/code&gt; 所以没什么需要额外操作的，但是对于 NVIDIA，你还需要安装 &lt;code&gt;nvidia&lt;/code&gt; 这个包来引入 NVIDIA 的闭源驱动。&lt;/p&gt;
&lt;p&gt;然后等待下载安装即可，现在大家的带宽都很高，如果确实选了离自己近的镜像站，这个步骤应该花不了多少时间。&lt;/p&gt;
&lt;p&gt;然后读取你对新系统的挂载信息并写入到新系统里，以便新系统基于这个数据挂载硬盘，使用 &lt;code&gt;genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;现在你的新分区里应该有一个新系统需要的各种文件了，但是你还需要对它进行各种设置，首先需要 chroot 到新的系统，这是一个 Linux 内核的功能，可以让你以另一个文件系统作为根目录从而操作其中的各种文件，这里使用 &lt;code&gt;arch-chroot /mnt&lt;/code&gt; 进入新系统的根目录。&lt;/p&gt;
&lt;p&gt;然后你要指定自己新系统的时区，比如你使用的时区是 &lt;code&gt;Asia/Shanghai&lt;/code&gt;，那可以执行 &lt;code&gt;ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/code&gt;，你也可以将 &lt;code&gt;Asia/Shanghai&lt;/code&gt; 修改为其它的时区，所有可用的时区都以目录和文件的形式列在 &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; 下面。&lt;/p&gt;
&lt;p&gt;然后你需要执行 &lt;code&gt;hwclock --systohc&lt;/code&gt;，这会假设你的 BIOS 时间是 UTC，这和 Windows 默认的假设不一致，Windows 认为你的 BIOS 时间就是本地时间。可以让 Linux 认为 BIOS 时间是本地时间，但是可能会导致各种问题，同样也有办法让 Windows 认为 BIOS 时间是 UTC 时间，只需要随便新建一个文本文档，写入如下内容：&lt;/p&gt;
&lt;figure data-raw=&quot;Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]
&amp;quot;RealTimeIsUniversal&amp;quot;=dword:00000001
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]
&quot;RealTimeIsUniversal&quot;=dword:00000001
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后保存并修改扩展名为 &lt;code&gt;.reg&lt;/code&gt;，然后双击导入注册表项并重启。&lt;/p&gt;
&lt;p&gt;接下来修改本地化相关内容，首先是 glibc 需要对不同的语言生成不同的配置，需要用编辑器编辑 &lt;code&gt;/etc/locale.gen&lt;/code&gt; 文件，必须要启用的是 &lt;code&gt;en_US.UTF-8 UTF-8&lt;/code&gt;，别的可以按需求启用你需要的，只要删掉开头的 &lt;code&gt;#&lt;/code&gt;，注意只要启用带 &lt;code&gt;UTF-8&lt;/code&gt; 的就可以。不过这一步也可以略过其他的只启用英语，然后在桌面环境里修改语言的话桌面环境应该会自动处理相关的文件。然后运行 &lt;code&gt;locale-gen&lt;/code&gt;，它会根据上述文件的内容具体生成对应文件。&lt;/p&gt;
&lt;p&gt;然后创建 &lt;code&gt;/etc/locale.conf&lt;/code&gt; 文件，写入你当前使用的 &lt;code&gt;LANG&lt;/code&gt; 变量，不过其实 tty 不能显示中文，所以这一步推荐设置成英文，等到桌面起来了再改也来得及，因此推荐写入 &lt;code&gt;LANG=en_US.UTF-8&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;网络相关的配置首先需要设置 hostname，这一步只要打开 &lt;code&gt;/etc/hostname&lt;/code&gt; 文件写入你想要的主机名就行了。我的习惯是使用 NetworkManager 管理网络连接，因此需要设置让系统下次启动时启用 NetworkManager，只要 &lt;code&gt;systemctl enable NetworkManager&lt;/code&gt; 就可以。NetworkManager 会自动管理你的网卡，比如有线网卡就会自动尝试 DHCP，同时也提供和桌面环境的集成，方便使用无线网卡。&lt;/p&gt;
&lt;p&gt;一些无线网卡需要的固件可能被单独划分在别的包里，此时你可以安装这些包，比如高通的网卡就是 &lt;code&gt;pacman -S linux-firmware-qcom&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后你需要进行启动相关的设置，首先你得生成 initramfs，这个东西解决的问题是“需要加载模块才能读取对应的文件系统，但模块就存在那个文件系统上”这种问题，为了打破鸡生蛋还是蛋生鸡的循环，解决方法就是创建一个非常小的包含必要模块的文件，和内核放在一起，保证启动时可以加载这个文件。生成这个文件很简单，因为我们没有什么特殊的配置，只要执行 &lt;code&gt;mkinitcpio -P&lt;/code&gt; 就行了。&lt;/p&gt;
&lt;p&gt;同时现代的 CPU 都支持加载微码来热修复 CPU 的 bug，这也是通过在启动时加载相关的文件实现，首先需要安装对应的微码包，如果是 Intel 就 &lt;code&gt;pacman -S intel-ucode&lt;/code&gt;，AMD 就 &lt;code&gt;pacman -S amd-ucode&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后你还需要一个 bootloader 加载你的内核和 initramfs，最流行功能最全的是 GRUB，但我觉得 systemd-boot 也完全够用了，所以我选择 systemd-boot。因为已经安装了 systemd 所以就不需要额外安装什么了，只要 &lt;code&gt;bootctl install&lt;/code&gt;，就可以安装引导需要的文件。&lt;/p&gt;
&lt;p&gt;但我们仍然需要告诉 loader 去哪里加载内核，加载哪个内核。systemd-boot 需要我们手动编写配置文件记录这些内容。首先需要 &lt;code&gt;mkdir /boot/loader/entries&lt;/code&gt; 建立用于放置不同内核启动项的文件，然后再编辑 &lt;code&gt;/boot/loader/entries/arch.conf&lt;/code&gt; 给默认的内核编写一个文件。&lt;/p&gt;
&lt;p&gt;一个配置文件推荐包含以下内容：&lt;/p&gt;
&lt;figure data-raw=&quot;title   Arch Linux
linux   /vmlinuz-linux
initrd	/amd-ucode.img
initrd  /initramfs-linux.img
options root=&amp;quot;UUID=xxxx-xxxx-xxxx&amp;quot; rw add_efi_memmap
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;title   Arch Linux
linux   /vmlinuz-linux
initrd	/amd-ucode.img
initrd  /initramfs-linux.img
options root=&quot;UUID=xxxx-xxxx-xxxx&quot; rw add_efi_memmap
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;基本上你需要改的有两处，一个是如果是 Intel 就把 &lt;code&gt;amd-ucode&lt;/code&gt; 改成 &lt;code&gt;intel-ucode&lt;/code&gt;，另一个是要把内核参数里 &lt;code&gt;root=&lt;/code&gt; 的值设置为你的根分区，以便内核找到你真正的根分区。这个可以通过打开 &lt;code&gt;/etc/fstab&lt;/code&gt; 找到里面挂载到 &lt;code&gt;/&lt;/code&gt; 的设备得到需要的值。&lt;/p&gt;
&lt;p&gt;然后你需要编辑 &lt;code&gt;/boot/loader/loader.conf&lt;/code&gt;，这是给 loader 的配置，其实只需要一行 &lt;code&gt;default arch.conf&lt;/code&gt;，告诉 loader 默认加载 arch 内核的配置就可以了。&lt;/p&gt;
&lt;p&gt;最后需要进行密码配置，首先执行 &lt;code&gt;passwd&lt;/code&gt; 设置 root 密码。由于 root 权限太高，平时不建议使用 root 操作，所以我们可以通过 &lt;code&gt;useradd -m newuser&lt;/code&gt; 创建一个普通用户，&lt;code&gt;-m&lt;/code&gt; 的意思是会自动给用户创建同名的 home 目录存储用户相关的文件，你也可以把 &lt;code&gt;newuser&lt;/code&gt; 改成任何你想要的用户名。然后执行 &lt;code&gt;passwd newuser&lt;/code&gt; 给这个新用户设置密码。同时为了方便进行高权限操作，我们需要允许新用户执行 &lt;code&gt;sudo&lt;/code&gt;，首先执行 &lt;code&gt;EDITOR=nano visudo&lt;/code&gt; 编辑 sudoers 文件，找到 &lt;code&gt;root ALL=(ALL) ALL&lt;/code&gt; 一行，然后在下面插入 &lt;code&gt;newuser ALL=(ALL) ALL&lt;/code&gt;（记得用你想要的用户名），保存即可。&lt;/p&gt;
&lt;p&gt;然后运行 &lt;code&gt;systemctl enable gdm&lt;/code&gt;，这会告诉系统启动时启用 GNOME 显示管理器，下次启动时你就会得到图形界面并可以直接登录进桌面。此时关于新系统的设置都已基本完成，执行 &lt;code&gt;exit&lt;/code&gt; 退出 chroot，然后执行 &lt;code&gt;reboot&lt;/code&gt; 重启电脑，你应该可以在 UEFI 启动选单里找到 Linux Boot Manager，选择就会启动新安装的 Arch Linux。&lt;/p&gt;
&lt;p&gt;由于此时应该已经启动图形界面了，对于桌面的各种设置只要在图形界面的设置程序里设置即可，就不需要专门讲述怎么用了。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/Arch%20Linux/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/tags/Arch%20Linux/" />
  </entry>
  <entry>
    <title>DaVinci Resolve 奇怪的素材位置计算逻辑</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/" />
    <id>https://sh.alynx.one/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-07-28T07:20:02.000Z</published>
    <updated>2023-07-28T07:20:02.000Z</updated>
    <summary type="html">
      &lt;p&gt;上一篇文章提到了 DaVinci Resolve 对于素材位置的计算逻辑非常奇怪并且不肯修改，这篇我试图概括一下具体的计算逻辑方便自己使用。如果你也遇到了同样的问题并且希望他们改进，可以去支持 &lt;a href=&quot;https://forum.blackmagicdesign.com/viewtopic.php?f=33&amp;amp;t=179153&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;我发的帖子（英语）&lt;/a&gt;。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;上一篇文章提到了 DaVinci Resolve 对于素材位置的计算逻辑非常奇怪并且不肯修改，这篇我试图概括一下具体的计算逻辑方便自己使用。如果你也遇到了同样的问题并且希望他们改进，可以去支持 &lt;a href=&quot;https://forum.blackmagicdesign.com/viewtopic.php?f=33&amp;amp;t=179153&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;我发的帖子（英语）&lt;/a&gt;。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%87%86&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/#%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%87%86&quot;&gt;&lt;/a&gt;计算基准&lt;/h1&gt;
&lt;p&gt;缩放/裁切/位置永远以原图大小作为基准，不会互相影响。&lt;/p&gt;
&lt;p&gt;项目设置里有“缩放原图至适配大小且不出现裁切”和“不调整原图大小并裁切超出部分”两个比较合理的选项，“缩放原图至适配大小且不出现裁切”可以理解为插入时间线之前就改变了原图大小。例如画布尺寸 1920x1080，素材尺寸 512x512，选择“缩放原图至适配大小且不出现裁切”，相当于用外部命令把素材缩放到 1080x1080 然后再插入时间线，后续缩放/裁切/位置均以 1080x1080 作为基准。&lt;/p&gt;
&lt;h1 id=&quot;%E7%BC%A9%E6%94%BE&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/#%E7%BC%A9%E6%94%BE&quot;&gt;&lt;/a&gt;缩放&lt;/h1&gt;
&lt;p&gt;缩放变换只计算原图大小。&lt;/p&gt;
&lt;p&gt;缩放变换默认以素材中心作为基准。由于位置变换计算太复杂了，不考虑改变锚点参数的情况。&lt;/p&gt;
&lt;h1 id=&quot;%E8%A3%81%E5%88%87&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/#%E8%A3%81%E5%88%87&quot;&gt;&lt;/a&gt;裁切&lt;/h1&gt;
&lt;p&gt;裁切只计算原图大小。无论素材的缩放变换参数是多少，都使用原图大小计算结果。&lt;/p&gt;
&lt;p&gt;例：画布 1920x1080，素材 512x512。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择“缩放原图至适配大小且不出现裁切”，此时原图大小是 1080x1080，左侧裁切 50% 应输入 &lt;code&gt;1080 * 50% = 512&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择“不调整原图大小并裁切超出部分”，此时原图大小是 512x512，左侧裁切 50% 应输入 &lt;code&gt;512 * 50% = 256&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于位置变换计算太复杂了，不考虑勾选“保留图片位置”的情况。&lt;/p&gt;
&lt;h1 id=&quot;%E4%BD%8D%E7%BD%AE&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/#%E4%BD%8D%E7%BD%AE&quot;&gt;&lt;/a&gt;位置&lt;/h1&gt;
&lt;p&gt;位置变换只计算原图大小。无论素材的缩放变换参数和裁切参数是多少，都使用原图大小计算结果。&lt;/p&gt;
&lt;p&gt;DaVinci Resolve 对于素材位置输入框使用特殊的计算逻辑（怀疑是 bug），假设画布宽度为 &lt;code&gt;canvas_width&lt;/code&gt;，画布高度为 &lt;code&gt;canvas_height&lt;/code&gt;，原图宽度为 &lt;code&gt;clip_width&lt;/code&gt;, 原图高度为 &lt;code&gt;clip_height&lt;/code&gt;，如果想将素材水平方向移动 &lt;code&gt;x&lt;/code&gt; 像素，垂直方向移动 &lt;code&gt;y&lt;/code&gt; 像素，则需要填入的数据需要按照 &lt;code&gt;f(x) = x / clip_width * canvas_width&lt;/code&gt; 和 &lt;code&gt;f(y) = y / clip_height * canvas_height&lt;/code&gt; 进行计算。注意，按此计算逻辑，填入的两个数据的比例显然和实际移动的像素比例不同。&lt;/p&gt;
&lt;p&gt;例：画布 1920x1080，素材 512x512。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择“缩放原图至适配大小且不出现裁切”，此时原图大小是 1080x1080，向左移动 540 像素应输入 &lt;code&gt;540 / 1080 * 1920 = 960&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择“不调整原图大小并裁切超出部分”，此时原图大小是 512x512，向左移动 540 像素应输入 &lt;code&gt;540 / 512 * 1920 = 2025&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

    </content>
    <category term="摄影" label="摄影" scheme="https://sh.alynx.one/categories/%E6%91%84%E5%BD%B1/" />
    <category term="摄影" label="摄影" scheme="https://sh.alynx.one/tags/%E6%91%84%E5%BD%B1/" />
  </entry>
  <entry>
    <title>首先是犯下傲慢之罪的闭源拖拉机</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Firstly-The-Arrogant-Closed-Source-Tractor/" />
    <id>https://sh.alynx.one/posts/Firstly-The-Arrogant-Closed-Source-Tractor/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-07-28T03:20:51.000Z</published>
    <updated>2022-07-28T11:26:00.000Z</updated>
    <summary type="html">
      &lt;p&gt;很遗憾的，我们没有生活在可以完全只使用开源软件的世界里，所以有时候不得不忍受一些闭源拖拉机的傲慢。一个经典的情况就是明明用户花了钱，还是得当孙子——我指的是用户反馈完全没有开发者看这件事情。或者更进一步，我认为 GitHub 或者 GitLab 的 issue （或者 bugzilla）是比用户论坛更好的反馈工具。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;很遗憾的，我们没有生活在可以完全只使用开源软件的世界里，所以有时候不得不忍受一些闭源拖拉机的傲慢。一个经典的情况就是明明用户花了钱，还是得当孙子——我指的是用户反馈完全没有开发者看这件事情。或者更进一步，我认为 GitHub 或者 GitLab 的 issue （或者 bugzilla）是比用户论坛更好的反馈工具。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;一个发生在我身上的例子是 PowerAMP，我曾经是它的付费用户（现在也是付费用户，但并不是活跃用户）。PowerAMP 有这样一个问题，当你搜索一首歌的时候，你必须输入两个或以上的字符搜索才会启动。这对于英语歌来说不是什么问题，因为大部分单词都是两个字符以上，几乎不会出现需要依靠一个字符查找歌曲的情况。但假如你是一个不会假名的日语歌爱好者，你想要依赖标题里某个你认识的汉字搜索到你想要的歌，这时候 PowerAMP 的搜索就是完完全全的废物。至少对于我自己来说这个需求曾经切实存在了很长一段时间。我不是没有尝试给开发者反馈，PowerAMP 有一个自己的论坛用作用户反馈工具，但过了两年也没有人回复 &lt;a href=&quot;https://forum.powerampapp.com/topic/20907-start-searching-after-just-typing-1-character-instead-of-2/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;我的帖子&lt;/a&gt;。如果开发者完全不看用户反馈，或者只看热度高的用户反馈，那这论坛还有什么意义呢？&lt;/p&gt;
&lt;p&gt;所以非常搞笑的结论发生了，我作为一个付费用户，最终的解决方案是我去学了五十音，不过这也没有完全解决问题，我意识到即使这样，仍然存在无法解决的情况：比如标题只有一个汉字的歌，你永远也不可能在 PowerAMP 里通过标题搜索到它（那英点了个赞并评论“最烦装逼的播放器作者”）。我甚至已经脑补出了作者洋洋自得地写下 &lt;code&gt;if (str.length &amp;lt; 2) return;&lt;/code&gt; 以为自己对搜索做了天才般的优化，但在他可怜的脑袋里却找不到高德纳那句著名的“过早优化是万恶之源”，甚至用户的反馈也被他忽略掉了。最终我选择放弃这个自以为是的闭源拖拉机，换了一些功能没这么多，但却没有这个过早优化的替代品。&lt;/p&gt;
&lt;p&gt;更新（2022-07-28T19:26:00）：Arch Linux CN 社区里的 @weearc⚝ 跟我说他的 PowerAMP 输入单个字符是可以搜索的，这让我很疑惑，我又重新下载安装了一个 PowerAMP，但我的却仍然不行。我们俩研究一番后才发现问题所在：如果安装过后直接点导航栏的搜索，必须要输入两个或以上字符才能开始搜索。但如果在媒体库页面点击所有歌曲，然后点击列表标题下的搜索按钮，此时输入一个字符就会开始搜索。具体的原因可能是因为这时搜索添加了一个“所有歌曲”的过滤器，只搜索本地歌曲。大概是作者自以为是的决定限制包含在线源的搜索的启动条件来减少在线搜索的启动次数，不管怎么说这也属于一个过早优化，而且对我这种完全不使用在线功能的用户而言除了徒增迷惑之外没有任何的好处。虽然添加了“所有歌曲”的过滤器之后再从导航栏启动搜索仍然会带这个过滤器，可以作为一个 workaround 解决我的问题，我还是认为这对中文歌曲不是很友好。这次我发现 app 内的“联系我们”功能会给作者发邮件，于是我写了封邮件反馈这个不一致，希望他记得查看自己的邮箱。&lt;/p&gt;
&lt;p&gt;另一个我亲身经历的问题是 DaVinci Resolve，但是好话说在前头，比起大部分不友好的闭源软件开发商，BlackMagic
 Design 已经是班级里的三好学生了，我们就不提比如官方支持 Linux 这样大家都知道的优点，而是说一下同样的论坛反馈问题。Linux 版本的 DaVinci Resolve 不支持 Linux 上两种常见的输入法，而作为购买了 Studio 版的付费用户，我自然是积极的在官方论坛反馈了这个问题，结果嘛比 PowerAMP 好那么一点，一个 BlackMagic Design 的员工看到了我的帖子并把它移动到了 Feature Request 分区，然后就没有然后了。&lt;/p&gt;
&lt;p&gt;在某些人试图为拿走他们钱的闭源软件开发商找“也许是 Linux 输入法太多支持起来太麻烦他们真的没有足够人力做”的借口之前，我要先发制人说明一下，这其实也是个“一行代码”就能解决的问题，甚至并不需要 BlackMagic Design 写实际的代码。DaVinci Resolve 使用 Qt 作为界面库，Qt 本身就做好了 Linux 下面常见输入法的支持，只要在构建时候打开开关就可以，所以问题的关键在于他们的团队里没有人意识到 Linux 下面的 CJK 用户需要打开这个开关，也没有人愿意去做打开构建开关这个简单的工作，只是让反馈的帖子烂在论坛里。甚至更进一步，为什么我这么确定只需要做这么简单的工作呢？因为我自己发现了一个 workaround，只要把系统里 Qt 输入法插件的 &lt;code&gt;.so&lt;/code&gt; 文件复制到 DaVinci Resolve 自带的 Qt 的对应目录，一切就完全工作了，所以可以充分说明并不是存在什么难以克服的障碍。（如果你也需要解决这个问题，具体的操作请阅读 &lt;a href=&quot;/posts/Input-Method-Support-for-DaVinci-Resolve-on-Linux/&quot;&gt;DaVinci Resolve 在 Linux 下的输入法支持&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;说到 DaVinci Resolve，他们还有一个令人迷惑的坐标计算问题。比如你在尺寸为 3840x2160 的画布里放进一个 200x200 的图片素材，然后想让这个图片向右移动这个图片的宽度，你应该输入多少呢，答案并不是 200，而是 3840。具体的计算逻辑大概是 &lt;code&gt;f(x) = x / clip_width * canvas_width&lt;/code&gt;（计算纵坐标则需要换成高度，这样你横纵坐标看起来和实际位移完全不成比例），而这只是最简单的情况，如果你再对素材进行缩放，然后再进行裁切，那计算逻辑我也说不清楚是怎么回事了。如果你访问它的用户论坛，你会发现需要精确输入坐标的用户都对这个计算逻辑感到迷惑（相关的内容聚集在 &lt;a href=&quot;https://forum.blackmagicdesign.com/viewtopic.php?f=21&amp;amp;t=166202&amp;amp;sid=be6eee42737d87cb59463a6f3f3069c0&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这个帖子（英语）&lt;/a&gt;），并且这还导致了其它问题（用这个算法你可能需要输入极大的数值来挪动一个很小的素材，于是就会撞到输入框的数字上限）。但 BlackMagic Design 完全没有修改这个逻辑的想法。我可以理解为是怕影响兼容性，但完全可以添加一个设置项，如果勾选就保持以前的计算逻辑。这又是一个用户反馈了却被忽略的例子。&lt;/p&gt;
&lt;p&gt;但如果你读到这里觉得闭源软件的用户论坛就是最烂的反馈工具，那你还是太高估了闭源软件开发商的下限了。另一个我亲身经历的例子来自亲爱的 Micro$oft，作为 RDP 的标准制定者，微软的 Android RDP 客户端基本可以认为是实质上的官方实现，但 gnome-remote-desktop 的开发者遇到了 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-remote-desktop/-/issues/99&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;客户端内不能正确显示视频（英语）&lt;/a&gt; 的问题，导致这个问题的原因是 Microsoft 的 Android RDP 客户端写死了 image stride，导致读取错误，老实说这不是什么大不了的问题，改掉就好了嘛。于是我就积极主动的去该 app 的 Play Store 页面打算写评论，但是我看到应用简介里说“我们不会看 Play Store 评论，如果你要反馈问题，请发送至 &lt;code&gt;rdandr@microsoft.com&lt;/code&gt;”，于是我又写了封邮件描述相关的问题，然后被气了个半死：一封自动回复的邮件告诉我你应该到这个链接反馈问题，点开那个链接我得到一个大大的 &lt;code&gt;Error 404 This UserVoice instance is no longer available.&lt;/code&gt;。说不定这些傲慢的开发者还在沾沾自喜：我们的软件质量真好，竟然没有用户反馈问题！（不过我刚才又查看了一下 Play Store 页面，现在他们换成了一个反馈链接，我暂时还没有测试这个链接是否可用。）&lt;/p&gt;
&lt;p&gt;所以这其实是我推崇开源软件的原因之一：通常来说开源软件的开发者都很重视用户反馈，并且会建立良好的反馈渠道。即使你遇到了一个“知道错了，但我不改”的开发者，你也可以尝试自己动手修改代码解决问题，然后提交给他或者自己维护 patch。但对于闭源软件这显然不现实，你只能希望开发者大发慈悲常来看用户论坛并注意到你的反馈。&lt;/p&gt;
&lt;p&gt;另一方面，issue 大概是比用户论坛更好的反馈工具。虽然对于闭源软件开发商，很难找到相关的例子，不过 Valve 就是这么一个独特的例子。以前他们使用 GitHub Issue 作为 DOTA 2 和 CSGO 的 Linux / macOS 版本的反馈渠道，后来更进一步鼓励玩家在 GitHub Issue 上反馈 DOTA 2 的 bug。虽然 Valve 也存在“知道错了，但我不改”这种情况（比如 Steam Linux 版的输入法支持，但这个和他们使用了自己编写的 UI 框架有关系，大概解决起来有难度），但他们的开发者确实会看 GitHub Issue，并处理玩家的反馈（比如在官网 &lt;a href=&quot;https://www.dota2.com/newsentry/3640648066072340345&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;最新的一篇文章（英语）&lt;/a&gt; 里提到很多用户在 GitHub 上反馈了炸弹人的新 bug）。&lt;/p&gt;
&lt;div class=&quot;center&quot;&gt;
  &lt;img alt=&quot;1.png&quot; title=&quot;一位 DOTA 2 玩家正在学习使用 GitHub Issue……呃，这可能是个错误示范……&quot; src=&quot;/posts/Firstly-The-Arrogant-Closed-Source-Tractor/1.png&quot;&gt;
&lt;/div&gt;

&lt;p&gt;但，是什么导致 issue 在用户反馈上比用户论坛效果更好呢？毕竟本质上二者都是“发帖”“回复”的流程，我尝试分析一下其中的不同。&lt;/p&gt;
&lt;p&gt;一个我认为很重要的区别是社区文化，或者说是谁在使用相关的工具：2023 年，完全没有接触过开源项目的程序员应该是不存在的，也就是说如果你是开发者，你大概率早就使用过 GitHub 或者 GitLab 这样的工具，issue 对你来说是一个你会去重视或至少会去看的东西。而论坛更大概率不是开发者直接运营，也许是什么专门的论坛客服在处理，他们可能并不懂技术，或者就算开发者会参与进用户论坛，论坛帖子对程序员来说也不是什么一定要看的东西。当用户遇到问题的时候，向开发者直接反馈应当是解决问题最直接的途径，如果在用户和开发者之间插入一层不懂技术的客服，那大概率是场灾难。（我真的没有在针对什么“微软社区支持专员”哦，真的没有。）&lt;/p&gt;
&lt;p&gt;另一个可能的原因也许是排序方式：issue 默认是按发布时间而不是回复时间排列的，因此开发者大概率会逐个查看新出现的 issue 并处理。但论坛通常默认以回复时间排列，更加重视“热度”，于是很容易出现一个问题不太热门就完全被忽略掉的情况，但对于软件开发而言，不应该因为一个问题热度不高就完全置之不理，因为热度可能受很多其它因素影响，比如用户主要使用的语言和开发者不同，反馈时存在语言或者网络障碍，热度不能直观地反映出程序本身的问题。&lt;/p&gt;
&lt;p&gt;但也许上述区别只决定了开发者能不能看到用户反馈，另一个决定性因素是开发者想不想看到用户反馈。我个人是觉得对于软件质量的追求应该是程序员自发的而不是被迫的，所以对用户反馈更应当积极处理。不得不承认，相似体量的项目，开源项目的开发者比起闭源项目的开发者好像确实是更有责任感一点。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="吐槽" label="吐槽" scheme="https://sh.alynx.one/tags/%E5%90%90%E6%A7%BD/" />
  </entry>
  <entry>
    <title>PipeWire 和 HDMI 音频和虚拟设备和复合/分离通道</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/" />
    <id>https://sh.alynx.one/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-05-11T13:25:05.000Z</published>
    <updated>2023-06-07T08:47:45.000Z</updated>
    <summary type="html">
      &lt;p&gt;这篇文章同时有 &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;中文版本&lt;/a&gt; 和 &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;英文版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;This post is both available in &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;Chinese version&lt;/a&gt; and &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;English version&lt;/a&gt;.&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;这篇文章同时有 &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;中文版本&lt;/a&gt; 和 &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;英文版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;This post is both available in &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;Chinese version&lt;/a&gt; and &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;English version&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;&lt;/a&gt;中文版本&lt;/h1&gt;
&lt;p&gt;认识的朋友里很少有人有像我这么复杂的音频系统。长话短说，为了能让 PS4、Switch 和电脑分享一个扬声器，我把它接在了显示器上而不是电脑的内置声卡上，这样所有设备都通过 HDMI/DP 输出音频到扬声器。一开始这也没什么，后来我又添置了一块显示器，我发现在 Linux 下面经常搞不清楚究竟哪一个音频设备才是连接着扬声器的显示器，可能上周还是 HDMI 1，这周就变成 HDMI 2，而且也不是每次都会变，导致我经常需要试试才知道哪一个是我需要的。直到前天我忍不了了，决定发挥动手能力解决这个问题。&lt;/p&gt;
&lt;p&gt;一开始我以为是 PipeWire 给设备排序的时候是随机排序的，那简单，只要我找到每个设备对应的 ID，然后关掉没有扬声器的那个 HDMI 输出就可以了。但是我发现似乎 PipeWire 只是按照 ALSA 给出的设备编号来排序，并没有自己编号，于是就算关闭一个设备，下次被关闭的也可能是另一个。然后我就在想难道 ALSA 没有固定 HDMI 音频设备的功能吗？毕竟就算是显示器也是有 EDID 这种东西的，于是我查了各种 ALSA 的资料，确实是可以通过 udev 指定不同声卡的顺序，但对于 HDMI 这种属于同一个声卡的不同端口的设备没什么办法。我甚至查到了 NVIDIA 关于显卡音频的文档，里面说每个端口会有一个叫做 ELD 的数据，描述了连接的显示器信息，不过通过 &lt;code&gt;cat /proc/asound/cardX/eld*&lt;/code&gt; 查看之后我发现这个标准最多只给到显示器的型号，而我为了不在多显示器缩放上浪费精力，买了两台同样型号的显示器，没有序列号字段就还是没办法分辨不同的显示器！当然如果你的 HDMI 设备的型号不同，那其实就简单了，ALSA 现在会读取 ELD 里面的显示器型号，然后 PipeWire 会把这个作为 &lt;code&gt;node.nick&lt;/code&gt; 属性，你可以直接通过这个属性分辨设备，也可以利用这个属性写 WirePlumber 重命名规则修改你的桌面环境会用到的属性，就可以固定名称了。不过我还得继续寻求帮助。&lt;/p&gt;
&lt;p&gt;于是我就在公司的 research 邮件列表发了封邮件讲述了我的设备连接方式和需求，结果 Takashi Iwai（内核音频子系统的维护者之一）回复我说确实没有什么办法，音频驱动只是按照显卡给的顺序分配编号，所以大概率是随机的。特别是我还发现这玩意好像也不一定按照显示器输出的顺序来排号，于是 Plan A 是彻底行不通了。那我还有 Plan B 和 Plan C。&lt;/p&gt;
&lt;p&gt;和其它同事给的建议一样，其中一个想法是购买一个硬件的混合器，把两台显示器的音频输出硬件连接到同一个扬声器的输入，甚至一个同事还给我画了电路图说你只要这样就能自己做一个了。不过这个方案既有优点也优缺点，优点是电脑和游戏机可以同时发声，缺点是我要在电脑上修改音量就得始终记得把两个音量都改成一样的。我对前者需求不大，所以打算最后再尝试这个。&lt;/p&gt;
&lt;p&gt;当然有硬件的解法就有软件的解法，PipeWire 和 JACK 一样可以进行基于图的连接，那我只要搞一个虚拟的输出设备然后把两个 HDMI 设备跟它连一起不就行了？Arch Wiki 上恰好有一段 &lt;a href=&quot;https://wiki.archlinux.org/title/WirePlumber#Simultaneous_output_to_multiple_sinks_on_the_same_sound_card&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;同时向一块声卡上的不同端口输出音频&lt;/a&gt; 的文档，我本来以为照做即可，但发现还是不对，并没有出现我想象中的一个新音频设备。不过后来我仔细研究，搞懂了里面各种术语，才知道是怎么回事。&lt;/p&gt;
&lt;p&gt;首先我发现这一段文档其实只是描述如何创建一个“能同时显示两个 mapping 的 profile”，那到底什么是 mapping 什么是 profile？Mapping 可以理解成声卡上的某一种输入/输出组合，然后 profile 决定当前可以在哪几种组合中选择。举例来说就是假如你有一个 2 进 4 出的音频设备，那它可以是只有双声道输出，只有四声道输出，或者双声道输入四声道输出等等组合，这就是不同的 profile。为什么要同时输出不同端口需要创建一个 profile 呢，因为默认 ALSA 采用的是 auto-profile，会给每一个 mapping 创建一个 profile，而默认的一个 mapping 就是一个 HDMI 端口，因此假如你打开 pavucontrol 或者 Helvum，会发现如果不切换 profile，两个 HDMI 设备只能显示一个，也就没法给它们同时连接。当然你可能又会问为什么 GNOME Shell 里面又能显示两个 HDMI 设备？因为 &lt;code&gt;libgnome-volume-control&lt;/code&gt; 是先枚举设备然后枚举端口，并不是直接枚举端口（受 profile 影响），选择端口的时候再自动切换 profile。&lt;/p&gt;
&lt;p&gt;所以第一步是创建一个新的 profile sets，比如我创建的是 &lt;code&gt;/usr/share/alsa-card-profile/mixer/profile-sets/hdmi-multiple.conf&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;[General]
auto-profiles = no

[Mapping hdmi-stereo]
description = Digital Stereo (HDMI)
device-strings = hdmi:%f
paths-output = hdmi-output-0
channel-map = left,right
priority = 9
direction = output

[Mapping hdmi-stereo-extra1]
description = Digital Stereo (HDMI 2)
device-strings = hdmi:%f,1
paths-output = hdmi-output-1
channel-map = left,right
priority = 7
direction = output

# If you have more HDMI devices, add them here.

# Show multiple HDMI mappings so I could connect to them all.
[Profile hdmi-multiple]
description = Multiple Digital Stereo (HDMI)
output-mappings = hdmi-stereo hdmi-stereo-extra1
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;[General]
auto-profiles = no

[Mapping hdmi-stereo]
description = Digital Stereo (HDMI)
device-strings = hdmi:%f
paths-output = hdmi-output-0
channel-map = left,right
priority = 9
direction = output

[Mapping hdmi-stereo-extra1]
description = Digital Stereo (HDMI 2)
device-strings = hdmi:%f,1
paths-output = hdmi-output-1
channel-map = left,right
priority = 7
direction = output

# If you have more HDMI devices, add them here.

# Show multiple HDMI mappings so I could connect to them all.
[Profile hdmi-multiple]
description = Multiple Digital Stereo (HDMI)
output-mappings = hdmi-stereo hdmi-stereo-extra1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;上面的 mapping 是直接从 &lt;code&gt;default.conf&lt;/code&gt; 里面抄的，下面那个 profile 就是包含上面的两个 mapping，然后需要写 WirePlumber 规则来给显卡上的声卡套用这个 profile。我把它写到 &lt;code&gt;/etc/wireplumber/main.lua.d/51-hdmi-multiple.lua&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;rule = {
  matches = {
    {
      -- Sometimes PCI sound card name has `.1` or other suffix, so it&#039;s better
      -- to use description to match it.
      { &amp;quot;device.description&amp;quot;, &amp;quot;matches&amp;quot;, &amp;quot;TU104 HD Audio Controller&amp;quot; },
    },
  },
  apply_properties = {
    [&amp;quot;api.alsa.use-acp&amp;quot;] = true,
    -- By default, it creates profiles for each mappings, so one profile has one
    -- mapping, but I want to combine 2 mappings, so I have to manually create
    -- a profile to show 2 mappings.
    [&amp;quot;api.acp.auto-profile&amp;quot;] = false,
    [&amp;quot;api.acp.auto-port&amp;quot;] = false,
    [&amp;quot;device.profile-set&amp;quot;] = &amp;quot;hdmi-multiple.conf&amp;quot;,
    [&amp;quot;device.profile&amp;quot;] = &amp;quot;hdmi-multiple&amp;quot;,
  },
}

table.insert(alsa_monitor.rules, rule)
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;rule = {
  matches = {
    {
      -- Sometimes PCI sound card name has `.1` or other suffix, so it&#039;s better
      -- to use description to match it.
      { &quot;device.description&quot;, &quot;matches&quot;, &quot;TU104 HD Audio Controller&quot; },
    },
  },
  apply_properties = {
    [&quot;api.alsa.use-acp&quot;] = true,
    -- By default, it creates profiles for each mappings, so one profile has one
    -- mapping, but I want to combine 2 mappings, so I have to manually create
    -- a profile to show 2 mappings.
    [&quot;api.acp.auto-profile&quot;] = false,
    [&quot;api.acp.auto-port&quot;] = false,
    [&quot;device.profile-set&quot;] = &quot;hdmi-multiple.conf&quot;,
    [&quot;device.profile&quot;] = &quot;hdmi-multiple&quot;,
  },
}

table.insert(alsa_monitor.rules, rule)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后执行 &lt;code&gt;systemctl --user restart wireplumber&lt;/code&gt;，Helvum 里面应该就能同时看到两个显示器的 HDMI 音频设备了。&lt;/p&gt;
&lt;p&gt;接下来是 Arch Wiki 里面没有提到的部分，如何同时向两个设备输出音频？最简单的就是像 JACK 一样直接把输出的程序同时连接到两个音频设备上就行了，但这样既不能持久化，也不能在桌面环境里调节音量。阅读了 PipeWire 的文档之后发现这部分可以通过虚拟设备来解决，有一个叫做 combine-stream 的模块就可以创建这样的复合设备，于是参考 &lt;a href=&quot;https://docs.pipewire.org/page_module_combine_stream.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;combine-stream 的文档&lt;/a&gt;，我创建 &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-hdmi-combined-sink.conf&lt;/code&gt; 并写入如下内容：&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &amp;quot;combined-hdmi-stereo&amp;quot;
            node.description = &amp;quot;Combined HDMI / DisplayPort&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;TU104 HD Audio Controller&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-pci&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts glob. Match all HDMI devices on TU104.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            # Sometimes PCI sound card name has `.1` or other
                            # suffix, so it&#039;s better to use description to
                            # match it.
                            node.description = &amp;quot;~TU104 HD Audio Controller Digital Stereo *&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            combine.audio.position = [ FL FR ]
                            audio.position = [ FL FR ]
                        }
                    }
                }
            ]
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &quot;combined-hdmi-stereo&quot;
            node.description = &quot;Combined HDMI / DisplayPort&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;TU104 HD Audio Controller&quot;
                #device.icon-name = &quot;audio-card-analog-pci&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts glob. Match all HDMI devices on TU104.
                            media.class = &quot;Audio/Sink&quot;
                            # Sometimes PCI sound card name has `.1` or other
                            # suffix, so it&#039;s better to use description to
                            # match it.
                            node.description = &quot;~TU104 HD Audio Controller Digital Stereo *&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            combine.audio.position = [ FL FR ]
                            audio.position = [ FL FR ]
                        }
                    }
                }
            ]
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;逻辑很简单，就是创建一个复合设备，输入到该设备的音频会输出给给定显卡上的所有 HDMI 输出，然后 &lt;code&gt;systemctl --user restart pipewire wireplumber&lt;/code&gt; 就可以在 GNOME 里选择这个输出设备并调节音量了，不管扬声器插在哪个 HDMI/DP 显示器上，都能工作。&lt;/p&gt;
&lt;p&gt;解决了这个问题之后我发现利用 PipeWire 的虚拟设备还可以解决我 USB 声卡的通道问题。我现在用的是我上高三时候买的 Scarlett 2i4，有两个输入和四个输出，而 auto-profile 就会自动把它设置成一个四声道环绕声输出和一个立体声输入，但实际上这个四个输出是双声道的耳机和双声道的扬声器，两个输入通常会分别用来输入话筒和乐器，而不是作为双声道输入。于是长久以来我只能在各种软件里手动设置单声道音频解决这个问题。而这次读文档我发现 PipeWire 早就给出了例子，虽然是针对另一款声卡（&lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;UMC404HD 的扬声器/耳机分离&lt;/a&gt; 和 &lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;UMC404HD 的话筒/乐器分离&lt;/a&gt;），不过总而言之是大同小异，我也参照着弄了一下我的声卡。&lt;/p&gt;
&lt;p&gt;首先你想要手动分离声卡的各个通道，仍然需要换掉默认的 profile，不过这次不需要手动编写了，PipeWire 给所有音频设备都提供了一个叫做 &lt;code&gt;pro-audio&lt;/code&gt; 的 profile，这个会直接暴露声卡的所有通道而不做额外的假设（显然桌面环境对于这种裸配置的支持并不好），而后我们就可以为所欲为了，所以先创建 &lt;code&gt;/etc/wireplumber/main.lua.d/51-scarlett-2i4.lua&lt;/code&gt; 写入规则让它默认使用 &lt;code&gt;pro-audio&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;rule = {
  matches = {
    {
      { &amp;quot;device.name&amp;quot;, &amp;quot;matches&amp;quot;, &amp;quot;alsa_card.usb-Focusrite_Scarlett_2i4_USB-00&amp;quot; },
    },
  },
  apply_properties = {
    [&amp;quot;audio.rate&amp;quot;] = 48000,
    [&amp;quot;audio.allowed-rates&amp;quot;] = &amp;quot;44100,48000,88200,96000&amp;quot;,
    --[&amp;quot;api.alsa.period-size&amp;quot;] = 2048,
    --[&amp;quot;api.alsa.headroom&amp;quot;] = 1024,
    [&amp;quot;api.alsa.use-acp&amp;quot;] = true,
    -- By default, it creates profiles for stereo input and surround 4.0 output,
    -- but actually the card is 2 inputs, stereo headphones output and stereo
    -- speakers output, so we disable auto profile here, and use the Pro Audio
    -- profile to expose all ports, and combine them manually.
    [&amp;quot;api.acp.auto-profile&amp;quot;] = false,
    [&amp;quot;api.acp.auto-port&amp;quot;] = false,
    [&amp;quot;device.profile&amp;quot;] = &amp;quot;pro-audio&amp;quot;,
  },
},

table.insert(alsa_monitor.rules, rule)
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;rule = {
  matches = {
    {
      { &quot;device.name&quot;, &quot;matches&quot;, &quot;alsa_card.usb-Focusrite_Scarlett_2i4_USB-00&quot; },
    },
  },
  apply_properties = {
    [&quot;audio.rate&quot;] = 48000,
    [&quot;audio.allowed-rates&quot;] = &quot;44100,48000,88200,96000&quot;,
    --[&quot;api.alsa.period-size&quot;] = 2048,
    --[&quot;api.alsa.headroom&quot;] = 1024,
    [&quot;api.alsa.use-acp&quot;] = true,
    -- By default, it creates profiles for stereo input and surround 4.0 output,
    -- but actually the card is 2 inputs, stereo headphones output and stereo
    -- speakers output, so we disable auto profile here, and use the Pro Audio
    -- profile to expose all ports, and combine them manually.
    [&quot;api.acp.auto-profile&quot;] = false,
    [&quot;api.acp.auto-port&quot;] = false,
    [&quot;device.profile&quot;] = &quot;pro-audio&quot;,
  },
},

table.insert(alsa_monitor.rules, rule)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后 &lt;code&gt;systemctl --user restart wireplumber&lt;/code&gt;，再打开 Helvum 应该能看到声卡不再被瞎推测为什么 LR RR 之类的声道，而是直接显示 AUX0~3，接下来就可以创建虚拟设备分别映射不同的通道了。&lt;/p&gt;
&lt;p&gt;首先对于输出，我分离出耳机/扬声器两个不同的双声道虚拟输出设备，平时我只用耳机。这里和官方文档示例里声卡不同的地方是那款声卡后两个通道是耳机，而 Scarlett 2i4 前两个通道就是耳机，这也是为什么就算默认被当成四通道环绕声也能用的原因。总之在 &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-sinks.conf&lt;/code&gt; 里面写入如下的配置就可以了：&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # See &lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 uses the first two outputs for headphones.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Headphones&amp;quot;
            capture.props = {
                node.name = &amp;quot;Scarlett_2i4_Headphones&amp;quot;
                media.class = &amp;quot;Audio/Sink&amp;quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &amp;quot;playback.Scarlett_2i4_Headphones&amp;quot;
                audio.position = [ AUX0 AUX1 ]
                target.object = &amp;quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&amp;quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Speakers&amp;quot;
            capture.props = {
                node.name = &amp;quot;Scarlett_2i4_Speakers&amp;quot;
                media.class = &amp;quot;Audio/Sink&amp;quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &amp;quot;playback.Scarlett_2i4_Speakers&amp;quot;
                audio.position = [ AUX2 AUX3 ]
                target.object = &amp;quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&amp;quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # See &amp;lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&amp;gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 uses the first two outputs for headphones.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Headphones&quot;
            capture.props = {
                node.name = &quot;Scarlett_2i4_Headphones&quot;
                media.class = &quot;Audio/Sink&quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &quot;playback.Scarlett_2i4_Headphones&quot;
                audio.position = [ AUX0 AUX1 ]
                target.object = &quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Speakers&quot;
            capture.props = {
                node.name = &quot;Scarlett_2i4_Speakers&quot;
                media.class = &quot;Audio/Sink&quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &quot;playback.Scarlett_2i4_Speakers&quot;
                audio.position = [ AUX2 AUX3 ]
                target.object = &quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;执行 &lt;code&gt;systemctl --user restart pipewire wireplumber&lt;/code&gt; 应该可以看到多了两个分别是 Scarlett 2i4 Headphones 和 Scarlett 2i4 Speakers 的音频输出设备。对于输入通道，我们也同理将它映射成两个单独的单声道虚拟输入设备，写到 &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-sources.conf&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # See &lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 can be two mono inputs or one stereo
    # input, depends on how we wire it in software.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Left Mono Input&amp;quot;
            capture.props = {
                node.name = &amp;quot;capture.Scarlett_2i4_Left_Mono_Input&amp;quot;
                audio.position = [ AUX0 ]
                stream.dont-remix = true
                target.object = &amp;quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&amp;quot;
                node.passive = true
            }
            playback.props = {
                node.name = &amp;quot;Scarlett_2i4_Left_Mono_Input&amp;quot;
                media.class = &amp;quot;Audio/Source&amp;quot;
                audio.position = [ MONO ]
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Right Mono Inputt&amp;quot;
            capture.props = {
                node.name = &amp;quot;capture.Scarlett_2i4_Right_Mono_Input&amp;quot;
                audio.position = [ AUX1 ]
                stream.dont-remix = true
                target.object = &amp;quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&amp;quot;
                node.passive = true
            }
            playback.props = {
                node.name = &amp;quot;Scarlett_2i4_Right_Mono_Input&amp;quot;
                media.class = &amp;quot;Audio/Source&amp;quot;
                audio.position = [ MONO ]
            }
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # See &amp;lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&amp;gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 can be two mono inputs or one stereo
    # input, depends on how we wire it in software.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Left Mono Input&quot;
            capture.props = {
                node.name = &quot;capture.Scarlett_2i4_Left_Mono_Input&quot;
                audio.position = [ AUX0 ]
                stream.dont-remix = true
                target.object = &quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&quot;
                node.passive = true
            }
            playback.props = {
                node.name = &quot;Scarlett_2i4_Left_Mono_Input&quot;
                media.class = &quot;Audio/Source&quot;
                audio.position = [ MONO ]
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Right Mono Inputt&quot;
            capture.props = {
                node.name = &quot;capture.Scarlett_2i4_Right_Mono_Input&quot;
                audio.position = [ AUX1 ]
                stream.dont-remix = true
                target.object = &quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&quot;
                node.passive = true
            }
            playback.props = {
                node.name = &quot;Scarlett_2i4_Right_Mono_Input&quot;
                media.class = &quot;Audio/Source&quot;
                audio.position = [ MONO ]
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;按理说到这里就结束了，但以防万一真的有人想用这款声卡做四声道环绕声输出，或者立体声输入，同理可以使用之前的 combine-stream 再把这些虚拟设备复合起来，可以在 &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-combined.conf&lt;/code&gt; 写入如下配置：&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # Is there anyone who really uses Scarlett 2i4 for surround 4.0 output?
    # Anyway, we could achieve this with PipeWire&#039;s combine stream.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &amp;quot;Scarlett_2i4_Surround_4_0_Output&amp;quot;
            node.description = &amp;quot;Scarlett 2i4 Surround 4.0 Output&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR RL RR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;Scarlett 2i4&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-usb&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            # To get better effect, treat headphones output as rear output.
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Speakers.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Speakers&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ FL FR ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Headphones.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Headphones&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ RL RR ]
                        }
                    }
                }
            ]
        }
    }
    # To make it easier, we also use PipeWire&#039;s combine stream to make a stereo
    # input, so we don&#039;t need to wire manually.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = source
            node.name = &amp;quot;Scarlett_2i4_Stereo_Input&amp;quot;
            node.description = &amp;quot;Scarlett 2i4 Stereo Input&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;Scarlett 2i4&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-usb&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Left Mono Input.
                            media.class = &amp;quot;Audio/Source&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Left_Mono_Input&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FL ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Right Mono Input.
                            media.class = &amp;quot;Audio/Source&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Right_Mono_Input&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FR ]
                        }
                    }
                }
            ] 
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # Is there anyone who really uses Scarlett 2i4 for surround 4.0 output?
    # Anyway, we could achieve this with PipeWire&#039;s combine stream.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &quot;Scarlett_2i4_Surround_4_0_Output&quot;
            node.description = &quot;Scarlett 2i4 Surround 4.0 Output&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR RL RR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;Scarlett 2i4&quot;
                #device.icon-name = &quot;audio-card-analog-usb&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            # To get better effect, treat headphones output as rear output.
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Speakers.
                            media.class = &quot;Audio/Sink&quot;
                            node.name = &quot;Scarlett_2i4_Speakers&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ FL FR ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Headphones.
                            media.class = &quot;Audio/Sink&quot;
                            node.name = &quot;Scarlett_2i4_Headphones&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ RL RR ]
                        }
                    }
                }
            ]
        }
    }
    # To make it easier, we also use PipeWire&#039;s combine stream to make a stereo
    # input, so we don&#039;t need to wire manually.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = source
            node.name = &quot;Scarlett_2i4_Stereo_Input&quot;
            node.description = &quot;Scarlett 2i4 Stereo Input&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;Scarlett 2i4&quot;
                #device.icon-name = &quot;audio-card-analog-usb&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Left Mono Input.
                            media.class = &quot;Audio/Source&quot;
                            node.name = &quot;Scarlett_2i4_Left_Mono_Input&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FL ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Right Mono Input.
                            media.class = &quot;Audio/Source&quot;
                            node.name = &quot;Scarlett_2i4_Right_Mono_Input&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FR ]
                        }
                    }
                }
            ] 
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;理论上来说，再创建虚拟设备直接连到物理通道应该也是可行的，但我尝试过之后连接图乱掉了，所以我换成 combine-stream 实现了。有一个要注意的点是我在环绕声里交换了一下通道，扬声器输出被我当作前面的音源，而耳机输出被我当作后面的音源，这样应该效果会更好，不过是和 auto-profile 假设的相反。&lt;/p&gt;
&lt;p&gt;于是在购买这款声卡七八年之后我终于在 Linux 下面把它按我想要的用法划分了通道，同时发现 PipeWire 对复杂音频设备的处理确实比 PulseAudio 更加灵活，而和同样基于图和连接的 JACK 相比，又能同时控制不同的声卡，对于我这种设备复杂需求却不复杂的用户而言显然更加方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-1.png&quot; alt=&quot;screenshot-1&quot;&gt;
&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-2.png&quot; alt=&quot;screenshot-2&quot;&gt;
&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-3.png&quot; alt=&quot;screenshot-3&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;English-Version&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#English-Version&quot;&gt;&lt;/a&gt;English Version&lt;/h1&gt;
&lt;p&gt;I might be the only one who owns a complex audio setup among my friends. TL;DR: To share the only pair of speakers between PS4, Switch and computer I connect it to my monitor instead of internal sound card of my computer, so all devices can output audio to speakers via HDMI/DP. It&#039;s fine until I bought another monitor, it&#039;s hard to find which monitor is the one with speakers, maybe it&#039;s HDMI 1 this week and become HDMI 2 next week, so I always need to test before playing audio. I&#039;m too angry to accept this recently, so I try to fix it by hand.&lt;/p&gt;
&lt;p&gt;At first I guess PipeWire just randomly sorts audio ports, so it&#039;s easy to fix it, what I need to do is finding ID for each port and disabling the HDMI port without speakers. But soon I see PipeWire just sorts ports via ALSA&#039;s device number, so if I disable a port, the port might be the other monitor on next boot. Is there no way to let ALSA do a fixed mapping for HDMI audio devices? We all know monitors report EDID to system, and I read ALSA&#039;s document, it contains how to handle sequence of different sound cards via udev, but no way to handle ports on the same sound card like HDMI ports. I even find document of GPU audio from NVIDIA, it says each port has a ELD file, which contains monitor info, but if you try to read it with &lt;code&gt;cat /proc/asound/cardX/eld*&lt;/code&gt;, you&#039;ll find it only contains model, not serial number, and I have two monitors of the same model in order to save time on dual-monitor scale, so they looks the same. But if your monitors/TVs are of different models, it is easier, ALSA will read model in ELD and you can access it via &lt;code&gt;node.nick&lt;/code&gt; property of a PipeWire device, you can just read it, or write some WirePlumber rules to rename properties that your desktop environment uses, so you get a fixed name. But I need more help.&lt;/p&gt;
&lt;p&gt;Then I send a Email to our company&#039;s research mailing list of my setup and demand, and Takashi Iwai (maintainer of kernel&#039;s audio subsystem) tell me there is no better way, audio driver just assign number when GPU driver notifies a new port, so it&#039;s dynamic. And I also find GPU driver may not emit ports as display probing sequence, so Plan A fails, but I have Plan B and Plan C.&lt;/p&gt;
&lt;p&gt;Another colleague suggests me to buy a mixer hardware so I can connect two monitors into one pair of speakers, and he even draws a circuit diagram and says you could make one by yourself like this. I also considered this, it allows PC and game consoles play audio at the same time, but I have to manually sync volume of two audio devices on my PC. I don&#039;t need to play audio at the same time but I am lazy, so I decide to try this last.&lt;/p&gt;
&lt;p&gt;If there is a hardware solution, there should be a software solution. PipeWire supports graph-based connection like JACK, then I could just create a virtual output device, and wire two HDMI devices to it. There is a section called &lt;a href=&quot;https://wiki.archlinux.org/title/WirePlumber#Simultaneous_output_to_multiple_sinks_on_the_same_sound_card&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Simultaneous output to multiple sinks on the same sound card&lt;/a&gt; on Arch Wiki, I thought I just need to follow it, but I was wrong, there is no new audio device. The I read more documents to understand the term and totally understand it.&lt;/p&gt;
&lt;p&gt;First I find that section is only about how to create a &quot;profile that shows both two mappings&quot;, but what is mapping and what is profile? Mapping is like one kine of combination of input/output on a sound card, and profile controls which kind of combination you could use. For example, if you have a sound device which has 2 input channels and 4 output channels, it could be a stereo output, or surround 4.0 output, or stereo input + surround 4.0 output, those are different profiles. And why you need to manually create a profile to simultaneously output to two sinks? Because by default ALSA does auto-profile which creates a profile for each mapping, and by default one mapping is for one HDMI port, so if you launch pavucontrol or Helvum, you&#039;ll find you can only see 1 of 2 HDMI devices if you don&#039;t switch profile, so you cannot wire them both. But you may also ask why GNOME Shell shows both of 2 HDMI sinks? Because &lt;code&gt;libgnome-volume-control&lt;/code&gt; iterates sound cards first, and then ports on a sound card, not directly iterate ports (which could be effected by profile), and it will switch profile when you choose ports.&lt;/p&gt;
&lt;p&gt;So the first step to do is create a new profile sets, I use &lt;code&gt;/usr/share/alsa-card-profile/mixer/profile-sets/hdmi-multiple.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;[General]
auto-profiles = no

[Mapping hdmi-stereo]
description = Digital Stereo (HDMI)
device-strings = hdmi:%f
paths-output = hdmi-output-0
channel-map = left,right
priority = 9
direction = output

[Mapping hdmi-stereo-extra1]
description = Digital Stereo (HDMI 2)
device-strings = hdmi:%f,1
paths-output = hdmi-output-1
channel-map = left,right
priority = 7
direction = output

# If you have more HDMI devices, add them here.

# Show multiple HDMI mappings so I could connect to them all.
[Profile hdmi-multiple]
description = Multiple Digital Stereo (HDMI)
output-mappings = hdmi-stereo hdmi-stereo-extra1
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;[General]
auto-profiles = no

[Mapping hdmi-stereo]
description = Digital Stereo (HDMI)
device-strings = hdmi:%f
paths-output = hdmi-output-0
channel-map = left,right
priority = 9
direction = output

[Mapping hdmi-stereo-extra1]
description = Digital Stereo (HDMI 2)
device-strings = hdmi:%f,1
paths-output = hdmi-output-1
channel-map = left,right
priority = 7
direction = output

# If you have more HDMI devices, add them here.

# Show multiple HDMI mappings so I could connect to them all.
[Profile hdmi-multiple]
description = Multiple Digital Stereo (HDMI)
output-mappings = hdmi-stereo hdmi-stereo-extra1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;I just copy mapping from &lt;code&gt;default.conf&lt;/code&gt;, and the profile just contains those two mappings, and then write a WirePlumber rule to use this profile for GPU sound card. I write the rule into &lt;code&gt;/etc/wireplumber/main.lua.d/51-hdmi-multiple.lua&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;rule = {
  matches = {
    {
      -- Sometimes PCI sound card name has `.1` or other suffix, so it&#039;s better
      -- to use description to match it.
      { &amp;quot;device.description&amp;quot;, &amp;quot;matches&amp;quot;, &amp;quot;TU104 HD Audio Controller&amp;quot; },
    },
  },
  apply_properties = {
    [&amp;quot;api.alsa.use-acp&amp;quot;] = true,
    -- By default, it creates profiles for each mappings, so one profile has one
    -- mapping, but I want to combine 2 mappings, so I have to manually create
    -- a profile to show 2 mappings.
    [&amp;quot;api.acp.auto-profile&amp;quot;] = false,
    [&amp;quot;api.acp.auto-port&amp;quot;] = false,
    [&amp;quot;device.profile-set&amp;quot;] = &amp;quot;hdmi-multiple.conf&amp;quot;,
    [&amp;quot;device.profile&amp;quot;] = &amp;quot;hdmi-multiple&amp;quot;,
  },
}

table.insert(alsa_monitor.rules, rule)
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;rule = {
  matches = {
    {
      -- Sometimes PCI sound card name has `.1` or other suffix, so it&#039;s better
      -- to use description to match it.
      { &quot;device.description&quot;, &quot;matches&quot;, &quot;TU104 HD Audio Controller&quot; },
    },
  },
  apply_properties = {
    [&quot;api.alsa.use-acp&quot;] = true,
    -- By default, it creates profiles for each mappings, so one profile has one
    -- mapping, but I want to combine 2 mappings, so I have to manually create
    -- a profile to show 2 mappings.
    [&quot;api.acp.auto-profile&quot;] = false,
    [&quot;api.acp.auto-port&quot;] = false,
    [&quot;device.profile-set&quot;] = &quot;hdmi-multiple.conf&quot;,
    [&quot;device.profile&quot;] = &quot;hdmi-multiple&quot;,
  },
}

table.insert(alsa_monitor.rules, rule)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;And then run &lt;code&gt;systemctl --user restart wireplumber&lt;/code&gt;, you should see both 2 HDMI sinks in Helvum now.&lt;/p&gt;
&lt;p&gt;Then let&#039;s do steps which Arch Wiki does not contain, how to output audio to 2 sinks? The easiest way is manually wire output program to both 2 sinks, but that&#039;s not persistent, and you cannot control volume in desktop environment. After reading PipeWire&#039;s document, I find I could solve this via virtual devices, there is a module called combine-stream which could create such a combination device, so I just follow &lt;a href=&quot;https://docs.pipewire.org/page_module_combine_stream.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;combine-stream&#039;s document&lt;/a&gt;, write following content into &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-hdmi-combined-sink.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &amp;quot;combined-hdmi-stereo&amp;quot;
            node.description = &amp;quot;Combined HDMI / DisplayPort&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;TU104 HD Audio Controller&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-pci&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts glob. Match all HDMI devices on TU104.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            # Sometimes PCI sound card name has `.1` or other
                            # suffix, so it&#039;s better to use description to
                            # match it.
                            node.description = &amp;quot;~TU104 HD Audio Controller Digital Stereo *&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            combine.audio.position = [ FL FR ]
                            audio.position = [ FL FR ]
                        }
                    }
                }
            ]
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &quot;combined-hdmi-stereo&quot;
            node.description = &quot;Combined HDMI / DisplayPort&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;TU104 HD Audio Controller&quot;
                #device.icon-name = &quot;audio-card-analog-pci&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts glob. Match all HDMI devices on TU104.
                            media.class = &quot;Audio/Sink&quot;
                            # Sometimes PCI sound card name has `.1` or other
                            # suffix, so it&#039;s better to use description to
                            # match it.
                            node.description = &quot;~TU104 HD Audio Controller Digital Stereo *&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            combine.audio.position = [ FL FR ]
                            audio.position = [ FL FR ]
                        }
                    }
                }
            ]
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;It&#039;s fairly easy to understand, just create a combination device, all audio streams point to this device will be send to all HDMI sinks on a GPU sound card, and run &lt;code&gt;systemctl --user restart pipewire wireplumber&lt;/code&gt; you should be able to choose it as output sink and control its volume. No matter speakers are connected to which monitor, it should work.&lt;/p&gt;
&lt;p&gt;Then I find I could solve the channel problem of my USB sound card. I still uses Scarlett 2i4 bought when I was in high school, it has 2 input channels and 4 output channels, and auto-profile will set it to a surround 4.0 output and stereo input, but those 4 output channels is made of a stereo headphone output and a stereo speaker output, the 2 input channels typically are used as mono microphone and mono instructment. I used to set mono input in different software to fix my microphone. But now I find there is a example of another sound card in PipeWire&#039;s document (&lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Split speakers/headphones of UMC404HD&lt;/a&gt; 和 &lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Split speakers/headphones of UMC404HD&lt;/a&gt;), but mostly they are the same, so I also tweak my sound card.&lt;/p&gt;
&lt;p&gt;The same thing is to replace default profile in order to split each channels, but this time manually creating profile is not needed, PipeWire provides a &lt;code&gt;pro-audio&lt;/code&gt; profile for all audio devices, it will expose all channels without assuming their usage (obviously, your desktop environment supports this badly), and then we could do what we need, so just create a rule to use &lt;code&gt;pro-audio&lt;/code&gt; by default in &lt;code&gt;/etc/wireplumber/main.lua.d/51-scarlett-2i4.lua&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;rule = {
  matches = {
    {
      { &amp;quot;device.name&amp;quot;, &amp;quot;matches&amp;quot;, &amp;quot;alsa_card.usb-Focusrite_Scarlett_2i4_USB-00&amp;quot; },
    },
  },
  apply_properties = {
    [&amp;quot;audio.rate&amp;quot;] = 48000,
    [&amp;quot;audio.allowed-rates&amp;quot;] = &amp;quot;44100,48000,88200,96000&amp;quot;,
    --[&amp;quot;api.alsa.period-size&amp;quot;] = 2048,
    --[&amp;quot;api.alsa.headroom&amp;quot;] = 1024,
    [&amp;quot;api.alsa.use-acp&amp;quot;] = true,
    -- By default, it creates profiles for stereo input and surround 4.0 output,
    -- but actually the card is 2 inputs, stereo headphones output and stereo
    -- speakers output, so we disable auto profile here, and use the Pro Audio
    -- profile to expose all ports, and combine them manually.
    [&amp;quot;api.acp.auto-profile&amp;quot;] = false,
    [&amp;quot;api.acp.auto-port&amp;quot;] = false,
    [&amp;quot;device.profile&amp;quot;] = &amp;quot;pro-audio&amp;quot;,
  },
},

table.insert(alsa_monitor.rules, rule)
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;rule = {
  matches = {
    {
      { &quot;device.name&quot;, &quot;matches&quot;, &quot;alsa_card.usb-Focusrite_Scarlett_2i4_USB-00&quot; },
    },
  },
  apply_properties = {
    [&quot;audio.rate&quot;] = 48000,
    [&quot;audio.allowed-rates&quot;] = &quot;44100,48000,88200,96000&quot;,
    --[&quot;api.alsa.period-size&quot;] = 2048,
    --[&quot;api.alsa.headroom&quot;] = 1024,
    [&quot;api.alsa.use-acp&quot;] = true,
    -- By default, it creates profiles for stereo input and surround 4.0 output,
    -- but actually the card is 2 inputs, stereo headphones output and stereo
    -- speakers output, so we disable auto profile here, and use the Pro Audio
    -- profile to expose all ports, and combine them manually.
    [&quot;api.acp.auto-profile&quot;] = false,
    [&quot;api.acp.auto-port&quot;] = false,
    [&quot;device.profile&quot;] = &quot;pro-audio&quot;,
  },
},

table.insert(alsa_monitor.rules, rule)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Then run &lt;code&gt;systemctl --user restart wireplumber&lt;/code&gt;, and launch Helvum, the sound card now should has AUX0~3 instead of LR RR, and then create virtual devices that map to different channels.&lt;/p&gt;
&lt;p&gt;For output channels, I create two devices for headphones and speakers, I typically only uses headphones. Which differs from the example is Scarlett 2i4 uses AUX0/1 for headphones instead of AUX2/3, and that&#039;s the reason why is works in surround 4.0 output profile. Anyway, just write those configuration into &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-sinks.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # See &lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 uses the first two outputs for headphones.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Headphones&amp;quot;
            capture.props = {
                node.name = &amp;quot;Scarlett_2i4_Headphones&amp;quot;
                media.class = &amp;quot;Audio/Sink&amp;quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &amp;quot;playback.Scarlett_2i4_Headphones&amp;quot;
                audio.position = [ AUX0 AUX1 ]
                target.object = &amp;quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&amp;quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Speakers&amp;quot;
            capture.props = {
                node.name = &amp;quot;Scarlett_2i4_Speakers&amp;quot;
                media.class = &amp;quot;Audio/Sink&amp;quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &amp;quot;playback.Scarlett_2i4_Speakers&amp;quot;
                audio.position = [ AUX2 AUX3 ]
                target.object = &amp;quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&amp;quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # See &amp;lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&amp;gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 uses the first two outputs for headphones.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Headphones&quot;
            capture.props = {
                node.name = &quot;Scarlett_2i4_Headphones&quot;
                media.class = &quot;Audio/Sink&quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &quot;playback.Scarlett_2i4_Headphones&quot;
                audio.position = [ AUX0 AUX1 ]
                target.object = &quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Speakers&quot;
            capture.props = {
                node.name = &quot;Scarlett_2i4_Speakers&quot;
                media.class = &quot;Audio/Sink&quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &quot;playback.Scarlett_2i4_Speakers&quot;
                audio.position = [ AUX2 AUX3 ]
                target.object = &quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Then run &lt;code&gt;systemctl --user restart pipewire wireplumber&lt;/code&gt; there should be 2 sinks called Scarlett 2i4 Headphones and Scarlett 2i4 Speakers. For input channels, I also map them into 2 mono virtual input devices, write configuration into &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-sources.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # See &lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 can be two mono inputs or one stereo
    # input, depends on how we wire it in software.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Left Mono Input&amp;quot;
            capture.props = {
                node.name = &amp;quot;capture.Scarlett_2i4_Left_Mono_Input&amp;quot;
                audio.position = [ AUX0 ]
                stream.dont-remix = true
                target.object = &amp;quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&amp;quot;
                node.passive = true
            }
            playback.props = {
                node.name = &amp;quot;Scarlett_2i4_Left_Mono_Input&amp;quot;
                media.class = &amp;quot;Audio/Source&amp;quot;
                audio.position = [ MONO ]
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Right Mono Inputt&amp;quot;
            capture.props = {
                node.name = &amp;quot;capture.Scarlett_2i4_Right_Mono_Input&amp;quot;
                audio.position = [ AUX1 ]
                stream.dont-remix = true
                target.object = &amp;quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&amp;quot;
                node.passive = true
            }
            playback.props = {
                node.name = &amp;quot;Scarlett_2i4_Right_Mono_Input&amp;quot;
                media.class = &amp;quot;Audio/Source&amp;quot;
                audio.position = [ MONO ]
            }
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # See &amp;lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&amp;gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 can be two mono inputs or one stereo
    # input, depends on how we wire it in software.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Left Mono Input&quot;
            capture.props = {
                node.name = &quot;capture.Scarlett_2i4_Left_Mono_Input&quot;
                audio.position = [ AUX0 ]
                stream.dont-remix = true
                target.object = &quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&quot;
                node.passive = true
            }
            playback.props = {
                node.name = &quot;Scarlett_2i4_Left_Mono_Input&quot;
                media.class = &quot;Audio/Source&quot;
                audio.position = [ MONO ]
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Right Mono Inputt&quot;
            capture.props = {
                node.name = &quot;capture.Scarlett_2i4_Right_Mono_Input&quot;
                audio.position = [ AUX1 ]
                stream.dont-remix = true
                target.object = &quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&quot;
                node.passive = true
            }
            playback.props = {
                node.name = &quot;Scarlett_2i4_Right_Mono_Input&quot;
                media.class = &quot;Audio/Source&quot;
                audio.position = [ MONO ]
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Every thing should be done here, but just in case someone really uses this sound card for surround 4.0 output or stereo input, combine-stream also could be used to combine those virtual devices, it could be done via writing those contents into &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-combined.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # Is there anyone who really uses Scarlett 2i4 for surround 4.0 output?
    # Anyway, we could achieve this with PipeWire&#039;s combine stream.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &amp;quot;Scarlett_2i4_Surround_4_0_Output&amp;quot;
            node.description = &amp;quot;Scarlett 2i4 Surround 4.0 Output&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR RL RR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;Scarlett 2i4&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-usb&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            # To get better effect, treat headphones output as rear output.
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Speakers.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Speakers&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ FL FR ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Headphones.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Headphones&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ RL RR ]
                        }
                    }
                }
            ]
        }
    }
    # To make it easier, we also use PipeWire&#039;s combine stream to make a stereo
    # input, so we don&#039;t need to wire manually.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = source
            node.name = &amp;quot;Scarlett_2i4_Stereo_Input&amp;quot;
            node.description = &amp;quot;Scarlett 2i4 Stereo Input&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;Scarlett 2i4&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-usb&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Left Mono Input.
                            media.class = &amp;quot;Audio/Source&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Left_Mono_Input&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FL ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Right Mono Input.
                            media.class = &amp;quot;Audio/Source&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Right_Mono_Input&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FR ]
                        }
                    }
                }
            ] 
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # Is there anyone who really uses Scarlett 2i4 for surround 4.0 output?
    # Anyway, we could achieve this with PipeWire&#039;s combine stream.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &quot;Scarlett_2i4_Surround_4_0_Output&quot;
            node.description = &quot;Scarlett 2i4 Surround 4.0 Output&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR RL RR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;Scarlett 2i4&quot;
                #device.icon-name = &quot;audio-card-analog-usb&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            # To get better effect, treat headphones output as rear output.
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Speakers.
                            media.class = &quot;Audio/Sink&quot;
                            node.name = &quot;Scarlett_2i4_Speakers&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ FL FR ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Headphones.
                            media.class = &quot;Audio/Sink&quot;
                            node.name = &quot;Scarlett_2i4_Headphones&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ RL RR ]
                        }
                    }
                }
            ]
        }
    }
    # To make it easier, we also use PipeWire&#039;s combine stream to make a stereo
    # input, so we don&#039;t need to wire manually.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = source
            node.name = &quot;Scarlett_2i4_Stereo_Input&quot;
            node.description = &quot;Scarlett 2i4 Stereo Input&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;Scarlett 2i4&quot;
                #device.icon-name = &quot;audio-card-analog-usb&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Left Mono Input.
                            media.class = &quot;Audio/Source&quot;
                            node.name = &quot;Scarlett_2i4_Left_Mono_Input&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FL ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Right Mono Input.
                            media.class = &quot;Audio/Source&quot;
                            node.name = &quot;Scarlett_2i4_Right_Mono_Input&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FR ]
                        }
                    }
                }
            ] 
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Theoretically creating new virtual devices wired to physical channels should also work, but my graph messed up after I tried it. Note that I swapped channels in surround 4.0 output, I use speakers sink for front and headphones sink for rear, which might leads into a better result, but it&#039;s opposite to what auto-profile generates.&lt;/p&gt;
&lt;p&gt;So after owning this sound card for 7~8 years I finally tweaked it&#039;s channels as my will, and I find PipeWire is more flexible than PulseAudio on handling complex sound devices, and when compared with JACK which also uses graph and wire, PipeWire can control different sound cards, which is more convenient for users like me who have complex setup but simple demand.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-1.png&quot; alt=&quot;screenshot-1&quot;&gt;
&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-2.png&quot; alt=&quot;screenshot-2&quot;&gt;
&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-3.png&quot; alt=&quot;screenshot-3&quot;&gt;&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="音频" label="音频" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/%E9%9F%B3%E9%A2%91/" />
    <category term="PipeWire" label="PipeWire" scheme="https://sh.alynx.one/tags/PipeWire/" />
  </entry>
  <entry>
    <title>都不能算是 GNOME 的 Bug</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Not-A-GNOME-Bug-at-All/" />
    <id>https://sh.alynx.one/posts/Not-A-GNOME-Bug-at-All/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-05-08T10:52:40.000Z</published>
    <updated>2023-05-08T10:52:40.000Z</updated>
    <summary type="html">
      Arch Linux 的官方仓库里终于有 GNOME 44 了，今天更新了一下系统，在思考出怎么解决 DaVinci Resolve 一定要去加载 onetbb 里面 intel 的 OpenCL 实现之前，我遇到了一个更奇怪的问题：所有的 XWayland 程序都显示不出来窗口…
    </summary>
    <content type="html">
      &lt;p&gt;Arch Linux 的官方仓库里终于有 GNOME 44 了，今天更新了一下系统，在思考出怎么解决 DaVinci Resolve 一定要去加载 onetbb 里面 intel 的 OpenCL 实现之前，我遇到了一个更奇怪的问题：所有的 XWayland 程序都显示不出来窗口，程序启动了，没有报错，但是点不到。&lt;/p&gt;
&lt;p&gt;忘了我当时在查什么反正看了一下 &lt;code&gt;journalctl -f&lt;/code&gt; 发现一直刷一个 &lt;code&gt;mutter-x11-frames&lt;/code&gt; core dump 的 log，我想起来 mutter 44 应该是把 X11 程序的 decoration 挪到单独的 client 里面实现了，所以也许是 mutter 的问题，不过我还是尝试用 gdb 看了一下 backtrace：&lt;/p&gt;
&lt;figure data-raw=&quot;Thread 1 &amp;quot;mutter-x11-fram&amp;quot; received signal SIGSEGV, Segmentation fault.
___pthread_mutex_lock (mutex=0x123) at pthread_mutex_lock.c:80
Downloading source file /usr/src/debug/glibc/glibc/nptl/pthread_mutex_lock.c
80        unsigned int type = PTHREAD_MUTEX_TYPE_ELISION (mutex);                                                                                                                                                                                             
(gdb) bt
#0  ___pthread_mutex_lock (mutex=0x123) at pthread_mutex_lock.c:80
#1  0x00007ffff685aaf6 in wl_proxy_create_wrapper (proxy=proxy@entry=0x55555558e510) at ../wayland-1.22.0/src/wayland-client.c:2446
#2  0x00007ffff2ad337c in getServerProtocolsInfo (protocols=0x7fffffffdc70, nativeDpy=0x55555558e510) at ../egl-wayland/src/wayland-egldisplay.c:464
#3  wlEglGetPlatformDisplayExport (data=0x5555555ae000, platform=&lt;optimized out&gt;, nativeDpy=0x55555558e510, attribs=&lt;optimized out&gt;) at ../egl-wayland/src/wayland-egldisplay.c:580
#4  0x00007ffff26acfa0 in  () at /usr/lib/libEGL_nvidia.so.0
#5  0x00007ffff264c71c in  () at /usr/lib/libEGL_nvidia.so.0
#6  0x00007ffff2ba4885 in GetPlatformDisplayCommon (platform=12760, native_display=0x55555558e510, attrib_list=0x0, funcName=0x7ffff2baad18 &amp;quot;eglGetDisplay&amp;quot;) at ../libglvnd-v1.6.0/src/EGL/libegl.c:324
#7  0x00007ffff7a19357 in gdk_display_create_egl_display (native_display=0x55555558e510, platform=12757) at ../gtk/gdk/gdkdisplay.c:1484
#8  gdk_display_init_egl (self=0x5555555a1820, platform=12757, native_display=0x55555558e510, allow_any=0, error=0x5555555a17f8) at ../gtk/gdk/gdkdisplay.c:1667
#9  0x00007ffff79edb53 in gdk_x11_display_init_gl_backend (error=0x5555555a17f8, out_depth=0x5555555a18c4, out_visual=0x5555555a18c8, self=0x5555555a1820) at ../gtk/gdk/x11/gdkdisplay-x11.c:2975
#10 gdk_x11_display_init_gl (display=0x5555555a1820, error=0x5555555a17f8) at ../gtk/gdk/x11/gdkdisplay-x11.c:3013
#11 0x00007ffff7a198f0 in gdk_display_init_gl (self=0x5555555a1820) at ../gtk/gdk/gdkdisplay.c:1248
#12 gdk_display_prepare_gl (self=0x5555555a1820, error=0x0) at ../gtk/gdk/gdkdisplay.c:1320
#13 0x00007ffff79ec355 in gdk_x11_display_open (display_name=&lt;optimized out&gt;) at ../gtk/gdk/x11/gdkdisplay-x11.c:1479
#14 0x00007ffff7a15c62 in gdk_display_manager_open_display (manager=&lt;optimized out&gt;, name=0x0) at ../gtk/gdk/gdkdisplaymanager.c:431
#15 0x00007ffff777dda9 in gdk_display_open_default () at ../gtk/gdk/gdk.c:331
#16 gtk_init_check () at ../gtk/gtk/gtkmain.c:621
#17 gtk_init_check () at ../gtk/gtk/gtkmain.c:603
#18 0x00007ffff777dfee in gtk_init () at ../gtk/gtk/gtkmain.c:659
#19 0x0000555555557070 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at ../mutter/src/frames/main.c:56
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;Thread 1 &quot;mutter-x11-fram&quot; received signal SIGSEGV, Segmentation fault.
___pthread_mutex_lock (mutex=0x123) at pthread_mutex_lock.c:80
Downloading source file /usr/src/debug/glibc/glibc/nptl/pthread_mutex_lock.c
80        unsigned int type = PTHREAD_MUTEX_TYPE_ELISION (mutex);                                                                                                                                                                                             
(gdb) bt
#0  ___pthread_mutex_lock (mutex=0x123) at pthread_mutex_lock.c:80
#1  0x00007ffff685aaf6 in wl_proxy_create_wrapper (proxy=proxy@entry=0x55555558e510) at ../wayland-1.22.0/src/wayland-client.c:2446
#2  0x00007ffff2ad337c in getServerProtocolsInfo (protocols=0x7fffffffdc70, nativeDpy=0x55555558e510) at ../egl-wayland/src/wayland-egldisplay.c:464
#3  wlEglGetPlatformDisplayExport (data=0x5555555ae000, platform=&amp;lt;optimized out&amp;gt;, nativeDpy=0x55555558e510, attribs=&amp;lt;optimized out&amp;gt;) at ../egl-wayland/src/wayland-egldisplay.c:580
#4  0x00007ffff26acfa0 in  () at /usr/lib/libEGL_nvidia.so.0
#5  0x00007ffff264c71c in  () at /usr/lib/libEGL_nvidia.so.0
#6  0x00007ffff2ba4885 in GetPlatformDisplayCommon (platform=12760, native_display=0x55555558e510, attrib_list=0x0, funcName=0x7ffff2baad18 &quot;eglGetDisplay&quot;) at ../libglvnd-v1.6.0/src/EGL/libegl.c:324
#7  0x00007ffff7a19357 in gdk_display_create_egl_display (native_display=0x55555558e510, platform=12757) at ../gtk/gdk/gdkdisplay.c:1484
#8  gdk_display_init_egl (self=0x5555555a1820, platform=12757, native_display=0x55555558e510, allow_any=0, error=0x5555555a17f8) at ../gtk/gdk/gdkdisplay.c:1667
#9  0x00007ffff79edb53 in gdk_x11_display_init_gl_backend (error=0x5555555a17f8, out_depth=0x5555555a18c4, out_visual=0x5555555a18c8, self=0x5555555a1820) at ../gtk/gdk/x11/gdkdisplay-x11.c:2975
#10 gdk_x11_display_init_gl (display=0x5555555a1820, error=0x5555555a17f8) at ../gtk/gdk/x11/gdkdisplay-x11.c:3013
#11 0x00007ffff7a198f0 in gdk_display_init_gl (self=0x5555555a1820) at ../gtk/gdk/gdkdisplay.c:1248
#12 gdk_display_prepare_gl (self=0x5555555a1820, error=0x0) at ../gtk/gdk/gdkdisplay.c:1320
#13 0x00007ffff79ec355 in gdk_x11_display_open (display_name=&amp;lt;optimized out&amp;gt;) at ../gtk/gdk/x11/gdkdisplay-x11.c:1479
#14 0x00007ffff7a15c62 in gdk_display_manager_open_display (manager=&amp;lt;optimized out&amp;gt;, name=0x0) at ../gtk/gdk/gdkdisplaymanager.c:431
#15 0x00007ffff777dda9 in gdk_display_open_default () at ../gtk/gdk/gdk.c:331
#16 gtk_init_check () at ../gtk/gtk/gtkmain.c:621
#17 gtk_init_check () at ../gtk/gtk/gtkmain.c:603
#18 0x00007ffff777dfee in gtk_init () at ../gtk/gtk/gtkmain.c:659
#19 0x0000555555557070 in main (argc=&amp;lt;optimized out&amp;gt;, argv=&amp;lt;optimized out&amp;gt;) at ../mutter/src/frames/main.c:56
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后我就在想看起来是 GTK4 的问题，我还去群里问了一下有没有 GNOME + NVIDIA 的用户，看看是我的问题还是 bug，不过没人理我，还差点把我恶心到了。然后我想了一下试了 &lt;code&gt;GDK_BACKEND=x11 nautilus&lt;/code&gt; 发现也有一样的问题，就跑到 GTK 那边提了个 issue，结果那位有点出名的毒舌老哥跟我说看着不像是 GTK 的问题倒像是 nvidia 的问题，我也怀疑过，但我检查了一下和 nvidia 相关的都没什么变化，然后我去翻 glvnd 和 egl-wayland 的仓库也没翻出什么。换到 KDE 下面还是一样有问题。但我突然想到会不会和我设置的一些环境变量有关系，于是就去注销了一大片，结果就好了。最后我看了一下好像有 platform，发现是我设置过一个 &lt;code&gt;EGL_PLATFORM=wayland&lt;/code&gt; 的环境变量，删掉这个就好了。&lt;/p&gt;
&lt;p&gt;我想了一下这应该是我当初弄 Firefox 的硬件解码视频时候设置的，果不其然在 &lt;a href=&quot;https://github.com/elFarto/nvidia-vaapi-driver#firefox&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/elFarto/nvidia-vaapi-driver#firefox&lt;/a&gt; 里面写了，看起来是因为这个变量导致 XWayland 程序加载 EGL 的时候把 platform 当成了 Wayland，不过我没想清楚为什么滚系统之前没有遇到这个问题。&lt;/p&gt;
&lt;p&gt;总之这是个不能算 bug 的问题了，如果我在群里问的时候有人回我，我就能直接排除法发现是我自己配置的问题，结果提了 issue 以后发现不是上游的问题感觉很尴尬。想了一下还是决定把这个记在这里，因为我推测有很多人看了 &lt;code&gt;nvidia-vaapi-driver&lt;/code&gt; 的文档，说不定也设置了这个变量然后遇到了同样的问题，记录下来方便搜到。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    <category term="NVIDIA" label="NVIDIA" scheme="https://sh.alynx.one/tags/NVIDIA/" />
  </entry>
  <entry>
    <title>Emacs 和 Lazy Loading 和 use-package</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Emacs-Lazy-Loading-use-package/" />
    <id>https://sh.alynx.one/posts/Emacs-Lazy-Loading-use-package/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-01-20T09:55:00.000Z</published>
    <updated>2023-01-20T09:55:00.000Z</updated>
    <summary type="html">
      事先叠 buff：我不是说 use-package 一定要这么用，我也不是说所用不用 use-package 的人都不好，我只是说我觉得应该这样用 use-package 比较合适。 use-package 是个好东西，因为它解决了 Emacs 插件包从安装到配置的全过程，可以让…
    </summary>
    <content type="html">
      &lt;p&gt;事先叠 buff：我不是说 &lt;code&gt;use-package&lt;/code&gt; 一定要这么用，我也不是说所用不用 &lt;code&gt;use-package&lt;/code&gt; 的人都不好，我只是说我觉得应该这样用 &lt;code&gt;use-package&lt;/code&gt; 比较合适。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; 是个好东西，因为它解决了 Emacs 插件包从安装到配置的全过程，可以让配置更结构化。不过也有人觉得 &lt;code&gt;use-package&lt;/code&gt; 关键字过于复杂，总是没办法确定什么配置写到什么字段里面，也不知道展开之后悄悄发生了什么事情。从我再次决定自己打造一份 Emacs 配置以来看了很多不同人的配置，发现他们使用 &lt;code&gt;use-package&lt;/code&gt; 的方式也是五花八门，有些人不爱用 &lt;code&gt;:bind&lt;/code&gt; 和 &lt;code&gt;:hook&lt;/code&gt;，干脆自己在 &lt;code&gt;:config&lt;/code&gt; 里面调用 &lt;code&gt;define-key&lt;/code&gt; 和 &lt;code&gt;add-hook&lt;/code&gt;，有些人不清楚为什么自己的 &lt;code&gt;:config&lt;/code&gt; 被延迟运行了，干脆全都用 &lt;code&gt;:init&lt;/code&gt;。还有些人直接换成了其它号称更简单可控的替代品。我不是说上面这些方法都错了，实际上只要能得到想要的结果也无所谓怎么写，但我是一个比较注重逻辑的人，所以研究了一下到底这些关键字是怎么回事，并且试图写篇文章记录我推荐的写法。本来我打算写在注释里的，可是感觉写得太多，所以就放到博客里了。&lt;/p&gt;
&lt;p&gt;问题的核心无非是：为什么我写的 &lt;code&gt;:config&lt;/code&gt; 没有运行？到底什么情况下会有延迟加载？我打算在这里详细分析一下。&lt;/p&gt;
&lt;p&gt;首先 Emacs 有一种叫做 autoloads 的东西，插件包的作者可以在某些函数前加上 autoloads 标记，然后创建 autoloads 文件。这个功能的作用很好理解，原本在启动时需要加载所有插件包的文件以便用户使用相应的功能，但不是所有的插件都是启动时就需要，只在启动时加载会让启动速度变得很慢。有了 autoloads 之后启动时只要加载 autoloads 文件，里面定义了如果运行某个函数，就去加载某个文件，这样等到对应的函数第一次运行的时候才被加载，从而提高启动速度。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;use-package&lt;/code&gt; 做了什么呢？&lt;code&gt;use-package&lt;/code&gt; 可以自动创建 autoloads，这样即使一个包本身没有 autoloads，也是可以延迟加载的。最简单的触发这个逻辑的关键字是 &lt;code&gt;:commands&lt;/code&gt;，就是给后续的函数创建 autoloads 的意思。但如果你仔细阅读文档，就会发现还有几个创建 autoloads 的关键字，分别是 &lt;code&gt;:bind&lt;/code&gt;、&lt;code&gt;:hook&lt;/code&gt;、&lt;code&gt;:mode&lt;/code&gt; 和 &lt;code&gt;:interpreter&lt;/code&gt;。**如果有这几个关键字，&lt;code&gt;use-package&lt;/code&gt; 不会立即加载一个包，而是依靠创建的 autoloads 实现延迟加载。**这也很好理解，这几个关键字的意思都是“在某种情况下启用”，所以自动延迟加载也很好理解。&lt;/p&gt;
&lt;p&gt;然后为什么会遇到 &lt;code&gt;:config&lt;/code&gt; 不会运行所以有些人统统把要调用的语句写到 &lt;code&gt;:init&lt;/code&gt; 里面的问题呢？一般都是发生在类似下面的写法（既有快捷键 / 钩子，又要一启动就启用什么模式）里：&lt;/p&gt;
&lt;figure data-raw=&quot;(use-package marginalia
  :ensure t
  :bind (:map minibuffer-local-map
              (&amp;quot;M-A&amp;quot; . marginalia-cycle))
  :config
  (marginalia-mode 1))
&quot; data-info=&quot;language-lisp&quot; data-lang=&quot;lisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-lisp&quot;&gt;(use-package marginalia
  :ensure t
  :bind (:map minibuffer-local-map
              (&quot;M-A&quot; . marginalia-cycle))
  :config
  (marginalia-mode 1))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我们得明确 &lt;code&gt;:init&lt;/code&gt; 和 &lt;code&gt;:config&lt;/code&gt; 的区别，&lt;code&gt;:init&lt;/code&gt; 是“无论包有没有加载，都一定会先执行”的配置，&lt;code&gt;:config&lt;/code&gt; 是“包加载之后才会被执行”的配置。然后按照上面关于延迟加载的分析，这就变成了一个“先有鸡还是先有蛋”的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;use-package&lt;/code&gt; 给这个包创建了快捷键对应的 autoloads，于是这个包不会立刻加载。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:config&lt;/code&gt; 里面 &lt;code&gt;(marginalia-mode 1)&lt;/code&gt; 要等到包加载之后才运行。&lt;/li&gt;
&lt;li&gt;这个包本身有给 &lt;code&gt;marginalia-mode&lt;/code&gt; 创建 autoloads，只要调用 &lt;code&gt;marginalia-mode&lt;/code&gt; 就会加载这个包，但是根据 1 和 2，这句不会被调用，包也不会被加载，除非按了 1 里面的快捷键。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打破这个循环的办法不止一种，比如把 &lt;code&gt;(marginalia-mode 1)&lt;/code&gt; 写进 &lt;code&gt;:init&lt;/code&gt;，这样无论如何都会调用它，于是 &lt;code&gt;use-package&lt;/code&gt; 创建的 autoloads 被忽略了，包肯定会被加载。但我个人倾向于把这种启用模式的函数放在 &lt;code&gt;:config&lt;/code&gt; 里面，而且作者也推荐不要在 &lt;code&gt;:init&lt;/code&gt; 里面放过于复杂的函数，这时候打破循环的办法也很简单，只要使用 &lt;code&gt;:demand t&lt;/code&gt;，告诉 &lt;code&gt;use-package&lt;/code&gt; 立即加载这个包即可。&lt;/p&gt;
&lt;p&gt;以上的内容其实都写在 &lt;a href=&quot;https://github.com/jwiegley/use-package#notes-about-lazy-loading&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/jwiegley/use-package#notes-about-lazy-loading&lt;/a&gt;，只是可能很多人没有注意或者没看明白，于是我试图在这里更详细的解释一下。可能有人会问搞这么复杂真的有意义吗？我直接自己不要延迟加载直接都 &lt;code&gt;require&lt;/code&gt; 不可以？不过我觉得这种激进的延迟加载方案确实让我的 Emacs 启动非常快，所以大概是有意义的吧。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Emacs" label="Emacs" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Emacs/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Emacs" label="Emacs" scheme="https://sh.alynx.one/tags/Emacs/" />
  </entry>
  <entry>
    <title>StackHarbor 的 2022 尾记</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/2022-Tail/" />
    <id>https://sh.alynx.one/posts/2022-Tail/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-01-10T05:43:00.000Z</published>
    <updated>2023-01-10T05:43:00.000Z</updated>
    <summary type="html">
      &lt;p&gt;每年写年终总结我都会拖很晚，因为基本上我写博客是看心情，最近事情比较多，其实也打算再拖几天的，但是实在是不想回家之后写，所以不得不今天仓促动手。&lt;/p&gt;
&lt;p&gt;然后实际上我不喜欢分类列提纲的写法，我本质上比较倾向于文学性的写法或者就是想到什么写什么，不过最近我在翻以前的年终总结的时候发现事情总是记的乱七八糟而且有些我都想不起来出现在哪篇文章里了，这当然可能也和我写完年终总结从来不看有关系，反正这次打算试一下分类的写法。&lt;/p&gt;
&lt;p&gt;按照惯例还是要感慨一句时间过得真快，仅仅只是靠记忆的话，就会觉得自己什么也没做就过了一年。写年终总结的时候到处翻一下记录，才会意识到自己其实做了不少事情。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;每年写年终总结我都会拖很晚，因为基本上我写博客是看心情，最近事情比较多，其实也打算再拖几天的，但是实在是不想回家之后写，所以不得不今天仓促动手。&lt;/p&gt;
&lt;p&gt;然后实际上我不喜欢分类列提纲的写法，我本质上比较倾向于文学性的写法或者就是想到什么写什么，不过最近我在翻以前的年终总结的时候发现事情总是记的乱七八糟而且有些我都想不起来出现在哪篇文章里了，这当然可能也和我写完年终总结从来不看有关系，反正这次打算试一下分类的写法。&lt;/p&gt;
&lt;p&gt;按照惯例还是要感慨一句时间过得真快，仅仅只是靠记忆的话，就会觉得自己什么也没做就过了一年。写年终总结的时候到处翻一下记录，才会意识到自己其实做了不少事情。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E7%BC%96%E7%A8%8B&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E7%BC%96%E7%A8%8B&quot;&gt;&lt;/a&gt;编程&lt;/h1&gt;
&lt;p&gt;我经常会处于一种“我好菜啊怎么什么都做不了”和“我还能搞定这个其实还不错”的叠加态，实际上仔细翻一下感觉去年还是做了不少东西。比如说在 HackWeek 把 Show Me The Key 成功换成了 GTK4。然后还抽时间利用 Telegram 机器人做了个照片墙，虽然中间我把它关了很长时间，不过后来我又把它跑起来了。&lt;/p&gt;
&lt;p&gt;这一年我印象最深的其实是搞我的 Emacs 配置。在有确定消息说 GitHub 打算放弃 Atom 之后，我不得不给我自己重新找一个编辑器，因为我得了一种看到 Visual Studio 就会死的病所以坚决不会用 VSCode，除非他们哪天改名部把 VS 从里面去掉。然后我一直是不喜欢模态编辑的所以也不会用 Vim，同时 Emacs 的 PGTK 分支已经被上游接受，所以我很高兴地重回 Emacs 拥抱我所知的第一个 pure Wayland 的 GUI 编辑器。说是重回，其实相当于重新学习了一遍 Emacs Lisp，毕竟我一开始尝试 Emacs 是被 Spacemacs 那句著名的口号吸引的（但是我又不用 Evil）。那时候其实我不太懂 Emacs Lisp，但是现在回头再看发现确实是更好掌握了。虽然有无数的人说应该从别人配好的 Emacs 配置开始，但我还是决定自己编写一套配置而不是使用最流行的 doom。一个是这些配置好像都以模态编辑为中心，另一个是我经常会自己定制自己的编辑器，使用这些别人配好的配置调起来总觉得很不自在。然后就是我逐渐理解了 &lt;code&gt;use-package&lt;/code&gt; 的用法，解决了各种奇奇怪怪的问题，甚至还自己用 Emacs Lisp 写了很多自己需要的功能。虽然可能有人要问你搞这一通有什么意义之类的，但是我做事的一个原则就是看心情，我高兴就好，所以觉得还挺值的。&lt;/p&gt;
&lt;p&gt;然后不论是工作还是个人爱好上这一年多少也做了点东西，毕竟我的工作就是我的爱好。比如很有意思的一个是我研究了一下 GNOME 的智能卡登录到底怎么搞，顺便也大致了解了一下 PAM 的配置，虽然可能这个还是没什么用，不过最后我修改了 openSUSE 的 gdm 包添加了一直缺失的指纹和智能卡的 PAM 配置，也算是帮助了其他人。我还抽出时间调查了一下 GTK3 和 GTK4 的亮色 / 暗色主题切换到底是怎么回事。然后还做了一些微小的贡献，比如我印象里一直有人吐槽说 GNOME Shell 的搜索只能从开头匹配而不能做子串匹配，还有人说难道他们只会用 &lt;code&gt;String.prototype.startsWith()&lt;/code&gt; 不会用 &lt;code&gt;String.prototype.includes()&lt;/code&gt;，我一开始只是想既然这么简单，有吐槽的时间为什么不自己改一个？于是我花时间看了一下还真不是这么简单，总之最后我阅读了 glib 里面的算法，并且添加了根据不同的匹配模式分组的功能，现在如果有单词开头匹配的会优先显示，然后再显示子串匹配，就可以通过搜索 &lt;code&gt;fox&lt;/code&gt; 得到 &lt;code&gt;Firefox&lt;/code&gt; 了（&lt;a href=&quot;https://gitlab.gnome.org/GNOME/glib/-/merge_requests/3107&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/glib/-/merge_requests/3107&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;和这个类似的还有另一个，我看到有人说 &lt;code&gt;gdbus-codegen&lt;/code&gt; 生成的代码没有加空指针检查导致程序崩溃，然后和开发者吵了起来，开发者说加空指针检查不是真的解决问题，这里不应该传空指针，那个人就丢出一堆各种代码规范说传了空指针应该继续运行不该崩溃，开发者说你给我们加的话我们愿意接受，他又说自己不擅长 python，总之我看了觉得很不可理喻，于是我自己改掉提交了然后嘲笑了那人一通。有些时候真不是开发者脾气不好，是有人态度太差……（&lt;a href=&quot;https://gitlab.gnome.org/GNOME/glib/-/merge_requests/3175&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/glib/-/merge_requests/3175&lt;/a&gt;）&lt;/p&gt;
&lt;h1 id=&quot;%E9%9F%B3%E4%B9%90&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E9%9F%B3%E4%B9%90&quot;&gt;&lt;/a&gt;音乐&lt;/h1&gt;
&lt;p&gt;去年一年我还是录了好几个曲子的，虽然我自己是觉得没怎么练琴而且还经常咕咕咕。不过我发出来的我自己还都觉得不错，虽然不是每个都有很多播放量吧。最近手上有几个想录的，比如 シリウスの心臓 和 暗恋是一个人的事，不过可能又要拖到年后了。&lt;/p&gt;
&lt;p&gt;然后今年通过 &lt;a href=&quot;https://space.bilibili.com/4947340&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;澪音奏&lt;/a&gt; 的翻唱听了好多伍佰的曲子，对于我这种几乎不会主动找歌曲来听的人，能扩充曲库还是好事。还在 B 站听了纵贯线的亡命之徒，没早点听到这个真是有点可惜。&lt;/p&gt;
&lt;h1 id=&quot;%E6%95%B0%E7%A0%81&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E6%95%B0%E7%A0%81&quot;&gt;&lt;/a&gt;数码&lt;/h1&gt;
&lt;p&gt;其实我觉得我也没买什么东西，但是再看一下又不少，很多其实没什么可说的，比如买了个新镜头，那就是新镜头，也没什么好在博客里分析一番的。考虑到那块老移动硬盘用了很久，又买了一块三星的 T7 Shield，固态的移动硬盘还是可靠很多。犹豫了很久还是买了平板，不过不是 iPad，是 Galaxy Tab S8，除了 LCD 屏幕有点漏光，别的我都很满意，不管是看谱子还是看视频都不错，虽然有些 app 不支持横屏，但我还是觉得文件管理更重要。&lt;/p&gt;
&lt;p&gt;开销比较大的是装了一台 NAS，实际也是挑来挑去才决定的，运行了小一年觉得还不错，极大的缓解了我的存储压力。&lt;/p&gt;
&lt;h1 id=&quot;%E6%91%84%E5%BD%B1&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E6%91%84%E5%BD%B1&quot;&gt;&lt;/a&gt;摄影&lt;/h1&gt;
&lt;p&gt;自我评价的话我觉得还是有点进步，别的不说，今年我拍了很多自己觉得不错的照片。摸索了一年，我大概也知道怎么用 darktable 得到想要的效果了。之前看到有人总结了一下自己拍过的照片里觉得不错的，我觉得这个想法很好，于是挑了一些今年满意的照片放在这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/2022-Tail/DSC00674.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC06074.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC07236.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/R3103214_04.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/R3103766_04.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC08433.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC08556.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC09543.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC09817_01.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/R3104386.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/R3104387.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/000183680027.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/000183800005.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/000183800014.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/000183800015.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC01159.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC01265.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC01274.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;很想找机会把我喜欢的照片打印出来装上相框挂在家里，只是一直没去做这件事。&lt;/p&gt;
&lt;h1 id=&quot;%E5%8A%A8%E6%BC%AB&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E5%8A%A8%E6%BC%AB&quot;&gt;&lt;/a&gt;动漫&lt;/h1&gt;
&lt;p&gt;今年应该只看了两部，一部是 DitF，具体的评价我在 &lt;a href=&quot;/posts/Not-to-Be-EVA-but-to-Be-Pacific-Rim/&quot;&gt;这篇文章&lt;/a&gt; 写过了。另一部是 赛博朋克：边缘行者，我其实是不喜欢赛博朋克题材的，但是这一部做得太好了，我在这里向所有读者推荐。&lt;/p&gt;
&lt;h1 id=&quot;%E5%B0%8F%E8%AF%B4&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E5%B0%8F%E8%AF%B4&quot;&gt;&lt;/a&gt;小说&lt;/h1&gt;
&lt;p&gt;今年应该是看了基地三部曲，还有格兰特船长的儿女和神秘岛，因为都是很好找到电子版的，所以没有买实体书，神秘岛以前看过简写版，其他的都是头一次看，总体上来说我觉得都不错，毕竟也是流传很久的书了。&lt;/p&gt;
&lt;h1 id=&quot;%E6%B8%B8%E6%88%8F&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E6%B8%B8%E6%88%8F&quot;&gt;&lt;/a&gt;游戏&lt;/h1&gt;
&lt;p&gt;除了和开黑群的朋友打 Dota 2 就是和牛爷爷高先生吃鸡，今年更多的玩了游廊地图，感觉我还是想玩休闲一点不太需要团队配合的，吃鸡的话我以为我很久没玩了水平会很差，不过我好像逐渐掌握这个游戏怎么赢了，而且经常可以吃鸡。其实玩游戏本身倒不重要，重要的是有人一起玩。一个人玩的话，要不是因为看中单光一，我大概不会坚持玩 Dota 2。&lt;/p&gt;
&lt;h1 id=&quot;%E7%94%9F%E6%B4%BB&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E7%94%9F%E6%B4%BB&quot;&gt;&lt;/a&gt;生活&lt;/h1&gt;
&lt;p&gt;在经历了翻大饼之后果然是不负众望的夺冠了，虽然已经好了。大饼现在是翻过来了，但是保不准哪天又要翻回去，反正我是受够了这种提心吊胆的日子。仔细想想今年我大概有好几次对着共享单车打开健康码扫码，还是挺可怕的。蓝猫今年去了日本，没办法再找她玩了，虽然我很羡慕，但是我又穷又懒。至于脱单这种事情，算了吧，我已经放弃了，一个人待着也挺好的，我一点都不羡慕别人（假的）。&lt;/p&gt;
&lt;p&gt;最近几天突然又肋骨痛，只要有动作扯到就很难受，我也不知道是气胸还是肋间神经痛还是肌肉拉伤，本来打算去医院看看的，但最近事情安排满了，回家的时间取决于车票不取决于我，所以只能等回家之后再说。&lt;/p&gt;

    </content>
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    <category term="时光飞逝" label="时光飞逝" scheme="https://sh.alynx.one/tags/%E6%97%B6%E5%85%89%E9%A3%9E%E9%80%9D/" />
  </entry>
  <entry>
    <title>YubiKey 和 GNOME 和智能卡登录</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/YubiKey-GNOME-Smartcard-Login/" />
    <id>https://sh.alynx.one/posts/YubiKey-GNOME-Smartcard-Login/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-11-28T10:24:04.000Z</published>
    <updated>2025-04-24T09:42:09.000Z</updated>
    <summary type="html">
      最近我终于决定买了一个 YubiKey 5C，说出来不怕各位笑话，我买这玩意最初的动机只是觉得每次开机和解锁输密码太麻烦（但是为什么我不觉得 sudo 输密码麻烦呢？）。这还和我之前处理了一个 openSUSE 的 PAM 问题有关，我发现 GDM 有好几种不同的 PAM 配置，…
    </summary>
    <content type="html">
      &lt;p&gt;最近我终于决定买了一个 YubiKey 5C，说出来不怕各位笑话，我买这玩意最初的动机只是觉得每次开机和解锁输密码太麻烦（但是为什么我不觉得 &lt;code&gt;sudo&lt;/code&gt; 输密码麻烦呢？）。这还和我之前处理了一个 openSUSE 的 PAM 问题有关，我发现 GDM 有好几种不同的 PAM 配置，除了平时用的 &lt;code&gt;gdm-password&lt;/code&gt; 密码登录，还有 &lt;code&gt;gdm-fingerprint&lt;/code&gt; 指纹登录和 &lt;code&gt;gdm-smartcard&lt;/code&gt; 智能卡登录。我一开始是打算买个指纹传感器的，查了一下 fprintd 的文档，支持的型号并不多，而且在淘宝上问客服 USB Product ID 和 Vendor ID 显然得不到回答，就退而求其次买智能卡了，而搜索智能卡得到最多的结果就是 YubiKey，进入一个不了解的领域之前和大部分人选一样的一般不会错太多，于是就下手了。&lt;/p&gt;
&lt;p&gt;话说回来智能卡登录，如果你搜索 YubiKey 相关的文章，绝大多数都会告诉你把 &lt;code&gt;pam_u2f.so&lt;/code&gt; 加到需要密码登录的 PAM 配置里，比如 &lt;code&gt;sudo&lt;/code&gt; 或者 &lt;code&gt;gdm-password&lt;/code&gt;，但这显然不是我想要的，我要的方案不是替换密码登录，而是和密码登录平行的配置文件，我知道 GNOME 有已经写好的智能卡配置，但是任何地方都搜不到如何启用，设置里没有相关选项，连 Arch Wiki 给的方案都只是用 &lt;code&gt;pam_u2f.so&lt;/code&gt;。Red Hat 的支持文档里倒是提到了智能卡登录，然而用的却是他们自己的某个工具配置的。显然这是个起夜级 feature，最好的办法也许是找个起夜级 Linux 的桌面工程师来问问，哦什么我自己就是起夜级 Linux 桌面工程师，那没事了。还要说的一件事是怎么想智能卡这东西都和安全相关，而我自己不是专业的安全行业人士，所以我不会尝试解释清楚和安全相关的一些名词，以及如果我哪里真的写错了，希望专业人士多多指点，我肯定改。&lt;/p&gt;
&lt;p&gt;总之相信你自己因为你才是职业选手，我还是自己看看这东西怎么弄吧，毕竟用 Arch 再用 GNOME 同时还打算搞 GNOME 的智能卡登录的人没几个，所以 Wiki 没有倒也正常。首先肯定是看 &lt;code&gt;/etc/pam.d/gdm-smartcard&lt;/code&gt; 这个文件，里面别的看起来都比较正常，只有一行看起来和智能卡有关系：&lt;/p&gt;
&lt;figure data-raw=&quot;auth       required                    pam_pkcs11.so        wait_for_card card_only
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;auth       required                    pam_pkcs11.so        wait_for_card card_only
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;线索是有了，看来我需要这个 &lt;code&gt;pam_pkcs11.so&lt;/code&gt;，虽然我也不知道这是什么，先搜一下哪个包有这个文件比较好。&lt;code&gt;pacman -F pam_pkcs11.so&lt;/code&gt; 竟然没有返回任何结果，我确定不是我的 pacman 数据库没更新，那只能去浏览器里搜索了，最后我搜到了 &lt;a href=&quot;https://github.com/OpenSC/pam_pkcs11&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/OpenSC/pam_pkcs11&lt;/a&gt;，虽然我也不知道 &lt;code&gt;PKCS#11&lt;/code&gt; 是个什么玩意，但反正它是个 PAM 模块，既然不在官方仓库里，那大概率 AUR 里有人打包了，于是直接 &lt;code&gt;paru pam_pksc11&lt;/code&gt; 就装了一个上来。&lt;/p&gt;
&lt;p&gt;但装是装好了，也看不出来这玩意和 YubiKey 有什么联系，我大概是搜索了 PKCS YubiKey 然后搜到了 YubiKey 给的文档 &lt;a href=&quot;https://developers.yubico.com/PIV/Guides/SSH_with_PIV_and_PKCS11.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Using PIV for SSH through PKCS #11&lt;/a&gt;，好吧虽然我不是要用来 SSH 但是多半也有点用。看下来反正这个东西和 YubiKey 的 PIV 功能有关，我把 PIV 相关的文档都看了一遍，结果是云里雾里，相当没有头绪。一大堆文档告诉你各种各样的需求要做什么，但是几乎没怎么说这都是什么，于是恰好我的需求不在列表里我就不知道怎么办了。我又回头去看 &lt;code&gt;pam_pkcs11&lt;/code&gt; 的文档，它写了一长串的东西，我反复看了几遍之后发现只要看 &lt;a href=&quot;http://opensc.github.io/pam_pkcs11/doc/pam_pkcs11.html#HOWTO&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;第 11 节的 HOWTO 部分&lt;/a&gt; 就可以了。虽然我也不太清楚它都在说什么，但是至少这里告诉我说需要一个 root CA certificate，但我是个人使用哪来的这玩意，再回头看 YubiKey 的那篇文档里面恰好提到了什么 self-signed certificate，我拿这个试一试，结果成功了。为了方便参考，下面我就不讲我是怎么倒推这些奇怪的需求的了，而是顺序讲一下都需要配置什么。&lt;/p&gt;
&lt;p&gt;首先如果你像我一样刚买了一个 YubiKey 打算利用它的 PIV 功能，那你得先初始化它，也就是改掉默认的 PIN，PUK 和管理密钥，这个可以通过官方的 YubiKey Manager 软件来操作：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S yubikey-manager
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pacman -S yubikey-manager
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;之前这个软件还有个 Qt 写的 GUI 版本，但是已经被官方放弃了，不过本来 GUI 也不是很好用，所以建议还是用命令行：&lt;/p&gt;
&lt;figure data-raw=&quot;% ykman piv access change-pin
% ykman piv access change-puk
% ykman piv access change-management-key --generate --protect --touch
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% ykman piv access change-pin
% ykman piv access change-puk
% ykman piv access change-management-key --generate --protect --touch
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;默认 PIN 是 &lt;code&gt;123456&lt;/code&gt;，默认 PUK 是 &lt;code&gt;12345678&lt;/code&gt;，而管理密钥是个特别长的一串，用 &lt;code&gt;--generate&lt;/code&gt; 可以让 &lt;code&gt;ykman&lt;/code&gt; 给你生成一个，&lt;code&gt;--protect&lt;/code&gt; 则是把这个直接存到 YubiKey 里面并用 PIN 保护，&lt;code&gt;--touch&lt;/code&gt; 则是说每次要管理密钥的时候需要你摸一下。我也不是很懂，也许写进去以后需要的时候就不用自己背这玩意而是输 PIN 就行了吧，反正建议看官方文档 &lt;a href=&quot;https://developers.yubico.com/PIV/Guides/Device_setup.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Device setup&lt;/a&gt; 和 &lt;code&gt;ykman&lt;/code&gt; 的 &lt;code&gt;--help&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我的建议是不要看太多官方文档，因为它一会告诉你用 &lt;code&gt;yubico-piv-tool&lt;/code&gt; 创建密钥，一会告诉你说可以用 &lt;code&gt;openssl&lt;/code&gt; 创建密钥，一会又告诉你可以用 &lt;code&gt;pkcs11-tool&lt;/code&gt; 搭配 &lt;code&gt;libykcs11.so&lt;/code&gt; 创建密钥，算了吧，头都看晕了，我的测试是用 &lt;code&gt;yubico-piv-tool&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;figure data-raw=&quot;% paru yubico-piv-tool
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% paru yubico-piv-tool
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;9a&lt;/code&gt; 这个槽创建一个 key 并把它的公钥写出来，为什么是 &lt;code&gt;9a&lt;/code&gt; 好像因为这是第一个槽来着，自己去查官方文档吧，也可以写到别的槽里面：&lt;/p&gt;
&lt;figure data-raw=&quot;% yubico-piv-tool -s 9a -a verify-pin -a generate -o public.pem
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% yubico-piv-tool -s 9a -a verify-pin -a generate -o public.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;需要先输入 PIN，然后灯闪的时候需要摸一下 YubiKey，它就开始生成了。&lt;/p&gt;
&lt;p&gt;还要给这个密钥生成一个签名：&lt;/p&gt;
&lt;figure data-raw=&quot;% yubico-piv-tool -s 9a -a verify-pin -a selfsign-certificate -S &amp;quot;/CN=Alynx Zhou/&amp;quot; -i public.pem -o cert.pem
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% yubico-piv-tool -s 9a -a verify-pin -a selfsign-certificate -S &quot;/CN=Alynx Zhou/&quot; -i public.pem -o cert.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;注意 &lt;code&gt;CN=&lt;/code&gt; 后面的部分，这里会被 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 用来验证这个智能卡属于系统里面哪个用户，所以简单的话直接写你的登录用户名，当然你像我一样不想写用户名也是有办法对应的，同样要输入 PIN。&lt;/p&gt;
&lt;p&gt;再把证书导回到同一个槽，我也不知道为什么，文档说了我照做了（大概是为了方便携带，需要证书的时候可以直接从 YubiKey 里面导出）：&lt;/p&gt;
&lt;figure data-raw=&quot;% yubico-piv-tool -s 9a -a verify-pin -a import-certificate -i cert.pem
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% yubico-piv-tool -s 9a -a verify-pin -a import-certificate -i cert.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;还是要输入 PIN 然后灯闪的时候摸一下。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2025-04-24）：我发现生成的证书就像 HTTPS 的证书一样其实是会过期的，默认的有效期是一年，到期了需要重新生成一个证书。我大概理解了这玩意是怎么回事并且搞清楚如何用 &lt;code&gt;ykman&lt;/code&gt; 配置了所以我这里再记录一下怎么用 &lt;code&gt;ykman&lt;/code&gt; 更新证书。&lt;/p&gt;
&lt;p&gt;整个的流程其实是你有一对私钥公钥用来签发证书，私钥在你的 YubiKey 里，公钥则是一个文件，使用公钥签发证书，然后把证书丢给 pam_pkcs11，pam_pkcs11 请求卡片用私钥验证证书是否符合。为了方便，证书可以导入 YubiKey，也可以从 YubiKey 里导出。&lt;/p&gt;
&lt;p&gt;首先可以用 &lt;code&gt;ykman piv info&lt;/code&gt; 查看一下目前证书的信息。&lt;/p&gt;
&lt;p&gt;如果已经有一个过期的就用 &lt;code&gt;ykman piv certificates delete 9a&lt;/code&gt; 删掉旧的证书。&lt;/p&gt;
&lt;p&gt;然后用 &lt;code&gt;ykman piv certificates generate -s &quot;CN=Alynx Zhou&quot; 9a public.pem&lt;/code&gt; 签发一个新证书，注意这里字符串的格式和 &lt;code&gt;yubico-piv-tool&lt;/code&gt; 不一样，这里用逗号而不是斜杠做分隔符。&lt;/p&gt;
&lt;p&gt;和 &lt;code&gt;yubico-piv-tool&lt;/code&gt; 不一样，此时证书是直接生成在卡片里的，要交给 pam_pkcs11 的话得用 &lt;code&gt;ykman piv certificates export 9a cert.pem&lt;/code&gt; 导出成文件。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;到这里 YubiKey 的配置就结束了。&lt;/p&gt;
&lt;p&gt;要在系统上使用智能卡验证需要安装系统上和智能卡交互的软件包：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S ccid opensc pcsclite
% paru pam_pkcs11
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pacman -S ccid opensc pcsclite
% paru pam_pkcs11
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;启动一个相关的 daemon，或者启动 socket 也行，需要的时候它就自己起来了：&lt;/p&gt;
&lt;figure data-raw=&quot;# systemctl enable --now pcscd.socket
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# systemctl enable --now pcscd.socket
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果我没漏掉什么乱七八糟的，就可以配置 PAM 模块了，它有一个配置目录叫 &lt;code&gt;/etc/pam_pksc11&lt;/code&gt;，首先你要把上面生成的证书放到 &lt;code&gt;/etc/pam_pkcs11/cacerts&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-raw=&quot;# cd /etc/pam_pkcs11/cacerts
# cp PATH_TO_YOUT_CERT/cert.pem ./
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# cd /etc/pam_pkcs11/cacerts
# cp PATH_TO_YOUT_CERT/cert.pem ./
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;你要在同一个目录下面运行一个什么什么 hash 命令生成一个 hash：&lt;/p&gt;
&lt;figure data-raw=&quot;# pkcs11_make_hash_link
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pkcs11_make_hash_link
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;接下来你要去搞它的配置文件，先复制一个样本过来：&lt;/p&gt;
&lt;figure data-raw=&quot;# cp /usr/share/doc/pam_pkcs11/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# cp /usr/share/doc/pam_pkcs11/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;好像其实也没什么需要改的。文档说默认的配置用的是 OpenSC 的 PKCS#11 库，虽然 YubiKey 的文档一直跟你说什么 &lt;code&gt;libykcs11.so&lt;/code&gt;，我的测试结果是不用理它，通用的接口就够了，以及这个 &lt;code&gt;libykcs11.so&lt;/code&gt; 是属于 &lt;code&gt;yubico-piv-tool&lt;/code&gt; 这个包的。&lt;/p&gt;
&lt;p&gt;假如你刚才 &lt;code&gt;CN=&lt;/code&gt; 后面写的不是你的用户名，那你需要一些配置告诉 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 你这个证书对应的哪个用户，这一步在它的配置文件里叫 &lt;code&gt;mapper&lt;/code&gt;。默认启用了一些 mapper 比如 &lt;code&gt;pwent&lt;/code&gt;，这个就是把 &lt;code&gt;CN=&lt;/code&gt; 后面的内容和 &lt;code&gt;/etc/passwd&lt;/code&gt; 里面的用户名做匹配，但是如果你像我一样写的是全名，那就需要另一个默认启用的模块叫 &lt;code&gt;subject&lt;/code&gt;。至于 subject 是什么需要运行下面这个命令：&lt;/p&gt;
&lt;figure data-raw=&quot;% pkcs11_inspect
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% pkcs11_inspect
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;它会输出各种 mapper 对应的 data，比如 &lt;code&gt;pwent&lt;/code&gt; 输出的就是 &lt;code&gt;Alynx Zhou&lt;/code&gt;，&lt;code&gt;subject&lt;/code&gt; 输出的则是 &lt;code&gt;/CN=Alynx Zhou&lt;/code&gt;。我们需要复制一个 &lt;code&gt;subject_mapping&lt;/code&gt; 配置文件的样本过来：&lt;/p&gt;
&lt;figure data-raw=&quot;# cp /usr/share/doc/pam_pkcs11/subject_mapping.example /etc/pam_pkcs11/subject_mapping
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# cp /usr/share/doc/pam_pkcs11/subject_mapping.example /etc/pam_pkcs11/subject_mapping
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在这个文件后面加一行：&lt;/p&gt;
&lt;figure data-raw=&quot;/CN=Alynx Zhou -&gt; alynx
&quot; data-info=&quot;language-plain&quot; data-lang=&quot;plain&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-plain&quot;&gt;/CN=Alynx Zhou -&amp;gt; alynx
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我的用户名是 &lt;code&gt;alynx&lt;/code&gt;，你可以换成你自己的。&lt;/p&gt;
&lt;p&gt;到这一步 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 这个模块已经可以通过智能卡验证你的身份了。&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&quot;alert-red&quot;&gt;更新（2025-04-24）：直接使用 p11-kit 的 MR 已经合并了，所以下面讲配置 NSS 数据库的部分都不需要做了。&lt;/div&gt;

&lt;p&gt;但是如果你火急火燎兴高采烈的重启了系统，GDM 还是会和你要密码。原因其实很简单，虽然现在 &lt;code&gt;/etc/pam.d/gdm-smartcard&lt;/code&gt; 已经可用了，但 GDM 只有在检测到智能卡之后才会调用这个文件尝试智能卡登录，很显然它没检测到智能卡。&lt;/p&gt;
&lt;p&gt;这里就比较难搞清楚了，我智能卡插的好好的，上面各种程序都能用，为什么你检测不到？我尝试用什么 GDM YubiKey 之类的关键词搜索了半天，也没人告诉我 GDM 到底怎么检测智能卡的。没有办法还是读代码吧，GNOME Shell &lt;code&gt;js/gdm/util.js&lt;/code&gt; 里面的逻辑是通过 D-Bus 的 &lt;code&gt;org.gnome.SettingsDaemon.Smartcard&lt;/code&gt; 获取智能卡信息，那我打开 D-Feet 从 Session Bus 里面找到这个，直接运行 &lt;code&gt;org.gnome.SettingsDaemon.Smartcard.Manager&lt;/code&gt; 的 &lt;code&gt;GetInsertedTokens&lt;/code&gt;，什么都没有。&lt;/p&gt;
&lt;p&gt;根据 D-Bus 的信息，很显然这个接口是 &lt;code&gt;gnome-settings-daemon&lt;/code&gt; 的 &lt;code&gt;smartcard&lt;/code&gt; 插件提供的，我大概是搜索了什么 gsd-smartcard PKCS#11 的关键字之后找到了 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-settings-daemon/-/merge_requests/208&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-settings-daemon/-/merge_requests/208&lt;/a&gt;，其实我一开始也没太看懂这是什么意思，但得到一些有用的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gsd-smartcard&lt;/code&gt; 用了什么 NSS API 获取智能卡设备。&lt;/li&gt;
&lt;li&gt;这玩意要一个什么 system shared certificate NSS database。&lt;/li&gt;
&lt;li&gt;除了 Red Hat 家那一套好像没什么别的发行版弄这个。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一路下来乱七八糟的名词已经够多的了现在又多了一个什么 NSS 而且只有 Red Hat 才配置了 system shared certificate NSS database，但不管怎么样我是职业选手我不能轻言放弃，还好 Arch Wiki 有这么一个页面 &lt;a href=&quot;https://wiki.archlinux.org/title/Network_Security_Services&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Network Security Services&lt;/a&gt;，但这不是管证书的吗，和智能卡设备有什么关系啊。这时候我又翻开了 Arch Wiki 关于智能卡的页面 &lt;a href=&quot;https://wiki.archlinux.org/title/Smartcards#Chromium&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Smartcards&lt;/a&gt;，里面讲了在 Chromium 里面加载智能卡需要在 NSS 数据库里面加一个模块（什么乱七八糟的），不过它操作的都是用户的家目录下面的数据库，这显然不是 system shared certificate NSS database。然后如果手工执行 &lt;code&gt;/usr/lib/gsd-smartcard -v&lt;/code&gt;，会发现这玩意尝试读取 &lt;code&gt;/etc/pki/nssdb&lt;/code&gt; 获取什么智能卡驱动列表，我系统里面根本没这个目录。算了，既然是 Red Hat 搞的东西，我看看他们怎么写的。正好我有个 Fedora 的虚拟机，打开虚拟机一看还真有这个目录，那就运行下面命令看看：&lt;/p&gt;
&lt;figure data-raw=&quot;% modutil -dbdir /etc/pki/nssdb -list
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% modutil -dbdir /etc/pki/nssdb -list
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;结果里面除了默认项还真有个叫 &lt;code&gt;p11-kit-proxy&lt;/code&gt; 的玩意，我又回去看了一眼那个 Merge Request，现在我完全明白了，不知道为什么 NSS 这玩意会记录一个读取智能卡的驱动列表，然后 &lt;code&gt;gsd-smartcard&lt;/code&gt; 是通过 NSS 获取到智能卡的驱动列表之后再尝试查询智能卡，实际上现在没什么人用 NSS 这个功能了，你这还得往系统的 NSS 数据库里面写东西，除了红帽子家都没人搞这个了，就算有用 NSS 读的（比如浏览器）也是读用户的 NSS 数据库。别的用智能卡的都直接用 &lt;code&gt;p11-kit&lt;/code&gt; 去读智能卡，所以这个 Merge Request 也改成直接用 &lt;code&gt;p11-kit&lt;/code&gt; 读了。不知道为什么这个 Merge Request 没能合并。再多说一句，就算是 Red Hat 的系统 NSS 数据库，现在也不直接写智能卡的驱动了，而也是通过 &lt;code&gt;p11-kit&lt;/code&gt;，所以刚才在 Fedora 的数据库里只看到 &lt;code&gt;p11-kit-proxy&lt;/code&gt; 这一个驱动……&lt;/p&gt;
&lt;p&gt;既然这样我们也在这个数据库里写一个 &lt;code&gt;p11-kit-proxy&lt;/code&gt;，根据 Arch Wiki 的智能卡页面，如果你要通过 &lt;code&gt;p11-kit&lt;/code&gt; 操作 OpenSC 的驱动（这都什么乱七八糟的），那可能需要安装一个 AUR 包来保证它被加载（实际上就是个文件而已）：&lt;/p&gt;
&lt;figure data-raw=&quot;% paru opensc-p11-kit-module
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% paru opensc-p11-kit-module
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;创建数据库目录并往数据库里写 &lt;code&gt;p11-kit-proxy&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;# mkdir /etc/pki/nssdb
# modutil -dbdir sql:/etc/pki/nssdb -add &amp;quot;p11-kit-proxy&amp;quot; -libfile p11-kit-proxy.so
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# mkdir /etc/pki/nssdb
# modutil -dbdir sql:/etc/pki/nssdb -add &quot;p11-kit-proxy&quot; -libfile p11-kit-proxy.so
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你和我一样又心急火燎的重启了，就会发现还是没用。这不科学啊，Fedora 的数据库里也是这么写的，看一眼 D-Bus 为什么还是没有智能卡。&lt;/p&gt;
&lt;p&gt;实际上最后我发现只差一点点，Fedora 给这个目录下文件的权限是 &lt;code&gt;-rw-r--r--&lt;/code&gt;，而我这边创建好的是 &lt;code&gt;-rw------&lt;/code&gt;。&lt;code&gt;gsd-smartcard&lt;/code&gt; 是以 session 用户运行的当然读不了。所以改一下权限就可以了。&lt;/p&gt;
&lt;figure data-raw=&quot;# chmod 0644 /etc/pki/nssdb/*
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# chmod 0644 /etc/pki/nssdb/*
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;接下来插着 YubiKey 重启，GDM 启动的 &lt;code&gt;gsd-smartcard&lt;/code&gt; 就能检测到智能卡，于是调用 &lt;code&gt;/etc/pam.d/gdm-smartcard&lt;/code&gt;，直接让你输入用户名，输入之后会提示你输入智能卡的 PIN，然后 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 进行验证，就可以登录了。锁屏之后也只要输入智能卡的 PIN 就可以解锁。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;按理说如果给 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 发一个空白的用户名，它会根据智能卡返回用户名的，不知道为什么我在 GDM 用不了，一定要开机手动输入，有空我看看代码也许可以修改一下。&lt;/del&gt; 我也不知道为什么一定要在 GDM 启动之前插入卡才可以，显示用户列表之后再插入卡我这里没反应。&lt;/p&gt;
&lt;p&gt;更新（2022-11-30）：花了我半天时间研究 GDM 和 PAM，问题不在 GDM，而是因为 Arch Linux 的 &lt;code&gt;gdm-smartcard&lt;/code&gt; 首先调用了 &lt;code&gt;pam_shells&lt;/code&gt; 检查用户是否有合法的 shell，遇到空用户名它第一个失败了，于是我提交了 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gdm/-/merge_requests/193&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;一个 MR&lt;/a&gt;，把 &lt;code&gt;pam_shells&lt;/code&gt; 挪到 &lt;code&gt;pam_pkcs11&lt;/code&gt; 下面，这样它会检查自动返回的用户名。（虽然这些 PAM 配置文件是发行版自己写的但是大家都提交到 GNOME 那边了，我只改了 Arch 的因为我在用，别的发行版的用户先偷着乐吧。）&lt;/p&gt;
&lt;p&gt;如果你想用智能卡解锁的话，一定得是用智能卡登录才可以，它会检查当前的卡是不是登录所用的那张卡，不是的话就只能密码解锁了。折腾这一套花了我一整天时间，因为资料实在是太少了，根本不知道它是怎么工作的。&lt;/p&gt;
&lt;p&gt;以及最后我还发现一篇文章，里面的内容也是讲这个 NSS 数据库的解决方案的，也许我早看见这个就不会这么麻烦了： &lt;a href=&quot;https://p11-glue.freedesktop.narkive.com/4z6daFWc/fixing-nss-and-p11-kit-in-fedora-and-beyond&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Fixing NSS and p11-kit in Fedora (and beyond)&lt;/a&gt;。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    <category term="YubiKey" label="YubiKey" scheme="https://sh.alynx.one/tags/YubiKey/" />
  </entry>
  <entry>
    <title>DaVinci Resolve 在 Linux 下的输入法支持</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Input-Method-Support-for-DaVinci-Resolve-on-Linux/" />
    <id>https://sh.alynx.one/posts/Input-Method-Support-for-DaVinci-Resolve-on-Linux/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-11-25T09:50:13.000Z</published>
    <updated>2022-11-25T09:50:13.000Z</updated>
    <summary type="html">
      令人出乎意料，我竟然是 DaVinci Resolve（后面都简称达芬奇了）的付费用户。虽然它不是开源软件，但是有很好的 Linux 支持，使用体验和功能都是同类中的佼佼者，而且收费也相当合理。我选择付费一个原因是你支持我，我就支持你，这其实和我支持 Steam 和 Valve …
    </summary>
    <content type="html">
      &lt;p&gt;令人出乎意料，我竟然是 DaVinci Resolve（后面都简称达芬奇了）的付费用户。虽然它不是开源软件，但是有很好的 Linux 支持，使用体验和功能都是同类中的佼佼者，而且收费也相当合理。我选择付费一个原因是你支持我，我就支持你，这其实和我支持 Steam 和 Valve 的理由差不多。另一个原因是众所周知的由于什么所谓系统专利许可证的原因达芬奇 Linux 版本不能解码 H264 和 H265 这两种常见的视频编码，只能使用 NVIDIA 显卡的 NVENC 和 NVDEC 来处理，而达芬奇将显卡加速功能作为收费的卖点。于是我就这样半自愿的上了贼船。&lt;/p&gt;
&lt;p&gt;当然排除掉解码问题之后还有另一个比较难受的地方，就是达芬奇 Linux 版没有输入法支持，于是完全没办法输入中文。我猜测不像是某些故意恶心人的企业对 Linux 不友好，而单纯是因为英语开发者没有“输入法”这种概念。毕竟达芬奇的图形界面是基于 Qt 的，而 Qt 直接有现成的输入法支持，构建的时候打开开关就可以了嘛。为此我甚至专门跑到 BlackMagic Design 的用户论坛发了个帖子（&lt;a href=&quot;https://forum.blackmagicdesign.com/viewtopic.php?f=33&amp;amp;t=150886&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://forum.blackmagicdesign.com/viewtopic.php?f=33&amp;amp;t=150886&lt;/a&gt;），作为付费用户，我给你钱，你就得给我办事，就是这么硬气。显然某位员工看到了我的帖子并把它移动到了 Feature Requests 版面，然后就没有然后了。闭源拖拉机总是这样，我看到了，但我懒得改，你给我等着吧。我倒不是说开源拖拉机的维护者都比较勤快，但是至少代码放在那里，说不定用户自己就给你改了送到你面前了，一般再懒的维护者都乐意接受。谁叫我没找到和达芬奇一样好用的开源视频剪辑软件呢。&lt;/p&gt;
&lt;p&gt;不过从它用的 Qt 这一点上来看，应该是有什么办法可以 hack 一下让它支持输入法的。虽然我不是很熟悉 Qt，但是 Fcitx 的开发者 &lt;a href=&quot;https://www.csslayer.info/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@csslayer&lt;/a&gt; 给了我一个方案，他之前写了一篇博客是关于给 Mathematica 添加输入法支持的（&lt;a href=&quot;https://www.csslayer.info/wordpress/fcitx-dev/a-case-study-how-to-compile-a-fcitx-platforminputcontext-plugin-for-a-proprietary-software-that-uses-qt-5/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://www.csslayer.info/wordpress/fcitx-dev/a-case-study-how-to-compile-a-fcitx-platforminputcontext-plugin-for-a-proprietary-software-that-uses-qt-5/&lt;/a&gt;），他觉得达芬奇也可以如法炮制，于是我阅读了一下，简单地概括就是首先查出来软件用了什么版本的 Qt，然后下载对应的源码，因为输入法支持属于 Qt 的某种插件，所以只要构建插件的时候链接到软件自带的 Qt，再把得到的插件复制到软件的 Qt 目录就可以了。一般来说软件就算修改了自带的 Qt，也不会修改有关插件的部分，所以我打算如法炮制一下。&lt;/p&gt;
&lt;p&gt;首先是查看达芬奇自带的 Qt 的版本，这个非常简单：&lt;/p&gt;
&lt;figure data-raw=&quot;% strings /opt/resolve/libs/libQt5Core.so.5 | rg &#039;Qt 5&#039;
Qt 5.15.2 (x86_64-little_endian-lp64 shared (dynamic) release build; by Clang 9.0.1 )
This is the QtCore library version Qt 5.15.2 (x86_64-little_endian-lp64 shared (dynamic) release build; by Clang 9.0.1 )
If that is not possible, in Qt 5 you must at least reimplement
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;% strings /opt/resolve/libs/libQt5Core.so.5 | rg &#039;Qt 5&#039;
Qt 5.15.2 (x86_64-little_endian-lp64 shared (dynamic) release build; by Clang 9.0.1 )
This is the QtCore library version Qt 5.15.2 (x86_64-little_endian-lp64 shared (dynamic) release build; by Clang 9.0.1 )
If that is not possible, in Qt 5 you must at least reimplement
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;到这里应该就是去下载 Qt 5.15.2 版本的源码了，不过我突发奇想看了一眼系统安装的 Qt 版本：&lt;/p&gt;
&lt;figure data-raw=&quot;% pacman -Qi qt5-base | rg Version
Version         : 5.15.7+kde+r176-1
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;% pacman -Qi qt5-base | rg Version
Version         : 5.15.7+kde+r176-1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;一般来说主次版本号不变的话不会有什么不兼容的改动，会不会我直接把系统的 &lt;code&gt;.so&lt;/code&gt; 文件复制过去就可以用了呢？Qt 5 的 ibus 支持已经是 Qt 本身代码库的一部分了，安装到系统的路径是 &lt;code&gt;/usr/lib/qt/plugins/platforminputcontexts/libibusplatforminputcontextplugin.so&lt;/code&gt;，我尝试直接把它链接过去：&lt;/p&gt;
&lt;figure data-raw=&quot;% sudo mkdir /opt/resolve/libs/plugins/platforminputcontexts
% sudo ln -s /usr/lib/qt/plugins/platforminputcontexts/libibusplatforminputcontextplugin.so /opt/resolve/libs/plugins/platforminputcontexts
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;% sudo mkdir /opt/resolve/libs/plugins/platforminputcontexts
% sudo ln -s /usr/lib/qt/plugins/platforminputcontexts/libibusplatforminputcontextplugin.so /opt/resolve/libs/plugins/platforminputcontexts
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后就没有然后了，我启动达芬奇之后 ibus 就直接工作了。没想到他们虽然不太了解 Linux 输入法，Qt 版本跟的倒是还挺新的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Input-Method-Support-for-DaVinci-Resolve-on-Linux/screenshot-1.png&quot; alt=&quot;just works&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于 Fcitx5 用户的话，首先要注意 Qt 5 的 Fcitx5 支持并不在 Qt 的代码库里，所以你需要安装 &lt;code&gt;fcitx5-qt&lt;/code&gt;。不过文件路径的话都是一样的，只要把文件名里的 &lt;code&gt;ibus&lt;/code&gt; 改成 &lt;code&gt;fcitx5&lt;/code&gt; 就可以了。如果直接链接不能用，需要按照老 K 博客里的办法自己编译的话，需要下载单独的 &lt;code&gt;fcitx5-qt&lt;/code&gt; 代码库。当然从根源上解决问题的话还是希望大家去论坛回复我的帖子，让 BlackMagic Design 开启构建开关，就不需要用奇怪的办法 hack 了。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    <category term="Qt" label="Qt" scheme="https://sh.alynx.one/tags/Qt/" />
  </entry>
  <entry>
    <title>GTK 和 libhandy 和 Arc-Dark 主题</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/GTK-libhandy-Arc-Dark/" />
    <id>https://sh.alynx.one/posts/GTK-libhandy-Arc-Dark/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-11-23T10:23:34.000Z</published>
    <updated>2022-11-23T10:23:34.000Z</updated>
    <summary type="html">
      黑夜让我选了黑色的主题，但是有些程序非要寻找光明？ 我自认为不是个对应用程序外观有着病态一致性要求的人，我也从不介意一些个性化的程序选择自己的特殊样式。所以当 GTK 4 推荐的 libadwaita 不再支持传统的 GTK 主题的时候我也没什么反应：毕竟这玩意默认的样式看起来还…
    </summary>
    <content type="html">
      &lt;blockquote class=&quot;center-quote&quot;&gt;黑夜让我选了黑色的主题，但是有些程序非要寻找光明？&lt;/blockquote&gt;

&lt;p&gt;我自认为不是个对应用程序外观有着病态一致性要求的人，我也从不介意一些个性化的程序选择自己的特殊样式。所以当 GTK 4 推荐的 libadwaita 不再支持传统的 GTK 主题的时候我也没什么反应：毕竟这玩意默认的样式看起来还挺好看的。但即使是我这样宽容的人，对于 GTK 3 那个熟的不能再熟的 Adwaita 主题也审美疲劳了，那个银色和棕色会让所有手机厂笑话的，即使有些手机厂的审美还不如这玩意。&lt;/p&gt;
&lt;p&gt;我个人最喜欢的配色其实是 Atom 的 One Dark 和 One Light，但我没那个精力利用调色盘自己维护一份主题，所以我退而求其次选择了在观感上比较接近的 &lt;a href=&quot;https://github.com/jnsh/arc-theme&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Arc 主题&lt;/a&gt;，这个主题其实是一个系列，我自己只在乎里面的两个变体：全亮色的 Arc 和全暗色的 Arc-Dark（似乎它自己 README 里面给的截图也有点问题）。&lt;/p&gt;
&lt;p&gt;我自己是一个暗色模式爱好者，毕竟长时间面对屏幕，白底黑字实在是太刺眼了，相对而言，深蓝色做背景色浅灰色做前景色要好看很多。在很久很久以前混沌初开，Linux 桌面程序员还没有意识到需要有个全局的暗色/亮色开关的时候，设置主题非常简单粗暴，打开 GNOME Tweaks 把 GTK Theme 设置为 Arc-Dark，我就心满意足了。&lt;/p&gt;
&lt;p&gt;可能是 libadwaita 不能更换主题导致很多反对的声音，并没有太多人谈论随之而来的全局暗色模式开关，但是某天我更新了系统之后发现设置里多了一个亮色/暗色选择，我觉得挺好，那我这里选暗色就行了嘛，果然所有用了 libadwaita 的程序都跟着变了亮暗，不过我用着用着就感觉不对劲了——怎么以前那些 GTK 3 的程序不用 Arc-Dark 而是用 Adwaita-dark 了，这和我想的不一样啊？然后我研究了一下，觉得更奇怪了，GTK 4 + libadwaita 的 GNOME Settings 用的是 libadwaita 的暗色版本（预期行为），GTK 3 的 GNOME Tweaks 用的是 GTK 3 的 Adwaita-dark（不对劲），但是同样是 GTK 3 的 GNOME Terminal 用的是我设置的 Arc-Dark（预期行为）。好家伙好家伙，我这一个桌面上三花聚顶了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GTK-libhandy-Arc-Dark/screenshot-1.png&quot; alt=&quot;三花聚顶&quot;&gt;&lt;/p&gt;
&lt;p&gt;总这么待着我觉得怪怪的，于是我研究了一下，如果我要是选亮色模式呢？现在 GNOME Settings 是 libadwaita 的亮色版本了，然后 GNOME Tweaks 和 GNOME Terminal 都是 Arc-Dark，虽然好像一致了，又好像有点不一致，这回从三花聚顶变成黑白通吃。总之我忍受了很久 GTK 4 程序 &lt;strong&gt;大部分&lt;/strong&gt; 是白的而 GTK 3 程序是黑的，直到我再也受不了决定翻开代码看看这些人是怎么写的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GTK-libhandy-Arc-Dark/screenshot-2.png&quot; alt=&quot;黑白通吃&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了能说明白，下面我就不从结果反推原因了，毕竟大家看到这里可能已经云里雾里，没必要和我再重复一遍破案过程了。&lt;/p&gt;
&lt;p&gt;可能大部分人不是 GTK 开发者也不使用 GTK，对这玩意怎么调用主题存在一定的误区。实际上可以分为以下几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不使用 libhandy 的 GTK 3 程序（比如 GNOME Terminal）和不使用 libadwaita 的 GTK 4 程序（比如 Show Me The Key），这一类程序不考虑 GNOME Settings 里面的亮色/暗色开关（指的是 GSettings 里面 &lt;code&gt;org.gnome.desktop.interface&lt;/code&gt; 的 &lt;code&gt;color-scheme&lt;/code&gt; 选项），而只考虑 &lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt;，这个值属于 &lt;code&gt;GtkSettings&lt;/code&gt;，需要编辑 &lt;code&gt;~/.config/gtk-4.0/settings.ini&lt;/code&gt; 和 &lt;code&gt;~/.config/gtk-3.0/settings.ini&lt;/code&gt;。以及是的你没看错，GTK 4 不一定非要用 libadwaita，实际上虽然这个库叫 libadwaita，但它和 GTK 3 那个叫做 Adwaita 的默认主题几乎没有关系，它是 GTK 3 的组件库 libhandy 的进化版本。GNOME 推荐使用这个以便让整个桌面有统一的风格，但是 GTK 4 仍然是个完整的 UI 库，程序开发者完全可以不使用 libadwaita。&lt;/li&gt;
&lt;li&gt;使用 libadwaita 的 GTK 4 程序（比如 GNOME Settings），这一类程序不考虑 GNOME Tweaks 里面的 GTK Theme 选项（实际上是 GSettings 里面 &lt;code&gt;org.gnome.desktop.interface&lt;/code&gt; 的 &lt;code&gt;gtk-theme&lt;/code&gt; 选项），只使用 libadwaita 内置的配色，所以我们也完全不需要关心它，它永远按照设置里的开关工作。&lt;/li&gt;
&lt;li&gt;使用 libhandy 的 GTK 3 程序（比如 GNOME Tweaks），这个就相当复杂了，libhandy 考虑了桌面环境的亮色/暗色主题切换，但也考虑了用户自定义的 GTK Theme，于是在这里它华丽的乱套了。&lt;/li&gt;
&lt;li&gt;还有最后一类程序，它们出于特定需要自己给自己套了自定义的 CSS，所以你拿它一点办法也没有，直接忽略（比如 Show Me The Key 的悬浮窗口）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看到这里一定有小黑子要怒吼了：“看看你们搞的乱七八糟的玩意！GNOME 真垃圾！老子就要刀耕火种就要当原始人，libadwaita 滚啊！”但是我建议用你那可怜的小脑袋瓜想一想，上面三条里面反而 libadwaita 是最符合预期的一个（亮色模式用亮色，暗色模式用暗色），所以我不会解决第二个，而是解决另外的两个。&lt;/p&gt;
&lt;p&gt;首先从 libhandy 下手，相关的代码位于 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/libhandy/-/blob/main/src/hdy-style-manager.c#L286-L348&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/libhandy/-/blob/main/src/hdy-style-manager.c#L286-L348&lt;/a&gt;，如果你可怜的小脑袋瓜也没耐心看看代码的话，那么我大发慈悲替你读了一遍。相关的逻辑大概是说首先覆盖掉当前程序的 &lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt;（别忘了 libhandy 程序也是 GTK 3 程序），这个值会被设置成 &lt;code&gt;color-scheme&lt;/code&gt; 的值。然后获取当前系统的 GTK Theme，因为我们考虑到浅色和深色主题切换，所以主题名被分成基础名和种类名两部分，如果系统的主题以 &lt;code&gt;-dark&lt;/code&gt; 结尾，那就去掉这个后缀，得到基础名，并设置为当前程序的主题。那问题难道出在 Arc-Dark 的结尾是 &lt;code&gt;-Dark&lt;/code&gt; 而不是 &lt;code&gt;-dark&lt;/code&gt; 吗？也不是，GTK 主题对于暗色和亮色的区分不在主题名上，而是在主题目录下面的两个文件，一个叫做 &lt;code&gt;gtk.css&lt;/code&gt;，另一个叫做 &lt;code&gt;gtk-dark.css&lt;/code&gt;，如果 &lt;code&gt;color-scheme&lt;/code&gt; 是 &lt;code&gt;prefer-dark&lt;/code&gt;，libhandy 就会加载后者而非前者，这部分的代码在 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/libhandy/-/blob/main/src/hdy-style-manager.c#L106-L141&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/libhandy/-/blob/main/src/hdy-style-manager.c#L106-L141&lt;/a&gt;。于是在系统设置为暗色模式的时候，libhandy 会去加载 Arc-Dark 的 &lt;code&gt;gtk-dark.css&lt;/code&gt;，但 Arc-Dark 作为一个暗色变体，只有 &lt;code&gt;gtk.css&lt;/code&gt;，所以加载失败，libhandy 回退到 &lt;code&gt;Adwaita&lt;/code&gt; 的 &lt;code&gt;gtk-dark.css&lt;/code&gt;。而系统设置为亮色的时候，libhandy 会去加载 Arc-Dark 的 &lt;code&gt;gtk.css&lt;/code&gt;，而作为一个暗色变体，这个文件实际写的是暗色配色，于是看起来正常了。（以及如果你 GTK Theme 设置为 &lt;code&gt;Adwaita-dark&lt;/code&gt; 从这里你就会发现实际上加载的是 &lt;code&gt;Adwaita&lt;/code&gt; 的 &lt;code&gt;gtk-dark.css&lt;/code&gt;，而不是 &lt;code&gt;Adwaita-dark&lt;/code&gt; 的 &lt;code&gt;gtk.css&lt;/code&gt;，即使它们的配色是一样的。）&lt;/p&gt;
&lt;p&gt;那么显然又有另一个问题，既然主题是靠内部的两个文件区分亮色和暗色的，为什么又会有 &lt;code&gt;Adwaita-dark&lt;/code&gt; 和 &lt;code&gt;Arc-Dark&lt;/code&gt; 这种名字里带暗色后缀的变体呢？并且还要在 &lt;code&gt;libhandy&lt;/code&gt; 里面处理这个后缀，是不是多此一举？我们可以暂时先不考虑这个问题，而先简单解决第三条。从上面的分析可以得知为了能正常支持系统的亮色暗色切换，我们需要的是一个同时包含亮色暗色的主题，而不是一个只有暗色变体的主题，于是我们不能把 GTK Theme 设置为 Arc-Dark，而应该使用 Arc，但假如你在 GNOME Tweaks 里面设置好之后，你会发现仍然是黑白通吃：GNOME Settings 是 libadwaita 的暗色版本，GNOME Tweaks 是 Arc 的暗色版本，而 GNOME Terminal 和 Show Me The Key 却变成了亮的 Arc！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GTK-libhandy-Arc-Dark/screenshot-3.png&quot; alt=&quot;小黑子们不要笑得太早了&quot;&gt;&lt;/p&gt;
&lt;p&gt;我知道有的小黑子要迫不及待开始炮轰 GNOME 了：“什么玩意，整来整去不还是整不好吗，不如来当原始人。”但问题其实就是原始人留下的。现在我们回头看第一条：不使用 libhandy 的 GTK 3 程序和不使用 libadwaita 的 GTK 4 程序，这一类程序不考虑 GNOME Settings 里面的亮色/暗色开关，而只考虑 &lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt;。所以这个奇怪的表现恰好验证了这一条，同时也解释了“既然主题是靠内部的两个文件区分亮色和暗色的，为什么又会有 &lt;code&gt;Adwaita-dark&lt;/code&gt; 和 &lt;code&gt;Arc-Dark&lt;/code&gt; 这种名字里带暗色后缀的变体”这个问题：因为在一开始的设计里并没有什么全局亮色/暗色开关，也就没有要求主题同时提供 &lt;code&gt;gtk.css&lt;/code&gt; 和 &lt;code&gt;gtk-dark.css&lt;/code&gt;，那么为了让用户可以自选亮色暗色，只有提供两个不同的主题来解决问题。这也就是在 &lt;code&gt;Adwaita&lt;/code&gt; 和 &lt;code&gt;Arc&lt;/code&gt; 都提供了 &lt;code&gt;gtk-dark.css&lt;/code&gt; 的情况下仍然存在 &lt;code&gt;Adwaita-dark&lt;/code&gt; 和 &lt;code&gt;Arc-Dark&lt;/code&gt; 的原因。然后在主题添加了 &lt;code&gt;gtk-dark.css&lt;/code&gt; 之后，为了让 libhandy 的程序能够跟随系统开关切换亮色和暗色，就不能为了那些传统程序把 GTK Theme 设置为暗色变体的主题了，此时如果设置为同时包含两个文件的主题，默认这些程序会选择 &lt;code&gt;gtk.css&lt;/code&gt;，也就会出现上面截图里的情况。解决这个的方案也不是很困难，&lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt; 就是为此添加的，支持它的 GTK 程序会按照这个选项来加载 &lt;code&gt;gtk.css&lt;/code&gt; 或 &lt;code&gt;gtk-dark.css&lt;/code&gt;。如果你像我一样平时主要用暗色模式，那就手动编辑 &lt;code&gt;~/.config/gtk-4.0/settings.ini&lt;/code&gt; 写入以下内容（GTK 3 的话就是 &lt;code&gt;~/.config/gtk-3.0/settings.ini&lt;/code&gt;）：&lt;/p&gt;
&lt;figure data-raw=&quot;[Settings]
gtk-application-prefer-dark-theme=1
&quot; data-info=&quot;language-ini&quot; data-lang=&quot;ini&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-ini&quot;&gt;[Settings]
gtk-application-prefer-dark-theme=1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;你要是亮色爱好者，那就改成 &lt;code&gt;0&lt;/code&gt;。这下倒是满足原始人的刀耕火种需求了哈，毕竟他们看起来也不想要系统的亮色/暗色开关的样子，不过说不定以后哪天系统的亮色/暗色开关也会同时修改这个选项呢？只是读取这个选项的 GTK 程序不会像 libhandy/libadwaita 的程序那样会动态切换，必须要关了重开才行。&lt;/p&gt;
&lt;p&gt;还有一个奇怪的问题要注意，通常我们是在 GNOME Tweaks 里面设置 GTK Theme，不过根据 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-tweaks/-/blob/master/gtweak/tweaks/tweak_group_appearance.py#L75-L88&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-tweaks/-/blob/master/gtweak/tweaks/tweak_group_appearance.py#L75-L88&lt;/a&gt;，它会把上面那个 &lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt; 设置成 &lt;code&gt;0&lt;/code&gt;，看注释里面的 BUG 描述，应该也是为了某种刀耕火种的情况解决的（甚至那时候还推荐搞个单独的暗色主题，并且删除了全局的倾向暗色的开关），大概那时候还没推荐用 libhandy，也没有 libadwaita，也没有设置里这种全局暗色/亮色的开关。总之我不建议经常修改 GTK 主题，并且每次修改之后记得手动修改这个选项。如果你觉得这种反复横跳又要保证兼容以前的决策的行为很蠢，那我只能说毕竟你不能要求以前的开发者预见到未来的人们怎么定义桌面的功能。&lt;/p&gt;
&lt;p&gt;当然如果你毫不在乎亮色暗色切换（我就是要一直用暗色，所以你暗色模式给我选对了暗色主题就行了！），那还有个比较投机取巧的解决方案：把 Arc-Dark 的 &lt;code&gt;gtk.css&lt;/code&gt; 复制并改名 &lt;code&gt;gtk-dark.css&lt;/code&gt; 就可以了，原理不难理解。并且 Arc 主题已经做了这样的修改，只是还没有 Release（参见 &lt;a href=&quot;https://github.com/jnsh/arc-theme/commit/73ada8563591fa48ae365686a358e874ca12edad&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/jnsh/arc-theme/commit/73ada8563591fa48ae365686a358e874ca12edad&lt;/a&gt;）。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    <category term="GTK" label="GTK" scheme="https://sh.alynx.one/tags/GTK/" />
  </entry>
</feed>
