<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喵's StackHarbor</title>
  <subtitle>Whisper to the World</subtitle>
  <icon>https://sh.alynx.one/images/Mikoto_Karon_White.webp</icon>
  <link rel="self" type="application/atom+xml" href="https://sh.alynx.one/atom.xml" />
  <link rel="alternate" type="text/html" href="https://sh.alynx.one/" />
  <updated>2023-07-28T12:42:53.000Z</updated>
  <id>https://sh.alynx.one/</id>
  <author>
    <name>Alynx Zhou</name>
    <email>alynx.zhou@gmail.com</email>
  </author>
  <generator uri="https://github.com/AlynxZhou/hikaru-generator-feed/" version="v2.4.1">Hikaru Generator Feed</generator>
  <entry>
    <title>2023 年的 Arch Linux 安装指南</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/2023-Arch-Install/" />
    <id>https://sh.alynx.one/posts/2023-Arch-Install/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-07-28T12:42:53.000Z</published>
    <updated>2023-07-28T12:42:53.000Z</updated>
    <summary type="html">
      在安装 Arch Linux 之前，首先要准备 Arch Linux 的安装媒介。如果你打算安装在虚拟机里，那你并不需要一个实体的存储介质，因为虚拟机可以直接加载 iso 文件。但不管你在哪里安装，你都需要获取这个 iso 文件，引导进入其中的临时系统才能继续安装。 Arch L…
    </summary>
    <content type="html">
      &lt;p&gt;在安装 Arch Linux 之前，首先要准备 Arch Linux 的安装媒介。如果你打算安装在虚拟机里，那你并不需要一个实体的存储介质，因为虚拟机可以直接加载 iso 文件。但不管你在哪里安装，你都需要获取这个 iso 文件，引导进入其中的临时系统才能继续安装。&lt;/p&gt;
&lt;p&gt;Arch Linux 的安装镜像每月更新一次，如果你点开官网的下载页面，你会发现没有直接的下载链接，而是推荐你使用种子下载或者镜像站下载。这是一个非常有必要的要求，因为官方的服务器不能承受世界各地所有的请求流量，以上两种方法通过将单一的下载来源转换为多个下载来源有效的减轻了官方服务器的压力。&lt;/p&gt;
&lt;p&gt;考虑到当今种子下载并不是一个流行的下载方式，对于部分读者而言可能难以掌握，我们这里就选择镜像站下载。所谓的镜像站就是将官方服务器上的文件原样下载到自己的服务器上，然后给别人提供下载服务的服务器。有了镜像站，世界各地的用户就不必连接相对较远较慢的官方服务器，而可以就近选择镜像站，获取到完全一样的文件。&lt;/p&gt;
&lt;p&gt;我们可以打开某个镜像站同步 &lt;code&gt;archlinux&lt;/code&gt; 的目录，然后找到 &lt;code&gt;iso/latest&lt;/code&gt; 目录，里面的 &lt;code&gt;archlinux-x86_64.iso&lt;/code&gt; 就是我们需要的，以清华大学的镜像站为例，链接就是 &lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-x86_64.iso&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-x86_64.iso&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;注意！Arch Linux 官方只对 x86-64 架构提供支持，如果你的设备不是该架构（可能性很低，如果你不是该架构，你应该已经有足够的经验自己解决问题了），可能需要使用其它分支项目并参阅相关的文档。&lt;/p&gt;
&lt;p&gt;当下载好 iso 文件之后，需要准备对应的安装媒介，这需要一个实体的存储介质，光盘是最传统的安装媒介，这也导致了各种系统的安装程序都以光盘镜像（iso）的格式打包。但想必当今的用户寻找光盘和光驱可能有些难度，所以 U 盘成为了更流行的安装媒介，找出一个你没有使用的 U 盘，备份好原本的数据，然后连接到你下载了安装镜像的电脑上。&lt;/p&gt;
&lt;p&gt;如果你的电脑上已经运行了 Linux，那你可以通过 &lt;code&gt;dd&lt;/code&gt; 命令将 iso 文件写入到 U 盘里，Arch Linux 的安装镜像经过特殊处理，可以支持这样的 U 盘引导。首先通过 &lt;code&gt;lsblk -f&lt;/code&gt; 查看你的 U 盘对应的设备文件是什么，然后使用 &lt;code&gt;dd if=/PATH/TO/archlinux-x86_64.iso of=/dev/sdX&lt;/code&gt;，记得把 iso 和设备文件的路径改成你的实际路径，并且不要使用 U 盘分区的设备文件，而是使用代表整个 U 盘的设备文件。然后执行 &lt;code&gt;sync&lt;/code&gt;，让内核把内存里缓冲的数据写回磁盘，保证安装镜像完全写进 U 盘里面。&lt;/p&gt;
&lt;p&gt;但你也可能会说如果我有 Linux，我为什么要装 Linux？这种情况下我们推荐 Windows 用户使用 Rufus 创建安装 U 盘，这个软件下载即可运行，不需要安装，然后在软件里分别选择 iso 文件的位置和 U 盘设备，点击写入即可获得一个安装 U 盘。&lt;/p&gt;
&lt;p&gt;无论你使用哪种方式，接下来弹出 U 盘，准备重启电脑。不过要保证重启的时候 U 盘仍然在你的电脑上。现在的电脑应该都支持 UEFI 引导，你需要搜索你的主板型号得知你的电脑应该按什么按键进入启动设备选单，反正无非是 F8、DEL、Enter 中的一个，在显示主板 logo 的时候狂按，直到出现一个让你选择的菜单，使用键盘上的方向键选择你刚刚做好的安装 U 盘，然后按下 Enter 选择。等屏幕上走完启动流程，你应该就会自动登录进一个 Arch Linux 的环境。如果你开启了安全启动，那你需要关掉，因为 Arch Linux 的安装镜像并没有进行安全启动需要的签名，这里就不介绍具体如何关闭了，因为各家主板的界面都不一样，建议搜索引擎搜索自己的主板型号+关闭安全启动。&lt;/p&gt;
&lt;p&gt;Arch Linux 的安装环境是没有桌面的，你需要在命令行里自己调用各种命令完成一系列安装相关的操作，这样看起来比较难，但是也很灵活，可以根据自己的需要调整。首先你要做的是确定自己已经联网了，最简单的就是从路由器插一根网线到你的电脑上，这样应该就能上网了。如果你没有网线——那现在就该去买一根，比起现在给你讲清楚怎么在命令行下面连接无线网络，买网线更简单，真的。&lt;/p&gt;
&lt;p&gt;然后你应该使用 &lt;code&gt;date&lt;/code&gt; 命令查看系统时间是否重要，许多加密方式依赖时间正确，比如 https，因此如果它不正确，你应该改正它，不过大部分情况都是正确的。&lt;/p&gt;
&lt;p&gt;接下来你应该准备安装系统的磁盘分区，首先你得通过 &lt;code&gt;lsblk -f&lt;/code&gt; 找到要安装的硬盘，如果是 SATA 硬盘，它可能是 &lt;code&gt;/dev/sda&lt;/code&gt; 或者 &lt;code&gt;/dev/sdb&lt;/code&gt; 之类，如果是 NVMe 硬盘，那可能是 &lt;code&gt;/dev/nvme0n1&lt;/code&gt;，一般来说根据容量判断是不会错的。你的目标磁盘上应当留有一定的未分配空间给新系统使用。注意如果分区和格式化时操作错误，可能会让你丢失已有的重要数据，因此在进行操作前务必仔细确认。&lt;/p&gt;
&lt;p&gt;UEFI 引导的机器大部分都使用 GPT 分区表，当然这其实主要是 Windows 的限制，因此我们使用 &lt;code&gt;gdisk&lt;/code&gt; 进行分区，如果你使用的不是 GPT 分区表，那你可能需要自行了解一些相关知识。当你不知道该做什么的时候，输入 &lt;code&gt;?&lt;/code&gt; 可以显示帮助，输入 &lt;code&gt;p&lt;/code&gt; 可以打印当前的分区表，输入 &lt;code&gt;q&lt;/code&gt; 可以退出 &lt;code&gt;gdisk&lt;/code&gt;，只有输入 &lt;code&gt;w&lt;/code&gt; 才会真正修改硬盘上的分区表，所以如果你不确定就不要输入 &lt;code&gt;w&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;输入 &lt;code&gt;p&lt;/code&gt; 打出当前的分区表之后，你应该首先找到一个小的 FAT32 分区，一般会在磁盘的开头，容量不会超过 1G，这是你的 ESP 系统分区，UEFI 要求把引导文件放在这里。然后你应该按 &lt;code&gt;n&lt;/code&gt; 新建一个分区，一般它会自动计算未分配空间的开头，不过你也可以手动输入来纠正，然后输入新分区的结尾位置，也可以用 &lt;code&gt;+100G&lt;/code&gt; 的方式表示从开头位置创建一个 100G 的分区。一般只要分一个分区做 Linux 的根分区就好了，不过你有需要也可以创建更多的分区，比如你可能需要一个 swap 分区，那就用相同的办法创建一个。创建完你需要的分区之后，输入 &lt;code&gt;p&lt;/code&gt; 确认一下新的分区表，然后按 &lt;code&gt;w&lt;/code&gt; 写入分区表。&lt;/p&gt;
&lt;p&gt;接下来你需要在分好的分区上创建文件系统也就是格式化，因为分区表只是标记“从哪里到哪里属于哪个分区”，并没有在对应的位置创建实际的结构。比如你可以用 &lt;code&gt;mkfs.ext4 /dev/sdXY&lt;/code&gt; 格式化你刚创建的根分区，然后用 &lt;code&gt;mkswap /dev/sdXY&lt;/code&gt; 格式化你刚才创建的 swap 分区。记得在执行命令之前确认你使用的设备文件正确。然后你需要挂载你创建的分区到 &lt;code&gt;/mnt&lt;/code&gt;，稍候会向里面写入系统文件。首先用 &lt;code&gt;mount /dev/sdXY /mnt&lt;/code&gt;，把根分区挂载上，然后你需要创建其它分区的挂载点，比如 EFI 系统分区，对于这个如何挂载有很多种说法，不过我一般直接把它当作 boot 分区挂载，这样内核也会被安装到这个分区，有些预装 Windows 系统的电脑可能会分一个极小的 EFI 系统分区以至于放不下内核，那你可能需要查找更多资料，这不在这篇文章的讨论范围之内。总之先 &lt;code&gt;mkdir /mnt/boot&lt;/code&gt; 然后 &lt;code&gt;mount /dev/sdXY /mnt/boot&lt;/code&gt;。最后可以用 &lt;code&gt;swapon /dev/sdXY&lt;/code&gt; 启用你刚才创建的 swap 分区，这样记录新系统挂载点的时候就会记录这个 swap 分区。&lt;/p&gt;
&lt;p&gt;然后需要修改镜像站列表，和之前下载 iso 一样，系统需要的各种软件包也依靠镜像站提高分发效率。你需要用一个编辑器编辑 &lt;code&gt;/etc/pacman.d/mirrorlist&lt;/code&gt;，如果你没有熟悉的编辑器，那 &lt;code&gt;nano&lt;/code&gt; 应该是个适合新手的选择，因为各种操作需要的快捷键都会显示在屏幕底部，&lt;code&gt;^&lt;/code&gt; 代表 Ctrl，&lt;code&gt;M&lt;/code&gt; 代表 Alt，在列表里找到离你地理位置比较近的几个镜像站，然后删除对应的 &lt;code&gt;Server = &lt;/code&gt; 前面的 &lt;code&gt;#&lt;/code&gt; 来启用这个镜像站，一般启用两三个就足够了。&lt;/p&gt;
&lt;p&gt;然后就可以正式安装软件包到创建的分区了！使用 &lt;code&gt;pacstrap -K /mnt base base-devel linux linux-firmware&lt;/code&gt; 安装软件包到 &lt;code&gt;/mnt&lt;/code&gt;，你可以在后面附加更多你需要的软件包以便一并安装，甚至如果你不想第一次启动新系统还是命令行的话，也可以在这一步直接附加桌面环境进去。这里我贴一个基于我常用软件总结的列表作为参考：&lt;/p&gt;
&lt;figure data-raw=&quot;base base-devel linux linux-firmware man-db man-pages btrfs-progs vim nano git rsync gnome gdm networkmanager firefox meson ninja efibootmgr haveged ibus-rime ffmpeg noto-fonts noto-fonts-cjk noto-fonts-emoji ntfs-3g btop p7zip parallel tree ttf-roboto unrar unarchiver wget usbutils bind
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;base base-devel linux linux-firmware man-db man-pages btrfs-progs vim nano git rsync gnome gdm networkmanager firefox meson ninja efibootmgr haveged ibus-rime ffmpeg noto-fonts noto-fonts-cjk noto-fonts-emoji ntfs-3g btop p7zip parallel tree ttf-roboto unrar unarchiver wget usbutils bind
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你和我有不同的偏好，你应该已经清楚如何安装你需要的软件，我在这里只以我自己使用的软件作为例子。为了方便使用，我在这一步直接安装了桌面环境，但桌面环境需要有可用的显卡驱动，对于 Intel 和 AMD，它们的开源驱动已经足够好用，应该会自动引入 &lt;code&gt;mesa&lt;/code&gt; 所以没什么需要额外操作的，但是对于 NVIDIA，你还需要安装 &lt;code&gt;nvidia&lt;/code&gt; 这个包来引入 NVIDIA 的闭源驱动。&lt;/p&gt;
&lt;p&gt;然后等待下载安装即可，现在大家的带宽都很高，如果确实选了离自己近的镜像站，这个步骤应该花不了多少时间。&lt;/p&gt;
&lt;p&gt;然后读取你对新系统的挂载信息并写入到新系统里，以便新系统基于这个数据挂载硬盘，使用 &lt;code&gt;genfstab -U /mnt &amp;gt;&amp;gt; /mnt/etc/fstab&lt;/code&gt; 即可。&lt;/p&gt;
&lt;p&gt;现在你的新分区里应该有一个新系统需要的各种文件了，但是你还需要对它进行各种设置，首先需要 chroot 到新的系统，这是一个 Linux 内核的功能，可以让你以另一个文件系统作为根目录从而操作其中的各种文件，这里使用 &lt;code&gt;arch-chroot /mnt&lt;/code&gt; 进入新系统的根目录。&lt;/p&gt;
&lt;p&gt;然后你要指定自己新系统的时区，比如你使用的时区是 &lt;code&gt;Asia/Shanghai&lt;/code&gt;，那可以执行 &lt;code&gt;ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime&lt;/code&gt;，你也可以将 &lt;code&gt;Asia/Shanghai&lt;/code&gt; 修改为其它的时区，所有可用的时区都以目录和文件的形式列在 &lt;code&gt;/usr/share/zoneinfo/&lt;/code&gt; 下面。&lt;/p&gt;
&lt;p&gt;然后你需要执行 &lt;code&gt;hwclock --systohc&lt;/code&gt;，这会假设你的 BIOS 时间是 UTC，这和 Windows 默认的假设不一致，Windows 认为你的 BIOS 时间就是本地时间。可以让 Linux 认为 BIOS 时间是本地时间，但是可能会导致各种问题，同样也有办法让 Windows 认为 BIOS 时间是 UTC 时间，只需要随便新建一个文本文档，写入如下内容：&lt;/p&gt;
&lt;figure data-raw=&quot;Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]
&amp;quot;RealTimeIsUniversal&amp;quot;=dword:00000001
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]
&quot;RealTimeIsUniversal&quot;=dword:00000001
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后保存并修改扩展名为 &lt;code&gt;.reg&lt;/code&gt;，然后双击导入注册表项并重启。&lt;/p&gt;
&lt;p&gt;接下来修改本地化相关内容，首先是 glibc 需要对不同的语言生成不同的配置，需要用编辑器编辑 &lt;code&gt;/etc/locale.gen&lt;/code&gt; 文件，必须要启用的是 &lt;code&gt;en_US.UTF-8 UTF-8&lt;/code&gt;，别的可以按需求启用你需要的，只要删掉开头的 &lt;code&gt;#&lt;/code&gt;，注意只要启用带 &lt;code&gt;UTF-8&lt;/code&gt; 的就可以。不过这一步也可以略过其他的只启用英语，然后在桌面环境里修改语言的话桌面环境应该会自动处理相关的文件。然后运行 &lt;code&gt;locale-gen&lt;/code&gt;，它会根据上述文件的内容具体生成对应文件。&lt;/p&gt;
&lt;p&gt;然后创建 &lt;code&gt;/etc/locale.conf&lt;/code&gt; 文件，写入你当前使用的 &lt;code&gt;LANG&lt;/code&gt; 变量，不过其实 tty 不能显示中文，所以这一步推荐设置成英文，等到桌面起来了再改也来得及，因此推荐写入 &lt;code&gt;LANG=en_US.UTF-8&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;网络相关的配置首先需要设置 hostname，这一步只要打开 &lt;code&gt;/etc/hostname&lt;/code&gt; 文件写入你想要的主机名就行了。我的习惯是使用 NetworkManager 管理网络连接，因此需要设置让系统下次启动时启用 NetworkManager，只要 &lt;code&gt;systemctl enable NetworkManager&lt;/code&gt; 就可以。NetworkManager 会自动管理你的网卡，比如有线网卡就会自动尝试 DHCP，同时也提供和桌面环境的集成，方便使用无线网卡。&lt;/p&gt;
&lt;p&gt;一些无线网卡需要的固件可能被单独划分在别的包里，此时你可以安装这些包，比如高通的网卡就是 &lt;code&gt;pacman -S linux-firmware-qcom&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后你需要进行启动相关的设置，首先你得生成 initramfs，这个东西解决的问题是“需要加载模块才能读取对应的文件系统，但模块就存在那个文件系统上”这种问题，为了打破鸡生蛋还是蛋生鸡的循环，解决方法就是创建一个非常小的包含必要模块的文件，和内核放在一起，保证启动时可以加载这个文件。生成这个文件很简单，因为我们没有什么特殊的配置，只要执行 &lt;code&gt;mkinitcpio -P&lt;/code&gt; 就行了。&lt;/p&gt;
&lt;p&gt;同时现代的 CPU 都支持加载微码来热修复 CPU 的 bug，这也是通过在启动时加载相关的文件实现，首先需要安装对应的微码包，如果是 Intel 就 &lt;code&gt;pacman -S intel-ucode&lt;/code&gt;，AMD 就 &lt;code&gt;pacman -S amd-ucode&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后你还需要一个 bootloader 加载你的内核和 initramfs，最流行功能最全的是 GRUB，但我觉得 systemd-boot 也完全够用了，所以我选择 systemd-boot。因为已经安装了 systemd 所以就不需要额外安装什么了，只要 &lt;code&gt;bootctl install&lt;/code&gt;，就可以安装引导需要的文件。&lt;/p&gt;
&lt;p&gt;但我们仍然需要告诉 loader 去哪里加载内核，加载哪个内核。systemd-boot 需要我们手动编写配置文件记录这些内容。首先需要 &lt;code&gt;mkdir /boot/loader/entries&lt;/code&gt; 建立用于放置不同内核启动项的文件，然后再编辑 &lt;code&gt;/boot/loader/entries/arch.conf&lt;/code&gt; 给默认的内核编写一个文件。&lt;/p&gt;
&lt;p&gt;一个配置文件推荐包含以下内容：&lt;/p&gt;
&lt;figure data-raw=&quot;title   Arch Linux
linux   /vmlinuz-linux
initrd	/amd-ucode.img
initrd  /initramfs-linux.img
options root=&amp;quot;UUID=xxxx-xxxx-xxxx&amp;quot; rw add_efi_memmap
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;title   Arch Linux
linux   /vmlinuz-linux
initrd	/amd-ucode.img
initrd  /initramfs-linux.img
options root=&quot;UUID=xxxx-xxxx-xxxx&quot; rw add_efi_memmap
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;基本上你需要改的有两处，一个是如果是 Intel 就把 &lt;code&gt;amd-ucode&lt;/code&gt; 改成 &lt;code&gt;intel-ucode&lt;/code&gt;，另一个是要把内核参数里 &lt;code&gt;root=&lt;/code&gt; 的值设置为你的根分区，以便内核找到你真正的根分区。这个可以通过打开 &lt;code&gt;/etc/fstab&lt;/code&gt; 找到里面挂载到 &lt;code&gt;/&lt;/code&gt; 的设备得到需要的值。&lt;/p&gt;
&lt;p&gt;然后你需要编辑 &lt;code&gt;/boot/loader/loader.conf&lt;/code&gt;，这是给 loader 的配置，其实只需要一行 &lt;code&gt;default arch.conf&lt;/code&gt;，告诉 loader 默认加载 arch 内核的配置就可以了。&lt;/p&gt;
&lt;p&gt;最后需要进行密码配置，首先执行 &lt;code&gt;passwd&lt;/code&gt; 设置 root 密码。由于 root 权限太高，平时不建议使用 root 操作，所以我们可以通过 &lt;code&gt;useradd -m newuser&lt;/code&gt; 创建一个普通用户，&lt;code&gt;-m&lt;/code&gt; 的意思是会自动给用户创建同名的 home 目录存储用户相关的文件，你也可以把 &lt;code&gt;newuser&lt;/code&gt; 改成任何你想要的用户名。然后执行 &lt;code&gt;passwd newuser&lt;/code&gt; 给这个新用户设置密码。同时为了方便进行高权限操作，我们需要允许新用户执行 &lt;code&gt;sudo&lt;/code&gt;，首先执行 &lt;code&gt;EDITOR=nano visudo&lt;/code&gt; 编辑 sudoers 文件，找到 &lt;code&gt;root ALL=(ALL) ALL&lt;/code&gt; 一行，然后在下面插入 &lt;code&gt;newuser ALL=(ALL) ALL&lt;/code&gt;（记得用你想要的用户名），保存即可。&lt;/p&gt;
&lt;p&gt;然后运行 &lt;code&gt;systemctl enable gdm&lt;/code&gt;，这会告诉系统启动时启用 GNOME 显示管理器，下次启动时你就会得到图形界面并可以直接登录进桌面。此时关于新系统的设置都已基本完成，执行 &lt;code&gt;exit&lt;/code&gt; 退出 chroot，然后执行 &lt;code&gt;reboot&lt;/code&gt; 重启电脑，你应该可以在 UEFI 启动选单里找到 Linux Boot Manager，选择就会启动新安装的 Arch Linux。&lt;/p&gt;
&lt;p&gt;由于此时应该已经启动图形界面了，对于桌面的各种设置只要在图形界面的设置程序里设置即可，就不需要专门讲述怎么用了。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/Arch%20Linux/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/tags/Arch%20Linux/" />
  </entry>
  <entry>
    <title>DaVinci Resolve 奇怪的素材位置计算逻辑</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/" />
    <id>https://sh.alynx.one/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-07-28T07:20:02.000Z</published>
    <updated>2023-07-28T07:20:02.000Z</updated>
    <summary type="html">
      &lt;p&gt;上一篇文章提到了 DaVinci Resolve 对于素材位置的计算逻辑非常奇怪并且不肯修改，这篇我试图概括一下具体的计算逻辑方便自己使用。如果你也遇到了同样的问题并且希望他们改进，可以去支持 &lt;a href=&quot;https://forum.blackmagicdesign.com/viewtopic.php?f=33&amp;amp;t=179153&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;我发的帖子（英语）&lt;/a&gt;。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;上一篇文章提到了 DaVinci Resolve 对于素材位置的计算逻辑非常奇怪并且不肯修改，这篇我试图概括一下具体的计算逻辑方便自己使用。如果你也遇到了同样的问题并且希望他们改进，可以去支持 &lt;a href=&quot;https://forum.blackmagicdesign.com/viewtopic.php?f=33&amp;amp;t=179153&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;我发的帖子（英语）&lt;/a&gt;。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%87%86&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/#%E8%AE%A1%E7%AE%97%E5%9F%BA%E5%87%86&quot;&gt;&lt;/a&gt;计算基准&lt;/h1&gt;
&lt;p&gt;缩放/裁切/位置永远以原图大小作为基准，不会互相影响。&lt;/p&gt;
&lt;p&gt;项目设置里有“缩放原图至适配大小且不出现裁切”和“不调整原图大小并裁切超出部分”两个比较合理的选项，“缩放原图至适配大小且不出现裁切”可以理解为插入时间线之前就改变了原图大小。例如画布尺寸 1920x1080，素材尺寸 512x512，选择“缩放原图至适配大小且不出现裁切”，相当于用外部命令把素材缩放到 1080x1080 然后再插入时间线，后续缩放/裁切/位置均以 1080x1080 作为基准。&lt;/p&gt;
&lt;h1 id=&quot;%E7%BC%A9%E6%94%BE&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/#%E7%BC%A9%E6%94%BE&quot;&gt;&lt;/a&gt;缩放&lt;/h1&gt;
&lt;p&gt;缩放变换只计算原图大小。&lt;/p&gt;
&lt;p&gt;缩放变换默认以素材中心作为基准。由于位置变换计算太复杂了，不考虑改变锚点参数的情况。&lt;/p&gt;
&lt;h1 id=&quot;%E8%A3%81%E5%88%87&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/#%E8%A3%81%E5%88%87&quot;&gt;&lt;/a&gt;裁切&lt;/h1&gt;
&lt;p&gt;裁切只计算原图大小。无论素材的缩放变换参数是多少，都使用原图大小计算结果。&lt;/p&gt;
&lt;p&gt;例：画布 1920x1080，素材 512x512。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择“缩放原图至适配大小且不出现裁切”，此时原图大小是 1080x1080，左侧裁切 50% 应输入 &lt;code&gt;1080 * 50% = 512&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择“不调整原图大小并裁切超出部分”，此时原图大小是 512x512，左侧裁切 50% 应输入 &lt;code&gt;512 * 50% = 256&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于位置变换计算太复杂了，不考虑勾选“保留图片位置”的情况。&lt;/p&gt;
&lt;h1 id=&quot;%E4%BD%8D%E7%BD%AE&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Strange-Logic-of-DaVinci-Resolve-on-Calculating-Clip-Position/#%E4%BD%8D%E7%BD%AE&quot;&gt;&lt;/a&gt;位置&lt;/h1&gt;
&lt;p&gt;位置变换只计算原图大小。无论素材的缩放变换参数和裁切参数是多少，都使用原图大小计算结果。&lt;/p&gt;
&lt;p&gt;DaVinci Resolve 对于素材位置输入框使用特殊的计算逻辑（怀疑是 bug），假设画布宽度为 &lt;code&gt;canvas_width&lt;/code&gt;，画布高度为 &lt;code&gt;canvas_height&lt;/code&gt;，原图宽度为 &lt;code&gt;clip_width&lt;/code&gt;, 原图高度为 &lt;code&gt;clip_height&lt;/code&gt;，如果想将素材水平方向移动 &lt;code&gt;x&lt;/code&gt; 像素，垂直方向移动 &lt;code&gt;y&lt;/code&gt; 像素，则需要填入的数据需要按照 &lt;code&gt;f(x) = x / clip_width * canvas_width&lt;/code&gt; 和 &lt;code&gt;f(y) = y / clip_height * canvas_height&lt;/code&gt; 进行计算。注意，按此计算逻辑，填入的两个数据的比例显然和实际移动的像素比例不同。&lt;/p&gt;
&lt;p&gt;例：画布 1920x1080，素材 512x512。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择“缩放原图至适配大小且不出现裁切”，此时原图大小是 1080x1080，向左移动 540 像素应输入 &lt;code&gt;540 / 1080 * 1920 = 960&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;选择“不调整原图大小并裁切超出部分”，此时原图大小是 512x512，向左移动 540 像素应输入 &lt;code&gt;540 / 512 * 1920 = 2025&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;

    </content>
    <category term="摄影" label="摄影" scheme="https://sh.alynx.one/categories/%E6%91%84%E5%BD%B1/" />
    <category term="摄影" label="摄影" scheme="https://sh.alynx.one/tags/%E6%91%84%E5%BD%B1/" />
  </entry>
  <entry>
    <title>首先是犯下傲慢之罪的闭源拖拉机</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Firstly-The-Arrogant-Closed-Source-Tractor/" />
    <id>https://sh.alynx.one/posts/Firstly-The-Arrogant-Closed-Source-Tractor/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-07-28T03:20:51.000Z</published>
    <updated>2022-07-28T11:26:00.000Z</updated>
    <summary type="html">
      &lt;p&gt;很遗憾的，我们没有生活在可以完全只使用开源软件的世界里，所以有时候不得不忍受一些闭源拖拉机的傲慢。一个经典的情况就是明明用户花了钱，还是得当孙子——我指的是用户反馈完全没有开发者看这件事情。或者更进一步，我认为 GitHub 或者 GitLab 的 issue （或者 bugzilla）是比用户论坛更好的反馈工具。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;很遗憾的，我们没有生活在可以完全只使用开源软件的世界里，所以有时候不得不忍受一些闭源拖拉机的傲慢。一个经典的情况就是明明用户花了钱，还是得当孙子——我指的是用户反馈完全没有开发者看这件事情。或者更进一步，我认为 GitHub 或者 GitLab 的 issue （或者 bugzilla）是比用户论坛更好的反馈工具。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;一个发生在我身上的例子是 PowerAMP，我曾经是它的付费用户（现在也是付费用户，但并不是活跃用户）。PowerAMP 有这样一个问题，当你搜索一首歌的时候，你必须输入两个或以上的字符搜索才会启动。这对于英语歌来说不是什么问题，因为大部分单词都是两个字符以上，几乎不会出现需要依靠一个字符查找歌曲的情况。但假如你是一个不会假名的日语歌爱好者，你想要依赖标题里某个你认识的汉字搜索到你想要的歌，这时候 PowerAMP 的搜索就是完完全全的废物。至少对于我自己来说这个需求曾经切实存在了很长一段时间。我不是没有尝试给开发者反馈，PowerAMP 有一个自己的论坛用作用户反馈工具，但过了两年也没有人回复 &lt;a href=&quot;https://forum.powerampapp.com/topic/20907-start-searching-after-just-typing-1-character-instead-of-2/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;我的帖子&lt;/a&gt;。如果开发者完全不看用户反馈，或者只看热度高的用户反馈，那这论坛还有什么意义呢？&lt;/p&gt;
&lt;p&gt;所以非常搞笑的结论发生了，我作为一个付费用户，最终的解决方案是我去学了五十音，不过这也没有完全解决问题，我意识到即使这样，仍然存在无法解决的情况：比如标题只有一个汉字的歌，你永远也不可能在 PowerAMP 里通过标题搜索到它（那英点了个赞并评论“最烦装逼的播放器作者”）。我甚至已经脑补出了作者洋洋自得地写下 &lt;code&gt;if (str.length &amp;lt; 2) return;&lt;/code&gt; 以为自己对搜索做了天才般的优化，但在他可怜的脑袋里却找不到高德纳那句著名的“过早优化是万恶之源”，甚至用户的反馈也被他忽略掉了。最终我选择放弃这个自以为是的闭源拖拉机，换了一些功能没这么多，但却没有这个过早优化的替代品。&lt;/p&gt;
&lt;p&gt;更新（2022-07-28T19:26:00）：Arch Linux CN 社区里的 @weearc⚝ 跟我说他的 PowerAMP 输入单个字符是可以搜索的，这让我很疑惑，我又重新下载安装了一个 PowerAMP，但我的却仍然不行。我们俩研究一番后才发现问题所在：如果安装过后直接点导航栏的搜索，必须要输入两个或以上字符才能开始搜索。但如果在媒体库页面点击所有歌曲，然后点击列表标题下的搜索按钮，此时输入一个字符就会开始搜索。具体的原因可能是因为这时搜索添加了一个“所有歌曲”的过滤器，只搜索本地歌曲。大概是作者自以为是的决定限制包含在线源的搜索的启动条件来减少在线搜索的启动次数，不管怎么说这也属于一个过早优化，而且对我这种完全不使用在线功能的用户而言除了徒增迷惑之外没有任何的好处。虽然添加了“所有歌曲”的过滤器之后再从导航栏启动搜索仍然会带这个过滤器，可以作为一个 workaround 解决我的问题，我还是认为这对中文歌曲不是很友好。这次我发现 app 内的“联系我们”功能会给作者发邮件，于是我写了封邮件反馈这个不一致，希望他记得查看自己的邮箱。&lt;/p&gt;
&lt;p&gt;另一个我亲身经历的问题是 DaVinci Resolve，但是好话说在前头，比起大部分不友好的闭源软件开发商，BlackMagic
 Design 已经是班级里的三好学生了，我们就不提比如官方支持 Linux 这样大家都知道的优点，而是说一下同样的论坛反馈问题。Linux 版本的 DaVinci Resolve 不支持 Linux 上两种常见的输入法，而作为购买了 Studio 版的付费用户，我自然是积极的在官方论坛反馈了这个问题，结果嘛比 PowerAMP 好那么一点，一个 BlackMagic Design 的员工看到了我的帖子并把它移动到了 Feature Request 分区，然后就没有然后了。&lt;/p&gt;
&lt;p&gt;在某些人试图为拿走他们钱的闭源软件开发商找“也许是 Linux 输入法太多支持起来太麻烦他们真的没有足够人力做”的借口之前，我要先发制人说明一下，这其实也是个“一行代码”就能解决的问题，甚至并不需要 BlackMagic Design 写实际的代码。DaVinci Resolve 使用 Qt 作为界面库，Qt 本身就做好了 Linux 下面常见输入法的支持，只要在构建时候打开开关就可以，所以问题的关键在于他们的团队里没有人意识到 Linux 下面的 CJK 用户需要打开这个开关，也没有人愿意去做打开构建开关这个简单的工作，只是让反馈的帖子烂在论坛里。甚至更进一步，为什么我这么确定只需要做这么简单的工作呢？因为我自己发现了一个 workaround，只要把系统里 Qt 输入法插件的 &lt;code&gt;.so&lt;/code&gt; 文件复制到 DaVinci Resolve 自带的 Qt 的对应目录，一切就完全工作了，所以可以充分说明并不是存在什么难以克服的障碍。（如果你也需要解决这个问题，具体的操作请阅读 &lt;a href=&quot;/posts/Input-Method-Support-for-DaVinci-Resolve-on-Linux/&quot;&gt;DaVinci Resolve 在 Linux 下的输入法支持&lt;/a&gt;。）&lt;/p&gt;
&lt;p&gt;说到 DaVinci Resolve，他们还有一个令人迷惑的坐标计算问题。比如你在尺寸为 3840x2160 的画布里放进一个 200x200 的图片素材，然后想让这个图片向右移动这个图片的宽度，你应该输入多少呢，答案并不是 200，而是 3840。具体的计算逻辑大概是 &lt;code&gt;f(x) = x / clip_width * canvas_width&lt;/code&gt;（计算纵坐标则需要换成高度，这样你横纵坐标看起来和实际位移完全不成比例），而这只是最简单的情况，如果你再对素材进行缩放，然后再进行裁切，那计算逻辑我也说不清楚是怎么回事了。如果你访问它的用户论坛，你会发现需要精确输入坐标的用户都对这个计算逻辑感到迷惑（相关的内容聚集在 &lt;a href=&quot;https://forum.blackmagicdesign.com/viewtopic.php?f=21&amp;amp;t=166202&amp;amp;sid=be6eee42737d87cb59463a6f3f3069c0&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这个帖子（英语）&lt;/a&gt;），并且这还导致了其它问题（用这个算法你可能需要输入极大的数值来挪动一个很小的素材，于是就会撞到输入框的数字上限）。但 BlackMagic Design 完全没有修改这个逻辑的想法。我可以理解为是怕影响兼容性，但完全可以添加一个设置项，如果勾选就保持以前的计算逻辑。这又是一个用户反馈了却被忽略的例子。&lt;/p&gt;
&lt;p&gt;但如果你读到这里觉得闭源软件的用户论坛就是最烂的反馈工具，那你还是太高估了闭源软件开发商的下限了。另一个我亲身经历的例子来自亲爱的 Micro$oft，作为 RDP 的标准制定者，微软的 Android RDP 客户端基本可以认为是实质上的官方实现，但 gnome-remote-desktop 的开发者遇到了 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-remote-desktop/-/issues/99&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;客户端内不能正确显示视频（英语）&lt;/a&gt; 的问题，导致这个问题的原因是 Microsoft 的 Android RDP 客户端写死了 image stride，导致读取错误，老实说这不是什么大不了的问题，改掉就好了嘛。于是我就积极主动的去该 app 的 Play Store 页面打算写评论，但是我看到应用简介里说“我们不会看 Play Store 评论，如果你要反馈问题，请发送至 &lt;code&gt;rdandr@microsoft.com&lt;/code&gt;”，于是我又写了封邮件描述相关的问题，然后被气了个半死：一封自动回复的邮件告诉我你应该到这个链接反馈问题，点开那个链接我得到一个大大的 &lt;code&gt;Error 404 This UserVoice instance is no longer available.&lt;/code&gt;。说不定这些傲慢的开发者还在沾沾自喜：我们的软件质量真好，竟然没有用户反馈问题！（不过我刚才又查看了一下 Play Store 页面，现在他们换成了一个反馈链接，我暂时还没有测试这个链接是否可用。）&lt;/p&gt;
&lt;p&gt;所以这其实是我推崇开源软件的原因之一：通常来说开源软件的开发者都很重视用户反馈，并且会建立良好的反馈渠道。即使你遇到了一个“知道错了，但我不改”的开发者，你也可以尝试自己动手修改代码解决问题，然后提交给他或者自己维护 patch。但对于闭源软件这显然不现实，你只能希望开发者大发慈悲常来看用户论坛并注意到你的反馈。&lt;/p&gt;
&lt;p&gt;另一方面，issue 大概是比用户论坛更好的反馈工具。虽然对于闭源软件开发商，很难找到相关的例子，不过 Valve 就是这么一个独特的例子。以前他们使用 GitHub Issue 作为 DOTA 2 和 CSGO 的 Linux / macOS 版本的反馈渠道，后来更进一步鼓励玩家在 GitHub Issue 上反馈 DOTA 2 的 bug。虽然 Valve 也存在“知道错了，但我不改”这种情况（比如 Steam Linux 版的输入法支持，但这个和他们使用了自己编写的 UI 框架有关系，大概解决起来有难度），但他们的开发者确实会看 GitHub Issue，并处理玩家的反馈（比如在官网 &lt;a href=&quot;https://www.dota2.com/newsentry/3640648066072340345&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;最新的一篇文章（英语）&lt;/a&gt; 里提到很多用户在 GitHub 上反馈了炸弹人的新 bug）。&lt;/p&gt;
&lt;div class=&quot;center&quot;&gt;
  &lt;img alt=&quot;1.png&quot; title=&quot;一位 DOTA 2 玩家正在学习使用 GitHub Issue……呃，这可能是个错误示范……&quot; src=&quot;/posts/Firstly-The-Arrogant-Closed-Source-Tractor/1.png&quot;&gt;
&lt;/div&gt;

&lt;p&gt;但，是什么导致 issue 在用户反馈上比用户论坛效果更好呢？毕竟本质上二者都是“发帖”“回复”的流程，我尝试分析一下其中的不同。&lt;/p&gt;
&lt;p&gt;一个我认为很重要的区别是社区文化，或者说是谁在使用相关的工具：2023 年，完全没有接触过开源项目的程序员应该是不存在的，也就是说如果你是开发者，你大概率早就使用过 GitHub 或者 GitLab 这样的工具，issue 对你来说是一个你会去重视或至少会去看的东西。而论坛更大概率不是开发者直接运营，也许是什么专门的论坛客服在处理，他们可能并不懂技术，或者就算开发者会参与进用户论坛，论坛帖子对程序员来说也不是什么一定要看的东西。当用户遇到问题的时候，向开发者直接反馈应当是解决问题最直接的途径，如果在用户和开发者之间插入一层不懂技术的客服，那大概率是场灾难。（我真的没有在针对什么“微软社区支持专员”哦，真的没有。）&lt;/p&gt;
&lt;p&gt;另一个可能的原因也许是排序方式：issue 默认是按发布时间而不是回复时间排列的，因此开发者大概率会逐个查看新出现的 issue 并处理。但论坛通常默认以回复时间排列，更加重视“热度”，于是很容易出现一个问题不太热门就完全被忽略掉的情况，但对于软件开发而言，不应该因为一个问题热度不高就完全置之不理，因为热度可能受很多其它因素影响，比如用户主要使用的语言和开发者不同，反馈时存在语言或者网络障碍，热度不能直观地反映出程序本身的问题。&lt;/p&gt;
&lt;p&gt;但也许上述区别只决定了开发者能不能看到用户反馈，另一个决定性因素是开发者想不想看到用户反馈。我个人是觉得对于软件质量的追求应该是程序员自发的而不是被迫的，所以对用户反馈更应当积极处理。不得不承认，相似体量的项目，开源项目的开发者比起闭源项目的开发者好像确实是更有责任感一点。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="吐槽" label="吐槽" scheme="https://sh.alynx.one/tags/%E5%90%90%E6%A7%BD/" />
  </entry>
  <entry>
    <title>PipeWire 和 HDMI 音频和虚拟设备和复合/分离通道</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/" />
    <id>https://sh.alynx.one/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-05-11T13:25:05.000Z</published>
    <updated>2023-06-07T08:47:45.000Z</updated>
    <summary type="html">
      &lt;p&gt;这篇文章同时有 &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;中文版本&lt;/a&gt; 和 &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;英文版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;This post is both available in &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;Chinese version&lt;/a&gt; and &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;English version&lt;/a&gt;.&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;这篇文章同时有 &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;中文版本&lt;/a&gt; 和 &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;英文版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;This post is both available in &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;Chinese version&lt;/a&gt; and &lt;a href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;English version&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;&lt;/a&gt;中文版本&lt;/h1&gt;
&lt;p&gt;认识的朋友里很少有人有像我这么复杂的音频系统。长话短说，为了能让 PS4、Switch 和电脑分享一个扬声器，我把它接在了显示器上而不是电脑的内置声卡上，这样所有设备都通过 HDMI/DP 输出音频到扬声器。一开始这也没什么，后来我又添置了一块显示器，我发现在 Linux 下面经常搞不清楚究竟哪一个音频设备才是连接着扬声器的显示器，可能上周还是 HDMI 1，这周就变成 HDMI 2，而且也不是每次都会变，导致我经常需要试试才知道哪一个是我需要的。直到前天我忍不了了，决定发挥动手能力解决这个问题。&lt;/p&gt;
&lt;p&gt;一开始我以为是 PipeWire 给设备排序的时候是随机排序的，那简单，只要我找到每个设备对应的 ID，然后关掉没有扬声器的那个 HDMI 输出就可以了。但是我发现似乎 PipeWire 只是按照 ALSA 给出的设备编号来排序，并没有自己编号，于是就算关闭一个设备，下次被关闭的也可能是另一个。然后我就在想难道 ALSA 没有固定 HDMI 音频设备的功能吗？毕竟就算是显示器也是有 EDID 这种东西的，于是我查了各种 ALSA 的资料，确实是可以通过 udev 指定不同声卡的顺序，但对于 HDMI 这种属于同一个声卡的不同端口的设备没什么办法。我甚至查到了 NVIDIA 关于显卡音频的文档，里面说每个端口会有一个叫做 ELD 的数据，描述了连接的显示器信息，不过通过 &lt;code&gt;cat /proc/asound/cardX/eld*&lt;/code&gt; 查看之后我发现这个标准最多只给到显示器的型号，而我为了不在多显示器缩放上浪费精力，买了两台同样型号的显示器，没有序列号字段就还是没办法分辨不同的显示器！当然如果你的 HDMI 设备的型号不同，那其实就简单了，ALSA 现在会读取 ELD 里面的显示器型号，然后 PipeWire 会把这个作为 &lt;code&gt;node.nick&lt;/code&gt; 属性，你可以直接通过这个属性分辨设备，也可以利用这个属性写 WirePlumber 重命名规则修改你的桌面环境会用到的属性，就可以固定名称了。不过我还得继续寻求帮助。&lt;/p&gt;
&lt;p&gt;于是我就在公司的 research 邮件列表发了封邮件讲述了我的设备连接方式和需求，结果 Takashi Iwai（内核音频子系统的维护者之一）回复我说确实没有什么办法，音频驱动只是按照显卡给的顺序分配编号，所以大概率是随机的。特别是我还发现这玩意好像也不一定按照显示器输出的顺序来排号，于是 Plan A 是彻底行不通了。那我还有 Plan B 和 Plan C。&lt;/p&gt;
&lt;p&gt;和其它同事给的建议一样，其中一个想法是购买一个硬件的混合器，把两台显示器的音频输出硬件连接到同一个扬声器的输入，甚至一个同事还给我画了电路图说你只要这样就能自己做一个了。不过这个方案既有优点也优缺点，优点是电脑和游戏机可以同时发声，缺点是我要在电脑上修改音量就得始终记得把两个音量都改成一样的。我对前者需求不大，所以打算最后再尝试这个。&lt;/p&gt;
&lt;p&gt;当然有硬件的解法就有软件的解法，PipeWire 和 JACK 一样可以进行基于图的连接，那我只要搞一个虚拟的输出设备然后把两个 HDMI 设备跟它连一起不就行了？Arch Wiki 上恰好有一段 &lt;a href=&quot;https://wiki.archlinux.org/title/WirePlumber#Simultaneous_output_to_multiple_sinks_on_the_same_sound_card&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;同时向一块声卡上的不同端口输出音频&lt;/a&gt; 的文档，我本来以为照做即可，但发现还是不对，并没有出现我想象中的一个新音频设备。不过后来我仔细研究，搞懂了里面各种术语，才知道是怎么回事。&lt;/p&gt;
&lt;p&gt;首先我发现这一段文档其实只是描述如何创建一个“能同时显示两个 mapping 的 profile”，那到底什么是 mapping 什么是 profile？Mapping 可以理解成声卡上的某一种输入/输出组合，然后 profile 决定当前可以在哪几种组合中选择。举例来说就是假如你有一个 2 进 4 出的音频设备，那它可以是只有双声道输出，只有四声道输出，或者双声道输入四声道输出等等组合，这就是不同的 profile。为什么要同时输出不同端口需要创建一个 profile 呢，因为默认 ALSA 采用的是 auto-profile，会给每一个 mapping 创建一个 profile，而默认的一个 mapping 就是一个 HDMI 端口，因此假如你打开 pavucontrol 或者 Helvum，会发现如果不切换 profile，两个 HDMI 设备只能显示一个，也就没法给它们同时连接。当然你可能又会问为什么 GNOME Shell 里面又能显示两个 HDMI 设备？因为 &lt;code&gt;libgnome-volume-control&lt;/code&gt; 是先枚举设备然后枚举端口，并不是直接枚举端口（受 profile 影响），选择端口的时候再自动切换 profile。&lt;/p&gt;
&lt;p&gt;所以第一步是创建一个新的 profile sets，比如我创建的是 &lt;code&gt;/usr/share/alsa-card-profile/mixer/profile-sets/hdmi-multiple.conf&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;[General]
auto-profiles = no

[Mapping hdmi-stereo]
description = Digital Stereo (HDMI)
device-strings = hdmi:%f
paths-output = hdmi-output-0
channel-map = left,right
priority = 9
direction = output

[Mapping hdmi-stereo-extra1]
description = Digital Stereo (HDMI 2)
device-strings = hdmi:%f,1
paths-output = hdmi-output-1
channel-map = left,right
priority = 7
direction = output

# If you have more HDMI devices, add them here.

# Show multiple HDMI mappings so I could connect to them all.
[Profile hdmi-multiple]
description = Multiple Digital Stereo (HDMI)
output-mappings = hdmi-stereo hdmi-stereo-extra1
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;[General]
auto-profiles = no

[Mapping hdmi-stereo]
description = Digital Stereo (HDMI)
device-strings = hdmi:%f
paths-output = hdmi-output-0
channel-map = left,right
priority = 9
direction = output

[Mapping hdmi-stereo-extra1]
description = Digital Stereo (HDMI 2)
device-strings = hdmi:%f,1
paths-output = hdmi-output-1
channel-map = left,right
priority = 7
direction = output

# If you have more HDMI devices, add them here.

# Show multiple HDMI mappings so I could connect to them all.
[Profile hdmi-multiple]
description = Multiple Digital Stereo (HDMI)
output-mappings = hdmi-stereo hdmi-stereo-extra1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;上面的 mapping 是直接从 &lt;code&gt;default.conf&lt;/code&gt; 里面抄的，下面那个 profile 就是包含上面的两个 mapping，然后需要写 WirePlumber 规则来给显卡上的声卡套用这个 profile。我把它写到 &lt;code&gt;/etc/wireplumber/main.lua.d/51-hdmi-multiple.lua&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;rule = {
  matches = {
    {
      -- Sometimes PCI sound card name has `.1` or other suffix, so it&#039;s better
      -- to use description to match it.
      { &amp;quot;device.description&amp;quot;, &amp;quot;matches&amp;quot;, &amp;quot;TU104 HD Audio Controller&amp;quot; },
    },
  },
  apply_properties = {
    [&amp;quot;api.alsa.use-acp&amp;quot;] = true,
    -- By default, it creates profiles for each mappings, so one profile has one
    -- mapping, but I want to combine 2 mappings, so I have to manually create
    -- a profile to show 2 mappings.
    [&amp;quot;api.acp.auto-profile&amp;quot;] = false,
    [&amp;quot;api.acp.auto-port&amp;quot;] = false,
    [&amp;quot;device.profile-set&amp;quot;] = &amp;quot;hdmi-multiple.conf&amp;quot;,
    [&amp;quot;device.profile&amp;quot;] = &amp;quot;hdmi-multiple&amp;quot;,
  },
}

table.insert(alsa_monitor.rules, rule)
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;rule = {
  matches = {
    {
      -- Sometimes PCI sound card name has `.1` or other suffix, so it&#039;s better
      -- to use description to match it.
      { &quot;device.description&quot;, &quot;matches&quot;, &quot;TU104 HD Audio Controller&quot; },
    },
  },
  apply_properties = {
    [&quot;api.alsa.use-acp&quot;] = true,
    -- By default, it creates profiles for each mappings, so one profile has one
    -- mapping, but I want to combine 2 mappings, so I have to manually create
    -- a profile to show 2 mappings.
    [&quot;api.acp.auto-profile&quot;] = false,
    [&quot;api.acp.auto-port&quot;] = false,
    [&quot;device.profile-set&quot;] = &quot;hdmi-multiple.conf&quot;,
    [&quot;device.profile&quot;] = &quot;hdmi-multiple&quot;,
  },
}

table.insert(alsa_monitor.rules, rule)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后执行 &lt;code&gt;systemctl --user restart wireplumber&lt;/code&gt;，Helvum 里面应该就能同时看到两个显示器的 HDMI 音频设备了。&lt;/p&gt;
&lt;p&gt;接下来是 Arch Wiki 里面没有提到的部分，如何同时向两个设备输出音频？最简单的就是像 JACK 一样直接把输出的程序同时连接到两个音频设备上就行了，但这样既不能持久化，也不能在桌面环境里调节音量。阅读了 PipeWire 的文档之后发现这部分可以通过虚拟设备来解决，有一个叫做 combine-stream 的模块就可以创建这样的复合设备，于是参考 &lt;a href=&quot;https://docs.pipewire.org/page_module_combine_stream.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;combine-stream 的文档&lt;/a&gt;，我创建 &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-hdmi-combined-sink.conf&lt;/code&gt; 并写入如下内容：&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &amp;quot;combined-hdmi-stereo&amp;quot;
            node.description = &amp;quot;Combined HDMI / DisplayPort&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;TU104 HD Audio Controller&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-pci&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts glob. Match all HDMI devices on TU104.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            # Sometimes PCI sound card name has `.1` or other
                            # suffix, so it&#039;s better to use description to
                            # match it.
                            node.description = &amp;quot;~TU104 HD Audio Controller Digital Stereo *&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            combine.audio.position = [ FL FR ]
                            audio.position = [ FL FR ]
                        }
                    }
                }
            ]
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &quot;combined-hdmi-stereo&quot;
            node.description = &quot;Combined HDMI / DisplayPort&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;TU104 HD Audio Controller&quot;
                #device.icon-name = &quot;audio-card-analog-pci&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts glob. Match all HDMI devices on TU104.
                            media.class = &quot;Audio/Sink&quot;
                            # Sometimes PCI sound card name has `.1` or other
                            # suffix, so it&#039;s better to use description to
                            # match it.
                            node.description = &quot;~TU104 HD Audio Controller Digital Stereo *&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            combine.audio.position = [ FL FR ]
                            audio.position = [ FL FR ]
                        }
                    }
                }
            ]
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;逻辑很简单，就是创建一个复合设备，输入到该设备的音频会输出给给定显卡上的所有 HDMI 输出，然后 &lt;code&gt;systemctl --user restart pipewire wireplumber&lt;/code&gt; 就可以在 GNOME 里选择这个输出设备并调节音量了，不管扬声器插在哪个 HDMI/DP 显示器上，都能工作。&lt;/p&gt;
&lt;p&gt;解决了这个问题之后我发现利用 PipeWire 的虚拟设备还可以解决我 USB 声卡的通道问题。我现在用的是我上高三时候买的 Scarlett 2i4，有两个输入和四个输出，而 auto-profile 就会自动把它设置成一个四声道环绕声输出和一个立体声输入，但实际上这个四个输出是双声道的耳机和双声道的扬声器，两个输入通常会分别用来输入话筒和乐器，而不是作为双声道输入。于是长久以来我只能在各种软件里手动设置单声道音频解决这个问题。而这次读文档我发现 PipeWire 早就给出了例子，虽然是针对另一款声卡（&lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;UMC404HD 的扬声器/耳机分离&lt;/a&gt; 和 &lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;UMC404HD 的话筒/乐器分离&lt;/a&gt;），不过总而言之是大同小异，我也参照着弄了一下我的声卡。&lt;/p&gt;
&lt;p&gt;首先你想要手动分离声卡的各个通道，仍然需要换掉默认的 profile，不过这次不需要手动编写了，PipeWire 给所有音频设备都提供了一个叫做 &lt;code&gt;pro-audio&lt;/code&gt; 的 profile，这个会直接暴露声卡的所有通道而不做额外的假设（显然桌面环境对于这种裸配置的支持并不好），而后我们就可以为所欲为了，所以先创建 &lt;code&gt;/etc/wireplumber/main.lua.d/51-scarlett-2i4.lua&lt;/code&gt; 写入规则让它默认使用 &lt;code&gt;pro-audio&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;rule = {
  matches = {
    {
      { &amp;quot;device.name&amp;quot;, &amp;quot;matches&amp;quot;, &amp;quot;alsa_card.usb-Focusrite_Scarlett_2i4_USB-00&amp;quot; },
    },
  },
  apply_properties = {
    [&amp;quot;audio.rate&amp;quot;] = 48000,
    [&amp;quot;audio.allowed-rates&amp;quot;] = &amp;quot;44100,48000,88200,96000&amp;quot;,
    --[&amp;quot;api.alsa.period-size&amp;quot;] = 2048,
    --[&amp;quot;api.alsa.headroom&amp;quot;] = 1024,
    [&amp;quot;api.alsa.use-acp&amp;quot;] = true,
    -- By default, it creates profiles for stereo input and surround 4.0 output,
    -- but actually the card is 2 inputs, stereo headphones output and stereo
    -- speakers output, so we disable auto profile here, and use the Pro Audio
    -- profile to expose all ports, and combine them manually.
    [&amp;quot;api.acp.auto-profile&amp;quot;] = false,
    [&amp;quot;api.acp.auto-port&amp;quot;] = false,
    [&amp;quot;device.profile&amp;quot;] = &amp;quot;pro-audio&amp;quot;,
  },
},

table.insert(alsa_monitor.rules, rule)
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;rule = {
  matches = {
    {
      { &quot;device.name&quot;, &quot;matches&quot;, &quot;alsa_card.usb-Focusrite_Scarlett_2i4_USB-00&quot; },
    },
  },
  apply_properties = {
    [&quot;audio.rate&quot;] = 48000,
    [&quot;audio.allowed-rates&quot;] = &quot;44100,48000,88200,96000&quot;,
    --[&quot;api.alsa.period-size&quot;] = 2048,
    --[&quot;api.alsa.headroom&quot;] = 1024,
    [&quot;api.alsa.use-acp&quot;] = true,
    -- By default, it creates profiles for stereo input and surround 4.0 output,
    -- but actually the card is 2 inputs, stereo headphones output and stereo
    -- speakers output, so we disable auto profile here, and use the Pro Audio
    -- profile to expose all ports, and combine them manually.
    [&quot;api.acp.auto-profile&quot;] = false,
    [&quot;api.acp.auto-port&quot;] = false,
    [&quot;device.profile&quot;] = &quot;pro-audio&quot;,
  },
},

table.insert(alsa_monitor.rules, rule)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后 &lt;code&gt;systemctl --user restart wireplumber&lt;/code&gt;，再打开 Helvum 应该能看到声卡不再被瞎推测为什么 LR RR 之类的声道，而是直接显示 AUX0~3，接下来就可以创建虚拟设备分别映射不同的通道了。&lt;/p&gt;
&lt;p&gt;首先对于输出，我分离出耳机/扬声器两个不同的双声道虚拟输出设备，平时我只用耳机。这里和官方文档示例里声卡不同的地方是那款声卡后两个通道是耳机，而 Scarlett 2i4 前两个通道就是耳机，这也是为什么就算默认被当成四通道环绕声也能用的原因。总之在 &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-sinks.conf&lt;/code&gt; 里面写入如下的配置就可以了：&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # See &lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 uses the first two outputs for headphones.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Headphones&amp;quot;
            capture.props = {
                node.name = &amp;quot;Scarlett_2i4_Headphones&amp;quot;
                media.class = &amp;quot;Audio/Sink&amp;quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &amp;quot;playback.Scarlett_2i4_Headphones&amp;quot;
                audio.position = [ AUX0 AUX1 ]
                target.object = &amp;quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&amp;quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Speakers&amp;quot;
            capture.props = {
                node.name = &amp;quot;Scarlett_2i4_Speakers&amp;quot;
                media.class = &amp;quot;Audio/Sink&amp;quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &amp;quot;playback.Scarlett_2i4_Speakers&amp;quot;
                audio.position = [ AUX2 AUX3 ]
                target.object = &amp;quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&amp;quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # See &amp;lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&amp;gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 uses the first two outputs for headphones.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Headphones&quot;
            capture.props = {
                node.name = &quot;Scarlett_2i4_Headphones&quot;
                media.class = &quot;Audio/Sink&quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &quot;playback.Scarlett_2i4_Headphones&quot;
                audio.position = [ AUX0 AUX1 ]
                target.object = &quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Speakers&quot;
            capture.props = {
                node.name = &quot;Scarlett_2i4_Speakers&quot;
                media.class = &quot;Audio/Sink&quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &quot;playback.Scarlett_2i4_Speakers&quot;
                audio.position = [ AUX2 AUX3 ]
                target.object = &quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;执行 &lt;code&gt;systemctl --user restart pipewire wireplumber&lt;/code&gt; 应该可以看到多了两个分别是 Scarlett 2i4 Headphones 和 Scarlett 2i4 Speakers 的音频输出设备。对于输入通道，我们也同理将它映射成两个单独的单声道虚拟输入设备，写到 &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-sources.conf&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # See &lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 can be two mono inputs or one stereo
    # input, depends on how we wire it in software.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Left Mono Input&amp;quot;
            capture.props = {
                node.name = &amp;quot;capture.Scarlett_2i4_Left_Mono_Input&amp;quot;
                audio.position = [ AUX0 ]
                stream.dont-remix = true
                target.object = &amp;quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&amp;quot;
                node.passive = true
            }
            playback.props = {
                node.name = &amp;quot;Scarlett_2i4_Left_Mono_Input&amp;quot;
                media.class = &amp;quot;Audio/Source&amp;quot;
                audio.position = [ MONO ]
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Right Mono Inputt&amp;quot;
            capture.props = {
                node.name = &amp;quot;capture.Scarlett_2i4_Right_Mono_Input&amp;quot;
                audio.position = [ AUX1 ]
                stream.dont-remix = true
                target.object = &amp;quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&amp;quot;
                node.passive = true
            }
            playback.props = {
                node.name = &amp;quot;Scarlett_2i4_Right_Mono_Input&amp;quot;
                media.class = &amp;quot;Audio/Source&amp;quot;
                audio.position = [ MONO ]
            }
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # See &amp;lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&amp;gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 can be two mono inputs or one stereo
    # input, depends on how we wire it in software.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Left Mono Input&quot;
            capture.props = {
                node.name = &quot;capture.Scarlett_2i4_Left_Mono_Input&quot;
                audio.position = [ AUX0 ]
                stream.dont-remix = true
                target.object = &quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&quot;
                node.passive = true
            }
            playback.props = {
                node.name = &quot;Scarlett_2i4_Left_Mono_Input&quot;
                media.class = &quot;Audio/Source&quot;
                audio.position = [ MONO ]
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Right Mono Inputt&quot;
            capture.props = {
                node.name = &quot;capture.Scarlett_2i4_Right_Mono_Input&quot;
                audio.position = [ AUX1 ]
                stream.dont-remix = true
                target.object = &quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&quot;
                node.passive = true
            }
            playback.props = {
                node.name = &quot;Scarlett_2i4_Right_Mono_Input&quot;
                media.class = &quot;Audio/Source&quot;
                audio.position = [ MONO ]
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;按理说到这里就结束了，但以防万一真的有人想用这款声卡做四声道环绕声输出，或者立体声输入，同理可以使用之前的 combine-stream 再把这些虚拟设备复合起来，可以在 &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-combined.conf&lt;/code&gt; 写入如下配置：&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # Is there anyone who really uses Scarlett 2i4 for surround 4.0 output?
    # Anyway, we could achieve this with PipeWire&#039;s combine stream.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &amp;quot;Scarlett_2i4_Surround_4_0_Output&amp;quot;
            node.description = &amp;quot;Scarlett 2i4 Surround 4.0 Output&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR RL RR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;Scarlett 2i4&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-usb&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            # To get better effect, treat headphones output as rear output.
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Speakers.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Speakers&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ FL FR ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Headphones.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Headphones&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ RL RR ]
                        }
                    }
                }
            ]
        }
    }
    # To make it easier, we also use PipeWire&#039;s combine stream to make a stereo
    # input, so we don&#039;t need to wire manually.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = source
            node.name = &amp;quot;Scarlett_2i4_Stereo_Input&amp;quot;
            node.description = &amp;quot;Scarlett 2i4 Stereo Input&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;Scarlett 2i4&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-usb&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Left Mono Input.
                            media.class = &amp;quot;Audio/Source&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Left_Mono_Input&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FL ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Right Mono Input.
                            media.class = &amp;quot;Audio/Source&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Right_Mono_Input&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FR ]
                        }
                    }
                }
            ] 
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # Is there anyone who really uses Scarlett 2i4 for surround 4.0 output?
    # Anyway, we could achieve this with PipeWire&#039;s combine stream.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &quot;Scarlett_2i4_Surround_4_0_Output&quot;
            node.description = &quot;Scarlett 2i4 Surround 4.0 Output&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR RL RR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;Scarlett 2i4&quot;
                #device.icon-name = &quot;audio-card-analog-usb&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            # To get better effect, treat headphones output as rear output.
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Speakers.
                            media.class = &quot;Audio/Sink&quot;
                            node.name = &quot;Scarlett_2i4_Speakers&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ FL FR ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Headphones.
                            media.class = &quot;Audio/Sink&quot;
                            node.name = &quot;Scarlett_2i4_Headphones&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ RL RR ]
                        }
                    }
                }
            ]
        }
    }
    # To make it easier, we also use PipeWire&#039;s combine stream to make a stereo
    # input, so we don&#039;t need to wire manually.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = source
            node.name = &quot;Scarlett_2i4_Stereo_Input&quot;
            node.description = &quot;Scarlett 2i4 Stereo Input&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;Scarlett 2i4&quot;
                #device.icon-name = &quot;audio-card-analog-usb&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Left Mono Input.
                            media.class = &quot;Audio/Source&quot;
                            node.name = &quot;Scarlett_2i4_Left_Mono_Input&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FL ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Right Mono Input.
                            media.class = &quot;Audio/Source&quot;
                            node.name = &quot;Scarlett_2i4_Right_Mono_Input&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FR ]
                        }
                    }
                }
            ] 
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;理论上来说，再创建虚拟设备直接连到物理通道应该也是可行的，但我尝试过之后连接图乱掉了，所以我换成 combine-stream 实现了。有一个要注意的点是我在环绕声里交换了一下通道，扬声器输出被我当作前面的音源，而耳机输出被我当作后面的音源，这样应该效果会更好，不过是和 auto-profile 假设的相反。&lt;/p&gt;
&lt;p&gt;于是在购买这款声卡七八年之后我终于在 Linux 下面把它按我想要的用法划分了通道，同时发现 PipeWire 对复杂音频设备的处理确实比 PulseAudio 更加灵活，而和同样基于图和连接的 JACK 相比，又能同时控制不同的声卡，对于我这种设备复杂需求却不复杂的用户而言显然更加方便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-1.png&quot; alt=&quot;screenshot-1&quot;&gt;
&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-2.png&quot; alt=&quot;screenshot-2&quot;&gt;
&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-3.png&quot; alt=&quot;screenshot-3&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;EnglishVersion&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/#EnglishVersion&quot;&gt;&lt;/a&gt;English Version&lt;/h1&gt;
&lt;p&gt;I might be the only one who owns a complex audio setup among my friends. TL;DR: To share the only pair of speakers between PS4, Switch and computer I connect it to my monitor instead of internal sound card of my computer, so all devices can output audio to speakers via HDMI/DP. It&#039;s fine until I bought another monitor, it&#039;s hard to find which monitor is the one with speakers, maybe it&#039;s HDMI 1 this week and become HDMI 2 next week, so I always need to test before playing audio. I&#039;m too angry to accept this recently, so I try to fix it by hand.&lt;/p&gt;
&lt;p&gt;At first I guess PipeWire just randomly sorts audio ports, so it&#039;s easy to fix it, what I need to do is finding ID for each port and disabling the HDMI port without speakers. But soon I see PipeWire just sorts ports via ALSA&#039;s device number, so if I disable a port, the port might be the other monitor on next boot. Is there no way to let ALSA do a fixed mapping for HDMI audio devices? We all know monitors report EDID to system, and I read ALSA&#039;s document, it contains how to handle sequence of different sound cards via udev, but no way to handle ports on the same sound card like HDMI ports. I even find document of GPU audio from NVIDIA, it says each port has a ELD file, which contains monitor info, but if you try to read it with &lt;code&gt;cat /proc/asound/cardX/eld*&lt;/code&gt;, you&#039;ll find it only contains model, not serial number, and I have two monitors of the same model in order to save time on dual-monitor scale, so they looks the same. But if your monitors/TVs are of different models, it is easier, ALSA will read model in ELD and you can access it via &lt;code&gt;node.nick&lt;/code&gt; property of a PipeWire device, you can just read it, or write some WirePlumber rules to rename properties that your desktop environment uses, so you get a fixed name. But I need more help.&lt;/p&gt;
&lt;p&gt;Then I send a Email to our company&#039;s research mailing list of my setup and demand, and Takashi Iwai (maintainer of kernel&#039;s audio subsystem) tell me there is no better way, audio driver just assign number when GPU driver notifies a new port, so it&#039;s dynamic. And I also find GPU driver may not emit ports as display probing sequence, so Plan A fails, but I have Plan B and Plan C.&lt;/p&gt;
&lt;p&gt;Another colleague suggests me to buy a mixer hardware so I can connect two monitors into one pair of speakers, and he even draws a circuit diagram and says you could make one by yourself like this. I also considered this, it allows PC and game consoles play audio at the same time, but I have to manually sync volume of two audio devices on my PC. I don&#039;t need to play audio at the same time but I am lazy, so I decide to try this last.&lt;/p&gt;
&lt;p&gt;If there is a hardware solution, there should be a software solution. PipeWire supports graph-based connection like JACK, then I could just create a virtual output device, and wire two HDMI devices to it. There is a section called &lt;a href=&quot;https://wiki.archlinux.org/title/WirePlumber#Simultaneous_output_to_multiple_sinks_on_the_same_sound_card&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Simultaneous output to multiple sinks on the same sound card&lt;/a&gt; on Arch Wiki, I thought I just need to follow it, but I was wrong, there is no new audio device. The I read more documents to understand the term and totally understand it.&lt;/p&gt;
&lt;p&gt;First I find that section is only about how to create a &quot;profile that shows both two mappings&quot;, but what is mapping and what is profile? Mapping is like one kine of combination of input/output on a sound card, and profile controls which kind of combination you could use. For example, if you have a sound device which has 2 input channels and 4 output channels, it could be a stereo output, or surround 4.0 output, or stereo input + surround 4.0 output, those are different profiles. And why you need to manually create a profile to simultaneously output to two sinks? Because by default ALSA does auto-profile which creates a profile for each mapping, and by default one mapping is for one HDMI port, so if you launch pavucontrol or Helvum, you&#039;ll find you can only see 1 of 2 HDMI devices if you don&#039;t switch profile, so you cannot wire them both. But you may also ask why GNOME Shell shows both of 2 HDMI sinks? Because &lt;code&gt;libgnome-volume-control&lt;/code&gt; iterates sound cards first, and then ports on a sound card, not directly iterate ports (which could be effected by profile), and it will switch profile when you choose ports.&lt;/p&gt;
&lt;p&gt;So the first step to do is create a new profile sets, I use &lt;code&gt;/usr/share/alsa-card-profile/mixer/profile-sets/hdmi-multiple.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;[General]
auto-profiles = no

[Mapping hdmi-stereo]
description = Digital Stereo (HDMI)
device-strings = hdmi:%f
paths-output = hdmi-output-0
channel-map = left,right
priority = 9
direction = output

[Mapping hdmi-stereo-extra1]
description = Digital Stereo (HDMI 2)
device-strings = hdmi:%f,1
paths-output = hdmi-output-1
channel-map = left,right
priority = 7
direction = output

# If you have more HDMI devices, add them here.

# Show multiple HDMI mappings so I could connect to them all.
[Profile hdmi-multiple]
description = Multiple Digital Stereo (HDMI)
output-mappings = hdmi-stereo hdmi-stereo-extra1
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;[General]
auto-profiles = no

[Mapping hdmi-stereo]
description = Digital Stereo (HDMI)
device-strings = hdmi:%f
paths-output = hdmi-output-0
channel-map = left,right
priority = 9
direction = output

[Mapping hdmi-stereo-extra1]
description = Digital Stereo (HDMI 2)
device-strings = hdmi:%f,1
paths-output = hdmi-output-1
channel-map = left,right
priority = 7
direction = output

# If you have more HDMI devices, add them here.

# Show multiple HDMI mappings so I could connect to them all.
[Profile hdmi-multiple]
description = Multiple Digital Stereo (HDMI)
output-mappings = hdmi-stereo hdmi-stereo-extra1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;I just copy mapping from &lt;code&gt;default.conf&lt;/code&gt;, and the profile just contains those two mappings, and then write a WirePlumber rule to use this profile for GPU sound card. I write the rule into &lt;code&gt;/etc/wireplumber/main.lua.d/51-hdmi-multiple.lua&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;rule = {
  matches = {
    {
      -- Sometimes PCI sound card name has `.1` or other suffix, so it&#039;s better
      -- to use description to match it.
      { &amp;quot;device.description&amp;quot;, &amp;quot;matches&amp;quot;, &amp;quot;TU104 HD Audio Controller&amp;quot; },
    },
  },
  apply_properties = {
    [&amp;quot;api.alsa.use-acp&amp;quot;] = true,
    -- By default, it creates profiles for each mappings, so one profile has one
    -- mapping, but I want to combine 2 mappings, so I have to manually create
    -- a profile to show 2 mappings.
    [&amp;quot;api.acp.auto-profile&amp;quot;] = false,
    [&amp;quot;api.acp.auto-port&amp;quot;] = false,
    [&amp;quot;device.profile-set&amp;quot;] = &amp;quot;hdmi-multiple.conf&amp;quot;,
    [&amp;quot;device.profile&amp;quot;] = &amp;quot;hdmi-multiple&amp;quot;,
  },
}

table.insert(alsa_monitor.rules, rule)
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;rule = {
  matches = {
    {
      -- Sometimes PCI sound card name has `.1` or other suffix, so it&#039;s better
      -- to use description to match it.
      { &quot;device.description&quot;, &quot;matches&quot;, &quot;TU104 HD Audio Controller&quot; },
    },
  },
  apply_properties = {
    [&quot;api.alsa.use-acp&quot;] = true,
    -- By default, it creates profiles for each mappings, so one profile has one
    -- mapping, but I want to combine 2 mappings, so I have to manually create
    -- a profile to show 2 mappings.
    [&quot;api.acp.auto-profile&quot;] = false,
    [&quot;api.acp.auto-port&quot;] = false,
    [&quot;device.profile-set&quot;] = &quot;hdmi-multiple.conf&quot;,
    [&quot;device.profile&quot;] = &quot;hdmi-multiple&quot;,
  },
}

table.insert(alsa_monitor.rules, rule)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;And then run &lt;code&gt;systemctl --user restart wireplumber&lt;/code&gt;, you should see both 2 HDMI sinks in Helvum now.&lt;/p&gt;
&lt;p&gt;Then let&#039;s do steps which Arch Wiki does not contain, how to output audio to 2 sinks? The easiest way is manually wire output program to both 2 sinks, but that&#039;s not persistent, and you cannot control volume in desktop environment. After reading PipeWire&#039;s document, I find I could solve this via virtual devices, there is a module called combine-stream which could create such a combination device, so I just follow &lt;a href=&quot;https://docs.pipewire.org/page_module_combine_stream.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;combine-stream&#039;s document&lt;/a&gt;, write following content into &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-hdmi-combined-sink.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &amp;quot;combined-hdmi-stereo&amp;quot;
            node.description = &amp;quot;Combined HDMI / DisplayPort&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;TU104 HD Audio Controller&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-pci&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts glob. Match all HDMI devices on TU104.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            # Sometimes PCI sound card name has `.1` or other
                            # suffix, so it&#039;s better to use description to
                            # match it.
                            node.description = &amp;quot;~TU104 HD Audio Controller Digital Stereo *&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            combine.audio.position = [ FL FR ]
                            audio.position = [ FL FR ]
                        }
                    }
                }
            ]
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &quot;combined-hdmi-stereo&quot;
            node.description = &quot;Combined HDMI / DisplayPort&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;TU104 HD Audio Controller&quot;
                #device.icon-name = &quot;audio-card-analog-pci&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts glob. Match all HDMI devices on TU104.
                            media.class = &quot;Audio/Sink&quot;
                            # Sometimes PCI sound card name has `.1` or other
                            # suffix, so it&#039;s better to use description to
                            # match it.
                            node.description = &quot;~TU104 HD Audio Controller Digital Stereo *&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            combine.audio.position = [ FL FR ]
                            audio.position = [ FL FR ]
                        }
                    }
                }
            ]
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;It&#039;s fairly easy to understand, just create a combination device, all audio streams point to this device will be send to all HDMI sinks on a GPU sound card, and run &lt;code&gt;systemctl --user restart pipewire wireplumber&lt;/code&gt; you should be able to choose it as output sink and control its volume. No matter speakers are connected to which monitor, it should work.&lt;/p&gt;
&lt;p&gt;Then I find I could solve the channel problem of my USB sound card. I still uses Scarlett 2i4 bought when I was in high school, it has 2 input channels and 4 output channels, and auto-profile will set it to a surround 4.0 output and stereo input, but those 4 output channels is made of a stereo headphone output and a stereo speaker output, the 2 input channels typically are used as mono microphone and mono instructment. I used to set mono input in different software to fix my microphone. But now I find there is a example of another sound card in PipeWire&#039;s document (&lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Split speakers/headphones of UMC404HD&lt;/a&gt; 和 &lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Split speakers/headphones of UMC404HD&lt;/a&gt;), but mostly they are the same, so I also tweak my sound card.&lt;/p&gt;
&lt;p&gt;The same thing is to replace default profile in order to split each channels, but this time manually creating profile is not needed, PipeWire provides a &lt;code&gt;pro-audio&lt;/code&gt; profile for all audio devices, it will expose all channels without assuming their usage (obviously, your desktop environment supports this badly), and then we could do what we need, so just create a rule to use &lt;code&gt;pro-audio&lt;/code&gt; by default in &lt;code&gt;/etc/wireplumber/main.lua.d/51-scarlett-2i4.lua&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;rule = {
  matches = {
    {
      { &amp;quot;device.name&amp;quot;, &amp;quot;matches&amp;quot;, &amp;quot;alsa_card.usb-Focusrite_Scarlett_2i4_USB-00&amp;quot; },
    },
  },
  apply_properties = {
    [&amp;quot;audio.rate&amp;quot;] = 48000,
    [&amp;quot;audio.allowed-rates&amp;quot;] = &amp;quot;44100,48000,88200,96000&amp;quot;,
    --[&amp;quot;api.alsa.period-size&amp;quot;] = 2048,
    --[&amp;quot;api.alsa.headroom&amp;quot;] = 1024,
    [&amp;quot;api.alsa.use-acp&amp;quot;] = true,
    -- By default, it creates profiles for stereo input and surround 4.0 output,
    -- but actually the card is 2 inputs, stereo headphones output and stereo
    -- speakers output, so we disable auto profile here, and use the Pro Audio
    -- profile to expose all ports, and combine them manually.
    [&amp;quot;api.acp.auto-profile&amp;quot;] = false,
    [&amp;quot;api.acp.auto-port&amp;quot;] = false,
    [&amp;quot;device.profile&amp;quot;] = &amp;quot;pro-audio&amp;quot;,
  },
},

table.insert(alsa_monitor.rules, rule)
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;rule = {
  matches = {
    {
      { &quot;device.name&quot;, &quot;matches&quot;, &quot;alsa_card.usb-Focusrite_Scarlett_2i4_USB-00&quot; },
    },
  },
  apply_properties = {
    [&quot;audio.rate&quot;] = 48000,
    [&quot;audio.allowed-rates&quot;] = &quot;44100,48000,88200,96000&quot;,
    --[&quot;api.alsa.period-size&quot;] = 2048,
    --[&quot;api.alsa.headroom&quot;] = 1024,
    [&quot;api.alsa.use-acp&quot;] = true,
    -- By default, it creates profiles for stereo input and surround 4.0 output,
    -- but actually the card is 2 inputs, stereo headphones output and stereo
    -- speakers output, so we disable auto profile here, and use the Pro Audio
    -- profile to expose all ports, and combine them manually.
    [&quot;api.acp.auto-profile&quot;] = false,
    [&quot;api.acp.auto-port&quot;] = false,
    [&quot;device.profile&quot;] = &quot;pro-audio&quot;,
  },
},

table.insert(alsa_monitor.rules, rule)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Then run &lt;code&gt;systemctl --user restart wireplumber&lt;/code&gt;, and launch Helvum, the sound card now should has AUX0~3 instead of LR RR, and then create virtual devices that map to different channels.&lt;/p&gt;
&lt;p&gt;For output channels, I create two devices for headphones and speakers, I typically only uses headphones. Which differs from the example is Scarlett 2i4 uses AUX0/1 for headphones instead of AUX2/3, and that&#039;s the reason why is works in surround 4.0 output profile. Anyway, just write those configuration into &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-sinks.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # See &lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 uses the first two outputs for headphones.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Headphones&amp;quot;
            capture.props = {
                node.name = &amp;quot;Scarlett_2i4_Headphones&amp;quot;
                media.class = &amp;quot;Audio/Sink&amp;quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &amp;quot;playback.Scarlett_2i4_Headphones&amp;quot;
                audio.position = [ AUX0 AUX1 ]
                target.object = &amp;quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&amp;quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Speakers&amp;quot;
            capture.props = {
                node.name = &amp;quot;Scarlett_2i4_Speakers&amp;quot;
                media.class = &amp;quot;Audio/Sink&amp;quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &amp;quot;playback.Scarlett_2i4_Speakers&amp;quot;
                audio.position = [ AUX2 AUX3 ]
                target.object = &amp;quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&amp;quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # See &amp;lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-speakersheadphones-virtual-sinks&amp;gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 uses the first two outputs for headphones.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Headphones&quot;
            capture.props = {
                node.name = &quot;Scarlett_2i4_Headphones&quot;
                media.class = &quot;Audio/Sink&quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &quot;playback.Scarlett_2i4_Headphones&quot;
                audio.position = [ AUX0 AUX1 ]
                target.object = &quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Speakers&quot;
            capture.props = {
                node.name = &quot;Scarlett_2i4_Speakers&quot;
                media.class = &quot;Audio/Sink&quot;
                audio.position = [ FL FR ]
            }
            playback.props = {
                node.name = &quot;playback.Scarlett_2i4_Speakers&quot;
                audio.position = [ AUX2 AUX3 ]
                target.object = &quot;alsa_output.usb-Focusrite_Scarlett_2i4_USB-00.pro-output-0&quot;
                stream.dont-remix = true
                node.passive = true
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Then run &lt;code&gt;systemctl --user restart pipewire wireplumber&lt;/code&gt; there should be 2 sinks called Scarlett 2i4 Headphones and Scarlett 2i4 Speakers. For input channels, I also map them into 2 mono virtual input devices, write configuration into &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-sources.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # See &lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 can be two mono inputs or one stereo
    # input, depends on how we wire it in software.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Left Mono Input&amp;quot;
            capture.props = {
                node.name = &amp;quot;capture.Scarlett_2i4_Left_Mono_Input&amp;quot;
                audio.position = [ AUX0 ]
                stream.dont-remix = true
                target.object = &amp;quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&amp;quot;
                node.passive = true
            }
            playback.props = {
                node.name = &amp;quot;Scarlett_2i4_Left_Mono_Input&amp;quot;
                media.class = &amp;quot;Audio/Source&amp;quot;
                audio.position = [ MONO ]
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &amp;quot;Scarlett 2i4 Right Mono Inputt&amp;quot;
            capture.props = {
                node.name = &amp;quot;capture.Scarlett_2i4_Right_Mono_Input&amp;quot;
                audio.position = [ AUX1 ]
                stream.dont-remix = true
                target.object = &amp;quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&amp;quot;
                node.passive = true
            }
            playback.props = {
                node.name = &amp;quot;Scarlett_2i4_Right_Mono_Input&amp;quot;
                media.class = &amp;quot;Audio/Source&amp;quot;
                audio.position = [ MONO ]
            }
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # See &amp;lt;https://gitlab.freedesktop.org/pipewire/pipewire/-/wikis/Virtual-Devices#behringer-umc404hd-microphoneguitar-virtual-sources&amp;gt;.
    #
    # Differs from UMC404HD, Scarlett 2i4 can be two mono inputs or one stereo
    # input, depends on how we wire it in software.
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Left Mono Input&quot;
            capture.props = {
                node.name = &quot;capture.Scarlett_2i4_Left_Mono_Input&quot;
                audio.position = [ AUX0 ]
                stream.dont-remix = true
                target.object = &quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&quot;
                node.passive = true
            }
            playback.props = {
                node.name = &quot;Scarlett_2i4_Left_Mono_Input&quot;
                media.class = &quot;Audio/Source&quot;
                audio.position = [ MONO ]
            }
        }
    }
    {   name = libpipewire-module-loopback
        args = {
            node.description = &quot;Scarlett 2i4 Right Mono Inputt&quot;
            capture.props = {
                node.name = &quot;capture.Scarlett_2i4_Right_Mono_Input&quot;
                audio.position = [ AUX1 ]
                stream.dont-remix = true
                target.object = &quot;alsa_input.usb-Focusrite_Scarlett_2i4_USB-00.pro-input-0&quot;
                node.passive = true
            }
            playback.props = {
                node.name = &quot;Scarlett_2i4_Right_Mono_Input&quot;
                media.class = &quot;Audio/Source&quot;
                audio.position = [ MONO ]
            }
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Every thing should be done here, but just in case someone really uses this sound card for surround 4.0 output or stereo input, combine-stream also could be used to combine those virtual devices, it could be done via writing those contents into &lt;code&gt;/etc/pipewire/pipewire.conf.d/10-scarlett-2i4-combined.conf&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;context.modules = [
    # Is there anyone who really uses Scarlett 2i4 for surround 4.0 output?
    # Anyway, we could achieve this with PipeWire&#039;s combine stream.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &amp;quot;Scarlett_2i4_Surround_4_0_Output&amp;quot;
            node.description = &amp;quot;Scarlett 2i4 Surround 4.0 Output&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR RL RR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;Scarlett 2i4&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-usb&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            # To get better effect, treat headphones output as rear output.
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Speakers.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Speakers&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ FL FR ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Headphones.
                            media.class = &amp;quot;Audio/Sink&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Headphones&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ RL RR ]
                        }
                    }
                }
            ]
        }
    }
    # To make it easier, we also use PipeWire&#039;s combine stream to make a stereo
    # input, so we don&#039;t need to wire manually.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = source
            node.name = &amp;quot;Scarlett_2i4_Stereo_Input&amp;quot;
            node.description = &amp;quot;Scarlett 2i4 Stereo Input&amp;quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &amp;quot;Scarlett 2i4&amp;quot;
                #device.icon-name = &amp;quot;audio-card-analog-usb&amp;quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Left Mono Input.
                            media.class = &amp;quot;Audio/Source&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Left_Mono_Input&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FL ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Right Mono Input.
                            media.class = &amp;quot;Audio/Source&amp;quot;
                            node.name = &amp;quot;Scarlett_2i4_Right_Mono_Input&amp;quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FR ]
                        }
                    }
                }
            ] 
        }
    }
]
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;context.modules = [
    # Is there anyone who really uses Scarlett 2i4 for surround 4.0 output?
    # Anyway, we could achieve this with PipeWire&#039;s combine stream.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = sink
            node.name = &quot;Scarlett_2i4_Surround_4_0_Output&quot;
            node.description = &quot;Scarlett 2i4 Surround 4.0 Output&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR RL RR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;Scarlett 2i4&quot;
                #device.icon-name = &quot;audio-card-analog-usb&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            # To get better effect, treat headphones output as rear output.
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Speakers.
                            media.class = &quot;Audio/Sink&quot;
                            node.name = &quot;Scarlett_2i4_Speakers&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ FL FR ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Headphones.
                            media.class = &quot;Audio/Sink&quot;
                            node.name = &quot;Scarlett_2i4_Headphones&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ FL FR ]
                            combine.audio.position = [ RL RR ]
                        }
                    }
                }
            ]
        }
    }
    # To make it easier, we also use PipeWire&#039;s combine stream to make a stereo
    # input, so we don&#039;t need to wire manually.
    {   name = libpipewire-module-combine-stream
        args = {
            combine.mode = source
            node.name = &quot;Scarlett_2i4_Stereo_Input&quot;
            node.description = &quot;Scarlett 2i4 Stereo Input&quot;
            combine.latency-compensate = false
            combine.props = {
                audio.position = [ FL FR ]
                # Those could be added here, but libgnome-volume-control only
                # read those for ports from cards, not for virtual / network
                # devices.
                #device.description = &quot;Scarlett 2i4&quot;
                #device.icon-name = &quot;audio-card-analog-usb&quot;
            }
            stream.props = {
                # Link matching channels without remixing.
                stream.dont-remix = true
            }
            stream.rules = [
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Left Mono Input.
                            media.class = &quot;Audio/Source&quot;
                            node.name = &quot;Scarlett_2i4_Left_Mono_Input&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FL ]
                        }
                    }
                }
                {
                    matches = [
                        # Any of the items in matches needs to match, if one
                        # does, actions are emited.
                        {
                            # All keys must match the value. `~` in value
                            # starts regex. Match Scarlett 2i4 Right Mono Input.
                            media.class = &quot;Audio/Source&quot;
                            node.name = &quot;Scarlett_2i4_Right_Mono_Input&quot;
                        }
                    ]
                    actions = {
                        create-stream = {
                            audio.position = [ MONO ]
                            combine.audio.position = [ FR ]
                        }
                    }
                }
            ] 
        }
    }
]
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Theoretically creating new virtual devices wired to physical channels should also work, but my graph messed up after I tried it. Note that I swapped channels in surround 4.0 output, I use speakers sink for front and headphones sink for rear, which might leads into a better result, but it&#039;s opposite to what auto-profile generates.&lt;/p&gt;
&lt;p&gt;So after owning this sound card for 7~8 years I finally tweaked it&#039;s channels as my will, and I find PipeWire is more flexible than PulseAudio on handling complex sound devices, and when compared with JACK which also uses graph and wire, PipeWire can control different sound cards, which is more convenient for users like me who have complex setup but simple demand.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-1.png&quot; alt=&quot;screenshot-1&quot;&gt;
&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-2.png&quot; alt=&quot;screenshot-2&quot;&gt;
&lt;img src=&quot;/posts/PipeWire-HDMI-Audio-Virtual-Device-Combine-Split-Channel/screenshot-3.png&quot; alt=&quot;screenshot-3&quot;&gt;&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="音频" label="音频" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/%E9%9F%B3%E9%A2%91/" />
    <category term="PipeWire" label="PipeWire" scheme="https://sh.alynx.one/tags/PipeWire/" />
  </entry>
  <entry>
    <title>都不能算是 GNOME 的 Bug</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Not-A-GNOME-Bug-at-All/" />
    <id>https://sh.alynx.one/posts/Not-A-GNOME-Bug-at-All/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-05-08T10:52:40.000Z</published>
    <updated>2023-05-08T10:52:40.000Z</updated>
    <summary type="html">
      Arch Linux 的官方仓库里终于有 GNOME 44 了，今天更新了一下系统，在思考出怎么解决 DaVinci Resolve 一定要去加载 onetbb 里面 intel 的 OpenCL 实现之前，我遇到了一个更奇怪的问题：所有的 XWayland 程序都显示不出来窗口…
    </summary>
    <content type="html">
      &lt;p&gt;Arch Linux 的官方仓库里终于有 GNOME 44 了，今天更新了一下系统，在思考出怎么解决 DaVinci Resolve 一定要去加载 onetbb 里面 intel 的 OpenCL 实现之前，我遇到了一个更奇怪的问题：所有的 XWayland 程序都显示不出来窗口，程序启动了，没有报错，但是点不到。&lt;/p&gt;
&lt;p&gt;忘了我当时在查什么反正看了一下 &lt;code&gt;journalctl -f&lt;/code&gt; 发现一直刷一个 &lt;code&gt;mutter-x11-frames&lt;/code&gt; core dump 的 log，我想起来 mutter 44 应该是把 X11 程序的 decoration 挪到单独的 client 里面实现了，所以也许是 mutter 的问题，不过我还是尝试用 gdb 看了一下 backtrace：&lt;/p&gt;
&lt;figure data-raw=&quot;Thread 1 &amp;quot;mutter-x11-fram&amp;quot; received signal SIGSEGV, Segmentation fault.
___pthread_mutex_lock (mutex=0x123) at pthread_mutex_lock.c:80
Downloading source file /usr/src/debug/glibc/glibc/nptl/pthread_mutex_lock.c
80        unsigned int type = PTHREAD_MUTEX_TYPE_ELISION (mutex);                                                                                                                                                                                             
(gdb) bt
#0  ___pthread_mutex_lock (mutex=0x123) at pthread_mutex_lock.c:80
#1  0x00007ffff685aaf6 in wl_proxy_create_wrapper (proxy=proxy@entry=0x55555558e510) at ../wayland-1.22.0/src/wayland-client.c:2446
#2  0x00007ffff2ad337c in getServerProtocolsInfo (protocols=0x7fffffffdc70, nativeDpy=0x55555558e510) at ../egl-wayland/src/wayland-egldisplay.c:464
#3  wlEglGetPlatformDisplayExport (data=0x5555555ae000, platform=&lt;optimized out&gt;, nativeDpy=0x55555558e510, attribs=&lt;optimized out&gt;) at ../egl-wayland/src/wayland-egldisplay.c:580
#4  0x00007ffff26acfa0 in  () at /usr/lib/libEGL_nvidia.so.0
#5  0x00007ffff264c71c in  () at /usr/lib/libEGL_nvidia.so.0
#6  0x00007ffff2ba4885 in GetPlatformDisplayCommon (platform=12760, native_display=0x55555558e510, attrib_list=0x0, funcName=0x7ffff2baad18 &amp;quot;eglGetDisplay&amp;quot;) at ../libglvnd-v1.6.0/src/EGL/libegl.c:324
#7  0x00007ffff7a19357 in gdk_display_create_egl_display (native_display=0x55555558e510, platform=12757) at ../gtk/gdk/gdkdisplay.c:1484
#8  gdk_display_init_egl (self=0x5555555a1820, platform=12757, native_display=0x55555558e510, allow_any=0, error=0x5555555a17f8) at ../gtk/gdk/gdkdisplay.c:1667
#9  0x00007ffff79edb53 in gdk_x11_display_init_gl_backend (error=0x5555555a17f8, out_depth=0x5555555a18c4, out_visual=0x5555555a18c8, self=0x5555555a1820) at ../gtk/gdk/x11/gdkdisplay-x11.c:2975
#10 gdk_x11_display_init_gl (display=0x5555555a1820, error=0x5555555a17f8) at ../gtk/gdk/x11/gdkdisplay-x11.c:3013
#11 0x00007ffff7a198f0 in gdk_display_init_gl (self=0x5555555a1820) at ../gtk/gdk/gdkdisplay.c:1248
#12 gdk_display_prepare_gl (self=0x5555555a1820, error=0x0) at ../gtk/gdk/gdkdisplay.c:1320
#13 0x00007ffff79ec355 in gdk_x11_display_open (display_name=&lt;optimized out&gt;) at ../gtk/gdk/x11/gdkdisplay-x11.c:1479
#14 0x00007ffff7a15c62 in gdk_display_manager_open_display (manager=&lt;optimized out&gt;, name=0x0) at ../gtk/gdk/gdkdisplaymanager.c:431
#15 0x00007ffff777dda9 in gdk_display_open_default () at ../gtk/gdk/gdk.c:331
#16 gtk_init_check () at ../gtk/gtk/gtkmain.c:621
#17 gtk_init_check () at ../gtk/gtk/gtkmain.c:603
#18 0x00007ffff777dfee in gtk_init () at ../gtk/gtk/gtkmain.c:659
#19 0x0000555555557070 in main (argc=&lt;optimized out&gt;, argv=&lt;optimized out&gt;) at ../mutter/src/frames/main.c:56
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;Thread 1 &quot;mutter-x11-fram&quot; received signal SIGSEGV, Segmentation fault.
___pthread_mutex_lock (mutex=0x123) at pthread_mutex_lock.c:80
Downloading source file /usr/src/debug/glibc/glibc/nptl/pthread_mutex_lock.c
80        unsigned int type = PTHREAD_MUTEX_TYPE_ELISION (mutex);                                                                                                                                                                                             
(gdb) bt
#0  ___pthread_mutex_lock (mutex=0x123) at pthread_mutex_lock.c:80
#1  0x00007ffff685aaf6 in wl_proxy_create_wrapper (proxy=proxy@entry=0x55555558e510) at ../wayland-1.22.0/src/wayland-client.c:2446
#2  0x00007ffff2ad337c in getServerProtocolsInfo (protocols=0x7fffffffdc70, nativeDpy=0x55555558e510) at ../egl-wayland/src/wayland-egldisplay.c:464
#3  wlEglGetPlatformDisplayExport (data=0x5555555ae000, platform=&amp;lt;optimized out&amp;gt;, nativeDpy=0x55555558e510, attribs=&amp;lt;optimized out&amp;gt;) at ../egl-wayland/src/wayland-egldisplay.c:580
#4  0x00007ffff26acfa0 in  () at /usr/lib/libEGL_nvidia.so.0
#5  0x00007ffff264c71c in  () at /usr/lib/libEGL_nvidia.so.0
#6  0x00007ffff2ba4885 in GetPlatformDisplayCommon (platform=12760, native_display=0x55555558e510, attrib_list=0x0, funcName=0x7ffff2baad18 &quot;eglGetDisplay&quot;) at ../libglvnd-v1.6.0/src/EGL/libegl.c:324
#7  0x00007ffff7a19357 in gdk_display_create_egl_display (native_display=0x55555558e510, platform=12757) at ../gtk/gdk/gdkdisplay.c:1484
#8  gdk_display_init_egl (self=0x5555555a1820, platform=12757, native_display=0x55555558e510, allow_any=0, error=0x5555555a17f8) at ../gtk/gdk/gdkdisplay.c:1667
#9  0x00007ffff79edb53 in gdk_x11_display_init_gl_backend (error=0x5555555a17f8, out_depth=0x5555555a18c4, out_visual=0x5555555a18c8, self=0x5555555a1820) at ../gtk/gdk/x11/gdkdisplay-x11.c:2975
#10 gdk_x11_display_init_gl (display=0x5555555a1820, error=0x5555555a17f8) at ../gtk/gdk/x11/gdkdisplay-x11.c:3013
#11 0x00007ffff7a198f0 in gdk_display_init_gl (self=0x5555555a1820) at ../gtk/gdk/gdkdisplay.c:1248
#12 gdk_display_prepare_gl (self=0x5555555a1820, error=0x0) at ../gtk/gdk/gdkdisplay.c:1320
#13 0x00007ffff79ec355 in gdk_x11_display_open (display_name=&amp;lt;optimized out&amp;gt;) at ../gtk/gdk/x11/gdkdisplay-x11.c:1479
#14 0x00007ffff7a15c62 in gdk_display_manager_open_display (manager=&amp;lt;optimized out&amp;gt;, name=0x0) at ../gtk/gdk/gdkdisplaymanager.c:431
#15 0x00007ffff777dda9 in gdk_display_open_default () at ../gtk/gdk/gdk.c:331
#16 gtk_init_check () at ../gtk/gtk/gtkmain.c:621
#17 gtk_init_check () at ../gtk/gtk/gtkmain.c:603
#18 0x00007ffff777dfee in gtk_init () at ../gtk/gtk/gtkmain.c:659
#19 0x0000555555557070 in main (argc=&amp;lt;optimized out&amp;gt;, argv=&amp;lt;optimized out&amp;gt;) at ../mutter/src/frames/main.c:56
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后我就在想看起来是 GTK4 的问题，我还去群里问了一下有没有 GNOME + NVIDIA 的用户，看看是我的问题还是 bug，不过没人理我，还差点把我恶心到了。然后我想了一下试了 &lt;code&gt;GDK_BACKEND=x11 nautilus&lt;/code&gt; 发现也有一样的问题，就跑到 GTK 那边提了个 issue，结果那位有点出名的毒舌老哥跟我说看着不像是 GTK 的问题倒像是 nvidia 的问题，我也怀疑过，但我检查了一下和 nvidia 相关的都没什么变化，然后我去翻 glvnd 和 egl-wayland 的仓库也没翻出什么。换到 KDE 下面还是一样有问题。但我突然想到会不会和我设置的一些环境变量有关系，于是就去注销了一大片，结果就好了。最后我看了一下好像有 platform，发现是我设置过一个 &lt;code&gt;EGL_PLATFORM=wayland&lt;/code&gt; 的环境变量，删掉这个就好了。&lt;/p&gt;
&lt;p&gt;我想了一下这应该是我当初弄 Firefox 的硬件解码视频时候设置的，果不其然在 &lt;a href=&quot;https://github.com/elFarto/nvidia-vaapi-driver#firefox&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/elFarto/nvidia-vaapi-driver#firefox&lt;/a&gt; 里面写了，看起来是因为这个变量导致 XWayland 程序加载 EGL 的时候把 platform 当成了 Wayland，不过我没想清楚为什么滚系统之前没有遇到这个问题。&lt;/p&gt;
&lt;p&gt;总之这是个不能算 bug 的问题了，如果我在群里问的时候有人回我，我就能直接排除法发现是我自己配置的问题，结果提了 issue 以后发现不是上游的问题感觉很尴尬。想了一下还是决定把这个记在这里，因为我推测有很多人看了 &lt;code&gt;nvidia-vaapi-driver&lt;/code&gt; 的文档，说不定也设置了这个变量然后遇到了同样的问题，记录下来方便搜到。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    <category term="NVIDIA" label="NVIDIA" scheme="https://sh.alynx.one/tags/NVIDIA/" />
  </entry>
  <entry>
    <title>Emacs 和 Lazy Loading 和 use-package</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Emacs-Lazy-Loading-use-package/" />
    <id>https://sh.alynx.one/posts/Emacs-Lazy-Loading-use-package/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-01-20T09:55:00.000Z</published>
    <updated>2023-01-20T09:55:00.000Z</updated>
    <summary type="html">
      事先叠 buff：我不是说 use-package 一定要这么用，我也不是说所用不用 use-package 的人都不好，我只是说我觉得应该这样用 use-package 比较合适。 use-package 是个好东西，因为它解决了 Emacs 插件包从安装到配置的全过程，可以让…
    </summary>
    <content type="html">
      &lt;p&gt;事先叠 buff：我不是说 &lt;code&gt;use-package&lt;/code&gt; 一定要这么用，我也不是说所用不用 &lt;code&gt;use-package&lt;/code&gt; 的人都不好，我只是说我觉得应该这样用 &lt;code&gt;use-package&lt;/code&gt; 比较合适。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;use-package&lt;/code&gt; 是个好东西，因为它解决了 Emacs 插件包从安装到配置的全过程，可以让配置更结构化。不过也有人觉得 &lt;code&gt;use-package&lt;/code&gt; 关键字过于复杂，总是没办法确定什么配置写到什么字段里面，也不知道展开之后悄悄发生了什么事情。从我再次决定自己打造一份 Emacs 配置以来看了很多不同人的配置，发现他们使用 &lt;code&gt;use-package&lt;/code&gt; 的方式也是五花八门，有些人不爱用 &lt;code&gt;:bind&lt;/code&gt; 和 &lt;code&gt;:hook&lt;/code&gt;，干脆自己在 &lt;code&gt;:config&lt;/code&gt; 里面调用 &lt;code&gt;define-key&lt;/code&gt; 和 &lt;code&gt;add-hook&lt;/code&gt;，有些人不清楚为什么自己的 &lt;code&gt;:config&lt;/code&gt; 被延迟运行了，干脆全都用 &lt;code&gt;:init&lt;/code&gt;。还有些人直接换成了其它号称更简单可控的替代品。我不是说上面这些方法都错了，实际上只要能得到想要的结果也无所谓怎么写，但我是一个比较注重逻辑的人，所以研究了一下到底这些关键字是怎么回事，并且试图写篇文章记录我推荐的写法。本来我打算写在注释里的，可是感觉写得太多，所以就放到博客里了。&lt;/p&gt;
&lt;p&gt;问题的核心无非是：为什么我写的 &lt;code&gt;:config&lt;/code&gt; 没有运行？到底什么情况下会有延迟加载？我打算在这里详细分析一下。&lt;/p&gt;
&lt;p&gt;首先 Emacs 有一种叫做 autoloads 的东西，插件包的作者可以在某些函数前加上 autoloads 标记，然后创建 autoloads 文件。这个功能的作用很好理解，原本在启动时需要加载所有插件包的文件以便用户使用相应的功能，但不是所有的插件都是启动时就需要，只在启动时加载会让启动速度变得很慢。有了 autoloads 之后启动时只要加载 autoloads 文件，里面定义了如果运行某个函数，就去加载某个文件，这样等到对应的函数第一次运行的时候才被加载，从而提高启动速度。&lt;/p&gt;
&lt;p&gt;而 &lt;code&gt;use-package&lt;/code&gt; 做了什么呢？&lt;code&gt;use-package&lt;/code&gt; 可以自动创建 autoloads，这样即使一个包本身没有 autoloads，也是可以延迟加载的。最简单的触发这个逻辑的关键字是 &lt;code&gt;:commands&lt;/code&gt;，就是给后续的函数创建 autoloads 的意思。但如果你仔细阅读文档，就会发现还有几个创建 autoloads 的关键字，分别是 &lt;code&gt;:bind&lt;/code&gt;、&lt;code&gt;:hook&lt;/code&gt;、&lt;code&gt;:mode&lt;/code&gt; 和 &lt;code&gt;:interpreter&lt;/code&gt;。&lt;strong&gt;如果有这几个关键字，&lt;code&gt;use-package&lt;/code&gt; 不会立即加载一个包，而是依靠创建的 autoloads 实现延迟加载。&lt;/strong&gt;这也很好理解，这几个关键字的意思都是“在某种情况下启用”，所以自动延迟加载也很好理解。&lt;/p&gt;
&lt;p&gt;然后为什么会遇到 &lt;code&gt;:config&lt;/code&gt; 不会运行所以有些人统统把要调用的语句写到 &lt;code&gt;:init&lt;/code&gt; 里面的问题呢？一般都是发生在类似下面的写法（既有快捷键 / 钩子，又要一启动就启用什么模式）里：&lt;/p&gt;
&lt;figure data-raw=&quot;(use-package marginalia
  :ensure t
  :bind (:map minibuffer-local-map
              (&amp;quot;M-A&amp;quot; . marginalia-cycle))
  :config
  (marginalia-mode 1))
&quot; data-info=&quot;language-lisp&quot; data-lang=&quot;lisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-lisp&quot;&gt;(use-package marginalia
  :ensure t
  :bind (:map minibuffer-local-map
              (&quot;M-A&quot; . marginalia-cycle))
  :config
  (marginalia-mode 1))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我们得明确 &lt;code&gt;:init&lt;/code&gt; 和 &lt;code&gt;:config&lt;/code&gt; 的区别，&lt;code&gt;:init&lt;/code&gt; 是“无论包有没有加载，都一定会先执行”的配置，&lt;code&gt;:config&lt;/code&gt; 是“包加载之后才会被执行”的配置。然后按照上面关于延迟加载的分析，这就变成了一个“先有鸡还是先有蛋”的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;use-package&lt;/code&gt; 给这个包创建了快捷键对应的 autoloads，于是这个包不会立刻加载。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;:config&lt;/code&gt; 里面 &lt;code&gt;(marginalia-mode 1)&lt;/code&gt; 要等到包加载之后才运行。&lt;/li&gt;
&lt;li&gt;这个包本身有给 &lt;code&gt;marginalia-mode&lt;/code&gt; 创建 autoloads，只要调用 &lt;code&gt;marginalia-mode&lt;/code&gt; 就会加载这个包，但是根据 1 和 2，这句不会被调用，包也不会被加载，除非按了 1 里面的快捷键。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打破这个循环的办法不止一种，比如把 &lt;code&gt;(marginalia-mode 1)&lt;/code&gt; 写进 &lt;code&gt;:init&lt;/code&gt;，这样无论如何都会调用它，于是 &lt;code&gt;use-package&lt;/code&gt; 创建的 autoloads 被忽略了，包肯定会被加载。但我个人倾向于把这种启用模式的函数放在 &lt;code&gt;:config&lt;/code&gt; 里面，而且作者也推荐不要在 &lt;code&gt;:init&lt;/code&gt; 里面放过于复杂的函数，这时候打破循环的办法也很简单，只要使用 &lt;code&gt;:demand t&lt;/code&gt;，告诉 &lt;code&gt;use-package&lt;/code&gt; 立即加载这个包即可。&lt;/p&gt;
&lt;p&gt;以上的内容其实都写在 &lt;a href=&quot;https://github.com/jwiegley/use-package#notes-about-lazy-loading&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/jwiegley/use-package#notes-about-lazy-loading&lt;/a&gt;，只是可能很多人没有注意或者没看明白，于是我试图在这里更详细的解释一下。可能有人会问搞这么复杂真的有意义吗？我直接自己不要延迟加载直接都 &lt;code&gt;require&lt;/code&gt; 不可以？不过我觉得这种激进的延迟加载方案确实让我的 Emacs 启动非常快，所以大概是有意义的吧。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Emacs" label="Emacs" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Emacs/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Emacs" label="Emacs" scheme="https://sh.alynx.one/tags/Emacs/" />
  </entry>
  <entry>
    <title>StackHarbor 的 2022 尾记</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/2022-Tail/" />
    <id>https://sh.alynx.one/posts/2022-Tail/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2023-01-10T05:43:00.000Z</published>
    <updated>2023-01-10T05:43:00.000Z</updated>
    <summary type="html">
      &lt;p&gt;每年写年终总结我都会拖很晚，因为基本上我写博客是看心情，最近事情比较多，其实也打算再拖几天的，但是实在是不想回家之后写，所以不得不今天仓促动手。&lt;/p&gt;
&lt;p&gt;然后实际上我不喜欢分类列提纲的写法，我本质上比较倾向于文学性的写法或者就是想到什么写什么，不过最近我在翻以前的年终总结的时候发现事情总是记的乱七八糟而且有些我都想不起来出现在哪篇文章里了，这当然可能也和我写完年终总结从来不看有关系，反正这次打算试一下分类的写法。&lt;/p&gt;
&lt;p&gt;按照惯例还是要感慨一句时间过得真快，仅仅只是靠记忆的话，就会觉得自己什么也没做就过了一年。写年终总结的时候到处翻一下记录，才会意识到自己其实做了不少事情。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;每年写年终总结我都会拖很晚，因为基本上我写博客是看心情，最近事情比较多，其实也打算再拖几天的，但是实在是不想回家之后写，所以不得不今天仓促动手。&lt;/p&gt;
&lt;p&gt;然后实际上我不喜欢分类列提纲的写法，我本质上比较倾向于文学性的写法或者就是想到什么写什么，不过最近我在翻以前的年终总结的时候发现事情总是记的乱七八糟而且有些我都想不起来出现在哪篇文章里了，这当然可能也和我写完年终总结从来不看有关系，反正这次打算试一下分类的写法。&lt;/p&gt;
&lt;p&gt;按照惯例还是要感慨一句时间过得真快，仅仅只是靠记忆的话，就会觉得自己什么也没做就过了一年。写年终总结的时候到处翻一下记录，才会意识到自己其实做了不少事情。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E7%BC%96%E7%A8%8B&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E7%BC%96%E7%A8%8B&quot;&gt;&lt;/a&gt;编程&lt;/h1&gt;
&lt;p&gt;我经常会处于一种“我好菜啊怎么什么都做不了”和“我还能搞定这个其实还不错”的叠加态，实际上仔细翻一下感觉去年还是做了不少东西。比如说在 HackWeek 把 Show Me The Key 成功换成了 GTK4。然后还抽时间利用 Telegram 机器人做了个照片墙，虽然中间我把它关了很长时间，不过后来我又把它跑起来了。&lt;/p&gt;
&lt;p&gt;这一年我印象最深的其实是搞我的 Emacs 配置。在有确定消息说 GitHub 打算放弃 Atom 之后，我不得不给我自己重新找一个编辑器，因为我得了一种看到 Visual Studio 就会死的病所以坚决不会用 VSCode，除非他们哪天改名部把 VS 从里面去掉。然后我一直是不喜欢模态编辑的所以也不会用 Vim，同时 Emacs 的 PGTK 分支已经被上游接受，所以我很高兴地重回 Emacs 拥抱我所知的第一个 pure Wayland 的 GUI 编辑器。说是重回，其实相当于重新学习了一遍 Emacs Lisp，毕竟我一开始尝试 Emacs 是被 Spacemacs 那句著名的口号吸引的（但是我又不用 Evil）。那时候其实我不太懂 Emacs Lisp，但是现在回头再看发现确实是更好掌握了。虽然有无数的人说应该从别人配好的 Emacs 配置开始，但我还是决定自己编写一套配置而不是使用最流行的 doom。一个是这些配置好像都以模态编辑为中心，另一个是我经常会自己定制自己的编辑器，使用这些别人配好的配置调起来总觉得很不自在。然后就是我逐渐理解了 &lt;code&gt;use-package&lt;/code&gt; 的用法，解决了各种奇奇怪怪的问题，甚至还自己用 Emacs Lisp 写了很多自己需要的功能。虽然可能有人要问你搞这一通有什么意义之类的，但是我做事的一个原则就是看心情，我高兴就好，所以觉得还挺值的。&lt;/p&gt;
&lt;p&gt;然后不论是工作还是个人爱好上这一年多少也做了点东西，毕竟我的工作就是我的爱好。比如很有意思的一个是我研究了一下 GNOME 的智能卡登录到底怎么搞，顺便也大致了解了一下 PAM 的配置，虽然可能这个还是没什么用，不过最后我修改了 openSUSE 的 gdm 包添加了一直缺失的指纹和智能卡的 PAM 配置，也算是帮助了其他人。我还抽出时间调查了一下 GTK3 和 GTK4 的亮色 / 暗色主题切换到底是怎么回事。然后还做了一些微小的贡献，比如我印象里一直有人吐槽说 GNOME Shell 的搜索只能从开头匹配而不能做子串匹配，还有人说难道他们只会用 &lt;code&gt;String.prototype.startsWith()&lt;/code&gt; 不会用 &lt;code&gt;String.prototype.includes()&lt;/code&gt;，我一开始只是想既然这么简单，有吐槽的时间为什么不自己改一个？于是我花时间看了一下还真不是这么简单，总之最后我阅读了 glib 里面的算法，并且添加了根据不同的匹配模式分组的功能，现在如果有单词开头匹配的会优先显示，然后再显示子串匹配，就可以通过搜索 &lt;code&gt;fox&lt;/code&gt; 得到 &lt;code&gt;Firefox&lt;/code&gt; 了（&lt;a href=&quot;https://gitlab.gnome.org/GNOME/glib/-/merge_requests/3107&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/glib/-/merge_requests/3107&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;和这个类似的还有另一个，我看到有人说 &lt;code&gt;gdbus-codegen&lt;/code&gt; 生成的代码没有加空指针检查导致程序崩溃，然后和开发者吵了起来，开发者说加空指针检查不是真的解决问题，这里不应该传空指针，那个人就丢出一堆各种代码规范说传了空指针应该继续运行不该崩溃，开发者说你给我们加的话我们愿意接受，他又说自己不擅长 python，总之我看了觉得很不可理喻，于是我自己改掉提交了然后嘲笑了那人一通。有些时候真不是开发者脾气不好，是有人态度太差……（&lt;a href=&quot;https://gitlab.gnome.org/GNOME/glib/-/merge_requests/3175&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/glib/-/merge_requests/3175&lt;/a&gt;）&lt;/p&gt;
&lt;h1 id=&quot;%E9%9F%B3%E4%B9%90&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E9%9F%B3%E4%B9%90&quot;&gt;&lt;/a&gt;音乐&lt;/h1&gt;
&lt;p&gt;去年一年我还是录了好几个曲子的，虽然我自己是觉得没怎么练琴而且还经常咕咕咕。不过我发出来的我自己还都觉得不错，虽然不是每个都有很多播放量吧。最近手上有几个想录的，比如 シリウスの心臓 和 暗恋是一个人的事，不过可能又要拖到年后了。&lt;/p&gt;
&lt;p&gt;然后今年通过 &lt;a href=&quot;https://space.bilibili.com/4947340&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;澪音奏&lt;/a&gt; 的翻唱听了好多伍佰的曲子，对于我这种几乎不会主动找歌曲来听的人，能扩充曲库还是好事。还在 B 站听了纵贯线的亡命之徒，没早点听到这个真是有点可惜。&lt;/p&gt;
&lt;h1 id=&quot;%E6%95%B0%E7%A0%81&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E6%95%B0%E7%A0%81&quot;&gt;&lt;/a&gt;数码&lt;/h1&gt;
&lt;p&gt;其实我觉得我也没买什么东西，但是再看一下又不少，很多其实没什么可说的，比如买了个新镜头，那就是新镜头，也没什么好在博客里分析一番的。考虑到那块老移动硬盘用了很久，又买了一块三星的 T7 Shield，固态的移动硬盘还是可靠很多。犹豫了很久还是买了平板，不过不是 iPad，是 Galaxy Tab S8，除了 LCD 屏幕有点漏光，别的我都很满意，不管是看谱子还是看视频都不错，虽然有些 app 不支持横屏，但我还是觉得文件管理更重要。&lt;/p&gt;
&lt;p&gt;开销比较大的是装了一台 NAS，实际也是挑来挑去才决定的，运行了小一年觉得还不错，极大的缓解了我的存储压力。&lt;/p&gt;
&lt;h1 id=&quot;%E6%91%84%E5%BD%B1&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E6%91%84%E5%BD%B1&quot;&gt;&lt;/a&gt;摄影&lt;/h1&gt;
&lt;p&gt;自我评价的话我觉得还是有点进步，别的不说，今年我拍了很多自己觉得不错的照片。摸索了一年，我大概也知道怎么用 darktable 得到想要的效果了。之前看到有人总结了一下自己拍过的照片里觉得不错的，我觉得这个想法很好，于是挑了一些今年满意的照片放在这里：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/2022-Tail/DSC00674.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC06074.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC07236.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/R3103214_04.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/R3103766_04.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC08433.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC08556.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC09543.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC09817_01.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/R3104386.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/R3104387.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/000183680027.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/000183800005.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/000183800014.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/000183800015.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC01159.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC01265.jpg&quot; alt=&quot;&quot;&gt;
&lt;img src=&quot;/posts/2022-Tail/DSC01274.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;很想找机会把我喜欢的照片打印出来装上相框挂在家里，只是一直没去做这件事。&lt;/p&gt;
&lt;h1 id=&quot;%E5%8A%A8%E6%BC%AB&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E5%8A%A8%E6%BC%AB&quot;&gt;&lt;/a&gt;动漫&lt;/h1&gt;
&lt;p&gt;今年应该只看了两部，一部是 DitF，具体的评价我在 &lt;a href=&quot;/posts/Not-to-Be-EVA-but-to-Be-Pacific-Rim/&quot;&gt;这篇文章&lt;/a&gt; 写过了。另一部是 赛博朋克：边缘行者，我其实是不喜欢赛博朋克题材的，但是这一部做得太好了，我在这里向所有读者推荐。&lt;/p&gt;
&lt;h1 id=&quot;%E5%B0%8F%E8%AF%B4&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E5%B0%8F%E8%AF%B4&quot;&gt;&lt;/a&gt;小说&lt;/h1&gt;
&lt;p&gt;今年应该是看了基地三部曲，还有格兰特船长的儿女和神秘岛，因为都是很好找到电子版的，所以没有买实体书，神秘岛以前看过简写版，其他的都是头一次看，总体上来说我觉得都不错，毕竟也是流传很久的书了。&lt;/p&gt;
&lt;h1 id=&quot;%E6%B8%B8%E6%88%8F&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E6%B8%B8%E6%88%8F&quot;&gt;&lt;/a&gt;游戏&lt;/h1&gt;
&lt;p&gt;除了和开黑群的朋友打 Dota 2 就是和牛爷爷高先生吃鸡，今年更多的玩了游廊地图，感觉我还是想玩休闲一点不太需要团队配合的，吃鸡的话我以为我很久没玩了水平会很差，不过我好像逐渐掌握这个游戏怎么赢了，而且经常可以吃鸡。其实玩游戏本身倒不重要，重要的是有人一起玩。一个人玩的话，要不是因为看中单光一，我大概不会坚持玩 Dota 2。&lt;/p&gt;
&lt;h1 id=&quot;%E7%94%9F%E6%B4%BB&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/2022-Tail/#%E7%94%9F%E6%B4%BB&quot;&gt;&lt;/a&gt;生活&lt;/h1&gt;
&lt;p&gt;在经历了翻大饼之后果然是不负众望的夺冠了，虽然已经好了。大饼现在是翻过来了，但是保不准哪天又要翻回去，反正我是受够了这种提心吊胆的日子。仔细想想今年我大概有好几次对着共享单车打开健康码扫码，还是挺可怕的。蓝猫今年去了日本，没办法再找她玩了，虽然我很羡慕，但是我又穷又懒。至于脱单这种事情，算了吧，我已经放弃了，一个人待着也挺好的，我一点都不羡慕别人（假的）。&lt;/p&gt;
&lt;p&gt;最近几天突然又肋骨痛，只要有动作扯到就很难受，我也不知道是气胸还是肋间神经痛还是肌肉拉伤，本来打算去医院看看的，但最近事情安排满了，回家的时间取决于车票不取决于我，所以只能等回家之后再说。&lt;/p&gt;

    </content>
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    <category term="时光飞逝" label="时光飞逝" scheme="https://sh.alynx.one/tags/%E6%97%B6%E5%85%89%E9%A3%9E%E9%80%9D/" />
  </entry>
  <entry>
    <title>YubiKey 和 GNOME 和智能卡登录</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/YubiKey-GNOME-Smartcard-Login/" />
    <id>https://sh.alynx.one/posts/YubiKey-GNOME-Smartcard-Login/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-11-28T10:24:04.000Z</published>
    <updated>2022-11-30T13:08:11.000Z</updated>
    <summary type="html">
      最近我终于决定买了一个 YubiKey 5C，说出来不怕各位笑话，我买这玩意最初的动机只是觉得每次开机和解锁输密码太麻烦（但是为什么我不觉得 sudo 输密码麻烦呢？）。这还和我之前处理了一个 openSUSE 的 PAM 问题有关，我发现 GDM 有好几种不同的 PAM 配置，…
    </summary>
    <content type="html">
      &lt;p&gt;最近我终于决定买了一个 YubiKey 5C，说出来不怕各位笑话，我买这玩意最初的动机只是觉得每次开机和解锁输密码太麻烦（但是为什么我不觉得 &lt;code&gt;sudo&lt;/code&gt; 输密码麻烦呢？）。这还和我之前处理了一个 openSUSE 的 PAM 问题有关，我发现 GDM 有好几种不同的 PAM 配置，除了平时用的 &lt;code&gt;gdm-password&lt;/code&gt; 密码登录，还有 &lt;code&gt;gdm-fingerprint&lt;/code&gt; 指纹登录和 &lt;code&gt;gdm-smartcard&lt;/code&gt; 智能卡登录。我一开始是打算买个指纹传感器的，查了一下 fprintd 的文档，支持的型号并不多，而且在淘宝上问客服 USB Product ID 和 Vendor ID 显然得不到回答，就退而求其次买智能卡了，而搜索智能卡得到最多的结果就是 YubiKey，进入一个不了解的领域之前和大部分人选一样的一般不会错太多，于是就下手了。&lt;/p&gt;
&lt;p&gt;话说回来智能卡登录，如果你搜索 YubiKey 相关的文章，绝大多数都会告诉你把 &lt;code&gt;pam_u2f.so&lt;/code&gt; 加到需要密码登录的 PAM 配置里，比如 &lt;code&gt;sudo&lt;/code&gt; 或者 &lt;code&gt;gdm-password&lt;/code&gt;，但这显然不是我想要的，我要的方案不是替换密码登录，而是和密码登录平行的配置文件，我知道 GNOME 有已经写好的智能卡配置，但是任何地方都搜不到如何启用，设置里没有相关选项，连 Arch Wiki 给的方案都只是用 &lt;code&gt;pam_u2f.so&lt;/code&gt;。Red Hat 的支持文档里倒是提到了智能卡登录，然而用的却是他们自己的某个工具配置的。显然这是个起夜级 feature，最好的办法也许是找个起夜级 Linux 的桌面工程师来问问，哦什么我自己就是起夜级 Linux 桌面工程师，那没事了。还要说的一件事是怎么想智能卡这东西都和安全相关，而我自己不是专业的安全行业人士，所以我不会尝试解释清楚和安全相关的一些名词，以及如果我哪里真的写错了，希望专业人士多多指点，我肯定改。&lt;/p&gt;
&lt;p&gt;总之相信你自己因为你才是职业选手，我还是自己看看这东西怎么弄吧，毕竟用 Arch 再用 GNOME 同时还打算搞 GNOME 的智能卡登录的人没几个，所以 Wiki 没有倒也正常。首先肯定是看 &lt;code&gt;/etc/pam.d/gdm-smartcard&lt;/code&gt; 这个文件，里面别的看起来都比较正常，只有一行看起来和智能卡有关系：&lt;/p&gt;
&lt;figure data-raw=&quot;auth       required                    pam_pkcs11.so        wait_for_card card_only
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;auth       required                    pam_pkcs11.so        wait_for_card card_only
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;线索是有了，看来我需要这个 &lt;code&gt;pam_pkcs11.so&lt;/code&gt;，虽然我也不知道这是什么，先搜一下哪个包有这个文件比较好。&lt;code&gt;pacman -F pam_pkcs11.so&lt;/code&gt; 竟然没有返回任何结果，我确定不是我的 pacman 数据库没更新，那只能去浏览器里搜索了，最后我搜到了 &lt;a href=&quot;https://github.com/OpenSC/pam_pkcs11&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/OpenSC/pam_pkcs11&lt;/a&gt;，虽然我也不知道 &lt;code&gt;PKCS#11&lt;/code&gt; 是个什么玩意，但反正它是个 PAM 模块，既然不在官方仓库里，那大概率 AUR 里有人打包了，于是直接 &lt;code&gt;paru pam_pksc11&lt;/code&gt; 就装了一个上来。&lt;/p&gt;
&lt;p&gt;但装是装好了，也看不出来这玩意和 YubiKey 有什么联系，我大概是搜索了 PKCS YubiKey 然后搜到了 YubiKey 给的文档 &lt;a href=&quot;https://developers.yubico.com/PIV/Guides/SSH_with_PIV_and_PKCS11.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Using PIV for SSH through PKCS #11&lt;/a&gt;，好吧虽然我不是要用来 SSH 但是多半也有点用。看下来反正这个东西和 YubiKey 的 PIV 功能有关，我把 PIV 相关的文档都看了一遍，结果是云里雾里，相当没有头绪。一大堆文档告诉你各种各样的需求要做什么，但是几乎没怎么说这都是什么，于是恰好我的需求不在列表里我就不知道怎么办了。我又回头去看 &lt;code&gt;pam_pkcs11&lt;/code&gt; 的文档，它写了一长串的东西，我反复看了几遍之后发现只要看 &lt;a href=&quot;http://opensc.github.io/pam_pkcs11/doc/pam_pkcs11.html#HOWTO&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;第 11 节的 HOWTO 部分&lt;/a&gt; 就可以了。虽然我也不太清楚它都在说什么，但是至少这里告诉我说需要一个 root CA certificate，但我是个人使用哪来的这玩意，再回头看 YubiKey 的那篇文档里面恰好提到了什么 self-signed certificate，我拿这个试一试，结果成功了。为了方便参考，下面我就不讲我是怎么倒推这些奇怪的需求的了，而是顺序讲一下都需要配置什么。&lt;/p&gt;
&lt;p&gt;首先如果你像我一样刚买了一个 YubiKey 打算利用它的 PIV 功能，那你得先初始化它，也就是改掉默认的 PIN，PUK 和管理密钥，这个可以通过官方的 YubiKey Manager 软件来操作，有 Qt 写的 GUI 版和命令行版本：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S yubikey-manager yubikey-manager-qt
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pacman -S yubikey-manager yubikey-manager-qt
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我推荐使用命令行版本操作，因为那个 GUI 经常转圈转半天或者点了没反应：&lt;/p&gt;
&lt;figure data-raw=&quot;% ykman piv access change-pin
% ykman piv access change-puk
% ykman piv access change-management-key --generate --protect --touch
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% ykman piv access change-pin
% ykman piv access change-puk
% ykman piv access change-management-key --generate --protect --touch
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;默认 PIN 是 &lt;code&gt;123456&lt;/code&gt;，默认 PUK 是 &lt;code&gt;12345678&lt;/code&gt;，而管理密钥是个特别长的一串，用 &lt;code&gt;--generate&lt;/code&gt; 可以让 &lt;code&gt;ykman&lt;/code&gt; 给你生成一个，&lt;code&gt;--protect&lt;/code&gt; 则是把这个直接存到 YubiKey 里面并用 PIN 保护，&lt;code&gt;--touch&lt;/code&gt; 则是说每次要管理密钥的时候需要你摸一下。我也不是很懂，也许写进去以后需要的时候就不用自己背这玩意而是输 PIN 就行了吧，反正建议看官方文档 &lt;a href=&quot;https://developers.yubico.com/PIV/Guides/Device_setup.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Device setup&lt;/a&gt; 和 &lt;code&gt;ykman&lt;/code&gt; 的 &lt;code&gt;--help&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;我的建议是不要看太多官方文档，因为它一会告诉你用 &lt;code&gt;yubico-piv-tool&lt;/code&gt; 创建密钥，一会告诉你说可以用 &lt;code&gt;openssl&lt;/code&gt; 创建密钥，一会又告诉你可以用 &lt;code&gt;pkcs11-tool&lt;/code&gt; 搭配 &lt;code&gt;libykcs11.so&lt;/code&gt; 创建密钥，算了吧，头都看晕了，我的测试是用 &lt;code&gt;yubico-piv-tool&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;figure data-raw=&quot;% paru yubico-piv-tool
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% paru yubico-piv-tool
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在 &lt;code&gt;9a&lt;/code&gt; 这个槽创建一个 key 并把它的公钥写出来，为什么是 &lt;code&gt;9a&lt;/code&gt; 好像因为这是第一个槽来着，自己去查官方文档吧，也可以写到别的槽里面：&lt;/p&gt;
&lt;figure data-raw=&quot;% yubico-piv-tool -s 9a -a verify-pin -a generate -o public.pem
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% yubico-piv-tool -s 9a -a verify-pin -a generate -o public.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;需要先输入 PIN，然后灯闪的时候需要摸一下 YubiKey，它就开始生成了。&lt;/p&gt;
&lt;p&gt;还要给这个密钥生成一个签名：&lt;/p&gt;
&lt;figure data-raw=&quot;% yubico-piv-tool -s 9a -a verify-pin -a selfsign-certificate -S &amp;quot;/CN=Alynx Zhou/&amp;quot; -i public.pem -o cert.pem
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% yubico-piv-tool -s 9a -a verify-pin -a selfsign-certificate -S &quot;/CN=Alynx Zhou/&quot; -i public.pem -o cert.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;注意 &lt;code&gt;CN=&lt;/code&gt; 后面的部分，这里会被 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 用来验证这个智能卡属于系统里面哪个用户，所以简单的话直接写你的登录用户名，当然你像我一样不想写用户名也是有办法对应的，同样要输入 PIN。&lt;/p&gt;
&lt;p&gt;再把证书导回到同一个槽，我也不知道为什么，文档说了我照做了：&lt;/p&gt;
&lt;figure data-raw=&quot;% yubico-piv-tool -s 9a -a verify-pin -a import-certificate -i cert.pem
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% yubico-piv-tool -s 9a -a verify-pin -a import-certificate -i cert.pem
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;还是要输入 PIN 然后灯闪的时候摸一下。&lt;/p&gt;
&lt;p&gt;到这里 YubiKey 的配置就结束了。&lt;/p&gt;
&lt;p&gt;要在系统上使用智能卡验证需要安装系统上和智能卡交互的软件包：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S ccid opensc pcsclite
% paru pam_pkcs11
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pacman -S ccid opensc pcsclite
% paru pam_pkcs11
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;启动一个相关的 daemon，或者启动 socket 也行，需要的时候它就自己起来了：&lt;/p&gt;
&lt;figure data-raw=&quot;# systemctl enable --now pcscd.socket
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# systemctl enable --now pcscd.socket
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果我没漏掉什么乱七八糟的，就可以配置 PAM 模块了，它有一个配置目录叫 &lt;code&gt;/etc/pam_pksc11&lt;/code&gt;，首先你要把上面生成的证书放到 &lt;code&gt;/etc/pam_pkcs11/cacerts&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-raw=&quot;# cd /pam/pkcs11/cacerts
# cp PATH_TO_YOUT_CERT/cert.pem ./
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# cd /pam/pkcs11/cacerts
# cp PATH_TO_YOUT_CERT/cert.pem ./
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;你要在同一个目录下面运行一个什么什么 hash 命令生成一个 hash：&lt;/p&gt;
&lt;figure data-raw=&quot;# pkcs11_make_hash_link
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# pkcs11_make_hash_link
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;接下来你要去搞它的配置文件，先复制一个样本过来：&lt;/p&gt;
&lt;figure data-raw=&quot;# cp /usr/share/doc/pam_pkcs11/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# cp /usr/share/doc/pam_pkcs11/pam_pkcs11.conf.example /etc/pam_pkcs11/pam_pkcs11.conf
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;好像其实也没什么需要改的。文档说默认的配置用的是 OpenSC 的 PKCS#11 库，虽然 YubiKey 的文档一直跟你说什么 &lt;code&gt;libykcs11.so&lt;/code&gt;，我的测试结果是不用理它，通用的接口就够了，以及这个 &lt;code&gt;libykcs11.so&lt;/code&gt; 是属于 &lt;code&gt;yubico-piv-tool&lt;/code&gt; 这个包的。&lt;/p&gt;
&lt;p&gt;假如你刚才 &lt;code&gt;CN=&lt;/code&gt; 后面写的不是你的用户名，那你需要一些配置告诉 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 你这个证书对应的哪个用户，这一步在它的配置文件里叫 &lt;code&gt;mapper&lt;/code&gt;。默认启用了一些 mapper 比如 &lt;code&gt;pwent&lt;/code&gt;，这个就是把 &lt;code&gt;CN=&lt;/code&gt; 后面的内容和 &lt;code&gt;/etc/passwd&lt;/code&gt; 里面的用户名做匹配，但是如果你像我一样写的是全名，那就需要另一个默认启用的模块叫 &lt;code&gt;subject&lt;/code&gt;。至于 subject 是什么需要运行下面这个命令：&lt;/p&gt;
&lt;figure data-raw=&quot;% pkcs11_inspect
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% pkcs11_inspect
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;它会输出各种 mapper 对应的 data，比如 &lt;code&gt;pwent&lt;/code&gt; 输出的就是 &lt;code&gt;Alynx Zhou&lt;/code&gt;，&lt;code&gt;subject&lt;/code&gt; 输出的则是 &lt;code&gt;/CN=Alynx Zhou&lt;/code&gt;。我们需要复制一个 &lt;code&gt;subject_mapping&lt;/code&gt; 配置文件的样本过来：&lt;/p&gt;
&lt;figure data-raw=&quot;# cp /usr/share/doc/pam_pkcs11/subject_mapping.example /etc/pam_pkcs11/subject_mapping
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# cp /usr/share/doc/pam_pkcs11/subject_mapping.example /etc/pam_pkcs11/subject_mapping
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;在这个文件后面加一行：&lt;/p&gt;
&lt;figure data-raw=&quot;/CN=Alynx Zhou -&gt; alynx
&quot; data-info=&quot;language-plain&quot; data-lang=&quot;plain&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-plain&quot;&gt;/CN=Alynx Zhou -&amp;gt; alynx
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我的用户名是 &lt;code&gt;alynx&lt;/code&gt;，你可以换成你自己的。&lt;/p&gt;
&lt;p&gt;到这一步 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 这个模块已经可以通过智能卡验证你的身份了，但是如果你火急火燎兴高采烈的重启了系统，GDM 还是会和你要密码。原因其实很简单，虽然现在 &lt;code&gt;/etc/pam.d/gdm-smartcard&lt;/code&gt; 已经可用了，但 GDM 只有在检测到智能卡之后才会调用这个文件尝试智能卡登录，很显然它没检测到智能卡。&lt;/p&gt;
&lt;p&gt;这里就比较难搞清楚了，我智能卡插的好好的，上面各种程序都能用，为什么你检测不到？我尝试用什么 GDM YubiKey 之类的关键词搜索了半天，也没人告诉我 GDM 到底怎么检测智能卡的。没有办法还是读代码吧，GNOME Shell &lt;code&gt;js/gdm/util.js&lt;/code&gt; 里面的逻辑是通过 D-Bus 的 &lt;code&gt;org.gnome.SettingsDaemon.Smartcard&lt;/code&gt; 获取智能卡信息，那我打开 D-Feet 从 Session Bus 里面找到这个，直接运行 &lt;code&gt;org.gnome.SettingsDaemon.Smartcard.Manager&lt;/code&gt; 的 &lt;code&gt;GetInsertedTokens&lt;/code&gt;，什么都没有。&lt;/p&gt;
&lt;p&gt;根据 D-Bus 的信息，很显然这个接口是 &lt;code&gt;gnome-settings-daemon&lt;/code&gt; 的 &lt;code&gt;smartcard&lt;/code&gt; 插件提供的，我大概是搜索了什么 gsd-smartcard PKCS#11 的关键字之后找到了 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-settings-daemon/-/merge_requests/208&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-settings-daemon/-/merge_requests/208&lt;/a&gt;，其实我一开始也没太看懂这是什么意思，但得到一些有用的信息：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gsd-smartcard&lt;/code&gt; 用了什么 NSS API 获取智能卡设备。&lt;/li&gt;
&lt;li&gt;这玩意要一个什么 system shared certificate NSS database。&lt;/li&gt;
&lt;li&gt;除了 Red Hat 家那一套好像没什么别的发行版弄这个。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这一路下来乱七八糟的名词已经够多的了现在又多了一个什么 NSS 而且只有 Red Hat 才配置了 system shared certificate NSS database，但不管怎么样我是职业选手我不能轻言放弃，还好 Arch Wiki 有这么一个页面 &lt;a href=&quot;https://wiki.archlinux.org/title/Network_Security_Services&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Network Security Services&lt;/a&gt;，但这不是管证书的吗，和智能卡设备有什么关系啊。这时候我又翻开了 Arch Wiki 关于智能卡的页面 &lt;a href=&quot;https://wiki.archlinux.org/title/Smartcards#Chromium&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Smartcards&lt;/a&gt;，里面讲了在 Chromium 里面加载智能卡需要在 NSS 数据库里面加一个模块（什么乱七八糟的），不过它操作的都是用户的家目录下面的数据库，这显然不是 system shared certificate NSS database。然后如果手工执行 &lt;code&gt;/usr/lib/gsd-smartcard -v&lt;/code&gt;，会发现这玩意尝试读取 &lt;code&gt;/etc/pki/nssdb&lt;/code&gt; 获取什么智能卡驱动列表，我系统里面根本没这个目录。算了，既然是 Red Hat 搞的东西，我看看他们怎么写的。正好我有个 Fedora 的虚拟机，打开虚拟机一看还真有这个目录，那就运行下面命令看看：&lt;/p&gt;
&lt;figure data-raw=&quot;% modutil -dbdir /etc/pki/nssdb -list
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% modutil -dbdir /etc/pki/nssdb -list
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;结果里面除了默认项还真有个叫 &lt;code&gt;p11-kit-proxy&lt;/code&gt; 的玩意，我又回去看了一眼那个 Merge Request，现在我完全明白了，不知道为什么 NSS 这玩意会记录一个读取智能卡的驱动列表，然后 &lt;code&gt;gsd-smartcard&lt;/code&gt; 是通过 NSS 获取到智能卡的驱动列表之后再尝试查询智能卡，实际上现在没什么人用 NSS 这个功能了，你这还得往系统的 NSS 数据库里面写东西，除了红帽子家都没人搞这个了，就算有用 NSS 读的（比如浏览器）也是读用户的 NSS 数据库。别的用智能卡的都直接用 &lt;code&gt;p11-kit&lt;/code&gt; 去读智能卡，所以这个 Merge Request 也改成直接用 &lt;code&gt;p11-kit&lt;/code&gt; 读了。不知道为什么这个 Merge Request 没能合并。再多说一句，就算是 Red Hat 的系统 NSS 数据库，现在也不直接写智能卡的驱动了，而也是通过 &lt;code&gt;p11-kit&lt;/code&gt;，所以刚才在 Fedora 的数据库里只看到 &lt;code&gt;p11-kit-proxy&lt;/code&gt; 这一个驱动……&lt;/p&gt;
&lt;p&gt;既然这样我们也在这个数据库里写一个 &lt;code&gt;p11-kit-proxy&lt;/code&gt;，根据 Arch Wiki 的智能卡页面，如果你要通过 &lt;code&gt;p11-kit&lt;/code&gt; 操作 OpenSC 的驱动（这都什么乱七八糟的），那可能需要安装一个 AUR 包来保证它被加载（实际上就是个文件而已）：&lt;/p&gt;
&lt;figure data-raw=&quot;% paru opensc-p11-kit-module
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;% paru opensc-p11-kit-module
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;创建数据库目录并往数据库里写 &lt;code&gt;p11-kit-proxy&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;# mkdir /etc/pki/nssdb
# modutil -dbdir sql:/etc/pki/nssdb -add &amp;quot;p11-kit-proxy&amp;quot; -libfile p11-kit-proxy.so
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# mkdir /etc/pki/nssdb
# modutil -dbdir sql:/etc/pki/nssdb -add &quot;p11-kit-proxy&quot; -libfile p11-kit-proxy.so
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你和我一样又心急火燎的重启了，就会发现还是没用。这不科学啊，Fedora 的数据库里也是这么写的，看一眼 D-Bus 为什么还是没有智能卡。&lt;/p&gt;
&lt;p&gt;实际上最后我发现只差一点点，Fedora 给这个目录下文件的权限是 &lt;code&gt;-rw-r--r--&lt;/code&gt;，而我这边创建好的是 &lt;code&gt;-rw------&lt;/code&gt;。&lt;code&gt;gsd-smartcard&lt;/code&gt; 是以 session 用户运行的当然读不了。所以改一下权限就可以了。&lt;/p&gt;
&lt;figure data-raw=&quot;# chmod 0644 /etc/pki/nssdb/*
&quot; data-info=&quot;language-shell&quot; data-lang=&quot;shell&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-shell&quot;&gt;# chmod 0644 /etc/pki/nssdb/*
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;接下来插着 YubiKey 重启，GDM 启动的 &lt;code&gt;gsd-smartcard&lt;/code&gt; 就能读到系统的 NSS 数据库，检测到智能卡，于是调用 &lt;code&gt;/etc/pam.d/gdm-smartcard&lt;/code&gt;，直接让你输入用户名，输入之后会提示你输入智能卡的 PIN，然后 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 进行验证，就可以登录了。锁屏之后也只要输入智能卡的 PIN 就可以解锁。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;按理说如果给 &lt;code&gt;pam_pkcs11.so&lt;/code&gt; 发一个空白的用户名，它会根据智能卡返回用户名的，不知道为什么我在 GDM 用不了，一定要开机手动输入，有空我看看代码也许可以修改一下。&lt;/del&gt; 我也不知道为什么一定要在 GDM 启动之前插入卡才可以，显示用户列表之后再插入卡我这里没反应。&lt;/p&gt;
&lt;p&gt;更新（2022-11-30）：花了我半天时间研究 GDM 和 PAM，问题不在 GDM，而是因为 Arch Linux 的 &lt;code&gt;gdm-smartcard&lt;/code&gt; 首先调用了 &lt;code&gt;pam_shells&lt;/code&gt; 检查用户是否有合法的 shell，遇到空用户名它第一个失败了，于是我提交了 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gdm/-/merge_requests/193&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;一个 MR&lt;/a&gt;，把 &lt;code&gt;pam_shells&lt;/code&gt; 挪到 &lt;code&gt;pam_pkcs11&lt;/code&gt; 下面，这样它会检查自动返回的用户名。（虽然这些 PAM 配置文件是发行版自己写的但是大家都提交到 GNOME 那边了，我只改了 Arch 的因为我在用，别的发行版的用户先偷着乐吧。）&lt;/p&gt;
&lt;p&gt;如果你想用智能卡解锁的话，一定得是用智能卡登录才可以，它会检查当前的卡是不是登录所用的那张卡，不是的话就只能密码解锁了。折腾这一套花了我一整天时间，因为资料实在是太少了，根本不知道它是怎么工作的。&lt;/p&gt;
&lt;p&gt;以及最后我还发现一篇文章，里面的内容也是讲这个 NSS 数据库的解决方案的，也许我早看见这个就不会这么麻烦了： &lt;a href=&quot;https://p11-glue.freedesktop.narkive.com/4z6daFWc/fixing-nss-and-p11-kit-in-fedora-and-beyond&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Fixing NSS and p11-kit in Fedora (and beyond)&lt;/a&gt;。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    <category term="YubiKey" label="YubiKey" scheme="https://sh.alynx.one/tags/YubiKey/" />
  </entry>
  <entry>
    <title>DaVinci Resolve 在 Linux 下的输入法支持</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Input-Method-Support-for-DaVinci-Resolve-on-Linux/" />
    <id>https://sh.alynx.one/posts/Input-Method-Support-for-DaVinci-Resolve-on-Linux/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-11-25T09:50:13.000Z</published>
    <updated>2022-11-25T09:50:13.000Z</updated>
    <summary type="html">
      令人出乎意料，我竟然是 DaVinci Resolve（后面都简称达芬奇了）的付费用户。虽然它不是开源软件，但是有很好的 Linux 支持，使用体验和功能都是同类中的佼佼者，而且收费也相当合理。我选择付费一个原因是你支持我，我就支持你，这其实和我支持 Steam 和 Valve …
    </summary>
    <content type="html">
      &lt;p&gt;令人出乎意料，我竟然是 DaVinci Resolve（后面都简称达芬奇了）的付费用户。虽然它不是开源软件，但是有很好的 Linux 支持，使用体验和功能都是同类中的佼佼者，而且收费也相当合理。我选择付费一个原因是你支持我，我就支持你，这其实和我支持 Steam 和 Valve 的理由差不多。另一个原因是众所周知的由于什么所谓系统专利许可证的原因达芬奇 Linux 版本不能解码 H264 和 H265 这两种常见的视频编码，只能使用 NVIDIA 显卡的 NVENC 和 NVDEC 来处理，而达芬奇将显卡加速功能作为收费的卖点。于是我就这样半自愿的上了贼船。&lt;/p&gt;
&lt;p&gt;当然排除掉解码问题之后还有另一个比较难受的地方，就是达芬奇 Linux 版没有输入法支持，于是完全没办法输入中文。我猜测不像是某些故意恶心人的企业对 Linux 不友好，而单纯是因为英语开发者没有“输入法”这种概念。毕竟达芬奇的图形界面是基于 Qt 的，而 Qt 直接有现成的输入法支持，构建的时候打开开关就可以了嘛。为此我甚至专门跑到 BlackMagic Design 的用户论坛发了个帖子（&lt;a href=&quot;https://forum.blackmagicdesign.com/viewtopic.php?f=33&amp;amp;t=150886&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://forum.blackmagicdesign.com/viewtopic.php?f=33&amp;amp;t=150886&lt;/a&gt;），作为付费用户，我给你钱，你就得给我办事，就是这么硬气。显然某位员工看到了我的帖子并把它移动到了 Feature Requests 版面，然后就没有然后了。闭源拖拉机总是这样，我看到了，但我懒得改，你给我等着吧。我倒不是说开源拖拉机的维护者都比较勤快，但是至少代码放在那里，说不定用户自己就给你改了送到你面前了，一般再懒的维护者都乐意接受。谁叫我没找到和达芬奇一样好用的开源视频剪辑软件呢。&lt;/p&gt;
&lt;p&gt;不过从它用的 Qt 这一点上来看，应该是有什么办法可以 hack 一下让它支持输入法的。虽然我不是很熟悉 Qt，但是 Fcitx 的开发者 &lt;a href=&quot;https://www.csslayer.info/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@csslayer&lt;/a&gt; 给了我一个方案，他之前写了一篇博客是关于给 Mathematica 添加输入法支持的（&lt;a href=&quot;https://www.csslayer.info/wordpress/fcitx-dev/a-case-study-how-to-compile-a-fcitx-platforminputcontext-plugin-for-a-proprietary-software-that-uses-qt-5/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://www.csslayer.info/wordpress/fcitx-dev/a-case-study-how-to-compile-a-fcitx-platforminputcontext-plugin-for-a-proprietary-software-that-uses-qt-5/&lt;/a&gt;），他觉得达芬奇也可以如法炮制，于是我阅读了一下，简单地概括就是首先查出来软件用了什么版本的 Qt，然后下载对应的源码，因为输入法支持属于 Qt 的某种插件，所以只要构建插件的时候链接到软件自带的 Qt，再把得到的插件复制到软件的 Qt 目录就可以了。一般来说软件就算修改了自带的 Qt，也不会修改有关插件的部分，所以我打算如法炮制一下。&lt;/p&gt;
&lt;p&gt;首先是查看达芬奇自带的 Qt 的版本，这个非常简单：&lt;/p&gt;
&lt;figure data-raw=&quot;% strings /opt/resolve/libs/libQt5Core.so.5 | rg &#039;Qt 5&#039;
Qt 5.15.2 (x86_64-little_endian-lp64 shared (dynamic) release build; by Clang 9.0.1 )
This is the QtCore library version Qt 5.15.2 (x86_64-little_endian-lp64 shared (dynamic) release build; by Clang 9.0.1 )
If that is not possible, in Qt 5 you must at least reimplement
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;% strings /opt/resolve/libs/libQt5Core.so.5 | rg &#039;Qt 5&#039;
Qt 5.15.2 (x86_64-little_endian-lp64 shared (dynamic) release build; by Clang 9.0.1 )
This is the QtCore library version Qt 5.15.2 (x86_64-little_endian-lp64 shared (dynamic) release build; by Clang 9.0.1 )
If that is not possible, in Qt 5 you must at least reimplement
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;到这里应该就是去下载 Qt 5.15.2 版本的源码了，不过我突发奇想看了一眼系统安装的 Qt 版本：&lt;/p&gt;
&lt;figure data-raw=&quot;% pacman -Qi qt5-base | rg Version
Version         : 5.15.7+kde+r176-1
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;% pacman -Qi qt5-base | rg Version
Version         : 5.15.7+kde+r176-1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;一般来说主次版本号不变的话不会有什么不兼容的改动，会不会我直接把系统的 &lt;code&gt;.so&lt;/code&gt; 文件复制过去就可以用了呢？Qt 5 的 ibus 支持已经是 Qt 本身代码库的一部分了，安装到系统的路径是 &lt;code&gt;/usr/lib/qt/plugins/platforminputcontexts/libibusplatforminputcontextplugin.so&lt;/code&gt;，我尝试直接把它链接过去：&lt;/p&gt;
&lt;figure data-raw=&quot;% sudo mkdir /opt/resolve/libs/plugins/platforminputcontexts
% sudo ln -s /usr/lib/qt/plugins/platforminputcontexts/libibusplatforminputcontextplugin.so /opt/resolve/libs/plugins/platforminputcontexts
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;% sudo mkdir /opt/resolve/libs/plugins/platforminputcontexts
% sudo ln -s /usr/lib/qt/plugins/platforminputcontexts/libibusplatforminputcontextplugin.so /opt/resolve/libs/plugins/platforminputcontexts
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后就没有然后了，我启动达芬奇之后 ibus 就直接工作了。没想到他们虽然不太了解 Linux 输入法，Qt 版本跟的倒是还挺新的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Input-Method-Support-for-DaVinci-Resolve-on-Linux/screenshot-1.png&quot; alt=&quot;just works&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于 Fcitx5 用户的话，首先要注意 Qt 5 的 Fcitx5 支持并不在 Qt 的代码库里，所以你需要安装 &lt;code&gt;fcitx5-qt&lt;/code&gt;。不过文件路径的话都是一样的，只要把文件名里的 &lt;code&gt;ibus&lt;/code&gt; 改成 &lt;code&gt;fcitx5&lt;/code&gt; 就可以了。如果直接链接不能用，需要按照老 K 博客里的办法自己编译的话，需要下载单独的 &lt;code&gt;fcitx5-qt&lt;/code&gt; 代码库。当然从根源上解决问题的话还是希望大家去论坛回复我的帖子，让 BlackMagic Design 开启构建开关，就不需要用奇怪的办法 hack 了。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    <category term="Qt" label="Qt" scheme="https://sh.alynx.one/tags/Qt/" />
  </entry>
  <entry>
    <title>GTK 和 libhandy 和 Arc-Dark 主题</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/GTK-libhandy-Arc-Dark/" />
    <id>https://sh.alynx.one/posts/GTK-libhandy-Arc-Dark/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-11-23T10:23:34.000Z</published>
    <updated>2022-11-23T10:23:34.000Z</updated>
    <summary type="html">
      黑夜让我选了黑色的主题，但是有些程序非要寻找光明？ 我自认为不是个对应用程序外观有着病态一致性要求的人，我也从不介意一些个性化的程序选择自己的特殊样式。所以当 GTK 4 推荐的 libadwaita 不再支持传统的 GTK 主题的时候我也没什么反应：毕竟这玩意默认的样式看起来还…
    </summary>
    <content type="html">
      &lt;blockquote class=&quot;center-quote&quot;&gt;黑夜让我选了黑色的主题，但是有些程序非要寻找光明？&lt;/blockquote&gt;

&lt;p&gt;我自认为不是个对应用程序外观有着病态一致性要求的人，我也从不介意一些个性化的程序选择自己的特殊样式。所以当 GTK 4 推荐的 libadwaita 不再支持传统的 GTK 主题的时候我也没什么反应：毕竟这玩意默认的样式看起来还挺好看的。但即使是我这样宽容的人，对于 GTK 3 那个熟的不能再熟的 Adwaita 主题也审美疲劳了，那个银色和棕色会让所有手机厂笑话的，即使有些手机厂的审美还不如这玩意。&lt;/p&gt;
&lt;p&gt;我个人最喜欢的配色其实是 Atom 的 One Dark 和 One Light，但我没那个精力利用调色盘自己维护一份主题，所以我退而求其次选择了在观感上比较接近的 &lt;a href=&quot;https://github.com/jnsh/arc-theme&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Arc 主题&lt;/a&gt;，这个主题其实是一个系列，我自己只在乎里面的两个变体：全亮色的 Arc 和全暗色的 Arc-Dark（似乎它自己 README 里面给的截图也有点问题）。&lt;/p&gt;
&lt;p&gt;我自己是一个暗色模式爱好者，毕竟长时间面对屏幕，白底黑字实在是太刺眼了，相对而言，深蓝色做背景色浅灰色做前景色要好看很多。在很久很久以前混沌初开，Linux 桌面程序员还没有意识到需要有个全局的暗色/亮色开关的时候，设置主题非常简单粗暴，打开 GNOME Tweaks 把 GTK Theme 设置为 Arc-Dark，我就心满意足了。&lt;/p&gt;
&lt;p&gt;可能是 libadwaita 不能更换主题导致很多反对的声音，并没有太多人谈论随之而来的全局暗色模式开关，但是某天我更新了系统之后发现设置里多了一个亮色/暗色选择，我觉得挺好，那我这里选暗色就行了嘛，果然所有用了 libadwaita 的程序都跟着变了亮暗，不过我用着用着就感觉不对劲了——怎么以前那些 GTK 3 的程序不用 Arc-Dark 而是用 Adwaita-dark 了，这和我想的不一样啊？然后我研究了一下，觉得更奇怪了，GTK 4 + libadwaita 的 GNOME Settings 用的是 libadwaita 的暗色版本（预期行为），GTK 3 的 GNOME Tweaks 用的是 GTK 3 的 Adwaita-dark（不对劲），但是同样是 GTK 3 的 GNOME Terminal 用的是我设置的 Arc-Dark（预期行为）。好家伙好家伙，我这一个桌面上三花聚顶了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GTK-libhandy-Arc-Dark/screenshot-1.png&quot; alt=&quot;三花聚顶&quot;&gt;&lt;/p&gt;
&lt;p&gt;总这么待着我觉得怪怪的，于是我研究了一下，如果我要是选亮色模式呢？现在 GNOME Settings 是 libadwaita 的亮色版本了，然后 GNOME Tweaks 和 GNOME Terminal 都是 Arc-Dark，虽然好像一致了，又好像有点不一致，这回从三花聚顶变成黑白通吃。总之我忍受了很久 GTK 4 程序 &lt;strong&gt;大部分&lt;/strong&gt; 是白的而 GTK 3 程序是黑的，直到我再也受不了决定翻开代码看看这些人是怎么写的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GTK-libhandy-Arc-Dark/screenshot-2.png&quot; alt=&quot;黑白通吃&quot;&gt;&lt;/p&gt;
&lt;p&gt;为了能说明白，下面我就不从结果反推原因了，毕竟大家看到这里可能已经云里雾里，没必要和我再重复一遍破案过程了。&lt;/p&gt;
&lt;p&gt;可能大部分人不是 GTK 开发者也不使用 GTK，对这玩意怎么调用主题存在一定的误区。实际上可以分为以下几类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不使用 libhandy 的 GTK 3 程序（比如 GNOME Terminal）和不使用 libadwaita 的 GTK 4 程序（比如 Show Me The Key），这一类程序不考虑 GNOME Settings 里面的亮色/暗色开关（指的是 GSettings 里面 &lt;code&gt;org.gnome.desktop.interface&lt;/code&gt; 的 &lt;code&gt;color-scheme&lt;/code&gt; 选项），而只考虑 &lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt;，这个值属于 &lt;code&gt;GtkSettings&lt;/code&gt;，需要编辑 &lt;code&gt;~/.config/gtk-4.0/settings.ini&lt;/code&gt; 和 &lt;code&gt;~/.config/gtk-3.0/settings.ini&lt;/code&gt;。以及是的你没看错，GTK 4 不一定非要用 libadwaita，实际上虽然这个库叫 libadwaita，但它和 GTK 3 那个叫做 Adwaita 的默认主题几乎没有关系，它是 GTK 3 的组件库 libhandy 的进化版本。GNOME 推荐使用这个以便让整个桌面有统一的风格，但是 GTK 4 仍然是个完整的 UI 库，程序开发者完全可以不使用 libadwaita。&lt;/li&gt;
&lt;li&gt;使用 libadwaita 的 GTK 4 程序（比如 GNOME Settings），这一类程序不考虑 GNOME Tweaks 里面的 GTK Theme 选项（实际上是 GSettings 里面 &lt;code&gt;org.gnome.desktop.interface&lt;/code&gt; 的 &lt;code&gt;gtk-theme&lt;/code&gt; 选项），只使用 libadwaita 内置的配色，所以我们也完全不需要关心它，它永远按照设置里的开关工作。&lt;/li&gt;
&lt;li&gt;使用 libhandy 的 GTK 3 程序（比如 GNOME Tweaks），这个就相当复杂了，libhandy 考虑了桌面环境的亮色/暗色主题切换，但也考虑了用户自定义的 GTK Theme，于是在这里它华丽的乱套了。&lt;/li&gt;
&lt;li&gt;还有最后一类程序，它们出于特定需要自己给自己套了自定义的 CSS，所以你拿它一点办法也没有，直接忽略（比如 Show Me The Key 的悬浮窗口）。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;看到这里一定有小黑子要怒吼了：“看看你们搞的乱七八糟的玩意！GNOME 真垃圾！老子就要刀耕火种就要当原始人，libadwaita 滚啊！”但是我建议用你那可怜的小脑袋瓜想一想，上面三条里面反而 libadwaita 是最符合预期的一个（亮色模式用亮色，暗色模式用暗色），所以我不会解决第二个，而是解决另外的两个。&lt;/p&gt;
&lt;p&gt;首先从 libhandy 下手，相关的代码位于 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/libhandy/-/blob/main/src/hdy-style-manager.c#L286-L348&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/libhandy/-/blob/main/src/hdy-style-manager.c#L286-L348&lt;/a&gt;，如果你可怜的小脑袋瓜也没耐心看看代码的话，那么我大发慈悲替你读了一遍。相关的逻辑大概是说首先覆盖掉当前程序的 &lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt;（别忘了 libhandy 程序也是 GTK 3 程序），这个值会被设置成 &lt;code&gt;color-scheme&lt;/code&gt; 的值。然后获取当前系统的 GTK Theme，因为我们考虑到浅色和深色主题切换，所以主题名被分成基础名和种类名两部分，如果系统的主题以 &lt;code&gt;-dark&lt;/code&gt; 结尾，那就去掉这个后缀，得到基础名，并设置为当前程序的主题。那问题难道出在 Arc-Dark 的结尾是 &lt;code&gt;-Dark&lt;/code&gt; 而不是 &lt;code&gt;-dark&lt;/code&gt; 吗？也不是，GTK 主题对于暗色和亮色的区分不在主题名上，而是在主题目录下面的两个文件，一个叫做 &lt;code&gt;gtk.css&lt;/code&gt;，另一个叫做 &lt;code&gt;gtk-dark.css&lt;/code&gt;，如果 &lt;code&gt;color-scheme&lt;/code&gt; 是 &lt;code&gt;prefer-dark&lt;/code&gt;，libhandy 就会加载后者而非前者，这部分的代码在 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/libhandy/-/blob/main/src/hdy-style-manager.c#L106-L141&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/libhandy/-/blob/main/src/hdy-style-manager.c#L106-L141&lt;/a&gt;。于是在系统设置为暗色模式的时候，libhandy 会去加载 Arc-Dark 的 &lt;code&gt;gtk-dark.css&lt;/code&gt;，但 Arc-Dark 作为一个暗色变体，只有 &lt;code&gt;gtk.css&lt;/code&gt;，所以加载失败，libhandy 回退到 &lt;code&gt;Adwaita&lt;/code&gt; 的 &lt;code&gt;gtk-dark.css&lt;/code&gt;。而系统设置为亮色的时候，libhandy 会去加载 Arc-Dark 的 &lt;code&gt;gtk.css&lt;/code&gt;，而作为一个暗色变体，这个文件实际写的是暗色配色，于是看起来正常了。（以及如果你 GTK Theme 设置为 &lt;code&gt;Adwaita-dark&lt;/code&gt; 从这里你就会发现实际上加载的是 &lt;code&gt;Adwaita&lt;/code&gt; 的 &lt;code&gt;gtk-dark.css&lt;/code&gt;，而不是 &lt;code&gt;Adwaita-dark&lt;/code&gt; 的 &lt;code&gt;gtk.css&lt;/code&gt;，即使它们的配色是一样的。）&lt;/p&gt;
&lt;p&gt;那么显然又有另一个问题，既然主题是靠内部的两个文件区分亮色和暗色的，为什么又会有 &lt;code&gt;Adwaita-dark&lt;/code&gt; 和 &lt;code&gt;Arc-Dark&lt;/code&gt; 这种名字里带暗色后缀的变体呢？并且还要在 &lt;code&gt;libhandy&lt;/code&gt; 里面处理这个后缀，是不是多此一举？我们可以暂时先不考虑这个问题，而先简单解决第三条。从上面的分析可以得知为了能正常支持系统的亮色暗色切换，我们需要的是一个同时包含亮色暗色的主题，而不是一个只有暗色变体的主题，于是我们不能把 GTK Theme 设置为 Arc-Dark，而应该使用 Arc，但假如你在 GNOME Tweaks 里面设置好之后，你会发现仍然是黑白通吃：GNOME Settings 是 libadwaita 的暗色版本，GNOME Tweaks 是 Arc 的暗色版本，而 GNOME Terminal 和 Show Me The Key 却变成了亮的 Arc！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/GTK-libhandy-Arc-Dark/screenshot-3.png&quot; alt=&quot;小黑子们不要笑得太早了&quot;&gt;&lt;/p&gt;
&lt;p&gt;我知道有的小黑子要迫不及待开始炮轰 GNOME 了：“什么玩意，整来整去不还是整不好吗，不如来当原始人。”但问题其实就是原始人留下的。现在我们回头看第一条：不使用 libhandy 的 GTK 3 程序和不使用 libadwaita 的 GTK 4 程序，这一类程序不考虑 GNOME Settings 里面的亮色/暗色开关，而只考虑 &lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt;。所以这个奇怪的表现恰好验证了这一条，同时也解释了“既然主题是靠内部的两个文件区分亮色和暗色的，为什么又会有 &lt;code&gt;Adwaita-dark&lt;/code&gt; 和 &lt;code&gt;Arc-Dark&lt;/code&gt; 这种名字里带暗色后缀的变体”这个问题：因为在一开始的设计里并没有什么全局亮色/暗色开关，也就没有要求主题同时提供 &lt;code&gt;gtk.css&lt;/code&gt; 和 &lt;code&gt;gtk-dark.css&lt;/code&gt;，那么为了让用户可以自选亮色暗色，只有提供两个不同的主题来解决问题。这也就是在 &lt;code&gt;Adwaita&lt;/code&gt; 和 &lt;code&gt;Arc&lt;/code&gt; 都提供了 &lt;code&gt;gtk-dark.css&lt;/code&gt; 的情况下仍然存在 &lt;code&gt;Adwaita-dark&lt;/code&gt; 和 &lt;code&gt;Arc-Dark&lt;/code&gt; 的原因。然后在主题添加了 &lt;code&gt;gtk-dark.css&lt;/code&gt; 之后，为了让 libhandy 的程序能够跟随系统开关切换亮色和暗色，就不能为了那些传统程序把 GTK Theme 设置为暗色变体的主题了，此时如果设置为同时包含两个文件的主题，默认这些程序会选择 &lt;code&gt;gtk.css&lt;/code&gt;，也就会出现上面截图里的情况。解决这个的方案也不是很困难，&lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt; 就是为此添加的，支持它的 GTK 程序会按照这个选项来加载 &lt;code&gt;gtk.css&lt;/code&gt; 或 &lt;code&gt;gtk-dark.css&lt;/code&gt;。如果你像我一样平时主要用暗色模式，那就手动编辑 &lt;code&gt;~/.config/gtk-4.0/settings.ini&lt;/code&gt; 写入以下内容（GTK 3 的话就是 &lt;code&gt;~/.config/gtk-3.0/settings.ini&lt;/code&gt;）：&lt;/p&gt;
&lt;figure data-raw=&quot;[Settings]
gtk-application-prefer-dark-theme=1
&quot; data-info=&quot;language-ini&quot; data-lang=&quot;ini&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-ini&quot;&gt;[Settings]
gtk-application-prefer-dark-theme=1
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;你要是亮色爱好者，那就改成 &lt;code&gt;0&lt;/code&gt;。这下倒是满足原始人的刀耕火种需求了哈，毕竟他们看起来也不想要系统的亮色/暗色开关的样子，不过说不定以后哪天系统的亮色/暗色开关也会同时修改这个选项呢？只是读取这个选项的 GTK 程序不会像 libhandy/libadwaita 的程序那样会动态切换，必须要关了重开才行。&lt;/p&gt;
&lt;p&gt;还有一个奇怪的问题要注意，通常我们是在 GNOME Tweaks 里面设置 GTK Theme，不过根据 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-tweaks/-/blob/master/gtweak/tweaks/tweak_group_appearance.py#L75-L88&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-tweaks/-/blob/master/gtweak/tweaks/tweak_group_appearance.py#L75-L88&lt;/a&gt;，它会把上面那个 &lt;code&gt;gtk-application-prefer-dark-theme&lt;/code&gt; 设置成 &lt;code&gt;0&lt;/code&gt;，看注释里面的 BUG 描述，应该也是为了某种刀耕火种的情况解决的（甚至那时候还推荐搞个单独的暗色主题，并且删除了全局的倾向暗色的开关），大概那时候还没推荐用 libhandy，也没有 libadwaita，也没有设置里这种全局暗色/亮色的开关。总之我不建议经常修改 GTK 主题，并且每次修改之后记得手动修改这个选项。如果你觉得这种反复横跳又要保证兼容以前的决策的行为很蠢，那我只能说毕竟你不能要求以前的开发者预见到未来的人们怎么定义桌面的功能。&lt;/p&gt;
&lt;p&gt;当然如果你毫不在乎亮色暗色切换（我就是要一直用暗色，所以你暗色模式给我选对了暗色主题就行了！），那还有个比较投机取巧的解决方案：把 Arc-Dark 的 &lt;code&gt;gtk.css&lt;/code&gt; 复制并改名 &lt;code&gt;gtk-dark.css&lt;/code&gt; 就可以了，原理不难理解。并且 Arc 主题已经做了这样的修改，只是还没有 Release（参见 &lt;a href=&quot;https://github.com/jnsh/arc-theme/commit/73ada8563591fa48ae365686a358e874ca12edad&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/jnsh/arc-theme/commit/73ada8563591fa48ae365686a358e874ca12edad&lt;/a&gt;）。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    <category term="GTK" label="GTK" scheme="https://sh.alynx.one/tags/GTK/" />
  </entry>
  <entry>
    <title>谁动了我的 DNS 解析？</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Who-Moved-My-DNS-Resolving/" />
    <id>https://sh.alynx.one/posts/Who-Moved-My-DNS-Resolving/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-11-09T13:06:00.000Z</published>
    <updated>2023-09-07T07:23:59.000Z</updated>
    <summary type="html">
      &lt;p&gt;如果有人看到这个标题以为是什么科学上网相关然后高兴地点进来的话不要怪我，我其实想说的是 Linux 上有关 DNS 解析的流程，这个标题显然是化用自《谁动了我的奶酪？》，即使我并没有读过这本书。我计网真的没认真听课，写的内容都是我现学现卖的，有不对的希望读者指正。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;如果有人看到这个标题以为是什么科学上网相关然后高兴地点进来的话不要怪我，我其实想说的是 Linux 上有关 DNS 解析的流程，这个标题显然是化用自《谁动了我的奶酪？》，即使我并没有读过这本书。我计网真的没认真听课，写的内容都是我现学现卖的，有不对的希望读者指正。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E9%9C%80%E6%B1%82&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving/#%E9%9C%80%E6%B1%82&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;
&lt;p&gt;我有一台 NAS，一台 PC 和一台路由器，为了能上网也为了家里的无线设备可以连接 NAS，我给 PC 和 NAS 分别接上路由器，但是路由器只有千兆网口，而 PC 和 NAS 各自多一个 2500 Mbps 的网卡，为了实现最高的连接速度，我又买了一根网线把 PC 和 NAS 直接连接起来，于是现在三台设备两两相连。&lt;/p&gt;
&lt;p&gt;直连两台设备其实非常简单，Network Manager 里面 IPv4 设置成手动，然后分别配置 IP 地址和子网掩码，再关掉 IPv6 就可以了，比如我分别设置 IP 为 &lt;code&gt;10.10.10.1&lt;/code&gt; 和 &lt;code&gt;10.10.10.2&lt;/code&gt;，然后子网掩码就是 &lt;code&gt;255.255.255.0&lt;/code&gt;。然后在进行各种网络访问的时候只要使用这个 IP 就可以通过直连访问了。&lt;/p&gt;
&lt;p&gt;但是我还是不太满意，我设置了帅气的主机名，为什么还得用 IP 访问呢？但如果我查询主机名对应的 IP，发现得到的并不是直连的 IP，而是比如 &lt;code&gt;192.168.1.80&lt;/code&gt; 这样的通过路由器的 IP。于是我开始研究如何配置让 DNS 解析给我返回直连的 IP。&lt;/p&gt;
&lt;h1 id=&quot;longlongago&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving/#longlongago&quot;&gt;&lt;/a&gt;long long ago&lt;/h1&gt;
&lt;p&gt;一般要讲故事，开头都是“很久很久以前……”，不过计算机领域也没什么太古老的故事可讲，毕竟公认的互联网前身 ARPANET 也就是二十世纪的事情。那个时候能互联的机器一共也就那么几个，所以解决的办法简单粗暴：我们每个机器都保存一个文件，里面记录所有人对应的域名和 IP 不就行了？这个优良传统一直留了下来，也就是现在所有系统里都有的 hosts 文件，不管你写的对不对，它的优先级都比 DNS 查询要高。对于我这个及其简单的网络环境，这肯定是不错的解决方案，但是程序员总会觉得这种非自动化的手段太 low 了，于是就被我 pass 掉了。&lt;/p&gt;
&lt;p&gt;然后随着加入网络的机器越来越多，这个办法不好用了，毕竟每来一个新人就要所有人更新自己的文件，这复杂度也太高了。所以干脆我们搞一个集中的服务器专门放这个列表，其它机器都向它查询就好了。这就是 DNS 服务器的原理了，然后在局域网里，一般路由器和 DNS 服务器以及 DHCP 服务器都是同一台机器，因为很自然的所有设备都会连到路由器上，而 DHCP 服务器恰好知道它分配出去的 IP 地址，所以如果你输入主机名恰好能解析，那通常是你的路由器做了这些工作。但对于我这个子网来说，为了这两台电脑再配置 DHCP 和 DNS 显然太麻烦了，pass。&lt;/p&gt;
&lt;p&gt;再后来各种子网越来越多，子网里的设备也越来越多，比如打印机这种，以至于现在各种智能家居，不可能再搞一个服务器用来注册“喂，我是茶壶”这种东西，于是苹果搞出了一个叫 Zeroconf 的协议，大概是在 DNS 的基础上可以让子网里支持这个协议的设备互相发现互相通知自己是什么。因为和 DNS 相关，所以有一个部分是 MulticastDNS (mDNS)，简单来说就是不通过 DNS 服务器，而是通过这个协议发现的设备列表实现 DNS 解析。所以这是第三种方式。&lt;/p&gt;
&lt;p&gt;以上三种方式其实都是我从 Arch Wiki 抄来的：&lt;a href=&quot;https://wiki.archlinux.org/title/Network_configuration#Local_network_hostname_resolution&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://wiki.archlinux.org/title/Network_configuration#Local_network_hostname_resolution&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;所以我决定搞一个第三种，这个好说，wiki 写了可以用 Avahi 做这个，不过怎么 systemd-resolved 也能做 mDNS？这玩意不是管 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 的吗？Network Manager 不是也管这个吗？&lt;/p&gt;
&lt;h1 id=&quot;chattr+ietcresolvconf&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving/#chattr+ietcresolvconf&quot;&gt;&lt;/a&gt;chattr +i /etc/resolv.conf&lt;/h1&gt;
&lt;p&gt;很多 Linux 用户都知道修改 DNS 服务器可以通过编辑 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 实现，很多 Linux 用户也被 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 困扰，一些人发现自己的这个文件是个软链接，而另一些人发现这个文件总被 Network Manager 覆盖，还有些人的发行版让他们用一个叫 &lt;code&gt;resolvconf&lt;/code&gt; 的工具处理，然后现在 systemd 又搞了个叫 resolved 的东西来插一脚……我说的这些已经足够让一些不想学新东西同时又神经紧张的人开始大喊“fuck systemd, fuck network manager, fuck desktop environment and fuck the whole modern world”然后执行 &lt;code&gt;chattr +i /etc/resolv.conf&lt;/code&gt; 了。不过别着急小炸药包们，也许这个世界上新出现的各种东西目的并不只是惹恼你们这群大笨蛋，哦是的，没错，我说，大笨蛋，恐龙勇士（停停停不要翻译腔了），而是真的有场景需要他们。也许对于某个 VPN 连接需要使用自己的 DNS 服务器，总之，不要觉得世界都围着你转，至少读一下这些东西的文档，会告诉你怎么阻止它们修改你的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 的。&lt;/p&gt;
&lt;p&gt;但其实也不是一个 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 搞定所有，有关这个的故事也是 long long ago，但毕竟是 UNIX 纪元之后的事情，没有太久，大概确实上古时代的程序都是直接读这个获取 DNS 服务器然后再做 DNS 解析的，但实际上这也不一定 OK，比如像之前说的打印机这种怎么解决？以及 hosts 呢？所以就有了更复杂的解决方案，大部分程序做 DNS 解析实际上是调用 glibc 里面 &lt;code&gt;getaddrinfo&lt;/code&gt; 这个 API，所以在它后面我们就可以做一些工作。一个叫做 Name Service Switch 的东西发明出来就是干这个的，它可以理解为一个基于插件的结构，我们可以通过阅读 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt; 里面的 &lt;code&gt;hosts&lt;/code&gt; 这一行来理解，比如我这里默认是这样的：&lt;/p&gt;
&lt;figure data-raw=&quot;hosts: mymachines resolve [!UNAVAIL=return] files myhostname dns
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;hosts: mymachines resolve [!UNAVAIL=return] files myhostname dns
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;简单翻译一下的话意思就是查询一个域名的时候首先看看是不是 systemd-machined 的容器（&lt;code&gt;mymachines&lt;/code&gt; 模块），不是的话再问问 systemd-resolved 能不能解析（&lt;code&gt;resolve&lt;/code&gt; 模块），如果 systemd-resolved 可用，那到这也就完事了，后面的就不管了（&lt;code&gt;[!UNAVAIL=return]&lt;/code&gt;），至于为什么我一会解释，然后 &lt;code&gt;files&lt;/code&gt; 模块会读 hosts 文件，所以它优先级总是高于 DNS 服务器，然后看看是不是本机（&lt;code&gt;myhostname&lt;/code&gt; 模块），然后再读 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 里面的 DNS 服务器进行查询。&lt;/p&gt;
&lt;p&gt;对于一个普通的桌面用户，应该使用的只是 Network Manager，默认 Network Manager 不会用 systemd-resolved，于是大部分情况一个外部域名最后还是查询 DNS 服务器，和以前没什么本质区别。那 Network Manager 你为什么要修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;？原因之一就是之前提到不同的 VPN 服务可能有不同的 DNS 服务器，因此建议这些用户不要手动编辑这个文件，可以直接在 Network Manager 的连接配置里设置某个连接的 DNS 服务器。&lt;/p&gt;
&lt;p&gt;那 systemd-resolved 又是什么玩意？是不是 systemd 作者又要搞出什么花样替换我习惯的东西？但这东西好像还真是有些实际的需求，它不是一个简单的 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 的管理工具，而可以理解为是一个自带缓存的 DNS 服务器。glibc 通过 &lt;code&gt;/etc/resolv.conf&lt;/code&gt; 里面的 DNS 服务器查询 DNS 其实是不做缓存的，有些场景用户可能希望能自己缓存结果加快速度，这时候就需要搞这个东西了，它自己是一个 DNS 服务器，因此也就不再执行 nsswitch 里面后续的组件（用你的 &lt;code&gt;dns&lt;/code&gt; 模块查询了我怎么缓存？）。除此之外它还声称自己提供了一个更好的 D-Bus 接口用来解析，而不是用 &lt;code&gt;getaddrinfo&lt;/code&gt;，不过话又说回来，谁闲得没事去支持你这新搞的 D-Bus API，特别是你自己还搞了个 &lt;code&gt;getaddrinfo&lt;/code&gt; 的模块。主观来说我其实不推荐一般的桌面用户配置这个，因为大概率你是在一个路由器后面，你的 DNS 服务器一般设置的都是路由器，而路由器上的 DNS 服务器一般会做缓存，所以其实完全没必要在自己电脑上启用这个……我也没遇到任何一定要使用它这个 D-Bus API 的程序。那 systemd-resolved 你为什么要修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;？原因是为了兼容那些直接读这个的上古程序，实际上人家就在这里写一行，就是让这些程序去查 systemd-resolved 内置的 DNS 服务器。&lt;/p&gt;
&lt;p&gt;那至于 &lt;code&gt;resolvconf&lt;/code&gt; 又是啥？这是一个叫 &lt;code&gt;openresolv&lt;/code&gt; 的项目搞出来的东西，需求就是有各种程序都打算自己修改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，不单单是上面那两个，还有一些 VPN 服务之类的，那你们干脆都别管了，我来管，听我的（现在有 N + 1 种解决方案了）。但实际上我也不推荐你使用这个，因为桌面用户根本没有使用场景，你用 Network Manager 的话，就不要再单独使用什么 VPN 工具，因为 Network Manager 本身支持很多种 VPN 连接，你直接用它管理就好了。就算你需要用 systemd-resolved，其实这个也替你考虑好了，Network Manager 支持 systemd-resolved，检测到你用它的话，就不会去改 &lt;code&gt;/etc/resolv.conf&lt;/code&gt;，而是直接去修改 systemd-resolved 的配置了。&lt;/p&gt;
&lt;p&gt;更新（2023-09-07）：感觉光靠嘴说还是不太清楚，我画了一张图……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Who-Moved-My-DNS-Resolving/dns.png&quot; alt=&quot;dns.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;所以你可以看到 Network Manager 默认其实并不参与 DNS 解析，它只是方便到处跑的笔记本用户能用上各个局域网内的 DNS 服务器而已。&lt;/p&gt;
&lt;h1 id=&quot;%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%98%AF%E9%97%A8%E8%89%BA%E6%9C%AF%EF%BC%8C%E5%BD%93%E4%B8%94%E4%BB%85%E5%BD%93%E4%BD%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84%E6%97%B6%E5%80%99%E2%80%A6%E2%80%A6&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving/#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E6%98%AF%E9%97%A8%E8%89%BA%E6%9C%AF%EF%BC%8C%E5%BD%93%E4%B8%94%E4%BB%85%E5%BD%93%E4%BD%A0%E4%B8%8D%E9%9C%80%E8%A6%81%E8%80%83%E8%99%91%E5%85%BC%E5%AE%B9%E6%80%A7%E7%9A%84%E6%97%B6%E5%80%99%E2%80%A6%E2%80%A6&quot;&gt;&lt;/a&gt;计算机科学是门艺术，当且仅当你不需要考虑兼容性的时候……&lt;/h1&gt;
&lt;p&gt;那说回到 mDNS 这个问题，为什么我不直接用 systemd-resolved 解决呢？一个是上面提到的我不需要再做一次 DNS 缓存了，另一个是因为 CUPS 这个打印服务依赖 Avahi，它其实不只用到 mDNS，还用到了 Zeroconf 里面其它的功能比如发现设备去连接打印机，虽然我暂时也用不到 CUPS，但我确实是不想搞 systemd-resolved 的 DNS 服务器了，还是配置 Avahi 吧。当然假如你说我既想要 systemd-resolved 的 DNS 缓存和 D-Bus API 又想要 Avahi 的 Zeroconf 怎么办呢？额，其实也有办法，systemd-resolved 提供了选项让你关掉它的 mDNS 功能，具体我没有尝试，不过这样应该就不会冲突了。所以不要见到点新东西就生气，人家把各种兼容的东西都考虑到了，看两眼文档还不行吗……&lt;/p&gt;
&lt;p&gt;然后搞清楚整个流程之后 Avahi 的配置其实不难，首先安装 &lt;code&gt;nss-mdns&lt;/code&gt; 这个包，顾名思义是给 &lt;code&gt;nsswitch&lt;/code&gt; 提供 &lt;code&gt;mdns&lt;/code&gt; 模块，然后启动 &lt;code&gt;avahi-daemon.service&lt;/code&gt;，然后编辑 &lt;code&gt;/etc/nsswitch.conf&lt;/code&gt;，在 &lt;code&gt;resolve&lt;/code&gt; 模块之前加入 &lt;code&gt;mdns4_minimal [NOTFOUND=return]&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;hosts: mymachines mdns4 resolve [!UNAVAIL=return] files myhostname dns
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;hosts: mymachines mdns4 resolve [!UNAVAIL=return] files myhostname dns
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;mdns4&lt;/code&gt; 模块会试图通过 mDNS 也就是找网络上其它的 Zeroconf 协议设备来解析 IPv4 地址，&lt;code&gt;4&lt;/code&gt; 表示只尝试 IPv4，因为这种内网设备多半你不会给它分配 IPv6，当然也有 &lt;code&gt;6&lt;/code&gt; 和没有数字同时支持两种的，不过由于现在的程序都优先查询 IPv6，而我只给直连配置了 IPv4，所以如果不用只支持 4 的，就会 fallback 到后面的模块，那就跑到路由器上查去了，我就是不想走路由器的。&lt;/p&gt;
&lt;h1 id=&quot;%E8%AF%BB%E8%80%85%E7%9C%8B%E7%88%BD%E4%BA%86%EF%BC%8C%E4%BD%86%E5%A5%BD%E5%83%8F%E7%BB%93%E6%9E%9C%E4%B8%8D%E6%98%AF%E6%88%91%E6%83%B3%E8%A6%81%E7%9A%84%E2%80%A6%E2%80%A6&quot;&gt;&lt;a class=&quot;heading-link header-link&quot; href=&quot;/posts/Who-Moved-My-DNS-Resolving/#%E8%AF%BB%E8%80%85%E7%9C%8B%E7%88%BD%E4%BA%86%EF%BC%8C%E4%BD%86%E5%A5%BD%E5%83%8F%E7%BB%93%E6%9E%9C%E4%B8%8D%E6%98%AF%E6%88%91%E6%83%B3%E8%A6%81%E7%9A%84%E2%80%A6%E2%80%A6&quot;&gt;&lt;/a&gt;读者看爽了，但好像结果不是我想要的……&lt;/h1&gt;
&lt;p&gt;等到我把所有的东西都搞好以后我发现一个问题……mDNS 虽然说是子网上的设备互相发现，但是它没规定是哪个子网……于是喜闻乐见的每次 &lt;code&gt;getent ahosts timbersaw.local&lt;/code&gt; 查询给我返回不一样的 IP，一会是 &lt;code&gt;10.10.10.2&lt;/code&gt; 一会是 &lt;code&gt;192.168.1.80&lt;/code&gt;，看起来还是写 hosts 比较靠谱……&lt;/p&gt;
&lt;p&gt;最后我的配置是不用 &lt;code&gt;mdns4&lt;/code&gt;，而是用 &lt;code&gt;mdns4_minimal&lt;/code&gt;，这两个的区别是后者只考虑 &lt;code&gt;.local&lt;/code&gt; 结尾的域名，并且如果查找不到的话直接返回 &lt;code&gt;NOTFOUND&lt;/code&gt;，而不是继续 fallback：&lt;/p&gt;
&lt;figure data-raw=&quot;hosts: mymachines mdns4_minimal [NOTFOUND=return] resolve [!UNAVAIL=return] files myhostname dns
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;hosts: mymachines mdns4_minimal [NOTFOUND=return] resolve [!UNAVAIL=return] files myhostname dns
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后再修改 &lt;code&gt;/etc/hosts&lt;/code&gt; 分别添加不带 &lt;code&gt;.local&lt;/code&gt; 的主机名（因为 &lt;code&gt;.local&lt;/code&gt; 会在 &lt;code&gt;files&lt;/code&gt; 之前先被 mDNS 处理）。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    <category term="网络" label="网络" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%BB%9C/" />
  </entry>
  <entry>
    <title>不应该做 EVA，而应该做环太平洋</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Not-to-Be-EVA-but-to-Be-Pacific-Rim/" />
    <id>https://sh.alynx.one/posts/Not-to-Be-EVA-but-to-Be-Pacific-Rim/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-08-18T17:06:22.000Z</published>
    <updated>2022-08-18T17:06:22.000Z</updated>
    <summary type="html">
      &lt;p&gt;想必把 2018 年的 DARLING in the FRANXX （名字太长了，后面简称 DitF 吧）称作有争议的作品应该不会有人反对，不过我恰好是个不喜欢追新番的人，不然也许我在 2018 年写篇关于这个的博客应该会能获得不少点击量。总之我在 2022 年下载了全集并且几乎是不间断的在三天之内看完了，可能不是特别好评价，但是觉得还是得写点什么。如果读者觉得“怎么复读了很多已有的观点”或者“和我想看的完全不一样”，还麻烦多包涵或者自行关闭标签页。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;想必把 2018 年的 DARLING in the FRANXX （名字太长了，后面简称 DitF 吧）称作有争议的作品应该不会有人反对，不过我恰好是个不喜欢追新番的人，不然也许我在 2018 年写篇关于这个的博客应该会能获得不少点击量。总之我在 2022 年下载了全集并且几乎是不间断的在三天之内看完了，可能不是特别好评价，但是觉得还是得写点什么。如果读者觉得“怎么复读了很多已有的观点”或者“和我想看的完全不一样”，还麻烦多包涵或者自行关闭标签页。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我认为这是一个优点和缺点同样突出的作品，倒不像很多人觉得是烂尾，结尾至少情理之中可以接受。主要问题是在于塑造人物形象和完善背景设定之间的冲突，也就是标题里写的“不应该做 EVA，而应该做环太平洋”。看完之后我半开玩笑地和 &lt;a href=&quot;https://ry.huaji.store/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@垚&lt;/a&gt; 说：“都怪庵野秀明，非要在巨大机器人动画里面加上一堆反乌托邦末世玄学宗教的背景设定，导致后来的巨大机器人动画不这么做就好像缺了点什么一样。”我其实对巨大机器人动画不算是专家（比如我显然没看过高达），但我觉得对 EVA 还算是熟悉。&lt;/p&gt;
&lt;p&gt;虽然我想说的问题是剧情方面的，不过还是要简单提一下作画。&lt;a href=&quot;https://ry.huaji.store/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@垚&lt;/a&gt; 和我表示他一开始是奔着 TRIGGER 才去看的 DitF，结果看过之后对于动作场面大失所望。我其实也不是特别了解 TRIGGER，只是之前被他拉去电影院看了普罗米亚。一定要比较的话确实不管是美术风格还是动作场面都没有普罗米亚那么有特色，但我还是觉得至少在及格线以上了。我觉得特别出色的是机体的设计，不管是 EVA 还是环太平洋，机体设计都是偏向机械化的（虽然 EVA 内在是生物，但是外表仍然是机械），同时是男性化的设计。我还是头一次在动漫里看到女性形象和不是特别机械化设计的机体，而且甚至有丰富的表情，非常新鲜的同时也很符合设定（实际上动画里很多时候使用了 FRANXX 的形象代替女性寄驶员），属于是一个巨大的加分项。叫龙的设计也算新鲜，至少对我来说，看第一集的时候我明明期待的是出来一个传统的怪兽形象的，结果出来的是这么一种可以算是放飞自我的东西。虽然在逻辑上可能比较难以解释它的存在性，不过好在是动漫嘛，不需要在里面找现实。（话说回来了解我的朋友应该知道我最喜欢的敌人设计是 NieR: Automata 里面的机械生命体。）&lt;/p&gt;
&lt;p&gt;然后说到我最关注的剧情了，我始终认为作品的核心是剧情。而且剧情是很难把控的东西，特别是对于原创剧情的作品来说，把剧情写好真的是一种不多见的能力。在我看来 DitF 在人物形象和感情戏上达到了一个极高的高度。主要人物有很多，但是每个人的个性都很清晰，并且我没有觉得哪个人的性格令我讨厌。同时故事本身不是简单直白一眼看到头的类型。比如第 13 集将故事推向了高潮，不仅仅因为这一集本身讲述的内容非常感人，而且将整个剧情前半部分埋下的伏笔全部都衔接上了（我甚至差点以为剧情要按绘本发展走向 bad end）。贯穿全篇出现过不止一次的“比翼鸟”的比喻，也非常的符合主题。但我在看一些二创视频的时候还是能看到一些 2018 年的评论在说第 14 集的剧情是喂屎，我确实可以理解追更的朋友当初等了一周之后看到这些阴差阳错然后还要提心吊胆等上一周才能看到下一集的焦躁心情，但这一集的矛盾激化成功的在一个高潮之后推进了剧情的节奏同时与下一集的高潮形成对比，而且这一集的内容非常的合理，虽然是各种巧合，但又很符合现实，符合人物的心理和动机。至于其它一些风评不好的部分比如搭档交换的剧情，只能说是见仁见智，有人不喜欢无可厚非，我还是觉得这部分也增加了故事的复杂性。&lt;/p&gt;
&lt;p&gt;但是与塑造人物形象形成对比，完善背景设定方面我认为有比较严重的硬伤。24 集里面在前半部分简单介绍了一个可以说是反乌托邦的设定，然后大量的篇幅用来刻画人物之间的关系和人物细腻的心理活动，结果在感情戏达到高潮之后仿佛是编剧突然想起来“啊，我们挖了好大的坑还没填呢”一样，开始匆忙的填之前的坑。比如我到现在也没想通只在第 15 集里出现了一次的那个巨大的手到底是什么和有什么存在意义。比如叫龙公主在第 17 集开始有大篇幅的剧情之前几乎没有任何铺垫（你别告诉我第 15 集核心里掉出来的小人就算铺垫了），这和感情戏部分各种伏笔先放好然后再衔接完全不像是一部作品的风格，反正你让我看到前半段各种叫龙出现之后是想不到有这么一个个体的存在的。第 19 集通过介绍博士的角度介绍了人类向不死方向的发展，多少算是成功地填了一部分坑。然后整个作品似乎就陷入了“编剧发现还剩五集了填不完坑了于是开始放飞自我”的方向发展了，星实体是个什么东西？之前完全没铺垫过，现在强行在一集内塞给观众。鹤望兰·天燕座又是怎么来的？就算不在动漫里找现实，这也过于不符合逻辑了，看看别的叫龙是什么样子，它们怎么搞出这么个造型的啊。到底是博士发癫了还是编剧发癫了？然后可能是由于实在没办法了，机械降神一个最大反派叫做 VIRM，这已经不是硬伤了，这是直接一刀把脑袋砍掉从脖子往下截肢了。于是一个完全没有铺垫，思维及其简单，做事不讲逻辑的工具 boss 出现了……你可以告诉我打了半年的敌人并不是真正的敌人，但我不能容忍你用这么一种侮辱观众智商的方式告诉我这个事实。然后再一次放飞自我把科技水平拉到太空时代，说实在的，这个和反派登场比起来，已经到了我看见什么都不惊讶的程度了。然后再经过几集漫长的毫无必要的人类叫龙和 VIRM 的太空混战剧情终于结束了这种煎熬，我只能说这部分比起种田是完全的不讲道理了。&lt;/p&gt;
&lt;p&gt;至于最后大结局的“生孩子”剧情，想必也有很多人不满意，虽然我自己讨厌小孩，但我觉得这部分不是什么问题。可能是考虑到当下的现实环境，年轻人确实对催生比较反感吧，但放在剧情里面，作为一个新世界开始的必要环节实际上是没什么问题的。最后黑色头发的少年和樱花色头发的少女在树下相遇的结尾也是我最满意的部分之一了，或者可能我恰好是一个容易被这种剧情打动的人吧。&lt;/p&gt;
&lt;p&gt;另外 &lt;a href=&quot;https://ry.huaji.store/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@垚&lt;/a&gt; 表示同样是 TRIGGER 的作品，普罗米亚的剧情要好很多，但我不是特别同意，我个人觉得普罗米亚最后 1/4 的剧情其实也向着强行收尾的方向走了，不过一部剧场版动画和季番还是不一样的，剧场版动画只有两个小时，不会有太复杂的背景设定，故事本身又是快节奏，就算强行推进一下剧情，观感也不会太差，而且独特的美术风格和配乐相当大程度的掩盖了剧情的问题。&lt;/p&gt;
&lt;p&gt;总而言之，我其实是不太在意“符合逻辑但是大部分观众都不喜欢”的剧情的，比起这个，我觉得“不符合逻辑”的剧情问题要严重得多，这说明剧情走向已经变成无法把控的东西了，为了强行在剩下的集数里面结束故事，不得不强行引入一些东西。如果你问我怎么修改剧情能解决掉硬伤，我其实一开始也没什么思路。不过和 &lt;a href=&quot;https://ry.huaji.store/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@垚&lt;/a&gt; 简单聊了一下之后我意识到了问题所在。从感情戏的篇幅和水平来看，很显然巨大机器人战斗只是个载体，这应该是个披着机器人战斗的皮的爱情故事，并且爱情故事部分相当的成功。在我看来 DitF 的思维和 EVA 其实是有相当大的差别的，虽然可能大家总是津津乐道碇真嗣、绫波零、明日香、渚薰之间的情感关系，但 EVA 没有对这部分的直接描写，更多是通过侧面细节描写，以及粉丝进行的分析推理得出的。所以 EVA 可以在背景设定上挖很大的坑然后有充足的时间填坑。因此我的想法是让这个作品向环太平洋的方向靠近，去掉反乌托邦的设定，比如什么种植园和 APE 都可以不要，直接快进到不知道为什么出现了名叫叫龙的怪兽进攻人类，于是人类设计了 FRANXX 并要少年少女操作来防御。然后人物的背景全部都不需要修改，最终的结局就像环太平洋一样直接摧毁掉叫龙来源就可以了。虽然可能会被 EVA 观众认为“没有达到 EVA 的高度”，但既然本来就不在一个赛道上（我这写的是爱情故事啊），这也没什么所谓了。考虑到第 13 集和 15 集的口碑，这样改应该不会折损它的优点。&lt;/p&gt;
&lt;p&gt;最后还是要说，虽然有这么明显的硬伤，这部作品突出的优点还是让我受到了很大震撼并且在接下来的一周都沉浸在剧情里不能自拔。我个人也非常喜欢这部作品的 ED，无论是旋律还是歌词，以及演唱方面都可以说是一流的作品，特别是第 13 集高潮部分的《ひとり》，单从音乐和剧情结合的角度来说，确实达到了 EVA 的高度（让我想起来《翼をください》。《トリカゴ》也是绝妙的作品，特别是伴随 ED 出现的画面，“如果这些人物所在的是一个没有叫龙和 FRANXX 存在的世界会是什么样子呢？”（很遗憾我对 OP 没什么感觉）我同样对广、02、五郎和莓的人物形象非常的喜爱，复杂的情感关系使得这些人物变得颇为立体，而且他们完全没有动漫里一些经常出现的会让我讨厌的人物特质。&lt;/p&gt;

    </content>
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    <category term="动漫" label="动漫" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/%E5%8A%A8%E6%BC%AB/" />
    <category term="动漫" label="动漫" scheme="https://sh.alynx.one/tags/%E5%8A%A8%E6%BC%AB/" />
    <category term="DARLING in the FRANXX" label="DARLING in the FRANXX" scheme="https://sh.alynx.one/tags/DARLING%20in%20the%20FRANXX/" />
  </entry>
  <entry>
    <title>PHP 故释</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/PHP-Story/" />
    <id>https://sh.alynx.one/posts/PHP-Story/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-08-10T05:24:41.000Z</published>
    <updated>2022-08-10T05:24:41.000Z</updated>
    <summary type="html">
      &lt;figure data-raw=&quot;// 新来的！如果你看到这段注释，说明上一个负责重构这个项目的程序员已经被气死了！
// 请你把下一行的数字加一，然后祝你好运！
// 63
&quot; data-info=&quot;language-php&quot; data-lang=&quot;php&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;// 新来的！如果你看到这段注释，说明上一个负责重构这个项目的程序员已经被气死了！
// 请你把下一行的数字加一，然后祝你好运！
// 63
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;起因是昨天晚上吃完饭回家路上和铁道迷闲聊说起他正在重写的 PHP 项目。于是我随口编了一个 &lt;del&gt;恐怖&lt;/del&gt; 段子。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;figure data-raw=&quot;// 新来的！如果你看到这段注释，说明上一个负责重构这个项目的程序员已经被气死了！
// 请你把下一行的数字加一，然后祝你好运！
// 63
&quot; data-info=&quot;language-php&quot; data-lang=&quot;php&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-php&quot;&gt;// 新来的！如果你看到这段注释，说明上一个负责重构这个项目的程序员已经被气死了！
// 请你把下一行的数字加一，然后祝你好运！
// 63
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;起因是昨天晚上吃完饭回家路上和铁道迷闲聊说起他正在重写的 PHP 项目。于是我随口编了一个 &lt;del&gt;恐怖&lt;/del&gt; 段子。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;为什么是 63：&lt;/p&gt;
&lt;figure data-raw=&quot;% node
Welcome to Node.js v18.7.0.
Type &amp;quot;.help&amp;quot; for more information.
&gt; Math.floor(Math.random() * 100)
63
&gt; 
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;% node
Welcome to Node.js v18.7.0.
Type &quot;.help&quot; for more information.
&amp;gt; Math.floor(Math.random() * 100)
63
&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

    </content>
    <category term="无题" label="无题" scheme="https://sh.alynx.one/categories/%E6%97%A0%E9%A2%98/" />
    <category term="无题" label="无题" scheme="https://sh.alynx.one/tags/%E6%97%A0%E9%A2%98/" />
    <category term="PHP" label="PHP" scheme="https://sh.alynx.one/tags/PHP/" />
  </entry>
  <entry>
    <title>可能只适合我自己的 RIME 配置 2</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/My-RIME-2/" />
    <id>https://sh.alynx.one/posts/My-RIME-2/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-07-18T10:50:50.000Z</published>
    <updated>2022-07-18T10:50:50.000Z</updated>
    <summary type="html">
      &lt;p&gt;上一篇：&lt;a href=&quot;/posts/My-RIME/&quot;&gt;可能只适合我自己的 RIME 配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一篇的原因是我最近在偶然间刷博客刷到一篇 &lt;a href=&quot;https://blog.coelacanthus.moe/posts/tech/a-new-rime-simp-pinyin-schema/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;讲 RIME 简体输入方案的文章&lt;/a&gt;，里面提到说朙月拼音因为是繁体转简体所以会出现各种错误（其实我个人倒是没怎么遇到过），然后推荐了一个完全针对简体字的输入方案 &lt;a href=&quot;https://github.com/hosxy/rime-aurora-pinyin/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;极光拼音&lt;/a&gt;，我自己其实只会输入简体字，不怎么需要输入繁体字的功能，所以打算试试。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;上一篇：&lt;a href=&quot;/posts/My-RIME/&quot;&gt;可能只适合我自己的 RIME 配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这一篇的原因是我最近在偶然间刷博客刷到一篇 &lt;a href=&quot;https://blog.coelacanthus.moe/posts/tech/a-new-rime-simp-pinyin-schema/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;讲 RIME 简体输入方案的文章&lt;/a&gt;，里面提到说朙月拼音因为是繁体转简体所以会出现各种错误（其实我个人倒是没怎么遇到过），然后推荐了一个完全针对简体字的输入方案 &lt;a href=&quot;https://github.com/hosxy/rime-aurora-pinyin/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;极光拼音&lt;/a&gt;，我自己其实只会输入简体字，不怎么需要输入繁体字的功能，所以打算试试。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;已经有人在 AUR 打包了 &lt;code&gt;rime-aurora-pinyin&lt;/code&gt;，所以我直接拿来用了，然后类似于我上一篇文章处理朙月拼音的办法，给这个也做了一些自定义设置，主要是添加 emoji，修改默认的全角标点上屏行为，以及加载扩展过的字典，不过遇到了几个问题。&lt;/p&gt;
&lt;p&gt;首先是我像上篇文章说的那样直接在 patch 下面添加 &lt;code&gt;__include: emoji_suggestion:/patch&lt;/code&gt; 并不能输入 emoji，我研究了很长时间，甚至以为 emoji 功能依赖繁体转简体。结果其实并不是，打开 &lt;code&gt;emoji_suggestion.yaml&lt;/code&gt; 可以看到下面几句：&lt;/p&gt;
&lt;figure data-raw=&quot;patch:
  switches/@next:
    name: emoji_suggestion
    reset: 1
    states: [ &amp;quot;🈚️️\uFE0E&amp;quot;, &amp;quot;🈶️️\uFE0F&amp;quot; ]
  &#039;engine/filters/@before 0&#039;:
    simplifier@emoji_suggestion
  emoji_suggestion:
    opencc_config: emoji.json
    option_name: emoji_suggestion
    tips: all
&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;patch:
  switches/@next:
    name: emoji_suggestion
    reset: 1
    states: [ &quot;🈚️️\uFE0E&quot;, &quot;🈶️️\uFE0F&quot; ]
  &#039;engine/filters/@before 0&#039;:
    simplifier@emoji_suggestion
  emoji_suggestion:
    opencc_config: emoji.json
    option_name: emoji_suggestion
    tips: all
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;switches&lt;/code&gt; 的部分可以先忽略，关键在于 &lt;code&gt;engine&lt;/code&gt;，这个 emoji 输入的原理是添加一个 filter，它接收一个输入，然后去附带的 opencc 的词典里查找这个输入得到对应的结果，再把这个输出给下一个 filter，按照词典，输入应该是中文字或者词，并且我看了一下词典，简体和繁体是都有的，所以也不存在简繁转换的问题。其实问题在于这段配置会把它作为第一个 filter 加入列表，而极光拼音的默认 filter 列表是这样的：&lt;/p&gt;
&lt;figure data-raw=&quot;  filters:
    - uniquifier
    - charset_filter@gb2312
    - charset_filter@gbk
&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  filters:
    - uniquifier
    - charset_filter@gb2312
    - charset_filter@gbk
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;也就是说如果把 emoji 的 filter 加到第一个，它的输出就要继续经过 &lt;code&gt;uniquifier&lt;/code&gt;，&lt;code&gt;charset_filter@gb2312&lt;/code&gt;，&lt;code&gt;charset_filter@gbk&lt;/code&gt;，后两个是极光拼音为了排除掉几乎用不到的生僻字而添加的。而 emoji 显然不属于 &lt;code&gt;gb2312&lt;/code&gt; 也不属于 &lt;code&gt;gbk&lt;/code&gt;，自然就被过滤掉了。&lt;/p&gt;
&lt;p&gt;所以我的解决方案是把 emoji 的 filter 加到列表最后，其实加到哪里无所谓，只要你确定前一个 filter 的输出是中文，能触发 emoji 的 opencc 词典就好了，我单独写了一个 &lt;code&gt;emoji_suggestion.patch.yaml&lt;/code&gt; 文件：&lt;/p&gt;
&lt;figure data-raw=&quot;switches/@next:
  name: emoji_suggestion
  reset: 1
  states: [ &amp;quot;🈚️️\uFE0E&amp;quot;, &amp;quot;🈶️️\uFE0F&amp;quot; ]
engine/filters/@next: simplifier@emoji_suggestion
emoji_suggestion:
  opencc_config: emoji.json
  option_name: emoji_suggestion
  tips: all
&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;switches/@next:
  name: emoji_suggestion
  reset: 1
  states: [ &quot;🈚️️\uFE0E&quot;, &quot;🈶️️\uFE0F&quot; ]
engine/filters/@next: simplifier@emoji_suggestion
emoji_suggestion:
  opencc_config: emoji.json
  option_name: emoji_suggestion
  tips: all
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;导入的时候就写 &lt;code&gt;__include: emoji_suggestion.patch:/&lt;/code&gt;。不过虽然我这个不再需要原来的那个 YAML 了，还是需要 &lt;code&gt;rime-emoji&lt;/code&gt; 这个项目里其余的文件的。&lt;/p&gt;
&lt;p&gt;顺便这也解释了为什么使用朙月拼音时候 emoji 后面的提示框显示的是繁体而非简体，因为朙月拼音从词库直接吐出来的是繁体，然后直接经过第一个 filter 就是 emoji，自然 emoji 查找时候用的就是繁体，然后才会经过简繁转换的 filter，所以如果把 emoji 的 filter 挪到简繁转换的 filter 后面，提示就会变成简体。&lt;/p&gt;
&lt;p&gt;解决了 emoji 问题之后还有另一个问题，因为这个 emoji 的 filter 的输入是中文词组，也就意味着必须词库能吐出对应的中文词才能输入 emoji，比如说刚配置出来极光拼音的时候是吐不出来“笑哭”这个词的，所以就不会触发笑哭的 emoji。据说其它平台的输入法也有这个问题。其实没什么太好的解决方案，你可以说自己先手动打几次对应的词然后等 RIME 记住这个输入，不过我觉得也不太好。我想到的办法是既然需要词库里有，不如就让我用 emoji 的 opencc 词典生成一个 RIME 词库，然后扩展词库的时候加进去，这样无论如何都能吐出来了。其实也不是很麻烦，但是需要你把文字转成对应的拼音，那当然不能人工做这个操作了，我利用 Node 的 pinyin 库写了个脚本来做这件事：&lt;/p&gt;
&lt;figure data-raw=&quot;#!/usr/bin/env node

const fs = require(&amp;quot;fs&amp;quot;);
const OpenCC = require(&amp;quot;opencc&amp;quot;);
const {pinyin} = require(&amp;quot;pinyin&amp;quot;);

// 我的词库只需要简体中文，如果你需要繁体中文，把 `t2s` 改成 `s2t` 应该就好了。
const converter = new OpenCC(&amp;quot;t2s.json&amp;quot;);

const outputFileName = &amp;quot;emoji_suggestion.dict.yaml&amp;quot;;

const inputFileNames = [];

if (process.argv.length &lt;= 2) {
  console.log(`Usage: ${process.argv[1]} file1 file2 ...`);
  process.exit(0);
}

for (let i = 2; i &lt; process.argv.length; ++i) {
  inputFileNames.push(process.argv[i]);
}

const results = {};

for (const inputFileName of inputFileNames) {
  const words = fs.readFileSync(
    inputFileName, &amp;quot;utf8&amp;quot;
  ).split(&amp;quot;\n&amp;quot;).filter((line) =&gt; {
    return line.length !== 0;
  }).map((line) =&gt; {
    return line.split(&amp;quot;\t&amp;quot;)[0];
  });
  for (const w of words) {
    // rime-emoji 的 opencc 词典同时包含简体中文和繁体中文，但比如极光拼音
    // 这种默认不包含简繁转换的方案多半只想要其中一种，所以使用 opencc 对候选词
    // 进行一次转换。
    const word = converter.convertSync(w);
    if (results[word] != null) {
      continue;
    }
    const py = pinyin(word, {
      &amp;quot;heteronym&amp;quot;: true,
      &amp;quot;segment&amp;quot;: true,
      &amp;quot;style&amp;quot;: &amp;quot;normal&amp;quot;
    }).map((array) =&gt; {
      // 有些时候就算利用结巴分词了，这个库仍然会没法判断多音字的读音然后丢出好
      // 几个结果，只取第一个好了。
      return array[0];
    }).join(&amp;quot; &amp;quot;);
    // 遇到处理不了的生僻字这个库会直接丢出原本的字……什么奇怪逻辑，只能判断是不
    // 是字母或空格了。
    if (/^[a-z ]*$/.test(py)) {
      results[word] = py;
    }
  }
}

const outputLines = [
  &amp;quot;# Rime dictionary for emoji&amp;quot;,
  &amp;quot;# encoding: utf-8&amp;quot;,
  &amp;quot;# Generated by `gen-emoji-dict.js` written by Alynx Zhou&amp;quot;,
  &amp;quot;&amp;quot;,
  &amp;quot;---&amp;quot;,
  &amp;quot;name: emoji_suggestion&amp;quot;,
  &amp;quot;version: \&amp;quot;0.1\&amp;quot;&amp;quot;,
  &amp;quot;sort: by_weight&amp;quot;,
  &amp;quot;...&amp;quot;,
  &amp;quot;&amp;quot;
];
for (const k in results) {
  outputLines.push(`${k}\t${results[k]}`);
}
// console.log(outputLines.join(&amp;quot;\n&amp;quot;));
fs.writeFileSync(outputFileName, outputLines.join(&amp;quot;\n&amp;quot;), &amp;quot;utf8&amp;quot;);
&quot; data-info=&quot;language-javascript&quot; data-lang=&quot;javascript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-javascript&quot;&gt;#!/usr/bin/env node

const fs = require(&quot;fs&quot;);
const OpenCC = require(&quot;opencc&quot;);
const {pinyin} = require(&quot;pinyin&quot;);

// 我的词库只需要简体中文，如果你需要繁体中文，把 `t2s` 改成 `s2t` 应该就好了。
const converter = new OpenCC(&quot;t2s.json&quot;);

const outputFileName = &quot;emoji_suggestion.dict.yaml&quot;;

const inputFileNames = [];

if (process.argv.length &amp;lt;= 2) {
  console.log(`Usage: ${process.argv[1]} file1 file2 ...`);
  process.exit(0);
}

for (let i = 2; i &amp;lt; process.argv.length; ++i) {
  inputFileNames.push(process.argv[i]);
}

const results = {};

for (const inputFileName of inputFileNames) {
  const words = fs.readFileSync(
    inputFileName, &quot;utf8&quot;
  ).split(&quot;\n&quot;).filter((line) =&amp;gt; {
    return line.length !== 0;
  }).map((line) =&amp;gt; {
    return line.split(&quot;\t&quot;)[0];
  });
  for (const w of words) {
    // rime-emoji 的 opencc 词典同时包含简体中文和繁体中文，但比如极光拼音
    // 这种默认不包含简繁转换的方案多半只想要其中一种，所以使用 opencc 对候选词
    // 进行一次转换。
    const word = converter.convertSync(w);
    if (results[word] != null) {
      continue;
    }
    const py = pinyin(word, {
      &quot;heteronym&quot;: true,
      &quot;segment&quot;: true,
      &quot;style&quot;: &quot;normal&quot;
    }).map((array) =&amp;gt; {
      // 有些时候就算利用结巴分词了，这个库仍然会没法判断多音字的读音然后丢出好
      // 几个结果，只取第一个好了。
      return array[0];
    }).join(&quot; &quot;);
    // 遇到处理不了的生僻字这个库会直接丢出原本的字……什么奇怪逻辑，只能判断是不
    // 是字母或空格了。
    if (/^[a-z ]*$/.test(py)) {
      results[word] = py;
    }
  }
}

const outputLines = [
  &quot;# Rime dictionary for emoji&quot;,
  &quot;# encoding: utf-8&quot;,
  &quot;# Generated by `gen-emoji-dict.js` written by Alynx Zhou&quot;,
  &quot;&quot;,
  &quot;---&quot;,
  &quot;name: emoji_suggestion&quot;,
  &quot;version: \&quot;0.1\&quot;&quot;,
  &quot;sort: by_weight&quot;,
  &quot;...&quot;,
  &quot;&quot;
];
for (const k in results) {
  outputLines.push(`${k}\t${results[k]}`);
}
// console.log(outputLines.join(&quot;\n&quot;));
fs.writeFileSync(outputFileName, outputLines.join(&quot;\n&quot;), &quot;utf8&quot;);
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当然这个脚本不是很完美，比如 pinyin 识别不了的生僻字直接忽略了，不过我觉得它都识别不了，我多半也不会打出来的。然后虽然可以利用 jieba 分词提高多音字的准确性，还是有些不正确的，这些遇到了再手动纠错吧。&lt;/p&gt;
&lt;p&gt;最后把这个词库添加进扩充词库：&lt;/p&gt;
&lt;figure data-raw=&quot;# 原来要结合默认词库和第三方词库，
# 需要自己编写一个词库让它 fallback 到极光拼音和第三方词库。
# 我说佛老师对不起对不起，我不懂规矩。
---
name: aurora_pinyin.extended
version: &amp;quot;0.1&amp;quot;
# `by_weight`（按词频高低排序）或 `original`（保持原码表中的顺序）。
sort: by_weight
# 听说默认简化字八股文效果不好，还是算了。
# https://blog.coelacanthus.moe/posts/tech/a-new-rime-simp-pinyin-schema/
# 因为导入的朙月拼音词库是繁转简，所以这里不能导入简化字八股文。
# 导入简化字八股文。
# vocabulary: essay-zh-hans
# 选择是否导入预设词汇表【八股文】。
# use_preset_vocabulary: true

import_tables:
  # 主要是为了肥猫 wiki 词库。极光拼音好像是内置常用简化字表的。
  - zhwiki
  - aurora_pinyin
  - emoji_suggestion
&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 原来要结合默认词库和第三方词库，
# 需要自己编写一个词库让它 fallback 到极光拼音和第三方词库。
# 我说佛老师对不起对不起，我不懂规矩。
---
name: aurora_pinyin.extended
version: &quot;0.1&quot;
# `by_weight`（按词频高低排序）或 `original`（保持原码表中的顺序）。
sort: by_weight
# 听说默认简化字八股文效果不好，还是算了。
# https://blog.coelacanthus.moe/posts/tech/a-new-rime-simp-pinyin-schema/
# 因为导入的朙月拼音词库是繁转简，所以这里不能导入简化字八股文。
# 导入简化字八股文。
# vocabulary: essay-zh-hans
# 选择是否导入预设词汇表【八股文】。
# use_preset_vocabulary: true

import_tables:
  # 主要是为了肥猫 wiki 词库。极光拼音好像是内置常用简化字表的。
  - zhwiki
  - aurora_pinyin
  - emoji_suggestion
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;顺便说一下我其实也不太了解这个扩展词库的顺序怎么设置比较好，不过我尝试的结果是像这样把 emoji 放在最后面，就不会每次输入在前面提示很多并不常用的 emoji 词组的问题。&lt;/p&gt;
&lt;p&gt;我这个脚本生成的词库只有简体，不过我发现朙月拼音的简繁转换还是可以正常处理简体词库的，也就是说会变成 词库出简体 -&amp;gt; 简繁转换 -&amp;gt; 繁体变 emoji，所以直接加给朙月拼音也没问题，如果我需要用繁体中文，可以直接切换方案到朙月拼音（虽然实际上我的配置是简化字版，不过看起来主要区别只是默认是否开启繁体转简体）。平时输入简体则直接用极光拼音。&lt;/p&gt;
&lt;p&gt;完整配置在 &lt;a href=&quot;https://github.com/AlynxZhou/alynx-rime-config/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;GitHub Repo&lt;/a&gt; 更新。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="输入法" label="输入法" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BE%93%E5%85%A5%E6%B3%95/" />
    <category term="RIME" label="RIME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BE%93%E5%85%A5%E6%B3%95/RIME/" />
    <category term="输入法" label="输入法" scheme="https://sh.alynx.one/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" />
    <category term="RIME" label="RIME" scheme="https://sh.alynx.one/tags/RIME/" />
  </entry>
  <entry>
    <title>阻止 clangd 污染项目根目录的一些方法</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Prevent-clangd-from-Making-Projects-Root-Dirty/" />
    <id>https://sh.alynx.one/posts/Prevent-clangd-from-Making-Projects-Root-Dirty/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-07-06T04:19:32.000Z</published>
    <updated>2022-08-17T08:28:58.000Z</updated>
    <summary type="html">
      &lt;p&gt;Emacs 的 lsp-mode 推荐使用 clangd 分析 C/C++ 代码，用起来体验还不错，但是让人非常恼火的是用户要主动或者被迫地在项目根目录下面添加一些文件，比如 &lt;code&gt;.clang_complete&lt;/code&gt; 或者 &lt;code&gt;compile_commands.json&lt;/code&gt; 来让 clangd 知道项目需要包含哪些库的头文件，以及 clangd 会直接把建立的索引丢到项目根目录下面的 &lt;code&gt;.cache&lt;/code&gt; 目录里。虽然可以把这些加入 &lt;code&gt;.gitignore&lt;/code&gt;，但保不齐哪个脾气古怪的上游维护者会和你纠缠半天让你解释为什么要加这些，实在是很麻烦。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;Emacs 的 lsp-mode 推荐使用 clangd 分析 C/C++ 代码，用起来体验还不错，但是让人非常恼火的是用户要主动或者被迫地在项目根目录下面添加一些文件，比如 &lt;code&gt;.clang_complete&lt;/code&gt; 或者 &lt;code&gt;compile_commands.json&lt;/code&gt; 来让 clangd 知道项目需要包含哪些库的头文件，以及 clangd 会直接把建立的索引丢到项目根目录下面的 &lt;code&gt;.cache&lt;/code&gt; 目录里。虽然可以把这些加入 &lt;code&gt;.gitignore&lt;/code&gt;，但保不齐哪个脾气古怪的上游维护者会和你纠缠半天让你解释为什么要加这些，实在是很麻烦。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;&lt;code&gt;compile_commands.json&lt;/code&gt; 比较好解决，clangd 提供了一个参数 &lt;code&gt;--compile-commands-dir=&amp;lt;string&amp;gt;&lt;/code&gt; 可以指定查找这个文件的目录，我直接把它设置为 &lt;code&gt;./build/&lt;/code&gt;，因为大部分项目的 &lt;code&gt;.gitignore&lt;/code&gt; 都会包含构建目录，也免得运行 &lt;code&gt;bear -- meson compile&lt;/code&gt; 之后再把这个文件从 &lt;code&gt;build&lt;/code&gt; 目录移出来。&lt;/p&gt;
&lt;figure data-raw=&quot;(use-package lsp-mode
  :ensure t
  :commands lsp
  :hook ((c-mode . lsp-deferred)
         (c++-mode . lsp-deferred)
         (c-or-c++-mode . lsp-deferred)
         (lsp-mode . lsp-enable-which-key-integration))
  :bind (:map lsp-mode-map
              (&amp;quot;M-.&amp;quot; . lsp-find-definition)
              (&amp;quot;M-,&amp;quot; . lsp-find-references))
  :custom
  ;; Move lsp files into local dir.
  (lsp-server-install-dir (locate-user-emacs-file &amp;quot;.local/lsp/&amp;quot;))
  (lsp-session-file (locate-user-emacs-file &amp;quot;.local/lsp-session&amp;quot;))
  (lsp-keymap-prefix &amp;quot;C-c l&amp;quot;)
  ;; Only enable log for debug.
  ;; This controls `*lsp-log*` buffer.
  (lsp-log-io nil)
  ;; JavaScript (ts-ls) settings.
  ;; OMG, the FUCKING EVIL SHITTY VSCode TypeScript language server generates
  ;; log in project dir, can MicroSoft stop to let their software put shit in
  ;; front of users?
  (lsp-clients-typescript-server-args &#039;(&amp;quot;--stdio&amp;quot; &amp;quot;--tsserver-log-file&amp;quot; &amp;quot;/tmp/tsserver-log.txt&amp;quot;))
  (lsp-javascript-format-insert-space-after-opening-and-before-closing-nonempty-braces nil)
  ;; Always let clangd look for compile_commands.json under build dir so it will
  ;; not make project root dirty.
  (lsp-clients-clangd-args (&amp;quot;--header-insertion-decorators=0&amp;quot; &amp;quot;--compile-commands-dir=./build/&amp;quot; &amp;quot;--enable-config&amp;quot;)))
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(use-package lsp-mode
  :ensure t
  :commands lsp
  :hook ((c-mode . lsp-deferred)
         (c++-mode . lsp-deferred)
         (c-or-c++-mode . lsp-deferred)
         (lsp-mode . lsp-enable-which-key-integration))
  :bind (:map lsp-mode-map
              (&quot;M-.&quot; . lsp-find-definition)
              (&quot;M-,&quot; . lsp-find-references))
  :custom
  ;; Move lsp files into local dir.
  (lsp-server-install-dir (locate-user-emacs-file &quot;.local/lsp/&quot;))
  (lsp-session-file (locate-user-emacs-file &quot;.local/lsp-session&quot;))
  (lsp-keymap-prefix &quot;C-c l&quot;)
  ;; Only enable log for debug.
  ;; This controls `*lsp-log*` buffer.
  (lsp-log-io nil)
  ;; JavaScript (ts-ls) settings.
  ;; OMG, the FUCKING EVIL SHITTY VSCode TypeScript language server generates
  ;; log in project dir, can MicroSoft stop to let their software put shit in
  ;; front of users?
  (lsp-clients-typescript-server-args &#039;(&quot;--stdio&quot; &quot;--tsserver-log-file&quot; &quot;/tmp/tsserver-log.txt&quot;))
  (lsp-javascript-format-insert-space-after-opening-and-before-closing-nonempty-braces nil)
  ;; Always let clangd look for compile_commands.json under build dir so it will
  ;; not make project root dirty.
  (lsp-clients-clangd-args (&quot;--header-insertion-decorators=0&quot; &quot;--compile-commands-dir=./build/&quot; &quot;--enable-config&quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;对于 &lt;code&gt;.cache/&lt;/code&gt; 就不是那么好解决了，根据 &lt;a href=&quot;https://github.com/clangd/clangd/issues/341#issuecomment-1003560792&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/clangd/clangd/issues/341#issuecomment-1003560792&lt;/a&gt;，似乎他们并没有关闭或者修改缓存目录的支持。不过我想到一个弯道超车的方案，&lt;code&gt;git&lt;/code&gt; 本身应该是有从其它位置加载用户定义的 &lt;code&gt;gitignore&lt;/code&gt; 文件的功能的，我利用这个写一个本地的 gitignore 不就行了吗，搜索之后得到 &lt;a href=&quot;https://stackoverflow.com/questions/5724455/can-i-make-a-user-specific-gitignore-file&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://stackoverflow.com/questions/5724455/can-i-make-a-user-specific-gitignore-file&lt;/a&gt;，操作起来也很简单。首先我把这个文件放到 &lt;code&gt;~/.config/git/gitignore&lt;/code&gt;，里面写上要忽略的 glob，然后运行 &lt;code&gt;git config --global core.excludesfile ~/.config/git/gitignore&lt;/code&gt; 就大功告成。&lt;/p&gt;
&lt;p&gt;不过就在我写这篇文章时，clangd 的 issue 上有人回复我，根据 &lt;a href=&quot;https://github.com/clangd/clangd/issues/184#issuecomment-998244415&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/clangd/clangd/issues/184#issuecomment-998244415&lt;/a&gt;，现在 clangd 应该是会把索引放在 &lt;code&gt;compile_commands.json&lt;/code&gt; 所在的目录，所以多少也算是解决了问题吧。虽然这样删掉构建目录之后索引缓存也没了，不过我觉得比起重建缓存，还是弄脏项目目录更恶心一点。&lt;/p&gt;
&lt;p&gt;更新（2022-08-17）：还有一个头疼的问题是 GLib 的 &lt;code&gt;g_clear_pointer&lt;/code&gt; 宏里面使用到了对指针本体取 &lt;code&gt;sizeof&lt;/code&gt; 的语法，而 clangd 默认会认为这是个错误，于是 lsp 就会标出一大堆问题。可以对项目进行设置关掉这一条，不过又会弄脏项目目录，查询文档得知 clangd 会读取 &lt;code&gt;~/.config/clangd/config.yaml&lt;/code&gt; 这个用户级别的配置文件，于是在里面写入内容关掉这条检查：&lt;/p&gt;
&lt;figure data-raw=&quot;Diagnostics:
  ClangTidy:
    Remove: bugprone-sizeof-expression
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;Diagnostics:
  ClangTidy:
    Remove: bugprone-sizeof-expression
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后给 clangd 传递 &lt;code&gt;--enable-config&lt;/code&gt; 这个参数即可。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/tags/%E7%BC%96%E7%A8%8B/" />
  </entry>
  <entry>
    <title>从 PulseAudio 到 PipeWire</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/From-PulseAudio-to-PipeWire/" />
    <id>https://sh.alynx.one/posts/From-PulseAudio-to-PipeWire/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-06-29T08:11:02.000Z</published>
    <updated>2022-07-21T09:16:00.000Z</updated>
    <summary type="html">
      &lt;p&gt;这篇的操作是在之前 &lt;a href=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/&quot;&gt;运行在 JACK 上层的 PulseAudio&lt;/a&gt; 基础上进行的。&lt;/p&gt;
&lt;p&gt;我自己的音频配置比较复杂，虽然 PipeWire 号称能兼容 PulseAudio 和 JACK 的 client 并且在某些发行版成为了默认选项，我还是没很快换掉。因为我想像之前用 PulseAudio 那样把 PipeWire 做成 JACK 的 client，虽然它的文档一直说支持这样，但是看起来两个月前代码才写好。于是我最近尝试了一下。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;这篇的操作是在之前 &lt;a href=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/&quot;&gt;运行在 JACK 上层的 PulseAudio&lt;/a&gt; 基础上进行的。&lt;/p&gt;
&lt;p&gt;我自己的音频配置比较复杂，虽然 PipeWire 号称能兼容 PulseAudio 和 JACK 的 client 并且在某些发行版成为了默认选项，我还是没很快换掉。因为我想像之前用 PulseAudio 那样把 PipeWire 做成 JACK 的 client，虽然它的文档一直说支持这样，但是看起来两个月前代码才写好。于是我最近尝试了一下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;首先需要安装 &lt;code&gt;pipewire&lt;/code&gt;，&lt;code&gt;pipewire-alsa&lt;/code&gt;，&lt;code&gt;pipewire-pulse&lt;/code&gt; 和一个 PipeWire Media Session Manager，我用的是新的 WirePlumber 但是不要装 &lt;code&gt;pipewire-jack&lt;/code&gt; 因为这个是模拟 JACK server 的。然后配置你的 session manager 开启 &lt;code&gt;alsa.jack-device = true&lt;/code&gt;，然后理论上就能在设置里看到 JACK Sink/Source 了……但是……&lt;/p&gt;
&lt;p&gt;首先装 &lt;code&gt;pipewire-pulse&lt;/code&gt; 会替代 &lt;code&gt;pulseaudio&lt;/code&gt;，但是按照上篇文章应该是安装了 &lt;code&gt;pulseaudio-jack&lt;/code&gt; 这个依赖 &lt;code&gt;pulseaudio&lt;/code&gt; 的包，解决方法是先卸载掉 &lt;code&gt;pulseaudio-jack&lt;/code&gt;。然后继续安装重新登录应该 PipeWire 已经起来了，按理说这时候启动 JACK 就可以，但是不管我怎么搞都看不到 JACK Sink/Source，所以就备用方案，直接用 PipeWire 替代 JACK 看看，虽然早就可以这么做了，但是之前之前尝试 PipeWire 感觉不是那么稳定，所以就没一直用。&lt;/p&gt;
&lt;p&gt;使用 PipeWire 当 JACK 的话要安装 &lt;code&gt;pipewire-jack&lt;/code&gt;，和前面差不多的问题是 &lt;code&gt;pipewire-jack&lt;/code&gt; 替代 &lt;code&gt;jack2&lt;/code&gt; 但是 &lt;code&gt;jack2-dbus&lt;/code&gt; 依赖 &lt;code&gt;jack2&lt;/code&gt;，那就先删掉 &lt;code&gt;jack2-dbus&lt;/code&gt; 再装就好了，然后重新登录，一切正常，Qjackctl 的 Graph 也能正常操作。而且比较有趣的是这样原本使用 PulseAudio 的程序也会在 JACK Graph 里面显示成节点（因为最后都通过 PipeWire），使用 Ardour 录音也没什么问题。其实我的需求还是比较简单的，也不需要什么太低的延迟，只是很多录音的程序都用 JACK 所以才要用。&lt;/p&gt;
&lt;p&gt;用了一段时间之后感觉没什么问题，设备之间来回切换也没有卡顿了，驱动我的 2i4 也是完全正常，以后应该就先这样用了。&lt;/p&gt;
&lt;p&gt;更新（2022-07-21）：我发现在 Ardour 里面录音还是有问题，具体表现是录超过 1 分钟就会报 xrun，怀疑是这个 bug：&lt;a href=&quot;https://gitlab.freedesktop.org/pipewire/pipewire/-/issues/2257&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.freedesktop.org/pipewire/pipewire/-/issues/2257&lt;/a&gt;。不过其它 DAW 比如 REAPER 或者 Zrythm 都没问题，我倒是挺想换成 Zrythm 的，但是它还在 Beta 阶段。以及前面板插入耳机似乎设置里检测不到，但是开启一下 pauvcontrol 又能检测到了，总之是一些奇怪的小问题，也许我应该换回去。&lt;/p&gt;
&lt;p&gt;更新（2022-07-21）：我把我的 Sony Playstation Eye 拔掉之后似乎 Ardour 就正常了……我记得这个摄像头的麦克风阵列以前可以用的，不知道为什么现在 PulseAudio 都用不了了，所以看起来不是 PipeWire 的问题。至于为什么只有 Ardour + PipeWire 会出现这个问题，我猜是因为 Ardour 会连接所有可用的设备给自己用，于是就被这个不工作的设备影响出现延迟，而原版的 JACK 只会请求一个设备，Ardour 根本就看不到 PS Eye。也许我还是得买个正经的摄像头……&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    <category term="音频" label="音频" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/%E9%9F%B3%E9%A2%91/" />
    <category term="录音" label="录音" scheme="https://sh.alynx.one/tags/%E5%BD%95%E9%9F%B3/" />
    <category term="PulseAudio" label="PulseAudio" scheme="https://sh.alynx.one/tags/PulseAudio/" />
    <category term="JACK" label="JACK" scheme="https://sh.alynx.one/tags/JACK/" />
    <category term="PipeWire" label="PipeWire" scheme="https://sh.alynx.one/tags/PipeWire/" />
  </entry>
  <entry>
    <title>装了台 NAS</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Build-My-NAS/" />
    <id>https://sh.alynx.one/posts/Build-My-NAS/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-05-07T09:49:46.000Z</published>
    <updated>2022-05-07T09:49:46.000Z</updated>
    <summary type="html">
      &lt;p&gt;本来我是不打算装 NAS 的，甚至都把我的星际蜗牛关了，因为我觉得我又没有网络多人协作的需求，而且我醒着的时候我的台式机也醒着，我睡着了又不会用到网络存储。不过自从我买了相机开始拍照片录视频，存储空间就越来越紧张了，先是把我机箱里的硬盘从 2T 直接升级到 8T，又觉得没有冗余始终心慌慌。偏偏我现在这个机箱哪里都不错，就是机械硬盘位不太充裕。为了扩展存储空间，也只能装一个 NAS 了。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;本来我是不打算装 NAS 的，甚至都把我的星际蜗牛关了，因为我觉得我又没有网络多人协作的需求，而且我醒着的时候我的台式机也醒着，我睡着了又不会用到网络存储。不过自从我买了相机开始拍照片录视频，存储空间就越来越紧张了，先是把我机箱里的硬盘从 2T 直接升级到 8T，又觉得没有冗余始终心慌慌。偏偏我现在这个机箱哪里都不错，就是机械硬盘位不太充裕。为了扩展存储空间，也只能装一个 NAS 了。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;决定好装 NAS 之后比较难的就是选硬件了，我肯定不会买那些闭源拖拉机的，我要装 Linux。肯定排除掉星际蜗牛，因为我实在不放心用那个背板带四块硬盘。然后对这种低功耗的设备用那种主板和 CPU 集成的赛扬应该不错，还免了主动散热，问题是我不知道在哪里能买到。所以还是考虑普通零售的硬件，不过大部分零售的硬件都有点性能过剩了，挑来挑去挑出下面的一套配置，比较个人倾向，不建议大家直接拿过来用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU：i3-10105T 645&lt;/li&gt;
&lt;li&gt;主板：七彩虹 B460I 579&lt;/li&gt;
&lt;li&gt;机箱：乔思伯 N1 669&lt;/li&gt;
&lt;li&gt;电源：银欣 SX500-LG 549&lt;/li&gt;
&lt;li&gt;散热：利民 AXP90-X47 139&lt;/li&gt;
&lt;li&gt;内存：光威 8G DDR4 2666 169x2&lt;/li&gt;
&lt;li&gt;网卡：EDUP PCI-E 2.5Gbps 网卡 89&lt;/li&gt;
&lt;li&gt;SSD：闪迪 至尊高速 NVMe 256G 259&lt;/li&gt;
&lt;li&gt;HDD：西数 HC550 16T 1498x4&lt;/li&gt;
&lt;li&gt;HDD：希捷 酷鹰 2T 375&lt;/li&gt;
&lt;li&gt;扩展：乐扩 M.2 A+E Key 转 SATA 75&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面简单介绍一下为什么选这套。&lt;/p&gt;
&lt;p&gt;首先装 NAS 第一个要决定的不是别的而是硬盘，毕竟你这设备就是拿来放硬盘的，因为台式机里面已经有 8T 的硬盘了，我也不想再经历换硬盘时候拷贝数据的痛苦，所以还是直接上了 16T 的。这种容量建议直接购买企业盘，不过也就和静音说拜拜了。没选希捷的银河系列不是因为别的，只是因为西数 HC 系列便宜点而已。选 4 块盘而不是 3 块的原因也很简单，我不会用 ZFS，肯定要用 btrfs，但是 btrfs 的 RAID5 有 bug，于是性能容量冗余的平衡点就是 RAID10 了，那就需要 4 块硬盘起步。&lt;/p&gt;
&lt;p&gt;决定好硬盘之后就得选合适的机箱，毕竟你得能把硬盘装进去，不过我对大部分的 NAS 机箱都不满意，有些类似个人产品或者众筹的机箱比如什么宝藏盒TANK之类的看起来很能装，但是造型不伦不类，做工也一般般，然后可能迎广或者万由有一些成品 NAS 机箱看起来不错，但是基本上是高配蜗牛，而且我实在不想用 flex 电源。其实某种意义上我是先看中乔思伯 N1 这个机箱才决定装的 NAS，我对这个牌子其实没什么好感，但这个机箱实在是过于好看，而且可以装 SFX 或者 SFX-L 电源，还是有很多零售产品可以选的。&lt;/p&gt;
&lt;p&gt;选好机箱以后就是机箱里能塞进什么硬件就塞什么硬件了，乔思伯 N1 和大部分 NAS 机箱一样都只能放 ITX 主板，但 ITX 主板可选的实在不多。首先我想要一个内置核显的 CPU，因为最简单的调试办法肯定是给机箱接上键盘鼠标显示器，也比较方便调整 BIOS，而 ITX 只有一个宝贵的 PCIE 插槽，再说 NAS 多半也没必要上个亮机卡耗电。而 AMD 那边 200GE 太弱了，Ryzen Pro 系列又太强了，实在不知道选什么比较好，而且也不容易买到最低配的 Ryzen Pro CPU，所以就选 Intel i3 了，正好还有带 T 的低功耗版本。同时 10 代的主板还比较好买，也就是说能买到新的。虽然这台机箱前面有 USB-C，不过实际上是和 USB 3.0 共享一个插座，所以也不需要主板有 USB-C 的插座。七彩虹这块 B460 的优点在于后面还是有一个标准的 USB-C 接口，以及能在京东自营买到。&lt;/p&gt;
&lt;p&gt;SFX 电源虽然不如 ATX 电源好选，但是仍然比 flex 电源好选太多了，而且这台机器还可以放下 SFX-L 的电源，12cm 的风扇肯定比 4cm 要安静很多。于是我就在京东随便挑了一个观感不坏的牌子的全模组 SFX-L 电源里功率最低的。不过装这个机箱的时候最好注意一点，买的电源的 24pin 线最好不要是那种捆成圆柱型的，因为需要从主板边上极小的缝隙里拉过来，排线肯定比圆柱线要容易过，银欣这款是排线。当然你是定制模组线的有钱人当我没说。&lt;/p&gt;
&lt;p&gt;这款机箱最高可以支持 70mm 的下压散热，所以其实完全可以买利民那款 12cm 的散热器，不过我觉得也无所谓了，我比较担心 12cm 的下压散热会导致在主板上装内存和 SSD 比较困难，9cm 的也够用了。&lt;/p&gt;
&lt;p&gt;内存其实是随便选的，因为我不用 ZFS，其它文件系统对于 ECC 也没那么严格的依赖。然后 i3 和 B460 也不会支持更高的频率了。&lt;/p&gt;
&lt;p&gt;考虑到我的台式机上有两个网口，分别是 1Gbps 和 2.5Gbps 的，我就在想可不可以把 NAS 和台式机通过 2.5Gbps 直接连起来（路由器什么时候普及 2.5Gbps 啊），这样速度基本上和访问本机的机械硬盘没有太大差距。但是主板厂家实在是太抠门了，本来 ITX 主板型号就不多，内置 2.5Gbps 网卡的就更少了。虽然让一个 2.5Gbps 的网卡占着 PCI-E x16 插槽实在是有点浪费，但也没别的选择了。至于万兆，考虑到要使用专门的线和专门的网卡，还得给台式机也装一个，算了吧，反正机械硬盘的阵列也跑不满万兆。&lt;/p&gt;
&lt;p&gt;然后系统盘只要随便搞一个 NVMe 就可以了，反正安装一个 Arch Linux 不会占用多少空间。实际上比较头痛的是怎么接上所有的硬盘。这款机箱有 5 个在背板上的 3.5 寸硬盘位和一个单独的 2.5 寸硬盘位。大部分 ITX 主板都只有 4 个 SATA 接口，本来我觉得接 4 盘的阵列够了，但是后来我发现北邮人 pt 可以使用我的交大学校邮箱注册……要是挂 PT，我觉得还是单独放一块硬盘比较好，那接口就不够用了。比较靠谱的办法是买 HBA 卡把 PCI-E 转成 SATA，但是已经被 2.5 Gbps 网卡用掉了。我还没有发现同时有网卡和 SATA 的 PCI-E 扩展卡。还有一个方案是 M.2 转 5 个 SATA 的转接卡，其实倒也可以用一块 2.5 寸的 SSD 当作系统盘，然后解放出这个 M.2 接口，不过我实在不放心把 4 盘阵列放在这种转接卡上……而且我估计系统盘也是不能接在转接卡上的。当然你可以买一块有 2.5 Gbps 网卡的 ITX 主板，不过那基本只有 Z590 可选了，最便宜的华擎 Z590 ITX 也要 1400。所以我最后采用的方案是放弃掉无线网卡，反正 NAS 摆在路由器附近可以拉网线，然后把无线网卡下面那个 A+E Key 的 M.2 接口利用上。有这样的转接卡，可以转接出两个 SATA 口，虽然我只要一个就够了。&lt;/p&gt;
&lt;p&gt;不过当我拿到转接卡的快递之后发现安装还是有点麻烦。最好的办法是拧下无线网卡之后发现那个保护罩可以拆掉一侧的面板，然后可以把无线网卡从保护罩上拿下来再换成转接卡。但是那个固定无线网卡的螺丝实在太紧了我拧不下来，只能放弃这个保护罩，反正转接卡应该也不会受到什么外力，就在我把转接卡插好打算开机之前，我发现还是有点问题……虽然 SATA 接口已经够矮了，但是里面那个用不上的 SATA 接口还是顶住了前面的音频接口，导致转接板是歪的。其实可以淘宝再买一个 M.2 A+E Key 的延长线，不过那样我纠结的就是把延长出来的转接卡固定在哪里了。不管了！反正我就要一个 SATA 口，用刀把里面的 SATA 口的顶端削掉吧！虽然削的很粗糙但是还是达到了效果，然后用一块胶带把那个口粘住，防止 SATA 接口里面的金属触点接触到音频口保护壳而短路，再把一块泡沫放到转接板后面顶住转接板，我觉得就差不多了。&lt;/p&gt;
&lt;p&gt;直接装上是歪的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Build-My-NAS/1.jpg&quot; alt=&quot;1.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;“高个的 SATA 接口被我给锯了，比矮个的还矮！”：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Build-My-NAS/2.jpg&quot; alt=&quot;2.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;“磨”改之后的效果，应该没问题吧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Build-My-NAS/3.jpg&quot; alt=&quot;3.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后就是绞尽脑汁把各种线塞到 ITX 机箱里面，实在是太痛苦了。对了，这个机箱自带的风扇接线不是很长，而它那个硬盘背板上的插针又是满速的，如果你要是想插到主板上进行调速，最好自备一根 4pin 风扇延长线。&lt;/p&gt;
&lt;p&gt;剩下就没什么好说的了，毕竟我不打算在这里复述一遍 Arch Wiki。我对 btrfs 使用的参数是 &lt;code&gt;-m raid1c3 -d raid10&lt;/code&gt;，然后在系统里设置了 samba 和 transmission 的daemon。最后附上一些装完的照片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Build-My-NAS/4.jpg&quot; alt=&quot;4.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Build-My-NAS/5.jpg&quot; alt=&quot;5.jpg&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Build-My-NAS/6.jpg&quot; alt=&quot;6.jpg&quot;&gt;&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
  </entry>
  <entry>
    <title>用 Telegram 机器人做后端的照片墙</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Telegram-Bot-as-Gallery-Backend/" />
    <id>https://sh.alynx.one/posts/Telegram-Bot-as-Gallery-Backend/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-03-23T08:01:11.000Z</published>
    <updated>2022-03-23T08:01:11.000Z</updated>
    <summary type="html">
      &lt;blockquote class=&quot;center-quote&quot;&gt;杜洛夫叔叔我啊，最喜欢 TON 了。&lt;/blockquote&gt;

&lt;p&gt;其实倒也不一定是 Telegram 机器人，只是我比较熟悉这个的 API，不过看杜洛夫叔叔自己打自己脸的架势甚至比起陈叔叔有过之而无不及，说不定哪天我真的可能把这个服务转移到别的上去，反正原理都是类似的。这篇文章只是记录一下这个点子的来源和形成过程，其实实现起来没什么技术难度。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;blockquote class=&quot;center-quote&quot;&gt;杜洛夫叔叔我啊，最喜欢 TON 了。&lt;/blockquote&gt;

&lt;p&gt;其实倒也不一定是 Telegram 机器人，只是我比较熟悉这个的 API，不过看杜洛夫叔叔自己打自己脸的架势甚至比起陈叔叔有过之而无不及，说不定哪天我真的可能把这个服务转移到别的上去，反正原理都是类似的。这篇文章只是记录一下这个点子的来源和形成过程，其实实现起来没什么技术难度。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我平时总是强迫自己多拍点照片，因为拍照这种东西如果不强迫自己，那就越来越懒最后干脆就不拍了。虽然我没什么审美也没什么技术，不过数量加运气还是能得到一些不错的照片。我试图把这些照片分享到公共平台，不过考虑到我自己的口味问题，有点难办。平时我一般发微信朋友圈然后点击同步到 QQ 空间，这样熟人就可以看到了，不过这不能算是公共平台吧。而微博这种垃圾平台，如果不是猫日在上面更新，我大概也早就不用了，所以是断然不可能发的。很多国内摄影会发小红书，但是我也比较讨厌这个平台，而且它似乎只有手机 APP 没有网页版。抖音我也没什么好感。B 站动态我倒是挺愿意发一发的，不过叔叔的技术水平实在是拉中拉，动态连个指定页码翻页功能都没有。然后考虑国外的社交平台的话，其实也没什么意思，这里我要特别提一下好多名人明星和摄影师喜欢的 Instagram，我真的不能理解这东西是怎么火的，手机客户端一点也不 Native，既不是 Android 风也不是 iOS 风，而且感觉功能比 Twitter 差多了，至于网页版，点开图片显示的窗口比手机屏幕还小，而且 2022 年了，抖音网页版都能不登录就访问，Instagram 网页版还一定要我登录。然后我想退而求其次我能不能利用现有的 API，写个 Telegram 机器人替我定期发图，我只要把图发给 Telegram 机器人就好了。我见过很多这样的 Twitter 机器人。不过问题还是一样，国内平台只想从真人用户身上薅钱，根本不在乎什么技术相关的东西，也不会给你做公开 API。国外平台的话，我还是更想给中文环境的用户看吧，所以也不合适。&lt;/p&gt;
&lt;p&gt;其实我不是没想过直接发在我自己的博客上，但是遇到了一些问题，首先博客是以文章为中心的，一篇文章要有标题，但是我想的就是发图然后配几句话或者根本不配（您 pay 吗？），要是单独作为一个 page，那这个 page 可能会很长。我也考虑过新建一个站点然后做一个特化的主题用生成器生成，不过这有点杀鸡用牛刀的意思了。再之后的问题是写博客我会写很长的文章，所以我肯定是在电脑上编写，但我发照片可能是心情到了就发，显然用手机更方便，要是为了这个再写一个网页的发图后台有点麻烦了。所以干脆综合一下想法，跑一个 Telegram 机器人作为后台，每次收到我发的图就自动建立目录然后下载进去，再生成静态网页就可以了。正好我之前从蓝猫那买了一个树莓派 4，但是不知道有什么用，就让它来跑这个。&lt;/p&gt;
&lt;p&gt;机器人的部分其实不难，需要注意的也就是限制能交互的用户名，以及只处理私聊的文本和图片消息。其实理论上可以做到每次发带字的图片组就发一条，但是考虑到扩展性我没这样做，而是使用命令处理了（而且从 API 上图片组也不是一条消息，而是多条消息带有同样的组标识）。我的做法是搞了一个状态机，进入 create 状态，收到的图片消息就会被加入图片数组，文本消息则会被连接起来，然后通过状态转移可以进入不同的状态，比如进入 authors 状态就会把收到的每条消息作为一个作者名字放进作者数组，然后最后执行 commit 命令让机器人以时间戳作为名字创建目录，然后把图片下载下来，把图片数组作者数组文本都作为键值对写入这个目录的 &lt;code&gt;index.json&lt;/code&gt;，这样我们就既有图片又有元数据了。然后让机器人调用生成用的脚本。同样还有 cancel 命令可以取消未 commit 的操作，以及超时之后自动取消。同时为了方便还有 delete 状态，每条消息都会被作为要删除的目录的名字，commit 之后一起删除。当然时间戳有一个需要注意的地方，就是 UNIX 纪元之前的时间是负数，如果直接转成字符串创建目录，就是以 &lt;code&gt;-&lt;/code&gt; 开头的，在 shell 里面会比较难处理（因为命令行程序会把 &lt;code&gt;-&lt;/code&gt; 作为参数开始的标记，这不是 shell 负责的，所以就算你反斜杠转义或者加引号也没用，一个通俗约定是在这样开头的字符串前面加一个 &lt;code&gt;--&lt;/code&gt; 的参数，意思是让程序不要把后面的字符串当作参数列表处理），简单地办法是替换掉这个符号就好了，比如我换成 &lt;code&gt;n&lt;/code&gt;（但是真的会有人穿越到 1970 年之前用这玩意吗？）。对于 Telegram Bot API 还有需要注意的地方，就是图片下面带的文字并不是在 &lt;code&gt;text&lt;/code&gt; 键下面，而是在 &lt;code&gt;caption&lt;/code&gt; 下面，不过处理的代码倒是可以复用。调用生成的脚本的时候也要注意工作目录，这个过程完全是处理磁盘文件，目录很重要。&lt;/p&gt;
&lt;p&gt;压缩图片的解决方案其实非常简单：用 Telegram 发图片的时候不就自动压缩图片了吗！虽然作为访问者，我常常希望图片网站提供原图下载，不过当我自己 host 一个图片网站的时候，我觉得还是不要传原图好了，毕竟我是放在 GitHub 上，有容量限制，而且就算没有容量限制，原图访问起来太慢了，体验也不会特别好，反正实在不行如果有访问者真心喜欢，让他发邮件联系我就行了。&lt;/p&gt;
&lt;p&gt;一开始其实我觉得这个网页应该会比较简单，所以干脆把构建网页的代码也写进机器人好了，不过群友建议还是分开，只是把 Telegram 机器人作为数据来源，这样以后也好添加别的数据来源，我觉得合理。构建网页其实很简单了，读取所有的图片目录的数据，排序，渲染进网页里，你可以用各种方式解决这个问题，比如现代的双向绑定框架 React 或者 Vue，比如传统的模板系统 EJS 或者 Nunjucks，但是我不想引入别的依赖了，所以做了一个投机取巧的办法，构建的时候读取各个目录的 json，然后得到一个大的数组，给它分页，写进不同的 json 里面，前端的网页通过 JavaScrip &lt;code&gt;fetch&lt;/code&gt; 去获取这个作为索引的 json，把实际的内容渲染进元素里面（其实就是不用 React 的单页应用了）。然后页码其实就是处理 QueryString 里面的 &lt;code&gt;p&lt;/code&gt; 参数，这个也可以用 JS 解决。于是我只要构建好之后把这个页面 push 到 GitHub 开启 Pages 就行了。（其实如果实在讨厌前端跑 JS 的话，后端代码里直接拼 HTML 字符串也行嘛，不过我是懒得改了。）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Telegram-Bot-as-Gallery-Backend/1.png&quot; alt=&quot;1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;前端的部分没什么好说的，怎么排版照片是个问题，我参考了 &lt;a href=&quot;https://css-tricks.com/adaptive-photo-layout-with-flexbox/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://css-tricks.com/adaptive-photo-layout-with-flexbox/&lt;/a&gt;，这个效果很不错，不过评论里指出可以用 CSS 伪元素占据最后的空白空间，我也这么实现的。&lt;/p&gt;
&lt;p&gt;后端（机器人）的代码在 &lt;a href=&quot;https://github.com/AlynxZhou/image-collector-bot/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/image-collector-bot/&lt;/a&gt;, 前端的代码在 &lt;a href=&quot;https://github.com/AlynxZhou/azgallery/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/azgallery/&lt;/a&gt;，感兴趣的朋友也可以自己搞一个玩玩，如果你想看最后的成果，这个博客的菜单栏里面就有照片墙的链接了。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/JavaScript/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/tags/%E7%BC%96%E7%A8%8B/" />
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/tags/JavaScript/" />
  </entry>
  <entry>
    <title>我如何在 Emacs 里面处理缩进宽度和 Tab 宽度</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/How-I-Handle-Indent-Offset-and-Tab-Width-in-Emacs/" />
    <id>https://sh.alynx.one/posts/How-I-Handle-Indent-Offset-and-Tab-Width-in-Emacs/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-03-06T14:00:00.000Z</published>
    <updated>2022-03-07T01:11:02.000Z</updated>
    <summary type="html">
      &lt;blockquote&gt;
&lt;p&gt;Tabs are 8 characters, and thus indentations are also 8 characters. There are heretic movements that try to make indentations 4 (or even 2!) characters deep, and that is akin to trying to define the value of PI to be 3.
-- Linux Kernel Coding Style&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，我不是在任何情况下都同意上面那句话，虽然在写 C 的时候它是绝对的真理。我个人倾向于取其中一部分——任何试图把 Tab 宽度定义为 8 以外的行为都无异于把 PI 定义为 3。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;blockquote&gt;
&lt;p&gt;Tabs are 8 characters, and thus indentations are also 8 characters. There are heretic movements that try to make indentations 4 (or even 2!) characters deep, and that is akin to trying to define the value of PI to be 3.
-- Linux Kernel Coding Style&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当然，我不是在任何情况下都同意上面那句话，虽然在写 C 的时候它是绝对的真理。我个人倾向于取其中一部分——任何试图把 Tab 宽度定义为 8 以外的行为都无异于把 PI 定义为 3。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;写这篇文章是因为我意识到一个问题：Tab 宽度和缩进宽度是两个无关的变量。很多人简单地把缩进宽度理解为 Tab 宽度，不过这不能怪他们，因为大部分的编辑器都把这两者当作相同的东西。而当我重新开始用 Emacs，才发现这两个本来应该是不一样的。&lt;/p&gt;
&lt;p&gt;为了防止迷惑，首先解释几个我说的名词：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Tab 宽度：字面意义上的一个 Tab 字符应该相当于几个空格的宽度，在 Emacs 里面是 &lt;code&gt;tab-width&lt;/code&gt; 这个变量，我个人建议固定为 8。&lt;/li&gt;
&lt;li&gt;缩进宽度：当你的代码应该增加一个缩进级别的时候，应该向右缩进几个空格的宽度，在 Emacs 里面每个模式都有不同的变量控制，比如 &lt;code&gt;c-indent-offset&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;缩进级别：代码逻辑层次（或许可以简单理解为作用域）每增加一层，一般就应该增加一个缩进层级。&lt;/li&gt;
&lt;li&gt;使用 Tab 缩进：不是说只使用 Tab 缩进的意思。事实上如果你的代码可以只使用 Tab 缩进，那么 Tab 宽度为几都无所谓，因为一个缩进宽度就是一个 Tab，但实际上你不一定只使用 Tab 缩进，因为你可能还包含对齐的情况，比方说函数头参数太多，而你希望换行后的参数能够和左括号的下一个字符对齐，那么这个距离大概率无法被 Tab 宽度整除。因此使用 Tab 缩进的含义是“总缩进宽度能够用 Tab 宽度整除的部分用 Tab，余数的部分用空格”，也就是 Emacs 里面 &lt;code&gt;(indent-tabs-mode 1)&lt;/code&gt; 的效果。&lt;/li&gt;
&lt;li&gt;使用空格缩进：和上面相反，意味着缩进部分完全不使用 Tab 字符，那么 Tab 宽度为几也无所谓。也就是 Emacs 里面 &lt;code&gt;(indent-tabs-mode -1)&lt;/code&gt; 的效果。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我个人的建议和倾向主要是两个，第一个是 Tab 宽度固定为 8，第二个则是如果你认为缩进宽度为 8 也就是一个 Tab 对你来说太宽，那么你就应该完全不用 Tab 缩进，也就是使用空格缩进，而不是修改 Tab 宽度。&lt;/p&gt;
&lt;p&gt;这样做的理由很简单，主要是我最近修改 GTK 代码时候发现的，GTK 代码是典型的 GNU 风格，我一开始以为它是完全不使用 Tab 缩进，并且缩进宽度是 2，并且我在 Atom 里面也是把这个项目的 Tab 宽度设为 2，但我前段时间发现 GTK 实际上是使用 Tab 的，比如一个很有意思的情况：某段代码的总缩进级别是 5，而它实际上使用的是 1 个 Tab 和 2 个空格，如果你把 Tab 宽度设置成 2，那这段代码在你的编辑器里就会错误的显示成 2 个缩进级别，只有你的 Tab 宽度是 8 的时候才能正确的显示。&lt;/p&gt;
&lt;p&gt;这些奇怪缩进的项目给了我两个教训：Tab 宽度和缩进宽度并不是一个东西，以及最好假设 Tab 宽度为 8。当然，以上的建议都是以遵照现有代码的风格为前提，应该不会有人任性到把别人的项目都改成自己风格再提交贡献吧。&lt;/p&gt;
&lt;p&gt;我倒不是完全的 Tab 缩进党，比如在 Python 里我设置缩进宽度是 4，而在 JavaScript 里我设置缩进宽度是 2，主要是因为对于 C 这种不允许嵌套函数并且没有类似 class 这种层次的语言来说，缩进级别完全就是函数内部逻辑，当你总缩进宽度达到 24 的时候，你已经在函数里有三层逻辑了。而对 Python 或者 JS 这类函数经常是类的方法的语言，本身函数就已经带着一个缩进级别了，三个缩进级别仅仅只代表两层函数内部逻辑，更别提比如回调函数是匿名函数的情况了。&lt;/p&gt;
&lt;p&gt;至于当缩进宽度不是 8 时使用空格缩进而不是用 Tab 然后修改 Tab 宽度的理由也很简单，和上面说的一样，完全使用 Tab 缩进时虽然 Tab 宽度不会影响总缩进级别，但是一旦遇到对齐的情况，Tab 宽度不一致，对齐的部分就不再一样了。&lt;/p&gt;
&lt;p&gt;说了这么多理论，该到具体的我怎么在 Emacs 里面处理了，首先是默认值，我个人是定义 Tab 宽度为 8 并且设置允许使用 Tab 缩进。&lt;/p&gt;
&lt;figure data-raw=&quot;(setq-default tab-width 8)
(setq-default indent-tabs-mode t)
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(setq-default tab-width 8)
(setq-default indent-tabs-mode t)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;默认的 C 编码风格是 GNU，但是 GNU 的编码风格实在是太恐怖了，特别是大部分人的入门书上应该都是 K&amp;amp;R 或者类似的风格。我换成了我喜欢的 linux 内核风格。有的变量你可以直接使用 &lt;code&gt;setq&lt;/code&gt;，但另一些使用 &lt;code&gt;setq&lt;/code&gt; 会说你声明了一个新的自由变量，这个时候还是遵照建议使用 Emacs 的 &lt;code&gt;customize&lt;/code&gt; 系统吧。&lt;/p&gt;
&lt;figure data-raw=&quot;(customize-set-variable &#039;c-default-style &#039;((java-mode . &amp;quot;java&amp;quot;)
                                           (awk-mode . &amp;quot;awk&amp;quot;)
                                           (other . &amp;quot;linux&amp;quot;)))
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(customize-set-variable &#039;c-default-style &#039;((java-mode . &quot;java&quot;)
                                           (awk-mode . &quot;awk&quot;)
                                           (other . &quot;linux&quot;)))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;前面说过 Emacs 对于不同的模式使用不同的变量作为缩进宽度，这样对于编写配置其实很困难，因为让你时刻记住哪个模式用哪个变量显然不太现实，这里我用了一个比较投机取巧的办法——Emacs 有所谓 buffer-local 变量的设定，也就是说一个变量会有一个默认值，然后每个 buffer 都可以有一个该变量的副本，可以设置成不同的值，如果没有则使用默认值。利用这个功能我创建了一个单独的 buffer-local 变量 &lt;code&gt;indent-offset&lt;/code&gt;，然后把以上所有这些都设置为该变量的别名，于是我对每个 buffer 只要修改 &lt;code&gt;indent-offset&lt;/code&gt; 的副本就可以了。我这里只写了我使用到的模式的变量，如果有其他的就加到列表里，或者我看 &lt;code&gt;doom-modeline&lt;/code&gt; 的代码里几乎包含了所有常见模式的变量，或许可以拿来用。&lt;/p&gt;
&lt;figure data-raw=&quot;(defconst mode-indent-offsets &#039;(c-basic-offset
                                js-indent-level
                                css-indent-offset
                                sgml-basic-offset
                                python-indent-offset
                                lua-indent-level
                                web-mode-code-indent-offset
                                web-mode-css-indent-offset
                                web-mode-markup-indent-offset
                                markdown-list-indent-width)
  &amp;quot;Different modes&#039; indent variables to make alias to indent-offset.&amp;quot;)

(dolist (mode-indent-offset mode-indent-offsets)
  (defvaralias mode-indent-offset &#039;indent-offset))

(defvar-local indent-offset tab-width)
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(defconst mode-indent-offsets &#039;(c-basic-offset
                                js-indent-level
                                css-indent-offset
                                sgml-basic-offset
                                python-indent-offset
                                lua-indent-level
                                web-mode-code-indent-offset
                                web-mode-css-indent-offset
                                web-mode-markup-indent-offset
                                markdown-list-indent-width)
  &quot;Different modes&#039; indent variables to make alias to indent-offset.&quot;)

(dolist (mode-indent-offset mode-indent-offsets)
  (defvaralias mode-indent-offset &#039;indent-offset))

(defvar-local indent-offset tab-width)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;那么接下来就是我们如何针对不同的 buffer 进行不同的设定了，这里分为两部分，一部分是这个 buffer 是否使用 Tab 缩进，另一部分则是缩进宽度设置为多少。Atom 里面有一个状态栏插件，点击就可以快速设置，Emacs 里面我写了两个简单的函数方便调用，执行对应的函数设置是否使用 Tab，并且它们都会询问你想把缩进宽度设置为多少。我分别把这两个函数绑定到 &lt;code&gt;C-c i TAB&lt;/code&gt; 和 &lt;code&gt;C-c i SPC&lt;/code&gt;。对于 GTK，操作起来可以是 &lt;code&gt;M-x indent-tabs RET 2 RET&lt;/code&gt;。&lt;/p&gt;
&lt;figure data-raw=&quot;(defun indent-tabs (num)
  &amp;quot;Mark this buffer to indent with tabs and set indent offset to NUM chars.&amp;quot;
  (interactive `(,(read-number &amp;quot;Indent offset (chars): &amp;quot; indent-offset)))
  (indent-tabs-mode 1)
  (when (/= indent-offset num)
    (setq indent-offset num)))
(global-set-key (kbd &amp;quot;C-c i TAB&amp;quot;) &#039;indent-tabs)

(defun indent-spaces (num)
  &amp;quot;Mark this buffer to indent with spaces and set indent offset to NUM chars.&amp;quot;
  (interactive `(,(read-number &amp;quot;Indent offset (chars): &amp;quot; indent-offset)))
  (indent-tabs-mode -1)
  (when (/= indent-offset num)
    (setq indent-offset num)))
(global-set-key (kbd &amp;quot;C-c i SPC&amp;quot;) &#039;indent-spaces)
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(defun indent-tabs (num)
  &quot;Mark this buffer to indent with tabs and set indent offset to NUM chars.&quot;
  (interactive `(,(read-number &quot;Indent offset (chars): &quot; indent-offset)))
  (indent-tabs-mode 1)
  (when (/= indent-offset num)
    (setq indent-offset num)))
(global-set-key (kbd &quot;C-c i TAB&quot;) &#039;indent-tabs)

(defun indent-spaces (num)
  &quot;Mark this buffer to indent with spaces and set indent offset to NUM chars.&quot;
  (interactive `(,(read-number &quot;Indent offset (chars): &quot; indent-offset)))
  (indent-tabs-mode -1)
  (when (/= indent-offset num)
    (setq indent-offset num)))
(global-set-key (kbd &quot;C-c i SPC&quot;) &#039;indent-spaces)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当然以防万一你真的遇到一个脾气古怪的作者，一定要使用 Tab 缩进并修改 Tab 宽度，我也写了个修改 Tab 宽度的函数。这个我绑定到 &lt;code&gt;C-c i w&lt;/code&gt; 了。&lt;/p&gt;
&lt;figure data-raw=&quot;(defun set-tab-width (num)
  &amp;quot;Mark this buffer to set tab width to NUM chars.&amp;quot;
  (interactive `(,(read-number &amp;quot;Tab width (chars): &amp;quot; tab-width)))
  (when (/= tab-width num)
    (setq tab-width num)))
(global-set-key (kbd &amp;quot;C-c i w&amp;quot;) &#039;set-tab-width)
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(defun set-tab-width (num)
  &quot;Mark this buffer to set tab width to NUM chars.&quot;
  (interactive `(,(read-number &quot;Tab width (chars): &quot; tab-width)))
  (when (/= tab-width num)
    (setq tab-width num)))
(global-set-key (kbd &quot;C-c i w&quot;) &#039;set-tab-width)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;现在我们有了给每个 buffer 修改设定的办法了，但是通常你对某种语言有一个自己偏爱的风格，肯定希望以这个为默认值，所以我写了一些代码，给每个模式设置成我喜欢的默认风格。同样地如果你装了更多的模式，或者和我有不同的喜好，就修改这些列表好了。&lt;/p&gt;
&lt;p&gt;这里使用 &lt;code&gt;(set-tab-width 8)&lt;/code&gt; 是因为有些模式比如 markdown-mode 把 &lt;code&gt;tab-width&lt;/code&gt; 定义为 4，按照前面说的，我觉得这是错的，同时上游为了保持向前兼容不好修改，于是这里简单地覆盖掉。&lt;/p&gt;
&lt;figure data-raw=&quot;(defconst indent-tabs-modes &#039;((prog-mode . 8)
                              ;; `markdown-mode` is not a `prog-mode`.
                              (markdown-mode . 8)
                              (gfm-mode . 8))
  &amp;quot;Modes that will use tabs to indent.&amp;quot;)

(defconst indent-spaces-modes &#039;((lisp-mode . 2)
                                (emacs-lisp-mode . 2)
                                (js-mode . 2)
                                (css-mode . 2)
                                (html-mode . 2)
                                (yaml-mode . 2)
                                (lua-mode . 3)
                                (python-mode . 4))
  &amp;quot;Modes that will use spaces to indent.&amp;quot;)

(dolist (pair indent-tabs-modes)
  (add-hook (intern (concat (symbol-name (car pair)) &amp;quot;-hook&amp;quot;))
            `(lambda () (indent-tabs ,(cdr pair)) (set-tab-width 8))))

(dolist (pair indent-spaces-modes)
    (add-hook (intern (concat (symbol-name (car pair)) &amp;quot;-hook&amp;quot;))
              `(lambda () (indent-spaces ,(cdr pair)) (set-tab-width 8))))
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(defconst indent-tabs-modes &#039;((prog-mode . 8)
                              ;; `markdown-mode` is not a `prog-mode`.
                              (markdown-mode . 8)
                              (gfm-mode . 8))
  &quot;Modes that will use tabs to indent.&quot;)

(defconst indent-spaces-modes &#039;((lisp-mode . 2)
                                (emacs-lisp-mode . 2)
                                (js-mode . 2)
                                (css-mode . 2)
                                (html-mode . 2)
                                (yaml-mode . 2)
                                (lua-mode . 3)
                                (python-mode . 4))
  &quot;Modes that will use spaces to indent.&quot;)

(dolist (pair indent-tabs-modes)
  (add-hook (intern (concat (symbol-name (car pair)) &quot;-hook&quot;))
            `(lambda () (indent-tabs ,(cdr pair)) (set-tab-width 8))))

(dolist (pair indent-spaces-modes)
    (add-hook (intern (concat (symbol-name (car pair)) &quot;-hook&quot;))
              `(lambda () (indent-spaces ,(cdr pair)) (set-tab-width 8))))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;有些 modeline 包含一个显示缩进信息的部分，比如 &lt;code&gt;doom-modeline&lt;/code&gt; 显示 &lt;code&gt;TAB&lt;/code&gt; 或者 &lt;code&gt;SPC&lt;/code&gt; 表示使用 Tab 缩进或使用空格缩进，然后如果该模式有自己的缩进宽度变量就显示，没有就显示 Tab 宽度（我没仔细读，总之它对这俩不做显式区分）。而按照上文，我肯定是倾向显式区分这两个东西的，所以我们不用它的，而是自定义一段 modeline，第一部分显示 &lt;code&gt;TAB&lt;/code&gt; 或 &lt;code&gt;SPC&lt;/code&gt;，第二段显示 &lt;code&gt;indent-offset&lt;/code&gt;，第三段显示 &lt;code&gt;tab-width&lt;/code&gt;。我没太搞懂 Emacs 的 modeline constructor 的语法，我觉得我写对了但却没有，于是最后变成 &lt;code&gt;:eval&lt;/code&gt; 一个 &lt;code&gt;format&lt;/code&gt; 调用了。&lt;/p&gt;
&lt;figure data-raw=&quot;(setq mode-line-misc-info &#039;(:eval (format &amp;quot;%s %d %d&amp;quot;
                                          (if indent-tabs-mode &amp;quot;TAB&amp;quot; &amp;quot;SPC&amp;quot;)
                                          indent-offset
                                          tab-width)))
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(setq mode-line-misc-info &#039;(:eval (format &quot;%s %d %d&quot;
                                          (if indent-tabs-mode &quot;TAB&quot; &quot;SPC&quot;)
                                          indent-offset
                                          tab-width)))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;最后我在网上抄了两个配置，一个是让它按回车时候不要自动缩进。另一个是修改默认的删除缩进的行为，默认当你在对着一个 Tab 按下退格键的时候，Emacs 把这个 Tab 变成缩进宽度数量的空格，然后删掉一个空格，这太诡异了，我就让它删掉一个字符好了。&lt;/p&gt;
&lt;figure data-raw=&quot;(setq-default electric-indent-inhibit t)
(setq backward-delete-char-untabify-method nil)
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(setq-default electric-indent-inhibit t)
(setq backward-delete-char-untabify-method nil)
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这样当你遇到一个和自己习惯不一样的文件，基本只要看情况调用 &lt;code&gt;indent-tabs&lt;/code&gt; 或者 &lt;code&gt;indent-spaces&lt;/code&gt; 即可。我在 Atom 用的插件还有一个自动猜测文件是使用 Tab 还是几个空格作为缩进的功能，不过我看了一下代码，它并不能解决我之前说到的 GTK 的问题，也就是说它会猜成 &lt;code&gt;SPC 2 2&lt;/code&gt; 而不是 &lt;code&gt;TAB 2 8&lt;/code&gt;，我懒得自己想一个猜测算法，于是就还是靠自己判断了。&lt;/p&gt;
&lt;p&gt;一个我比较想实现的功能是记录每个目录我用了什么设定，因为基本上每个项目都用一样的风格，这样就不用每次编辑文件都手动设置。我知道可以在每个目录创建一个文件记录 Emacs 的一些目录范围变量，但是问题是不是所有项目都想让你添加一个编辑器相关的文件，甚至你都不好修改 &lt;code&gt;.gitignore&lt;/code&gt; 排除你的文件。我比较想把这个存储记录丢到 Emacs 的目录里，不过并不知道怎么实现，如果哪天我搞清楚了，就去写一个。&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="编程" label="编程" scheme="https://sh.alynx.one/tags/%E7%BC%96%E7%A8%8B/" />
    <category term="Emacs" label="Emacs" scheme="https://sh.alynx.one/tags/Emacs/" />
  </entry>
  <entry>
    <title>Emacs 和 Monaco 字体和 Box-drawing Character</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Emacs-Monaco-Box-drawing-Character/" />
    <id>https://sh.alynx.one/posts/Emacs-Monaco-Box-drawing-Character/</id>
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    <published>2022-02-20T12:53:00.000Z</published>
    <updated>2022-02-26T01:51:25.000Z</updated>
    <summary type="html">
      &lt;p&gt;2016 年的我开始用 Atom 这种“modern”的编辑器，2022 年的我却又开始用回岁数比我都大的 GNU Emacs。切换的理由其实很简单，我曾经以为一直能追上最新版 Electron 的 VSCode 会成为第一个纯 Wayland 的代码编辑器——只要 Chromium 那边支持纯 Wayland 就好了嘛，然而直到 Emacs 那边的 pgtk 分支合并进主线（以防有读者不太清楚来龙去脉我解释一下，Emacs 虽然有图形界面，但实际上只是用 X 实现了一个 Terminal 层，而传统的 GTK3 界面只是使用 GTK3 创建一个 X 窗口，然后其它操作都是通过 X 进行，这实际上非常不适合 GTK3，导致了很多 bug，同时也使 Emacs 没法利用 GTK 的 Wayland 后端。而 pgtk 分支则是在 X 部分之外另起炉灶，利用 GTK 实现了一个和 X 部分平行的 Terminal 层，全部的绘制操作都是以 GTK/Cairo 的现代程序方式进行，自然也就摆脱了对 X 的依赖。总之在 Emacs 这样又老又庞大的代码库上做如此大范围的工程我觉得可以称得上是一项壮举了。），Chromium 的 ozone backend 还是问题多多。虽然 Emacs/Vim 这种软件看起来确实有点老派作风，但没想到也有走在这些“现代”编辑器前面的地方。&lt;/p&gt;

    </summary>
    <content type="html">
      &lt;p&gt;2016 年的我开始用 Atom 这种“modern”的编辑器，2022 年的我却又开始用回岁数比我都大的 GNU Emacs。切换的理由其实很简单，我曾经以为一直能追上最新版 Electron 的 VSCode 会成为第一个纯 Wayland 的代码编辑器——只要 Chromium 那边支持纯 Wayland 就好了嘛，然而直到 Emacs 那边的 pgtk 分支合并进主线（以防有读者不太清楚来龙去脉我解释一下，Emacs 虽然有图形界面，但实际上只是用 X 实现了一个 Terminal 层，而传统的 GTK3 界面只是使用 GTK3 创建一个 X 窗口，然后其它操作都是通过 X 进行，这实际上非常不适合 GTK3，导致了很多 bug，同时也使 Emacs 没法利用 GTK 的 Wayland 后端。而 pgtk 分支则是在 X 部分之外另起炉灶，利用 GTK 实现了一个和 X 部分平行的 Terminal 层，全部的绘制操作都是以 GTK/Cairo 的现代程序方式进行，自然也就摆脱了对 X 的依赖。总之在 Emacs 这样又老又庞大的代码库上做如此大范围的工程我觉得可以称得上是一项壮举了。），Chromium 的 ozone backend 还是问题多多。虽然 Emacs/Vim 这种软件看起来确实有点老派作风，但没想到也有走在这些“现代”编辑器前面的地方。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;至于这和我换掉 Atom 有什么联系呢？主要是我发现在家里的台式机上，所有 XWayland 程序在 nvidia 驱动下面都会有闪回的情况，也就是说你打字的时候突然会闪回前几帧的画面，过一会再闪回来，你经常看不到自己输入的字符。Electron 程序尤其严重，也就导致我没有办法使用 Atom 写代码，于是不得不捡起以前东拼西凑的 Emacs 配置重新研究。（奇怪的是我自己的台式机也是 nvidia 驱动，没遇到过这种问题。）&lt;/p&gt;
&lt;p&gt;扯远了，这篇文章主要想记录的问题是什么呢？其实还要和 Emacs 绘制界面的方式有关系，对于 Atom/VSCode 这种基于浏览器的程序来说绘制点什么图形元素很简单，但是对于 Emacs/Vim 这种来自于终端里的程序，开发者们习惯的是处理字符而不是处理图形，于是你会发现比如 80 column ruler 或者 indent guide 这种东西，在 Emacs 里面其实是通过在对应的位置插入竖线字符实现的……我个人不太喜欢这样，一个原因是我以为竖线字符并不是占满整行而是上下有空白。我一直以为这是 Emacs 的问题——你干嘛用竖线字符画 UI 啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Emacs-Monaco-Box-drawing-Character/1.png&quot; alt=&quot;有问题的样子&quot;&gt;&lt;/p&gt;
&lt;p&gt;直到有一天我输错了 alias 在 GNOME Terminal 里面打开了 Emacs，我惊讶的发现竖线竟然接上了头！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Emacs-Monaco-Box-drawing-Character/2.png&quot; alt=&quot;终端里的样子&quot;&gt;&lt;/p&gt;
&lt;p&gt;我当时就震惊了，我的终端和 Emacs 用的是同样的 Monaco 字体，怎么会不一样呢？难道是 Monaco 字体有问题？于是我上网搜了一下，我以前一直以为是 Emacs 的哪个设置比如 line-spacing 我没搞好，怎么搜也搜不出来，这次换成搜字体一下子就找到原因了：一个 Alacritty 的 issue 里面和我有同样的问题，不过他是 tmux 的分割线接不上头，都是 Monaco 字体。&lt;/p&gt;
&lt;p&gt;为什么只有 Monaco 接不上头呢？原来在字符界面下画这些竖线的字符和平时用 &lt;code&gt;Shift+\&lt;/code&gt; 输入的字符并不是一个，这类字符叫做 &lt;a href=&quot;https://en.wikipedia.org/wiki/Box-drawing_character&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Box-drawing Character&lt;/a&gt;，主要的范围是 &lt;code&gt;U+2500&lt;/code&gt; 到 &lt;code&gt;U+257F&lt;/code&gt;，这些字符用于在终端里绘制方框或者其它形状，所以应该是没有 padding 的，才能接上头，而 Monaco 这里有问题，它给这些字符加上了 padding，导致接不上。我尝试着给 Emacs 的字体换成 Source Code Pro，竖线立刻就连上了。&lt;/p&gt;
&lt;p&gt;怎么解决？换字体？不可能的，我是 Monaco 的狂粉，看惯了 Monaco 再看别的字体都觉得傻了吧唧的。如果不是因为它好看我才不会忍受它这么多缺点（没有内置粗体，虽然是等宽字体内部的连字表却和非等宽字体一样，有版权不能二次分发）。解决方法其实比较简单，把 &lt;code&gt;U+2500&lt;/code&gt; 到 &lt;code&gt;U+257F&lt;/code&gt; 的字符换成正常字体里的就可以了。简单的解决办法是用 FontForge 的同个实例打开 Monaco 和另一款字体（我选择了 Menlo，Menlo 是苹果用来替代 Monaco 做内置默认等宽字体的，应该会比较接近），然后选择 Monaco 的这个范围清空，然后选择 Menlo 的复制粘贴过来。不过我没在 FontForge 里面找到连续区间选择的办法，上网搜了一下说可以用它的脚本 API 选，办法是打开 File 菜单里面的 Execute Script，执行 &lt;code&gt;fontforge.activeFont().selection.select((&quot;ranges&quot;, None), 0x2500, 0x257F)&lt;/code&gt;。如果你不知道怎么把 Menlo 里面的一段字形复制粘贴到 Monaco 里面，你也可以在 Menlo 里执行这段脚本，然后反选，全部清空，然后把这部分生成一个字体，再去 Monaco 里面选 Elements 菜单里面的 Merge Fonts。&lt;/p&gt;
&lt;p&gt;或者你也可以看看这个 &lt;a href=&quot;https://github.com/Alhadis/Menloco&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;叫 Menloco 的项目&lt;/a&gt;，是我偶然间搜索到的有同样问题的用户的解决方案，这个项目包含更多的细微 tweak 脚本，帮你利用 Monaco 和 Menlo 合并出一个 Box-drawing Character 能完美接头的字体。不过有几个地方需要注意，一个是这个项目的作者应该是 macOS 的用户，如果你不是 macOS，需要自己想办法搞到 Menlo.ttf 和 Monaco.ttf，简单的办法是找个用 Mac 的朋友让他发给你，不过有可能你得到的是 Menlo.ttc，需要用 FontForge 打开选择 Regular 字重，然后导出成单个的 ttf。你还需要修改 &lt;code&gt;utils/find-font.sh&lt;/code&gt;，这个脚本的 &lt;code&gt;font_paths&lt;/code&gt; 只包含 macOS 放置字体的目录，你得加上你自己放这两个字体的目录。以及这个项目默认生成的字体名（不是文件名）叫 Menloco，如果你不想修改已有的写着 Monaco 的配置文件的话，就把 merge 这一项下面的 &lt;code&gt;--font-name=$(RESULT)&lt;/code&gt; 改成 &lt;code&gt;--font-name=$(INTO)&lt;/code&gt; 就好了。&lt;/p&gt;
&lt;p&gt;生成一个没问题的字体之后你还可以像我一样用 FontForge 做一些修改，比如说我发现 Menlo 有很多 Monaco 没有的字符，于是我直接把 Menlo merge 进了生成的字体里。并且我之前提到过 Monaco 作为一个等宽字体，内置的连字表竟然是非等宽的，不是像 Fira Code 那种把不同的编程符号连字起来同时保持等宽的连字，而是像普通无衬线一样把 &lt;code&gt;fi&lt;/code&gt; 一类的字符连起来变成单个字符宽度。我被坑得最狠的一次就是 review 同事的 patch，我问他这里是不是少了个空格，他说在他那看没问题，最后我发现是 Monaco 连字了！虽然你可以通过配置 fontconfig 关闭连字，但是 Firefox 是不吃这个配置的，而你也不可能给每个网页的代码块都加上关闭连字的 CSS。所以我直接在 FontForge 里面干掉了连字表，具体方法就是打开 Element 菜单下面的 Font Info，点击左侧的 Lookup，选中带 liga 的项 delete 之后导出字体即可。&lt;/p&gt;
&lt;p&gt;还有一个比较古怪的 Emacs 问题，Emacs 设置字体和其它程序不太一样，可以先设置一个默认字体然后针对不同的字符集设置不同的字体，一般要为中文单独设置字体才能得到合适的效果，就像下面这样：&lt;/p&gt;
&lt;figure data-raw=&quot;(set-face-attribute &#039;default nil
                    :family &amp;quot;Monaco&amp;quot;
                    ;; :slant &#039;normal
                    :width &#039;normal
                    :weight &#039;normal
                    ;; 1 height is 1/10 pt.
                    :height 140)

(dolist (charset &#039;(kana han symbol cjk-misc bopomofo))
  (set-fontset-font t charset (font-spec :family &amp;quot;Noto Sans Mono CJK SC&amp;quot;
                                         ;; :slant &#039;normal
                                         :width &#039;normal
                                         :weight &#039;normal)))
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(set-face-attribute &#039;default nil
                    :family &quot;Monaco&quot;
                    ;; :slant &#039;normal
                    :width &#039;normal
                    :weight &#039;normal
                    ;; 1 height is 1/10 pt.
                    :height 140)

(dolist (charset &#039;(kana han symbol cjk-misc bopomofo))
  (set-fontset-font t charset (font-spec :family &quot;Noto Sans Mono CJK SC&quot;
                                         ;; :slant &#039;normal
                                         :width &#039;normal
                                         :weight &#039;normal)))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;首先要注意 height 的单位是 1/10，所以你想要的字号需要乘 10 才行。&lt;/p&gt;
&lt;p&gt;然后你会发现明明你只设置了一个字号，可是中文和英文字体却不是等高的！也就是说如果你在本来都是英文的一行里面输入一个中文字，那这行的高度就会突然跳一下变高，非常烦人，也许是这两个字体在同样的字号的时候尺寸并不完全一致，但是明明其它程序都能正常处理，为什么这里这么怪！&lt;/p&gt;
&lt;p&gt;你可能会想要对中文那段单独设置 size 缩小一点，但是这样不行，你用 &lt;code&gt;C-x C-=&lt;/code&gt; 放大字体的时候中文字体就会固定大小不跟着你变了。正确的解决方法是加入下面一句：&lt;/p&gt;
&lt;figure data-raw=&quot;(setq face-font-rescale-alist &#039;((&amp;quot;Noto Sans Mono CJK SC&amp;quot; . 0.85)))
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(setq face-font-rescale-alist &#039;((&quot;Noto Sans Mono CJK SC&quot; . 0.85)))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这里你可以对任意的字体指定缩放参数，不会影响按键放大缩小。我尝试了一下 &lt;code&gt;0.85&lt;/code&gt; 比较合适，虽然可能这样汉字看起来会稍微小一点，但是 &lt;code&gt;0.9&lt;/code&gt; 就太高了仍然会跳。或许你会问那这样中文字宽不是英文字宽两倍了？那没有办法，Monaco 本身就属于一个比较宽的字体，那些满足英文宽度是高度一半的字体都比较瘦长，我个人是不喜欢这样的风格的，所以对于我来说等高就行了，宽度我不太在乎。&lt;/p&gt;
&lt;p&gt;更新（2022-02-25T19:01:31）：我最近研究了一下，发现原来字号并不等于行高。虽然字体有一个 em size 作为基础的方块大小，但是设计师经常指定一些奇怪的 ascender 和 descender 值让字体的高度超出 em size……我不太清楚 Atom 或者说 Chromium 是怎么进行中英文混排的，不过 Emacs 排版时候是对齐 baseline，然后 ascender 和 descender 完全一致才能保证行高不会在切换字体时候变化。但是这实在是太难了，大部分中文字体和英文字体都对不上，特别是 Noto Sans CJK 系列，不知道为什么比其它的高特别多。一个简单的解决办法是使用等距更纱黑体，里面混合的英文等宽字体 Iosevka 和中文的思源黑体拥有一致的 ascender 和 descender，但我实在是不喜欢 Iosevka。并且不知道为什么，Noto Sans CJK 和等距更纱黑体里面的内置的思源黑体应该是同一种字体，Noto Sans CJK 就要比他高很多。我还尝试了修改 Monaco 的 ascender 和 descender，不过这部分非常复杂，涉及到好几个不同的值，而且不同字体比例尺也不一样。最关键的是修改之后相当于把字体拉高了，于是 box-drawing character 又接不上了……上面那个修改缩放参数其实也不是无级缩放，实际上是乘字号之后取整然后再去找对应大小的字符，所以其实就是找小几号的 Noto Sans CJK。具体的可以在 Emacs 里面 &lt;code&gt;M-x describe-font&lt;/code&gt; 查看详情。&lt;/p&gt;
&lt;p&gt;更新（2022-02-26T09:51:25）：补充一下，浏览器的混排应该和 Emacs 是一样的，我刚才尝试了一下，我的博客行高固定是因为我给 &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 设置了 &lt;code&gt;line-height: 1.5&lt;/code&gt;，这个大小超过了 Noto Sans CJK 的行高，如果删掉这一行，你就会发现含有 Noto Sans CJK 的行比只有 Monaco 的行要高很多。不过 Emacs 没办法像浏览器一样指定一个最小行高，只能是它自己根据这一行的字符计算行高，所以没什么比较好的解决办法。&lt;/p&gt;
&lt;p&gt;搞定这些之后，至少 Emacs 里面看起来比较顺眼了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Emacs-Monaco-Box-drawing-Character/3.png&quot; alt=&quot;正常的样子&quot;&gt;&lt;/p&gt;

    </content>
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="字体" label="字体" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%AD%97%E4%BD%93/" />
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    <category term="字体" label="字体" scheme="https://sh.alynx.one/tags/%E5%AD%97%E4%BD%93/" />
    <category term="Emacs" label="Emacs" scheme="https://sh.alynx.one/tags/Emacs/" />
  </entry>
</feed>
