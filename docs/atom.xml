<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喵's StackHarbor</title>
  <subtitle>Whisper to the World</subtitle>
  <icon>https://sh.alynx.one/images/FutureGazerSmall.webp</icon>
  <link rel="self" type="application/atom+xml" href="https://sh.alynx.one/atom.xml" />
  
  <link rel="alternate" type="text/html" href="https://sh.alynx.one/" />
  
  <updated>2020-10-06T09:48:00.000Z</updated>
  
  <id>https://sh.alynx.one/</id>
  
  <author>
    <name>Alynx Zhou</name>
    <email>alynx.zhou@gmail.com</email>
  </author>
  
  <generator uri="https://github.com/AlynxZhou/hikaru-generator-feed/" version="v2.2.9">Hikaru Generator Feed</generator>
  
  
  
  
  
  <entry>
    <title>奇怪的书名和我和吐槽</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Strange-Book-Names/" />
    <id>https://sh.alynx.one/posts/Strange-Book-Names/</id>
    
    <published>2020-10-06T09:48:00.000Z</published>
    
    
    <updated>2020-10-06T09:48:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;好久没更新非技术类博文了。可能很多人不但丢掉了阅读的习惯，连书店都不去了，书店都沦为练习册店，学生们更加对书店敬而远之，这种恶性循环实在是可悲又无趣的事情。&lt;/p&gt;
&lt;p&gt;今天和同学一起去了书店，在常规意义的书店而非练习册店的部分发现了一些有趣或奇怪的书名，很有槽点，让人想要吐槽。于是拍了点照片发到这里。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;好久没更新非技术类博文了。可能很多人不但丢掉了阅读的习惯，连书店都不去了，书店都沦为练习册店，学生们更加对书店敬而远之，这种恶性循环实在是可悲又无趣的事情。&lt;/p&gt;
&lt;p&gt;今天和同学一起去了书店，在常规意义的书店而非练习册店的部分发现了一些有趣或奇怪的书名，很有槽点，让人想要吐槽。于是拍了点照片发到这里。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;套娃型&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E5%A5%97%E5%A8%83%E5%9E%8B&quot; title=&quot;套娃型&quot;&gt;&lt;/a&gt;套娃型&lt;/h1&gt;
&lt;p&gt;此类书名非常适合套娃，比如这本《如何阅读一本书》，且不说阅读方法因人而异且随经验变化，单就这个名字还可以有《如何阅读如何阅读一本书》、《如何阅读如何阅读如何阅读一本书》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/1.jpg&quot; alt=&quot;如何阅读一本书&quot;&gt;&lt;/p&gt;
&lt;p&gt;我以为只有当代为搏销量疯狂吸引眼球的作者会起这种名字，然而接下来我看到了一本《木心谈木心》。虽然我不太清楚木心是谁，但似乎是个有名的作者。这书名总是让我想后续会不会有《木心谈木心谈木心》、《木心谈木心谈木心谈木心》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/2.jpg&quot; alt=&quot;木心谈木心&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;性转型&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E6%80%A7%E8%BD%AC%E5%9E%8B&quot; title=&quot;性转型&quot;&gt;&lt;/a&gt;性转型&lt;/h1&gt;
&lt;p&gt;这本书的名字非常奇特，她叫做《少女福尔摩斯》，作为半资深福尔摩斯迷和半资深月球氪金母X，我只能说型月都没敢做的这作者做了。由于原作实在是珠玉在前，写老福的故事已经很难了，性转老福怕是难上加难，建议寄一本给蘑菇看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/3.jpg&quot; alt=&quot;少女福尔摩斯&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;蹭热度型&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E8%B9%AD%E7%83%AD%E5%BA%A6%E5%9E%8B&quot; title=&quot;蹭热度型&quot;&gt;&lt;/a&gt;蹭热度型&lt;/h1&gt;
&lt;p&gt;这位叫蒋勋的作者在书架上占据了一片，又是说唐诗又是说宋词，一会谈莫奈一会谈高达哦不是梵高和达芬奇，想必上知天文下知地理。&lt;strong&gt;不过这书脊把这些名人加粗放在下面，让我总是有一种这是个达芬奇/梵高/莫奈的著作、作品标题叫做蒋勋的感觉。&lt;/strong&gt; 不知道这个叫蒋勋的作品是不是样样通样样松呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/4.jpg&quot; alt=&quot;蒋勋&quot;&gt;&lt;/p&gt;
&lt;p&gt;还有这本《逝水年华》，连我的输入法都怀疑我是不是想输入《追忆似水年华》，敢问作者是不是有点大舌头，让出版社的编辑听错了标题？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/5.jpg&quot; alt=&quot;逝水年华&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;连锁反应型&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E8%BF%9E%E9%94%81%E5%8F%8D%E5%BA%94%E5%9E%8B&quot; title=&quot;连锁反应型&quot;&gt;&lt;/a&gt;连锁反应型&lt;/h1&gt;
&lt;p&gt;《知更鸟》吗？大家都说有本书想杀你，不知道与你是什么关系？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/6.jpg&quot; alt=&quot;知更鸟&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然《重返美丽新世界》和《美丽新世界》是一个作者，但总让我想起狗尾续貂，不知道是不是我错了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/7.jpg&quot; alt=&quot;美丽新世界&quot;&gt;&lt;/p&gt;
&lt;p&gt;好家伙，你把《24个比利》放在这，那他们肯定会打架的，不过叫《比利打群架》比《比利战争》更好吧，无谓夸大不可取，要实事求是。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/8.jpg&quot; alt=&quot;比利&quot;&gt;&lt;/p&gt;
&lt;p&gt;《面包树上的女人》怎么啦？她没怎么，《面包树出走了》，那可真是个离奇的故事，但是你这内容就不知道是不是好故事了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/9.jpg&quot; alt=&quot;面包树&quot;&gt;&lt;/p&gt;
&lt;p&gt;我以为文学大家不屑于做这种在标题上吸引人的无聊事情，毕竟内容才是王道。我也不是有意冒犯杨绛先生，但是《洗澡》做书名已经是太随意了，再整一本《洗澡之后》是不是过分了？还是说这是出书的不负责任的编辑洗澡前洗澡后决定的两本文集的名字？那这就说得通了。但是说实话《洗澡》、《洗澡之后》接下来摆一本《暗示》是不是店员的恶趣味？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/10.jpg&quot; alt=&quot;洗澡&quot;&gt;&lt;/p&gt;
&lt;p&gt;希望看了我文章的朋友不要给我评论“一看到白胳膊……”，我老实承认我不是一个完全脱离了低级趣味的人，写这文章也是让大家开心一下，毕竟实事求是更重要。我也希望写书的作者们都实事求是一点，内容不行，靠标题党吸引人肯定是经不起考验的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="随记" label="随记" scheme="https://sh.alynx.one/categories/%E9%9A%8F%E8%AE%B0/" />
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/tags/%E7%94%9F%E6%B4%BB/" />
    
  </entry>
  
  
  
  <entry>
    <title>固定 GNOME Shell 的输入法列表</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fixed-IME-List-for-GNOME-Shell/" />
    <id>https://sh.alynx.one/posts/Fixed-IME-List-for-GNOME-Shell/</id>
    
    <published>2020-09-26T02:40:00.000Z</published>
    
    
    <updated>2020-09-26T02:40:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;GNOME Shell 有个令人很不爽的“特性”，它的输入法列表使用的是最近使用优先排列。也就是说当你有三个或以上输入法的时候，比如我，我有英文简体中文和日语输入法，我经常在中英之间切换，这没什么，前两个总是中英所以按一次就可以在这两个之间切换，但假如我偶尔用了一次日语输入法，我的列表就被打乱了，我不清楚按几下才能切回中文，并且再切到英文也得看一眼才能知道。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;GNOME Shell 有个令人很不爽的“特性”，它的输入法列表使用的是最近使用优先排列。也就是说当你有三个或以上输入法的时候，比如我，我有英文简体中文和日语输入法，我经常在中英之间切换，这没什么，前两个总是中英所以按一次就可以在这两个之间切换，但假如我偶尔用了一次日语输入法，我的列表就被打乱了，我不清楚按几下才能切回中文，并且再切到英文也得看一眼才能知道。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我不是很理解这个特性存在的意义，设置里面是可以手动调节输入法的顺序的，我明明调成了我想要的顺序，你就给我这个顺序好了，这样我闭着眼睛不用动脑子都能猜出来要按几下，比如从英文到日语按两下，中文到日语按一下等等。可能有些人的脑子长得比较擅长模拟最近使用优先排列？反正我不行。&lt;/p&gt;
&lt;p&gt;既然感觉不爽那就动手处理一下好了，最近看了一些有关写 GNOME Shell 扩展的文档，所以写个扩展解决一下就可以了。为什么不直接提交给上游？因为上游一开始是固定顺序的，但是很久以前某个人加了这个“特性”，现在如果提个请求说删掉这个特性，势必会陷入一场“用户到底是喜欢最近使用优先排列还是固定排列”的争论，这肯定很难得出结论（毕竟大部分的人实际上是不需要使用输入法的英语用户以及只有两种输入法的用户！），并且按照 GNOME 上游的习惯他们也是不愿意为了这个多添加一个开关的。所以比起在拉锯战上浪费时间，先搞一个能用的才是我的风格。至于升级之后扩展挂掉……不就是在上游里和其他代码一起被重构和我自己单独重构的区别吗？只要我还在用应该就会持续更新了。&lt;/p&gt;
&lt;p&gt;具体的解决方法比较 dirty，是我从别的扩展里学来的：把 GNOME Shell 里面的类的原型上的方法替换成自己的，就可以修改实例调用时的函数了（也算 JS 特性之一），不过不要用箭头函数，因为显然我们希望 &lt;code&gt;this&lt;/code&gt; 是调用时的上下文也就是实例，而不是绑定到当前上下文。&lt;/p&gt;
&lt;p&gt;因为这算是我第一个扩展所以也多少记录一下踩的坑。&lt;/p&gt;
&lt;p&gt;首先 Gjs 的导入和 Node.js 的导入是不一样的，它通过一个 &lt;code&gt;imports&lt;/code&gt; 对象引入其他库，比如通过 GI 导入的就在 &lt;code&gt;gi&lt;/code&gt; 下面，因为是 GNOME Shell 扩展所以可以访问 GNOME Shell 的 JS 库，就是简单地把 JS 路径换成对象的 key 然后 JS 文件里所有的 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;function&lt;/code&gt; 都会被导出。比如导入 &lt;code&gt;Main&lt;/code&gt; 就是 &lt;code&gt;imports.ui.main.Main&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后就是怎么知道要修改什么以及如何获取到相关对象，不过因为 GNOME Shell JS 部分经常重构，也没什么完整的文档，反正只能多花时间看代码吧，而且它的结构其实比看起来的要复杂，所以经常需要仔细翻来翻去的。比如 GNOME Shell 的输入法部分很多人认为是需要修改 iBus，实际上 GNOME Shell 只是调用 iBus 作为后端，自己处理状态和界面，这部分的代码都在 &lt;code&gt;js/ui/status/keyboard.js&lt;/code&gt; 里面。&lt;/p&gt;
&lt;p&gt;扩展主要有 &lt;code&gt;init()&lt;/code&gt;，&lt;code&gt;enable()&lt;/code&gt; 和 &lt;code&gt;disable()&lt;/code&gt; 三个函数，&lt;code&gt;init()&lt;/code&gt; 在 GNOME Shell 加载扩展时候调用，我这个显然不需要。&lt;code&gt;enable()&lt;/code&gt; 是你在 Extensions app 里面打开开关时候调用的，&lt;code&gt;disable()&lt;/code&gt; 是关掉开关时候调用的。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;enable()&lt;/code&gt; 里面有几个需要我修改的地方，一个是阻止 &lt;code&gt;InputSourceManager&lt;/code&gt; 在输入法切换之后的最近使用优先排列，解决方法很简单，需要自己替换掉 &lt;code&gt;_currentInputSourceChanged&lt;/code&gt; 函数，注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L447-453&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L447-453&lt;/a&gt; 这一段更新代码。&lt;/p&gt;
&lt;p&gt;当然光有这个还是不行的，这样假如你是先切换过再打开扩展，实际上列表是你开启扩展之前的状态而不是用户设置的顺序，所以我们还需要在打开扩展之后更新它的列表，让它直接读取用户设置。更新列表的函数是 &lt;code&gt;_updateMruSources&lt;/code&gt;，假如检测到当前列表为空，会先从一个缓存的 gsettings 里读取之前存储的最近使用优先排列列表，这显然是很恶心的所以要注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L504-522&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L504-522&lt;/a&gt; 这一段。之后它会先加载当前列表里的，然后再把用户列表里增加的当前列表里没有的加到后面，因为我们已经决定要清空当前列表并且不加载 gsettings 里面的缓存，所以这个当前列表肯定是空，那直接加用户列表就行了，所以注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L525-533&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L525-533&lt;/a&gt;。这样我们后续只要清空 &lt;code&gt;_mruSources&lt;/code&gt; 设置 &lt;code&gt;_mruSourcesBackup&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 然后调用 &lt;code&gt;_updateMruSources&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;然后我们需要获取运行时的这个 &lt;code&gt;InputSourceManager&lt;/code&gt; 实例，这个实例没有被绑定到 &lt;code&gt;Main&lt;/code&gt; 对象上，不过我阅读代码发现它是个单例模式，就是说在 &lt;code&gt;js/ui/status/keyboard.js&lt;/code&gt; 有一个 &lt;code&gt;_inputSourceManager&lt;/code&gt; 变量，然后有个 &lt;code&gt;getInputSourceManager()&lt;/code&gt; 的函数，被调用时候如果有就返回 &lt;code&gt;_inputSourceManager&lt;/code&gt; 否则创建一个赋值返回，其他代码都用的这个，所以我们也导入这个就行了。&lt;/p&gt;
&lt;p&gt;然后你会发现另一个弱智的地方，怎么每次按下切换键，切换框都是从第一个切换到第二个？不是应该从我当前的切换到下一个吗？这个对于当前输入法总在第一个的最近使用优先排列是可以的，但在我们这个场景选中的并不总是第一个，所以需要修改。这部分函数是 &lt;code&gt;_switchInputSource&lt;/code&gt;，可以看到它只是展示了一个 &lt;code&gt;InputSourcePopup&lt;/code&gt;，而 &lt;code&gt;InputSourcePopup&lt;/code&gt; 继承的是 &lt;code&gt;imports.ui.switcherPopup.SwitcherPopup&lt;/code&gt;，这个类有一个叫做 &lt;code&gt;_selectedIndex&lt;/code&gt; 的变量用于选择下一个上一个时候的计算，而且它默认是 0！不能通过参数初始化！真是头秃，不过我们可以在创建完切换框但展示之前单独设置这个值就行了，所以我在 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L412&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L412&lt;/a&gt; 的下一行插入如下代码：&lt;/p&gt;
&lt;figure data-raw=&quot;if (this._currentSource != null) {
  popup._selectedIndex = this._mruSources.indexOf(this._currentSource);
}&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;if (this._currentSource != null) {
  popup._selectedIndex = this._mruSources.indexOf(this._currentSource);
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为我们不一定总有 &lt;code&gt;_currentSource&lt;/code&gt; 所以还是要检查一下，如果没有的话让它从 0 开始也无所谓。&lt;/p&gt;
&lt;p&gt;然后还有一个比较头痛的是快捷键是绑定的回调函数，回调函数又绑定了 &lt;code&gt;this&lt;/code&gt;，所以我们光修改原型是改不了被回调的函数的，这个也简单，我们需要读一下 &lt;code&gt;InputSourceManager&lt;/code&gt; 的 &lt;code&gt;constructor&lt;/code&gt; 的代码，然后删掉它在 &lt;code&gt;Main.wm&lt;/code&gt; 里面绑定的组合键重新绑定成我们的，就是这样：&lt;/p&gt;
&lt;figure data-raw=&quot;Main.wm.removeKeybinding(&amp;quot;switch-input-source&amp;quot;);
_inputSourceManager._keybindingAction =
  Main.wm.addKeybinding(
    &amp;quot;switch-input-source&amp;quot;,
    new Gio.Settings({&amp;quot;schema_id&amp;quot;: &amp;quot;org.gnome.desktop.wm.keybindings&amp;quot;}),
    Meta.KeyBindingFlags.NONE,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );
Main.wm.removeKeybinding(&amp;quot;switch-input-source-backward&amp;quot;);
_inputSourceManager._keybindingActionBackward =
  Main.wm.addKeybinding(
    &amp;quot;switch-input-source-backward&amp;quot;,
    new Gio.Settings({&amp;quot;schema_id&amp;quot;: &amp;quot;org.gnome.desktop.wm.keybindings&amp;quot;}),
    Meta.KeyBindingFlags.IS_REVERSED,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;Main.wm.removeKeybinding(&quot;switch-input-source&quot;);
_inputSourceManager._keybindingAction =
  Main.wm.addKeybinding(
    &quot;switch-input-source&quot;,
    new Gio.Settings({&quot;schema_id&quot;: &quot;org.gnome.desktop.wm.keybindings&quot;}),
    Meta.KeyBindingFlags.NONE,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );
Main.wm.removeKeybinding(&quot;switch-input-source-backward&quot;);
_inputSourceManager._keybindingActionBackward =
  Main.wm.addKeybinding(
    &quot;switch-input-source-backward&quot;,
    new Gio.Settings({&quot;schema_id&quot;: &quot;org.gnome.desktop.wm.keybindings&quot;}),
    Meta.KeyBindingFlags.IS_REVERSED,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;同样我们也不要忘记绑定 &lt;code&gt;this&lt;/code&gt;，实际上我们希望调用的时候绑定的 &lt;code&gt;this&lt;/code&gt; 是那个单例，那直接 &lt;code&gt;bind&lt;/code&gt; 它就好了。&lt;/p&gt;
&lt;p&gt;但是你会发现这个弱智的家伙没有按我们想象的工作！这是什么意思！仔细阅读代码之后我发现有如下逻辑：你按下的第一次组合键其实并不是算在那个弹框的按键回调里面，而是我们通过构造函数传递进去的，然后它分析这个传进去的按键是哪一种，调用 &lt;code&gt;_initialSelection&lt;/code&gt; 执行第一次切换，而这个家伙更弱智了！明明有 &lt;code&gt;_selectedIndex&lt;/code&gt; 它不用，竟然用硬编码的倒数第一个和第一个！真有你的啊！我不太敢修改 &lt;code&gt;SwitcherPopup&lt;/code&gt; 因为还有别的东西使用它，那就修改 &lt;code&gt;InputSourcePopup&lt;/code&gt; 这个子类吧，其实就是把 &lt;code&gt;InputSourcePopup.prototype._initialSelection&lt;/code&gt; 这个函数原来的的 &lt;code&gt;this._select(this._items.length - 1);&lt;/code&gt; 换成 &lt;code&gt;this._select(this._previous());&lt;/code&gt;，&lt;code&gt;this._select(1)&lt;/code&gt; 换成 &lt;code&gt;this._select(this._next())&lt;/code&gt;（1 其实是 0 + 1 的意思），不但功能增加了，可读性也提升了！&lt;/p&gt;
&lt;p&gt;现在搭配起来应该和我们的需求一致了！但假如我关掉扩展之后希望列表是打开之前的状态怎么办！还记得之前说的那个 &lt;code&gt;_updateMruSources&lt;/code&gt; 会读取 gsettings 吗？这个 gsettings 实际上在每次切换输入法的时候都会写入当前状态，那我们只要让它开启扩展时候不要写入，关掉扩展恢复的时候再更新不就读取了之前的状态吗。所以需要修改 &lt;code&gt;InputSourceManager.prototype._updateMruSettings&lt;/code&gt;，注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L432-438&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L432-438&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;总结一下其实就是在 &lt;code&gt;enable&lt;/code&gt; 的时候修改这些函数，然后获取单例，重新绑定快捷键，然后清空当前的列表重新更新列表，然后为了避免 bug，我们总是激活列表里的第一个输入法：&lt;/p&gt;
&lt;figure data-raw=&quot;if (_inputSourceManager._mruSources.length &gt; 0) {
  _inputSourceManager._mruSources[0].activate(true);
}&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;if (_inputSourceManager._mruSources.length &amp;gt; 0) {
  _inputSourceManager._mruSources[0].activate(true);
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;disable&lt;/code&gt; 的时候同样是把函数修改回去，然后获取单例，重新绑定快捷键这样它又绑成了原来的函数，然后清空当前的列表重新更新列表这样它就恢复到开启之前的顺序了，接下来同样地，因为最近使用优先列表的第一个元素肯定是正在用的，所以我们也还是激活第一个输入法就可以了。&lt;/p&gt;
&lt;p&gt;完整的项目参见 &lt;a href=&quot;https://github.com/AlynxZhou/gnome-shell-extension-fixed-ime-list/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;GitHub&lt;/a&gt;，Arch Linux 用户也可以从 AUR 或者 Arch Linux CN 源安装 &lt;code&gt;gnome-shell-extension-fixed-ime-list&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    
    
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    
  </entry>
  
  
  
  <entry>
    <title>GObject 备忘录</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/GObject-Reminder/" />
    <id>https://sh.alynx.one/posts/GObject-Reminder/</id>
    
    <published>2020-09-05T01:23:00.000Z</published>
    
    
    <updated>2020-09-05T01:23:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;说来惭愧，我一直记不太清 GObject 到底是怎么用的，毕竟作为一个写过 C++ 和 Python 然后常用 JS 的人来说，面向对象的实现是非常自然的，不需要考虑为什么。所以我总是看着一大堆类型转换和分散的定义以及各种 chain up 感到眩晕。而 GObject 的文档写的也相当分散，有种管中窥豹之感。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;说来惭愧，我一直记不太清 GObject 到底是怎么用的，毕竟作为一个写过 C++ 和 Python 然后常用 JS 的人来说，面向对象的实现是非常自然的，不需要考虑为什么。所以我总是看着一大堆类型转换和分散的定义以及各种 chain up 感到眩晕。而 GObject 的文档写的也相当分散，有种管中窥豹之感。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;有同学觉得其实把函数变成指针放在结构体里看起来就面向对象了，以前我也这么觉得，但是显然这样不能实现继承封装等等特性，GObject 独特之处在于它实现了这些，并且是和语言独立的。当然，要想在一个没有这些概念的语言里面做到这些，就有很多需要自己手动处理和函数库处理的地方，就是因为有些隐藏了起来有些又要自己做，才让它看起来像古老的黑魔法。&lt;/p&gt;
&lt;p&gt;最近我尝试做了一个小项目，以便搞清楚如何按照 GObject 的模式编写一些继承封装的代码。&lt;/p&gt;
&lt;p&gt;首先得给项目起名字，因为 GObject 要求你的命名符合一定的约定，其中一个前缀是项目名，不过这个 简单，就叫 &lt;code&gt;test&lt;/code&gt; 好了，然后做一个基类叫 &lt;code&gt;animal&lt;/code&gt;，于是就有了 &lt;code&gt;test-animal.h&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#ifndef __TEST_ANIMAL_H__
#define __TEST_ANIMAL_H__

#include &lt;glib-object.h&gt;

G_BEGIN_DECLS

// 这个玩意必须要手动定义。
#define TEST_TYPE_ANIMAL test_animal_get_type()
// 这个玩意会展开成一大堆函数声明、typedef 什么的，
// 所以我们只要按约定定义结构体实现函数。
G_DECLARE_DERIVABLE_TYPE(TestAnimal, test_animal, TEST, ANIMAL, GObject)

// 但是上面那个玩意其实不会给你搞一个类结构体出来，
// 而且这个因为是给其他文件用的所以必须写在头文件里，
// 不然人家怎么知道你有什么虚函数！
struct _TestAnimalClass {
    GObjectClass parent_class;
    // 定义一个可以继承的函数。
    void (*print)(TestAnimal *animal);
    gpointer padding[12];
};

// 因为上面的 class 里面定义了，这个只是调用那个。
void test_animal_print(TestAnimal *animal);
// 这个玩意得手动定义，是个不可继承的公开函数。
TestAnimal *test_animal_new(gchar *animal_name);

G_END_DECLS

#endif&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#ifndef __TEST_ANIMAL_H__
#define __TEST_ANIMAL_H__

#include &amp;lt;glib-object.h&amp;gt;

G_BEGIN_DECLS

// 这个玩意必须要手动定义。
#define TEST_TYPE_ANIMAL test_animal_get_type()
// 这个玩意会展开成一大堆函数声明、typedef 什么的，
// 所以我们只要按约定定义结构体实现函数。
G_DECLARE_DERIVABLE_TYPE(TestAnimal, test_animal, TEST, ANIMAL, GObject)

// 但是上面那个玩意其实不会给你搞一个类结构体出来，
// 而且这个因为是给其他文件用的所以必须写在头文件里，
// 不然人家怎么知道你有什么虚函数！
struct _TestAnimalClass {
    GObjectClass parent_class;
    // 定义一个可以继承的函数。
    void (*print)(TestAnimal *animal);
    gpointer padding[12];
};

// 因为上面的 class 里面定义了，这个只是调用那个。
void test_animal_print(TestAnimal *animal);
// 这个玩意得手动定义，是个不可继承的公开函数。
TestAnimal *test_animal_new(gchar *animal_name);

G_END_DECLS

#endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为代码里写了很多注释所以我这里就不再啰嗦一遍了，说点里面没写的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 表示你声明了一个可以继承的类，也就是说你需要自己弄一个虚函数表出来。有时候你会在某个 GObject 的项目里定义了一大堆宏（比如 GTK 就不爱用这个而是手动定义），其实它们和 &lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 做了一样的工作，因为总要做，就写了个宏实现。这个并不会给你定义具体的类结构体（其实就是虚函数表，用来存放所有可以继承重载的函数），所以我们要按照约定自己写一个 &lt;code&gt;_TestAnimalClass&lt;/code&gt; 的结构体，在类型名字前面加下划线作为结构体名也是约定俗成的，&lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 会展开出一句 &lt;code&gt;typedef struct _TestAnimalClass TestAnimalClass&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个类结构体约定第一个元素是它的父类型的类结构体——这其实意味着我们复制了一份父类型的虚函数表出来，于是我们就可以覆盖父类型的方法而不修改原本的父类型。这一句可能比较难懂，不过后面还有关联。&lt;/p&gt;
&lt;p&gt;这个类结构体存放的并不是实例的变量，它有点类似于 JS 里面的原型，这样我们就不需要给每一个生成的实例复制一份虚函数了，它们共用一个虚函数表。&lt;/p&gt;
&lt;p&gt;然后会有一个 &lt;code&gt;test-animal.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-animal.h&amp;quot;

// Derivable 类型会自动帮你定义实例结构体，
// 所以你想夹带点私货就得自己搞个 Private 类型。
typedef struct {
    gchar *animal_name;
} TestAnimalPrivate;

// 这个也会展开一大堆声明什么的。
G_DEFINE_TYPE_WITH_PRIVATE(TestAnimal, test_animal, G_TYPE_OBJECT)

// 要想通过 new 函数直接初始化一些值就需要搞点属性。
enum {
    PROP_0,
    PROP_ANIMAL_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        if (priv-&gt;animal_name)
            g_free(priv-&gt;animal_name);
        // 所以其实我们是在设置属性的时候更新私有成员。
        priv-&gt;animal_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        // 所以你看属性这个名称和我们想的属性不一样，
        // 其他语言里面属性就是成员，能存点东西，
        // 但这里好像属性只是成员的一个代理，
        // 具体的东西存在成员里面，通过属性设置。
        g_value_set_string(value, priv-&gt;animal_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 给子类提供一个默认的实现，这样它就不是一个纯虚函数了。
static void print_impl(TestAnimal *animal)
{
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);
    g_message(&amp;quot;I am an Animal called %s.&amp;quot;, priv-&gt;animal_name);
}

static void test_animal_class_init(TestAnimalClass *animal_class)
{
    // 首先我们覆盖这个类里面的 GObject 类的方法，
    // 你调用 GObject 的函数，他会先获取参数的 GObject 类，
    // 那就获取到我们这个了，然后具体的实现就是我们覆盖的这个。
    GObjectClass *object_class = G_OBJECT_CLASS(animal_class);
    object_class-&gt;get_property = get_property_impl;
    object_class-&gt;set_property = set_property_impl;

    // 给虚方法设置默认实现。
    animal_class-&gt;print = print_impl;

    obj_properties[PROP_ANIMAL_NAME] = g_param_spec_string(
        &amp;quot;animal-name&amp;quot;,
        &amp;quot;Animal Name&amp;quot;,
        &amp;quot;Name of Animal&amp;quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_animal_init(TestAnimal *animal)
{
}

void test_animal_print(TestAnimal *animal)
{
    // 你看其实这里和 GObject 类设置属性的原理是一样的。
    // 子类调用这个函数，实际上获取到的是子类自己那个 Animal 类，
    // 于是他只要覆盖自己的那个 Animal 类，调用的就是他自己的。
    TestAnimalClass *animal_class;
    animal_class = TEST_ANIMAL_GET_CLASS(animal);
    g_return_if_fail(animal_class-&gt;print != NULL);
    animal_class-&gt;print(animal);
}

TestAnimal *test_animal_new(gchar *animal_name)
{
    g_return_val_if_fail(animal_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_ANIMAL,
        &amp;quot;animal-name&amp;quot;, animal_name,
        NULL
    );
}&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-animal.h&quot;

// Derivable 类型会自动帮你定义实例结构体，
// 所以你想夹带点私货就得自己搞个 Private 类型。
typedef struct {
    gchar *animal_name;
} TestAnimalPrivate;

// 这个也会展开一大堆声明什么的。
G_DEFINE_TYPE_WITH_PRIVATE(TestAnimal, test_animal, G_TYPE_OBJECT)

// 要想通过 new 函数直接初始化一些值就需要搞点属性。
enum {
    PROP_0,
    PROP_ANIMAL_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        if (priv-&amp;gt;animal_name)
            g_free(priv-&amp;gt;animal_name);
        // 所以其实我们是在设置属性的时候更新私有成员。
        priv-&amp;gt;animal_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        // 所以你看属性这个名称和我们想的属性不一样，
        // 其他语言里面属性就是成员，能存点东西，
        // 但这里好像属性只是成员的一个代理，
        // 具体的东西存在成员里面，通过属性设置。
        g_value_set_string(value, priv-&amp;gt;animal_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 给子类提供一个默认的实现，这样它就不是一个纯虚函数了。
static void print_impl(TestAnimal *animal)
{
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);
    g_message(&quot;I am an Animal called %s.&quot;, priv-&amp;gt;animal_name);
}

static void test_animal_class_init(TestAnimalClass *animal_class)
{
    // 首先我们覆盖这个类里面的 GObject 类的方法，
    // 你调用 GObject 的函数，他会先获取参数的 GObject 类，
    // 那就获取到我们这个了，然后具体的实现就是我们覆盖的这个。
    GObjectClass *object_class = G_OBJECT_CLASS(animal_class);
    object_class-&amp;gt;get_property = get_property_impl;
    object_class-&amp;gt;set_property = set_property_impl;

    // 给虚方法设置默认实现。
    animal_class-&amp;gt;print = print_impl;

    obj_properties[PROP_ANIMAL_NAME] = g_param_spec_string(
        &quot;animal-name&quot;,
        &quot;Animal Name&quot;,
        &quot;Name of Animal&quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_animal_init(TestAnimal *animal)
{
}

void test_animal_print(TestAnimal *animal)
{
    // 你看其实这里和 GObject 类设置属性的原理是一样的。
    // 子类调用这个函数，实际上获取到的是子类自己那个 Animal 类，
    // 于是他只要覆盖自己的那个 Animal 类，调用的就是他自己的。
    TestAnimalClass *animal_class;
    animal_class = TEST_ANIMAL_GET_CLASS(animal);
    g_return_if_fail(animal_class-&amp;gt;print != NULL);
    animal_class-&amp;gt;print(animal);
}

TestAnimal *test_animal_new(gchar *animal_name)
{
    g_return_val_if_fail(animal_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_ANIMAL,
        &quot;animal-name&quot;, animal_name,
        NULL
    );
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;理论上来说我们直接往实例结构体里添加成员作为私有成员就可以，但是在头文件里定义实例结构体，其它文件是可以看到实例结构体的成员的，所以 &lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 不允许我们这么做。&lt;/p&gt;
&lt;p&gt;但有一个省事的宏 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt;，它要求我们做一个 Private 类型，里面存放我们想要的任何私有元素，它不会被继承，并且因为定义在 &lt;code&gt;.c&lt;/code&gt; 文件里所以也不会被其它文件看到。它还会提供一些 GObject 内置类型系统的实现函数（不然 GObject 系统怎么知道你建了哪些类型！），还有一些只在实现里面用到的定义。当然 Private 类型的名字也是约定好的。&lt;/p&gt;
&lt;p&gt;多说一句，按照 GTK 的代码实现，其实 Private 最后就是在实例结构体里面定义了一个叫 &lt;code&gt;priv&lt;/code&gt; 的指针，类型是自己定义的 Private 类型，因为 GTK 是手写的头文件定义然后用的 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt; 同时又没产生冲突，其实你也可以完全不理会这两个宏，全都自己写，只要保证类结构体和实例结构体的第一个成员是父类结构体和父实例结构体就可以了。但是 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt; 提供了一个 &lt;code&gt;项目名_类型名_get_instance_private&lt;/code&gt; 的函数，我们就不用直接访问 &lt;code&gt;priv&lt;/code&gt; 成员了。&lt;/p&gt;
&lt;p&gt;在使用 &lt;code&gt;g_object_new&lt;/code&gt; 新建一个对象的时候可以通过 key-value 的方式设置一些初始值，这个其实是通过 GObject 提供的 property 功能实现的，因为 C 并没有哈希表这种东西。这个过程很繁琐但也很固定，其实就是实现其它语言里面传一个对象作为构造函数参数然后以此设置私有成员初始值的功能。property 就是参数，具体的内容还是存在初始值里面的，不过其实你也可以通过 property 访问具体的值。这里很容易理解成 property 有自己单独的存储空间，其实不是。property 是可以继承的，所以子类可以同时设置父类和自己的 property。&lt;/p&gt;
&lt;p&gt;然后我们要接触到第一个重载的部分了，因为 &lt;code&gt;TestAnimal&lt;/code&gt; 继承了 GObject，所以我们要重载掉它类结构体里面的父类结构体的 &lt;code&gt;set_property&lt;/code&gt; 和 &lt;code&gt;get_property&lt;/code&gt; 函数。过程也很简单，GObject 要求我们实现两个函数 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt; 和 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt;，其中前者就是让我们初始化类结构体用的。首先进行一个类型转换把 &lt;code&gt;TestAnimalClass&lt;/code&gt; 转换成 &lt;code&gt;GObjectClass&lt;/code&gt;（为什么可以强转？那你先思考一下为什么定义类结构体时候第一个元素是父类结构体？就是因为要这样才能进行类型转换，本质上是个套娃），然后直接赋值。这样假如有人对我们这个类型执行 &lt;code&gt;g_object_set_property&lt;/code&gt;，实际上是调用的我们重载过的函数（为什么？怎么做到的？往下看）。&lt;/p&gt;
&lt;p&gt;那其实我们知道如何覆盖父类的方法，但运行的时候是如何动态重载到我们自己的函数的也不清楚，我们先搞定我们自己的那个虚函数，其实很简单，我们定义具体的方法的时候（指 &lt;code&gt;test_animal_print&lt;/code&gt;），不要让它实现具体的逻辑，而是让它通过参数的实例执行虚函数表里的函数就可以了。这需要一个自动生成的 &lt;code&gt;项目名_类型名_GET_CLASS&lt;/code&gt; 的宏，它的作用是通过一个实例查找到 &lt;strong&gt;这个实例本身&lt;/strong&gt; 对应的类结构体，然后就可以运行虚函数了。比如我给 &lt;code&gt;g_object_set_property&lt;/code&gt; 传一个 &lt;code&gt;TestAnimal&lt;/code&gt;，那我们调用的其实是 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的第一个成员那个 &lt;code&gt;GObjectClass&lt;/code&gt; 的 &lt;code&gt;set_property&lt;/code&gt;，这个已经被我们改成自己的了，于是就实现了一个 &lt;del&gt;不那么直观的&lt;/del&gt; 重载。&lt;/p&gt;
&lt;p&gt;当然假如我们不想写一个纯虚函数，可以在 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt; 里面设置一个初值，这样假如子类没有重载，调用的就是这个。&lt;/p&gt;
&lt;p&gt;那你可能要问假如我有一个不想被重载的函数呢，那你就不要跳虚函数表了，直接写逻辑就可以了。&lt;/p&gt;
&lt;p&gt;接下来我们终于可以写子类的，首先就是 &lt;code&gt;test-cat.h&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#ifndef __TEST_CAT_H__
#define __TEST_CAT_H__

#include &lt;glib-object.h&gt;
#include &amp;quot;test-animal.h&amp;quot;

G_BEGIN_DECLS

#define TEST_TYPE_CAT test_cat_get_type()
// Final 类型就不用写类结构体啦，反正那个最大的用处是用来写可以继承的虚函数。
G_DECLARE_FINAL_TYPE(TestCat, test_cat, TEST, CAT, TestAnimal);

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name);

G_END_DECLS

#endif&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#ifndef __TEST_CAT_H__
#define __TEST_CAT_H__

#include &amp;lt;glib-object.h&amp;gt;
#include &quot;test-animal.h&quot;

G_BEGIN_DECLS

#define TEST_TYPE_CAT test_cat_get_type()
// Final 类型就不用写类结构体啦，反正那个最大的用处是用来写可以继承的虚函数。
G_DECLARE_FINAL_TYPE(TestCat, test_cat, TEST, CAT, TestAnimal);

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name);

G_END_DECLS

#endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;TestCat&lt;/code&gt; 是继承 &lt;code&gt;TestAnimal&lt;/code&gt; 的，并且我们不想让它被继承，所以它就不需要写类结构体了（因为虚函数表是用来重载的，没有继承当然也没有重载）。&lt;/p&gt;
&lt;p&gt;所以接下来就直接到实现部分了，在 &lt;code&gt;test-cat.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-cat.h&amp;quot;

// Final 类型也没有 Private，但是它自己本身就是容器嘛！
// 所以实例结构体就给你自己写了。
// 当然别的文件不需要知道你有什么私货所以不要写在头文件里。
struct _TestCat {
    TestAnimal parent_instance;
    gchar *cat_name;
};

G_DEFINE_TYPE(TestCat, test_cat, TEST_TYPE_ANIMAL)

enum {
    PROP_0,
    PROP_CAT_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        if (cat-&gt;cat_name)
            g_free(cat-&gt;cat_name);
        cat-&gt;cat_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        g_value_set_string(value, cat-&gt;cat_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 那我们不想要默认的实现就可以覆盖掉自己的。
static void print_impl(TestAnimal *animal)
{
    TestCat *cat = TEST_CAT(animal);
    g_message(&amp;quot;I am a Cat called %s.&amp;quot;, cat-&gt;cat_name);
    // 这个自动生成的 parent 变量指向的是真正的父类！
    // 因为我们自己带的父类结构体被我们覆盖了，所以这里给你一个访问正主的机会。
    // 它是个 gpointer 所以你得手动设置类型。
    // 其实你的子类如果是完全覆盖父类的功能其实我觉得不用写这一句了。
    // 但是有时候你的子类是在父类上面增加功能就得写。
    // 这不就是 super 指针嘛！
    TEST_ANIMAL_CLASS(test_cat_parent_class)-&gt;print(animal);
}

static void test_cat_class_init(TestCatClass *cat_class)
{
    GObjectClass *object_class = G_OBJECT_CLASS(cat_class);
    object_class-&gt;get_property = get_property_impl;
    object_class-&gt;set_property = set_property_impl;

    // 干掉我们自己的这个父类结构体里面带的内置实现，
    // 这样父类的函数调用的其实是我们自己的这个实现。
    // 那你看你一会让父类调用自己一会又让自己调用父类可真是麻烦。
    TestAnimalClass *animal_class = TEST_ANIMAL_CLASS(cat_class);
    animal_class-&gt;print = print_impl;

    obj_properties[PROP_CAT_NAME] = g_param_spec_string(
        &amp;quot;cat-name&amp;quot;,
        &amp;quot;Cat Name&amp;quot;,
        &amp;quot;Name of Cat&amp;quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_cat_init(TestCat *cat)
{
}

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name)
{
    g_return_val_if_fail(animal_name != NULL &amp;amp;&amp;amp; cat_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_CAT,
        &amp;quot;animal-name&amp;quot;, animal_name,
        &amp;quot;cat-name&amp;quot;, cat_name,
        NULL
    );
}&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-cat.h&quot;

// Final 类型也没有 Private，但是它自己本身就是容器嘛！
// 所以实例结构体就给你自己写了。
// 当然别的文件不需要知道你有什么私货所以不要写在头文件里。
struct _TestCat {
    TestAnimal parent_instance;
    gchar *cat_name;
};

G_DEFINE_TYPE(TestCat, test_cat, TEST_TYPE_ANIMAL)

enum {
    PROP_0,
    PROP_CAT_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        if (cat-&amp;gt;cat_name)
            g_free(cat-&amp;gt;cat_name);
        cat-&amp;gt;cat_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        g_value_set_string(value, cat-&amp;gt;cat_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 那我们不想要默认的实现就可以覆盖掉自己的。
static void print_impl(TestAnimal *animal)
{
    TestCat *cat = TEST_CAT(animal);
    g_message(&quot;I am a Cat called %s.&quot;, cat-&amp;gt;cat_name);
    // 这个自动生成的 parent 变量指向的是真正的父类！
    // 因为我们自己带的父类结构体被我们覆盖了，所以这里给你一个访问正主的机会。
    // 它是个 gpointer 所以你得手动设置类型。
    // 其实你的子类如果是完全覆盖父类的功能其实我觉得不用写这一句了。
    // 但是有时候你的子类是在父类上面增加功能就得写。
    // 这不就是 super 指针嘛！
    TEST_ANIMAL_CLASS(test_cat_parent_class)-&amp;gt;print(animal);
}

static void test_cat_class_init(TestCatClass *cat_class)
{
    GObjectClass *object_class = G_OBJECT_CLASS(cat_class);
    object_class-&amp;gt;get_property = get_property_impl;
    object_class-&amp;gt;set_property = set_property_impl;

    // 干掉我们自己的这个父类结构体里面带的内置实现，
    // 这样父类的函数调用的其实是我们自己的这个实现。
    // 那你看你一会让父类调用自己一会又让自己调用父类可真是麻烦。
    TestAnimalClass *animal_class = TEST_ANIMAL_CLASS(cat_class);
    animal_class-&amp;gt;print = print_impl;

    obj_properties[PROP_CAT_NAME] = g_param_spec_string(
        &quot;cat-name&quot;,
        &quot;Cat Name&quot;,
        &quot;Name of Cat&quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_cat_init(TestCat *cat)
{
}

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name)
{
    g_return_val_if_fail(animal_name != NULL &amp;amp;&amp;amp; cat_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_CAT,
        &quot;animal-name&quot;, animal_name,
        &quot;cat-name&quot;, cat_name,
        NULL
    );
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Final 类型没有 Private，因为它自己就是 Private，所以这个定义实例结构体的权力交给了你，直接在里面写私有成员即可，但是不要忘了套娃（指第一个成员一定要是父实例结构体）。&lt;/p&gt;
&lt;p&gt;然后就是设置我们自己的 property 并重载 GObject 的虚函数，当然你可能会说这样父类型的 property 不就丢了吗？其实 property 是放在 GObject 系统单独的一个表里，需要的时候它去查询，并且会考虑父类型的继承链，所以我们不需要考虑重载时候覆盖掉父类型的问题。&lt;/p&gt;
&lt;p&gt;接下来就是重载父类型提供给我们的虚函数也就是 &lt;code&gt;TestCatClass.print&lt;/code&gt; 了！当然首先是把我们自己的类结构体里面的父类结构体的虚函数换掉。&lt;/p&gt;
&lt;p&gt;在写我们自己重载的函数的时候，一个比较重要的事情是 chain up，也就是最后一行那个 &lt;code&gt;TEST_ANIMAL_CLASS(test_cat_parent_class)-&amp;gt;print(animal);&lt;/code&gt;，有时候你重载只是做了一些子类自己的处理，然后还是需要父类提供的处理函数的，这该怎么办？你可能会说类结构体里面不是有个父类结构体了吗？但那个已经被我们覆盖了！你这样不就是咬自己尾巴的猫吗？&lt;/p&gt;
&lt;p&gt;当我们自己解决不了的时候就得 GObject 解决了，&lt;code&gt;G_DEFINE_TYPE&lt;/code&gt; 会提供一个 &lt;code&gt;项目名_类型名_parent_class&lt;/code&gt; 的指针定义，这个指向的是那个真正的唯一的 &lt;strong&gt;不是我们自己包含的&lt;/strong&gt; 那个父类结构体！也就是说对于子类和父类继承而言，有两个父类结构体，一个是父类自己作为一个类的那个，另一个是子类为了实现重载包含的那个，这个访问的就是前者。&lt;/p&gt;
&lt;p&gt;当然这个类型其实是个 &lt;code&gt;gpointer&lt;/code&gt; 所以我们还得自己转换一下类型，然后只要调用方法就可以了（这不就是 super 指针嘛）。&lt;/p&gt;
&lt;p&gt;最后我们写一个测试的程序 &lt;code&gt;main.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-animal.h&amp;quot;
#include &amp;quot;test-cat.h&amp;quot;

int main(int argc, char *argv[])
{
    TestAnimal *animal = test_animal_new(&amp;quot;animal1&amp;quot;);
    TestCat *cat = test_cat_new(&amp;quot;animal2&amp;quot;, &amp;quot;cat1&amp;quot;);
    test_animal_print(animal);
    test_animal_print(TEST_ANIMAL(cat));
    return 0;
}&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-animal.h&quot;
#include &quot;test-cat.h&quot;

int main(int argc, char *argv[])
{
    TestAnimal *animal = test_animal_new(&quot;animal1&quot;);
    TestCat *cat = test_cat_new(&quot;animal2&quot;, &quot;cat1&quot;);
    test_animal_print(animal);
    test_animal_print(TEST_ANIMAL(cat));
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后用这个 &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;CC := cc
OBJECTS := main.o test-animal.o test-cat.o
CFLAGS := `pkg-config --cflags gobject-2.0`
LIBS := `pkg-config --libs gobject-2.0`

all: ${OBJECTS}
    ${CC} -o test ${OBJECTS} ${LIBS}

main.o: test-animal.h test-cat.h
    ${CC} -c main.c ${CFLAGS}

test-animal.o:
    ${CC} -c test-animal.c ${CFLAGS}

test-cat.o: test-animal.h
    ${CC} -c test-cat.c ${CFLAGS}

.PHONY: clean
clean:
    -rm test ${OBJECTS}&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;CC := cc
OBJECTS := main.o test-animal.o test-cat.o
CFLAGS := `pkg-config --cflags gobject-2.0`
LIBS := `pkg-config --libs gobject-2.0`

all: ${OBJECTS}
    ${CC} -o test ${OBJECTS} ${LIBS}

main.o: test-animal.h test-cat.h
    ${CC} -c main.c ${CFLAGS}

test-animal.o:
    ${CC} -c test-animal.c ${CFLAGS}

test-cat.o: test-animal.h
    ${CC} -c test-cat.c ${CFLAGS}

.PHONY: clean
clean:
    -rm test ${OBJECTS}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;运行的结果是这样的：&lt;/p&gt;
&lt;figure data-raw=&quot;** Message: 11:23:25.727: I am an Animal called animal1.
** Message: 11:23:25.729: I am a Cat called cat1.
** Message: 11:23:25.729: I am an Animal called animal2.&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;** Message: 11:23:25.727: I am an Animal called animal1.
** Message: 11:23:25.729: I am a Cat called cat1.
** Message: 11:23:25.729: I am an Animal called animal2.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;你可以看到第一行是父类也就是 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的函数的输出。第二行是 &lt;code&gt;TestCatClass&lt;/code&gt; 重载的函数的输出，第三行则是 &lt;code&gt;TestCatClass&lt;/code&gt; 重载的函数 chain up 到 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的输出，但是输出的是子类继承的父类的属性！&lt;/p&gt;
&lt;p&gt;最后有关我到底该声明成子类还是父类以及传参时候要不要类型转换：其实在这个 GObject 的样例里面看起来是无所谓的，类型转换可行不可行其实取决于具体 new 的是什么，而不是声明的指针是什么，所以其实声明成父类和子类都没有关系，类型转换也主要是为了满足 C 语言对指针类型和函数声明的要求罢了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    
    
    <category term="GObject" label="GObject" scheme="https://sh.alynx.one/tags/GObject/" />
    
  </entry>
  
  
  
  <entry>
    <title>基于 GitHub Issue 的前端评论框</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Frontend-GitHub-Issue-Based-Comment/" />
    <id>https://sh.alynx.one/posts/Frontend-GitHub-Issue-Based-Comment/</id>
    
    <published>2020-08-15T10:25:00.000Z</published>
    
    
    <updated>2020-08-18T04:25:00.000Z</updated>
    
    
    <summary type="html">
      &lt;h1 id=&quot;造轮子是病，得治。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E9%80%A0%E8%BD%AE%E5%AD%90%E6%98%AF%E7%97%85%EF%BC%8C%E5%BE%97%E6%B2%BB%E3%80%82&quot; title=&quot;造轮子是病，得治。&quot;&gt;&lt;/a&gt;造轮子是病，得治。&lt;/h1&gt;
&lt;p&gt;自从造了 &lt;a href=&quot;/posts/Frontend-Blog-Search/&quot;&gt;前端博客搜索引擎&lt;/a&gt; 的轮子之后，我对自己的能力有了极大的信心，同时也掌握了一些有趣的用法，于是把枪口瞄准了下一个我看着不顺眼的地方——评论框。&lt;/p&gt;
&lt;p&gt;（这标题怎么写的和毕业论文似的！）&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;h1 id=&quot;造轮子是病，得治。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E9%80%A0%E8%BD%AE%E5%AD%90%E6%98%AF%E7%97%85%EF%BC%8C%E5%BE%97%E6%B2%BB%E3%80%82&quot; title=&quot;造轮子是病，得治。&quot;&gt;&lt;/a&gt;造轮子是病，得治。&lt;/h1&gt;
&lt;p&gt;自从造了 &lt;a href=&quot;/posts/Frontend-Blog-Search/&quot;&gt;前端博客搜索引擎&lt;/a&gt; 的轮子之后，我对自己的能力有了极大的信心，同时也掌握了一些有趣的用法，于是把枪口瞄准了下一个我看着不顺眼的地方——评论框。&lt;/p&gt;
&lt;p&gt;（这标题怎么写的和毕业论文似的！）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;轮子也不是白造的。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E8%BD%AE%E5%AD%90%E4%B9%9F%E4%B8%8D%E6%98%AF%E7%99%BD%E9%80%A0%E7%9A%84%E3%80%82&quot; title=&quot;轮子也不是白造的。&quot;&gt;&lt;/a&gt;轮子也不是白造的。&lt;/h1&gt;
&lt;p&gt;从我建站以来我的评论框就命途多舛，Disqus 虽然是最著名的评论系统，但是在国内访问不太顺畅。多说火了一段时间之后便关门大吉，HyperComments 则在我用了一段时间后发邮件提示要收费了，于是我之前的评论便华丽流失。而对于 Valine 这种基于 LeanCloud 的评论系统，我对 LeanCloud 不甚了解所以也不想尝试（而且 Valine 现在似乎转向闭源了，当初也许是个正确的决定）。然后赶上 Gitment 和 Gitalk 火了起来，大家意识到 GitHub Issue 正是个放评论的好地方。但是由于 &lt;a href=&quot;https://github.com/iissnan/hexo-theme-next/pull/1634#issuecomment-313596649&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Gitment 和 Gitalk 采用他们自己的服务器实现博客评论框提交——转发到 GitHub API 的实现&lt;/a&gt;，以及 &lt;a href=&quot;https://www.v2ex.com/t/535608&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;采用的 OAuth App 权限过高&lt;/a&gt;，有人怀疑这不太安全，于是我也没太敢参与。后来遇到 &lt;a href=&quot;https://github.com/wzpan/comment.js&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;comment.js&lt;/a&gt; 这个项目，它绕过了提交评论的问题——直接给一个到 GitHub Issue 的评论框的链接就可以了。于是我就开始用这个，至于什么 utterances 这种用 GitHub App 降低权限的评论系统，我也懒得尝试了。&lt;/p&gt;
&lt;p&gt;但我为什么决定替换掉 comment.js 我已经记不清楚了，可能是为了对主题的显示有更好的掌握吧，毕竟它带有自己的 CSS 样式而且经常和我的冲突，也可能是因为它迟迟没提供像 Disqus 一样查找每篇文章评论数目的功能，不过它现在已经不再维护了，所以我也算是未雨绸缪。&lt;/p&gt;
&lt;h1 id=&quot;事情本该很简单。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E4%BA%8B%E6%83%85%E6%9C%AC%E8%AF%A5%E5%BE%88%E7%AE%80%E5%8D%95%E3%80%82&quot; title=&quot;事情本该很简单。&quot;&gt;&lt;/a&gt;事情本该很简单。&lt;/h1&gt;
&lt;p&gt;研究了一下原理其实并不是很难，首先就是从 GitHub 的 API 上 ajax 获取数据，然后操作 DOM 添进去就可以了，所以我就先阅读了 &lt;a href=&quot;https://docs.github.com/en/rest/reference/issues&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;GitHub API 的文档&lt;/a&gt;，总之还算容易，只要先获取一个仓库的 issue 列表，然后按照某种方法在里面查找相关的 issue，如果没有就渲染一个到新建 issue 的链接，否则获取该 issue 的全部评论并显示就可以了。&lt;/p&gt;
&lt;p&gt;查找 issue 的 key 也算容易，我给它做成了函数参数，然后在主题模板里填一个每个页面唯一的字符串就行了，比如文章标题，然后新生成 issue 页面时候就把这个作为 issue 的标题，这样查找 GitHub Issue 页面时候也比较容易看。然后 GitHub 把 PR 也视为 issue，这个不要紧，收到数组之后过滤一下就好了。而显示数目我琢磨了一下其实也没什么难的嘛！我都获取到所有 issue 的信息了。做一个新的函数，主题作者在页面上放置一系列空的元素并设置好 class 属性，然后同样地把每个页面唯一的字符串设置成这些元素的属性（Disqus 也是这样的），加载函数时候把 class 作为参数传进去，分别从 issue 列表里查找对应的标题就可以了。还有一个奇葩问题是 GitHub issue 的 comments 指的是除了顶楼以外的评论，但很显然看起来不是这样的，这个也简单，直接把顶楼加到数组里就成了嘛。剩下就是艰苦的在浏览器里刀耕火种写 JS 拼 HTML 字符串发 ajax 请求写嵌套回调（没有 async/await 也太痛苦了吧！。&lt;/p&gt;
&lt;p&gt;一切正常工作了一段时间一后我发现不太对劲，怎么评论太多的时候显示不全呢？仔细查了一下发现 GitHub API 是强制分页的，也就是说不管你怎么设置，最多一次只能获取 100 条评论，默认则是 30 条，本来我不太想给博客加评论分页功能的，现在看来是 GitHub 被迫让我加啊。当然这个并不是最痛苦的，最痛苦的是它查找仓库的 issue 列表的时候也是强制分页的！这就麻烦了，还记得我们之前说要获取到列表之后查找标题吗？获取不到完整列表还怎么查找啊！&lt;/p&gt;
&lt;p&gt;当然你可以说按顺序多查几页不就行了嘛，这就是它分页难受的地方了！ajax 是异步的啊亲！你不会想让我一个 for 循环几个 ajax 还指望优雅的等他们结束了再跑查找吧！我知道能用 &lt;code&gt;Promise.all()&lt;/code&gt; 解决，但是由于我大发慈悲的支持使用 IE11 的用户（微软我&amp;amp;A%￥S&amp;amp;……省略一千字儒雅随和），所以我的函数是基于回调的，那也没什么办法。而且这样首先你得读一下仓库信息才能知道有多少个 open 的 issue（没错只能算 open 的不能算 close 的！所以在后面查 issue 的时候我也不得不筛选掉 close 的，不过这大概也许是个 feature？），然后自己计算有多少页。最后我只能造了一个不那么优雅的尾递归回调（反正就那个意思），不过它工作的不错，这样我就可以获取到全部的 issue 列表了。&lt;/p&gt;
&lt;p&gt;然后后面其实还是差不多，至于评论分页又不一样了，既然 GitHub 只有分页 API，我也就半推半就啊不是将计就计吧。我才不要继续获取全部评论了，我也每次直接获取 GitHub 那边的一页就行了，每页个数则由主题作者传参进来。至于如何确定我要哪一页呢？和搜索功能一样，继续前端解析 query string 呗。根据 issue 评论总数计算一下有几页，然后生成几个链接放在页尾，每次加载时候解析一下参数确定当前页是哪个即可。当然，不要忘了 issue 顶楼不算评论，计算分页的时候也不要给它加进去！而且既然是这么分页，我也懒得把顶楼算在里面了（不然真的麻烦的要死啊后面分页和每页个数全乱了），所以假如你设置每页 10 个评论，那第一页其实有 11 个，别烦我，代码在那，不满意自己改……然后继续刀耕火种……&lt;/p&gt;
&lt;p&gt;为了减轻负担，我没有实现太多的功能，比如时间戳我没有搞成什么几分钟几小时前，这种东西又不清晰又浪费带宽，我只搞了&lt;del&gt;基于 marked 的 Markdown 渲染（必须的）和&lt;/del&gt;语法高亮，Markdown 渲染不是必须的，因为你可以 &lt;a href=&quot;https://docs.github.com/en/rest/overview/media-types#comment-body-properties&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;设置 header 让 GitHub 直接返回 HTML&lt;/a&gt;。为了保证效果统一，这个 JS 只是建立了 HTML 布局，给每个元素添加了 class，具体的样式则完全是主题自己编写的，所以配合起来也比较好看。&lt;/p&gt;
&lt;p&gt;最后的效果其实还可以，完整的脚本就是 &lt;a href=&quot;/js/comment.js&quot;&gt;这个网站在用的 JS&lt;/a&gt;，具体和主题的整合方法就慢慢翻 ARIA 的模板吧。唯一的缺点是 GitHub API 的频率限制太低，按照这个弱智的 issue 列表分页的话又不得不多一次读取仓库有多少 issue 的请求，假如你的 issue 太多估计也是问题？不过应该不会有那么多博文吧！我只有调试脚本的时候遇到过被 GitHub 提示等会的问题，所以对于访问者应该没什么影响。有影响以后再想解决办法（或者没办法）。&lt;/p&gt;
&lt;p&gt;也许最好的办法是解决掉需求——要什么评论框？不就是破事水？如果有问题想联系作者电子邮件又不是不能用！（逃&lt;/p&gt;
&lt;h1 id=&quot;其实你知道，烦恼（bug）会解决烦恼（bug）。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E5%85%B6%E5%AE%9E%E4%BD%A0%E7%9F%A5%E9%81%93%EF%BC%8C%E7%83%A6%E6%81%BC%EF%BC%88bug%EF%BC%89%E4%BC%9A%E8%A7%A3%E5%86%B3%E7%83%A6%E6%81%BC%EF%BC%88bug%EF%BC%89%E3%80%82&quot; title=&quot;其实你知道，烦恼（bug）会解决烦恼（bug）。&quot;&gt;&lt;/a&gt;其实你知道，烦恼（bug）会解决烦恼（bug）。&lt;/h1&gt;
&lt;div class=&quot;alert-green&quot;&gt;这一部分更新于 2020-08-17 10:34:00。&lt;/div&gt;

&lt;p&gt;GitHub API 推荐用户 &lt;a href=&quot;https://docs.github.com/en/rest/overview/resources-in-the-rest-api#conditional-requests&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;缓存之前的请求响应，然后根据缓存的响应的 Header 里面的 ETag 发送请求查询是否过期，若未过期则返回一个不消耗频率限制次数的 304 状态码&lt;/a&gt;。我心想这也简单，那就在前端搞一个缓存就可以了。&lt;/p&gt;
&lt;p&gt;然后我搜索了一番找到了 CacheStorage，看起来它是唯一一个跨标签页的基于 Session 的正宗的前端缓存。但是很显然 IE 又不支持，而且这个 API 基于 Promise 并且只能缓存 Response 对象，也就是说没办法简单的通过在 XHR 的时候判断一下跳过不支持的情况，要 Polyfill 则需要引入完整的 Promise 和 fetch/Response，所以我们做了一个&lt;del&gt;艰难&lt;/del&gt;容易的决定——是时候去掉 IE 支持了！&lt;/p&gt;
&lt;p&gt;于是我把请求 API 的函数改成了如下操作：&lt;/p&gt;
&lt;figure data-raw=&quot;let cachePromise = window.caches.open(&amp;quot;cacheName&amp;quot;);

// Fetching JSON with cache for GitHub API.
const cachedFetchJSON = (path, opts = {}) =&gt; {
  let cachedResponse = null;
  return cachePromise.then((cache) =&gt; {
    return cache.match(path);
  }).then((response) =&gt; {
    // No cache or no ETag, just re-fetch;
    if (response == null || !response.headers.has(&amp;quot;ETag&amp;quot;)) {
      return window.fetch(path, opts);
    }
    // Ask GitHub API whether cache is outdated.
    cachedResponse = response;
    opts[&amp;quot;headers&amp;quot;] = opts[&amp;quot;headers&amp;quot;] || {};
    opts[&amp;quot;headers&amp;quot;][&amp;quot;If-None-Match&amp;quot;] = cachedResponse.headers.get(&amp;quot;ETag&amp;quot;);
    return window.fetch(path, opts);
  }).then((response) =&gt; {
    if (response.status === 200) {
      // No cache or cache outdated and succeed.
      // Update cache.
      cachePromise.then((cache) =&gt; {
        return cache.put(path, response);
      });
      // Cache needs an unconsumed response,
      // so we clone respone before consume it.
      return response.clone().json();
    } else if (response.status === 304 &amp;amp;&amp;amp; cachedResponse != null) {
      // Not modified so use cache.
      return cachedResponse.clone().json();
    } else {
      // fetch does not reject on HTTP error, so we do this manually.
      throw new Error(&amp;quot;Unexpected HTTP status code &amp;quot; + response.status);
    }
  });
};&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;let cachePromise = window.caches.open(&quot;cacheName&quot;);

// Fetching JSON with cache for GitHub API.
const cachedFetchJSON = (path, opts = {}) =&amp;gt; {
  let cachedResponse = null;
  return cachePromise.then((cache) =&amp;gt; {
    return cache.match(path);
  }).then((response) =&amp;gt; {
    // No cache or no ETag, just re-fetch;
    if (response == null || !response.headers.has(&quot;ETag&quot;)) {
      return window.fetch(path, opts);
    }
    // Ask GitHub API whether cache is outdated.
    cachedResponse = response;
    opts[&quot;headers&quot;] = opts[&quot;headers&quot;] || {};
    opts[&quot;headers&quot;][&quot;If-None-Match&quot;] = cachedResponse.headers.get(&quot;ETag&quot;);
    return window.fetch(path, opts);
  }).then((response) =&amp;gt; {
    if (response.status === 200) {
      // No cache or cache outdated and succeed.
      // Update cache.
      cachePromise.then((cache) =&amp;gt; {
        return cache.put(path, response);
      });
      // Cache needs an unconsumed response,
      // so we clone respone before consume it.
      return response.clone().json();
    } else if (response.status === 304 &amp;amp;&amp;amp; cachedResponse != null) {
      // Not modified so use cache.
      return cachedResponse.clone().json();
    } else {
      // fetch does not reject on HTTP error, so we do this manually.
      throw new Error(&quot;Unexpected HTTP status code &quot; + response.status);
    }
  });
};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当然理想很丰满现实很骨感，在不支持 CacheStorage 的浏览器里要 fallback 到不带缓存的版本，本来我以为很简单，但是……（下面开启吐槽时间。）&lt;/p&gt;
&lt;blockquote class=&quot;center-quote&quot;&gt;支持 IE 的前端的痛苦都是相似的，不支持 IE 的前端则各有各的痛苦。&lt;/blockquote&gt;

&lt;p&gt;为什么非 HTTPS + localhost 不能用 CacheStorage 啊，难道他们没考虑过在电脑上开发然后手机访问测试移动版吗？还是说他们打算在手机上起一个开发服务器？为什么 Firefox 在非 HTTPS 时限制 CacheStorage 的方法是在 Promise 里 reject 一个 Error 从而导致这个过程变成了异步的？为什么 CacheStorage 只能缓存 Response 而不是任意数据结构？Safari 不能完整支持 Response 对象也就算了，为什么移动版 Chrome 和 Firefox 也不支持？合着你们 fetch 返回的 Response 还不是 Response？这世界到底怎么了……&lt;/p&gt;
&lt;p&gt;所以最后需要一个长长的基于 Promise 的判断加载函数：&lt;/p&gt;
&lt;figure data-raw=&quot;// 加载评论的时候才加载缓存。
let cachePromise = null;

let fetchJSON = uncachedFetchJSON;

const loadCache = (name) =&gt; {
  // Unlike in .then(),
  // we must explicit resolve and reject in a Promise&#039;s execuator.
  return new Promise((resolve, reject) =&gt; {
    if (cachePromise != null &amp;amp;&amp;amp; fetchJSON !== uncachedFetchJSON) {
      return reject(new Error(&amp;quot;Cache is already loaded!&amp;quot;));
    }
    // Old version browsers does not support Response.
    if (window.Response == null) {
      return reject(
        new Error(&amp;quot;Old version browsers does not support Response.&amp;quot;)
      );
    }
    const testResponse = new window.Response();
    // Safari and most mobile browsers do not support `Response.clone()`.
    if (testResponse.headers == null || testResponse.clone == null) {
      return reject(new Error(
        &amp;quot;Safari and most mobile browsers do not support `Response.clone()`.&amp;quot;
      ));
    }
    // Chromium and Safari set `window.caches` to `undefined` if not HTTPS.
    if (window.caches == null) {
      return reject(new Error(
        &amp;quot;Chromium and Safari set `window.caches` to `undefined` if not HTTPS.&amp;quot;
      ));
    }
    window.caches.open(&amp;quot;CacheStorageTest&amp;quot;).then((cache) =&gt; {
      fetchJSON = cachedFetchJSON;
      cachePromise = window.caches.open(name);
      return window.caches.delete(&amp;quot;CacheStorageTest&amp;quot;);
    }).then(() =&gt; {
      return resolve();
    }).catch((error) =&gt; {
      // Firefox throws `SecurityError` if not HTTPS.
      console.error(error);
      return reject(new Error(&amp;quot;Firefox throws `SecurityError` if not HTTPS.&amp;quot;));
    });
  }).catch((error) =&gt; {
    console.error(error);
  });
};&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;// 加载评论的时候才加载缓存。
let cachePromise = null;

let fetchJSON = uncachedFetchJSON;

const loadCache = (name) =&amp;gt; {
  // Unlike in .then(),
  // we must explicit resolve and reject in a Promise&#039;s execuator.
  return new Promise((resolve, reject) =&amp;gt; {
    if (cachePromise != null &amp;amp;&amp;amp; fetchJSON !== uncachedFetchJSON) {
      return reject(new Error(&quot;Cache is already loaded!&quot;));
    }
    // Old version browsers does not support Response.
    if (window.Response == null) {
      return reject(
        new Error(&quot;Old version browsers does not support Response.&quot;)
      );
    }
    const testResponse = new window.Response();
    // Safari and most mobile browsers do not support `Response.clone()`.
    if (testResponse.headers == null || testResponse.clone == null) {
      return reject(new Error(
        &quot;Safari and most mobile browsers do not support `Response.clone()`.&quot;
      ));
    }
    // Chromium and Safari set `window.caches` to `undefined` if not HTTPS.
    if (window.caches == null) {
      return reject(new Error(
        &quot;Chromium and Safari set `window.caches` to `undefined` if not HTTPS.&quot;
      ));
    }
    window.caches.open(&quot;CacheStorageTest&quot;).then((cache) =&amp;gt; {
      fetchJSON = cachedFetchJSON;
      cachePromise = window.caches.open(name);
      return window.caches.delete(&quot;CacheStorageTest&quot;);
    }).then(() =&amp;gt; {
      return resolve();
    }).catch((error) =&amp;gt; {
      // Firefox throws `SecurityError` if not HTTPS.
      console.error(error);
      return reject(new Error(&quot;Firefox throws `SecurityError` if not HTTPS.&quot;));
    });
  }).catch((error) =&amp;gt; {
    console.error(error);
  });
};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;不管怎么样现在这个网站在支持 CacheStorage 和 Response 的浏览器上（似乎也就桌面版 Chrome/Firefox……）是缓存 GitHub API 的结果了，打开 DevTools 切到 Network 面板可以看到 GitHub API 返回的是 304 而不是 200，其他浏览器则 fallback 到无缓存的 fetch。当然其他浏览器不包含 IE 咯。&lt;/p&gt;
&lt;h1 id=&quot;由俭入奢易，由奢入俭难。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E7%94%B1%E4%BF%AD%E5%85%A5%E5%A5%A2%E6%98%93%EF%BC%8C%E7%94%B1%E5%A5%A2%E5%85%A5%E4%BF%AD%E9%9A%BE%E3%80%82&quot; title=&quot;由俭入奢易，由奢入俭难。&quot;&gt;&lt;/a&gt;由俭入奢易，由奢入俭难。&lt;/h1&gt;
&lt;div class=&quot;alert-green&quot;&gt;这一部分更新于 2020-08-18 12:25:00。&lt;/div&gt;

&lt;p&gt;我后来又仔细想了想，其实要兼容 IE 还是有办法的，首先 &lt;code&gt;fetch&lt;/code&gt; 和 &lt;code&gt;Promise&lt;/code&gt; 都有成熟的 polyfill，甚至 &lt;code&gt;URLSearchParams&lt;/code&gt; 也有，只要写一段脚本在不支持的时候加载他们就可以了。然后去掉所有 IE 不支持的 ES6 特性，比如箭头函数、模板字符串、&lt;code&gt;for…of…&lt;/code&gt; 循环以及 MapReduce（IE 竟然支持 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 真是惊到我了）。但是能做到并不意味着一定要做，人总是还要向前看的，现在是 2020 年，连罪魁祸首始作俑者微软都放弃了 IE，就算是照顾用户量，IE 用户也是可以忽略的那一部分了。既然我已经用 ES6 重写了，就不要想再让我为这种历史垃圾放弃我得到的好处了，从我开始写主题到现在丢掉 IE 支持也算是仁至义尽了，所以为什么不让这些用户支持一下 Firefox 呢？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/ARIA/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="评论" label="评论" scheme="https://sh.alynx.one/tags/%E8%AF%84%E8%AE%BA/" />
    
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/tags/JavaScript/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/tags/ARIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>和 cheerio 说再见！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Drop-Cheerio/" />
    <id>https://sh.alynx.one/posts/Drop-Cheerio/</id>
    
    <published>2020-08-04T13:06:00.000Z</published>
    
    
    <updated>2020-08-04T13:06:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我早就想把 cheerio 从 Hikaru 的依赖里移出去了，倒不是我对他的功能有什么不满，但是一年不更新 NPM 上的包也太恶心了吧！&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我早就想把 cheerio 从 Hikaru 的依赖里移出去了，倒不是我对他的功能有什么不满，但是一年不更新 NPM 上的包也太恶心了吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我的生成器使用 cheerio 的地方主要有两个，一是给标题生成喵点并依次生成 TOC，二是检查文章里相对路径的图片和链接引用并改成绝对路径，否则如果截取之后放在首页的摘要包含图片的话，会因为当前页面的地址变化而不工作。后者也是我自己编写生成器的原因之一，就是因为像 Hexo 或者 Hugo 这种已有的生成器内部并没有考虑，只能通过插件解决，我在写 Hexo 主题时嵌入了一个使用正则表达式的脚本，但相比之下我觉得还是一个能理解 HTML 的库更加可靠。所以后来我选了 cheerio 来做解析和修改以实现这些功能。&lt;/p&gt;
&lt;p&gt;但是 cheerio 有一个 &lt;a href=&quot;https://github.com/cheeriojs/cheerio/issues/1198&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;很古怪的 bug&lt;/a&gt;，存在于它目前在 NPM 上最新的版本 &lt;code&gt;1.0.0-rc3&lt;/code&gt; 上。假如你使用 cheerio 解析并编辑包含中文的 HTML 的话，导出字符串时所有的中文都被编码成了 HTML 实体，导致进行下一步处理比如用 &lt;code&gt;substring&lt;/code&gt; 截断的话，字符串长度变化了，而且可能会在文字中间截断。假如你使用 &lt;code&gt;decodeEntities: false&lt;/code&gt; 的话，原本文档里的 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; 一类的字符反而会被 cheerio 导出成 &lt;code&gt;&amp;lt;&lt;/code&gt;，变成一团乱麻。&lt;/p&gt;
&lt;p&gt;这个 bug 非常古怪并且我花了一段时间来研究它，上一个版本 &lt;code&gt;0.22.0&lt;/code&gt; 使用 &lt;code&gt;decodeEntities: false&lt;/code&gt; 是没有这个问题的。最后发现原因是 cheerio 在 &lt;code&gt;1.0.0-rc1&lt;/code&gt; 开始引入 parse5 代替原本的 htmlparser2 作为默认的 HTML 解析器，而 parse5 在解析时并不会使用 &lt;code&gt;decodeEntities&lt;/code&gt; 这个参数，比如你输入 &lt;code&gt;&amp;amp;lt;&lt;/code&gt;，parse5 解析时会在节点里存储原本的值 &lt;code&gt;&amp;lt;&lt;/code&gt;，但 cheerio 在序列化的时候还是会依赖这个参数进行编码，所以假如传递 &lt;code&gt;false&lt;/code&gt; 进去，cheerio 就不会主动进行 encode，导致最后出来的是 &lt;code&gt;&amp;lt;&lt;/code&gt;。而 htmlparser2 会按照这个参数选择解不解码，所以也不会发生这种错误。&lt;/p&gt;
&lt;p&gt;那这么看起来是 parse5 的问题？并不！parse5 有自己的序列化函数，和自己的解析函数是配套的，所以只要使用 parse5 的序列化函数就不会存在这个问题了。&lt;/p&gt;
&lt;p&gt;最后总结起来修复的办法也有很多：首先其实序列化的时候并不需要将所有元素都编码成 HTML 实体，只要对几个字符进行转义即可，我提交了这样的 PR，但因为 cheerio 和它自己的序列化库 dom-serializer 是两个仓库，不是很好处理，而且其实也没有从根源上解决 htmlparser2 和 parse5 表现不一致的问题。cheerio 后来的提交中采用的是简单办法，假如使用 parse5 解析就继续使用 parse5 序列化就好了。&lt;/p&gt;
&lt;p&gt;但是这个提交之后并没有发布到 NPM 上，NPM 挂的一直是有问题的 &lt;code&gt;1.0.0-rc3&lt;/code&gt; 版本，至于原因呢很简单，他们打算释出第一个稳定版本 &lt;code&gt;1.0.0&lt;/code&gt;，所以要等到所有 TODO 都解决了再发新版本！&lt;/p&gt;
&lt;p&gt;搞毛啊老哥，你这样放着有 bug 的版本是把用户做宝搞吗？而且你是个函数库，下面好多人依赖你处理 DOM 呢，NodeJS 上提供 jQuery 模式的函数库大概也没什么别的替代品了，一堆项目在 issue 里问你就给个这破理由？&lt;/p&gt;
&lt;p&gt;我选择的是锁死 &lt;code&gt;0.22.0&lt;/code&gt; 版本，其他下游的项目也都各自做了 workaround，要么安装 GitHub 上的 &lt;code&gt;1.0.0&lt;/code&gt; 分支要么回退版本。但总之都让强迫症很不爽啊！&lt;/p&gt;
&lt;p&gt;大家等他发稳定版就这么等了一年，在这一年间有些项目比如 &lt;a href=&quot;https://github.com/hexojs/hexo/issues/3677&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Hexo 直接抛弃了 cheerio 用正则处理 HTML&lt;/a&gt;，虽然他们主要是为了性能。我倒不是那么在乎生成器的性能（真的在乎的话我就该去用 Hugo，而且我也不敢说我自己的代码写的很好）。&lt;/p&gt;
&lt;p&gt;晚上睡觉前我突然想到假如只是过滤链接和图片并检查他们的属性的话其实不需要 jQuery 一样的 API，只需要能理解 HTML，那找个简单的解析器就可以了。而且第二天正好读了 &lt;a href=&quot;https://blog.phoenixlzx.com/2017/02/18/dont-ask-me-why-invent-another-planet-river-of-news/#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;卷老师的这篇博文&lt;/a&gt;，发现和我想的也差不多。于是就开始动手。&lt;/p&gt;
&lt;p&gt;卷老师用的 sanitize-html 对我来说不太合适，因为我的静态生成器并不需要过滤内容——都是 Markdown 生成的，而且不安全也是使用者自己故意写的，不是我的责任，生成器也没有不安全的 HTML 的运行环境。sanitize-html 和 cheerio 用的都是 htmlparser2 作为解析器，虽然它号称自己是跑得最快的 HTML 解析器，但经过之前那个问题我还是心有余悸。而且 htmlparser2 是非常简单的基于事件回调的解析器（就像 Python 自带的那个，我太久不写 Python 不记得叫什么了），不会给你构建树状结构也不包含序列化，自己写序列化就容易像之前那个 cheerio bug 一样出问题。所以我考察了一下 parse5 发现还不错，会构建树状结构，数据结构都写在文档里，同时就是简单的可以直接操作的 Object，至于速度虽然慢一点但我并不太在乎那 10 毫秒。&lt;/p&gt;
&lt;p&gt;于是我就先手动造了一些 wrapper 函数比如递归前置遍历一颗树来代替 cheerio 的 &lt;code&gt;$.each()&lt;/code&gt;，前置遍历正好是 HTML 文档自上往下的顺序，生成 TOC 的时候也是按照这个顺序来的，然后就是比如获取结点内文本的函数、获取属性和设置属性的函数之类的。至于插入结点我想了个巧妙的办法，因为 parse5 把最终解析到的文本作为单独的结点，我就直接在插入文本的函数里让 parse5 解析输入的 HTML，然后用得到的子结点替换被插入结点的子结点即可。&lt;/p&gt;
&lt;p&gt;随后我重写了生成 TOC，生成标题 ID 和检查文章里相对路径的图片和链接引用并改成绝对路径的函数。然后写了点简单的测试样例跑了一下发现没问题，就用它们替换掉 Hikaru 的 &lt;code&gt;utils.js&lt;/code&gt; 里面用 cheerio 的版本，然后修改了 process 代码。我造的这几个简单的 wrapper 完全符合我的要求，于是提交打版本号发布一气呵成，一年不更新的 cheerio 就从我的生成器里拜拜了。&lt;/p&gt;
&lt;p&gt;虽然嘴上说着不追求速度，但是凭我肉体的感觉还是多少快了一点儿，不过我也并不是很在乎生成的时间，感知真的不强，无所谓了。但我真的不能理解这种为了憋个大的不发版本把用户做宝搞的行为，就算是发个 &lt;code&gt;1.0.0-rc4&lt;/code&gt; 也比一年不发强吧！就算只是 make user happy 也好，何况面对的不是 user 而是其它项目的 dev 呢，都是同行，这行为算不算托大？反正我是习惯做了点改动就打个新版本，即使我自己安装的都是开发版本，我也希望能把我最新的修改送到用户手上，又不是 breaking change 或者什么不能随便更新的软件，打个小版本号至于那么难吗？？？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="Hikaru" label="Hikaru" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/Hikaru/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="Hikaru" label="Hikaru" scheme="https://sh.alynx.one/tags/Hikaru/" />
    
  </entry>
  
  
  
  <entry>
    <title>给你的主题来点暗色！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Dark-Mode-in-Theme/" />
    <id>https://sh.alynx.one/posts/Dark-Mode-in-Theme/</id>
    
    <published>2020-08-04T09:15:00.000Z</published>
    
    
    <updated>2020-08-07T02:50:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我自己对暗色模式其实是没什么兴趣的，因为设计一种配色就已经让我绞尽脑汁了，还要我设计另一种。但是我也确实意识到暗色模式在晚上玩手机实在是很方便，而且做这个也很流行，于是我也做了一个，只是因为我能做到。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我自己对暗色模式其实是没什么兴趣的，因为设计一种配色就已经让我绞尽脑汁了，还要我设计另一种。但是我也确实意识到暗色模式在晚上玩手机实在是很方便，而且做这个也很流行，于是我也做了一个，只是因为我能做到。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;跟着系统变色就行了吗？&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E8%B7%9F%E7%9D%80%E7%B3%BB%E7%BB%9F%E5%8F%98%E8%89%B2%E5%B0%B1%E8%A1%8C%E4%BA%86%E5%90%97%EF%BC%9F&quot; title=&quot;跟着系统变色就行了吗？&quot;&gt;&lt;/a&gt;跟着系统变色就行了吗？&lt;/h1&gt;
&lt;p&gt;现在的系统大概都支持暗色模式（Linux 的桌面环境早就有这种设置了，Firefox 可以直接读取我的系统设置，Android/iOS 也都有暗色模式开关），浏览器也紧跟潮流提供了 &lt;code&gt;@media&lt;/code&gt; 的 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;查询属性&lt;/a&gt;（IE：那……是……什……么……）。理论上来说只要简单地在 CSS 里面查询然后编写修改颜色的代码就可以了，问题只是如何修改颜色比较轻松。&lt;/p&gt;
&lt;h1 id=&quot;CSS变量是好东西！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#CSS%E5%8F%98%E9%87%8F%E6%98%AF%E5%A5%BD%E4%B8%9C%E8%A5%BF%EF%BC%81&quot; title=&quot;CSS变量是好东西！&quot;&gt;&lt;/a&gt;CSS 变量是好东西！&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;使用 CSS 变量&lt;/a&gt; 当然是最简单的解决方案了，就像我们平时编程一样使用变量作为 &lt;code&gt;color&lt;/code&gt; 和 &lt;code&gt;background&lt;/code&gt; 的值，然后在查询到暗色模式的代码块里给这些变量重新赋值，一切都十分简单有条理，而且最重要的是你不需要一个一个选择器查找有哪些需要变色的属性，所有的颜色变量都是放在一起的。&lt;/p&gt;
&lt;h1 id=&quot;真是恨死IE这废物了！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E7%9C%9F%E6%98%AF%E6%81%A8%E6%AD%BBIE%E8%BF%99%E5%BA%9F%E7%89%A9%E4%BA%86%EF%BC%81&quot; title=&quot;真是恨死IE这废物了！&quot;&gt;&lt;/a&gt;真是恨死 IE 这废物了！&lt;/h1&gt;
&lt;p&gt;虽然 IE 有很多不支持的选项，但是不支持 CSS 变量真是让我工作量剧增的一件事情。虽然我从不测试我的网站在 IE 上能否运行，但是在最新版 IE 上一般都是没问题的，因此我也会放弃一些最新版 IE 不支持的新特性，CSS 变量就是其中之一。&lt;/p&gt;
&lt;p&gt;既然没有办法用 CSS 变量，那就只能自己一个一个找选择器下面和颜色相关的属性，然后给它们重新设置属性了，真是找的人头晕眼花啊。&lt;/p&gt;
&lt;p&gt;可能有人会说你不是用 CSS 预处理器吗，预处理器不是也有变量吗？但是预处理器是在生成阶段把变量编译掉了啊！不方便到运行时（浏览器）里去替换变量。&lt;/p&gt;
&lt;h1 id=&quot;我就是想在暗色浏览器里用亮色啊！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E5%9C%A8%E6%9A%97%E8%89%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%94%A8%E4%BA%AE%E8%89%B2%E5%95%8A%EF%BC%81&quot; title=&quot;我就是想在暗色浏览器里用亮色啊！&quot;&gt;&lt;/a&gt;我就是想在暗色浏览器里用亮色啊！&lt;/h1&gt;
&lt;p&gt;在全部重新调整过颜色并能看之后（其实就是把浅色的色块换成深色，颜色层次基本不变，背景图搞个反色，至于那些彩色的按钮标签我实在没精力重新配色了，把透明度调低一点就好了），我自己还是比较喜欢自己一开始设计的样子，但我又是个习惯电脑全局暗色的人，这怎么能忍！&lt;/p&gt;
&lt;p&gt;CSS 的媒体属性不像一般的属性，只能是浏览器设置我们读取，没有办法用 JS 控制，于是也就没法简单地利用这个添加切换按钮。上网搜了半天也只有曲线救国的方案。&lt;/p&gt;
&lt;h1 id=&quot;曲线救国&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%9B%B2%E7%BA%BF%E6%95%91%E5%9B%BD&quot; title=&quot;曲线救国&quot;&gt;&lt;/a&gt;曲线救国&lt;/h1&gt;
&lt;p&gt;如果并不是想那么和系统的设置同步而只是给自己的网站添加切换的话，并不需要媒体查询。只要设计一个按钮给 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 添加删除 class/attribute 就行了。然后如果要和系统同步，在 JavaScript 里也有 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;相关的 API&lt;/a&gt; 可以做到查询和监听，在检测到变化的时候也修改 class/attribute 即可。&lt;/p&gt;
&lt;p&gt;我选择的是给 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 加 &lt;code&gt;data-theme=&quot;dark&quot;&lt;/code&gt; 或 &lt;code&gt;data-theme=&quot;light&quot;&lt;/code&gt; 属性，不选 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 是因为 WebKit 那些该死的不遵循标准的 scrollbar 伪类，文档没有说他们到底依附哪个元素，我尝试得到的是 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;。接下来只要把之前的 CSS 里面的媒体查询选择器改成 &lt;code&gt;html[data-theme=&quot;dark&quot;]&lt;/code&gt; 就行了。&lt;/p&gt;
&lt;p&gt;不过还要注意继承关系，这样写的话有些属性并不是继承外面的，而是在这个选择器里面就近继承。比如假如修改了 &lt;code&gt;html[data-theme=&quot;dark&quot;] a&lt;/code&gt; 的边框，那 &lt;code&gt;html[data-theme=&quot;dark&quot;] a.cls&lt;/code&gt; 的边框会优先继承这个，而不是 &lt;code&gt;a.cls&lt;/code&gt;。我知道有些人可能会笑我半懂不懂了，但是我确实遇到了这个问题，并且思考了一下找到了原因。&lt;/p&gt;
&lt;p&gt;还有一个比较尴尬的事情，我给一些元素设置了 &lt;code&gt;transition&lt;/code&gt; 用于 &lt;code&gt;:hover&lt;/code&gt; 之后加一个渐变颜色的效果，现在暗色模式也是修改颜色，导致这些元素会比其他元素慢变一下，没什么好办法因为你分不开两种 &lt;code&gt;color&lt;/code&gt; 变化。我的解决方案是一个一个找切换暗色模式时候会变属性的选择器，给它们也添加 &lt;code&gt;transition&lt;/code&gt;。效果还不错，不过 Chrome 在处理这种 CSS 动画时候竟然会掉帧？？？&lt;/p&gt;
&lt;p&gt;不管了，反正我用 Firefox，Firefox 效果好得很，完全不掉帧。&lt;/p&gt;
&lt;p&gt;更新（2020-08-07 10:50:00）：我怀疑 Chrome 想做新时代的 IE，其实并不是性能问题导致掉帧，WebKit 对于继承来的属性的 transition 存在问题，会导致不是同时变换而是有延迟的变换，效果糟透了，&lt;a href=&quot;https://stackoverflow.com/a/36779404&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;StackOverflow 上也有人遇到这个问题&lt;/a&gt;，看起来是 bug 并且不打算解决，而 Firefox 就没有这个问题。使用 CSS 变量在 WebKit 下效果会好一点，不过也不能给所有变色的元素加 transition，还是会卡，只能给 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 加一个，因为我的链接有 &lt;code&gt;:hover&lt;/code&gt; 时变色的 transition，都是 color 就没办法在那时 transition 而暗色模式时候不 transition。总之由于 WebKit 的存在导致没法让全部元素同步 transition，只能近似。两权相害取其轻，还是让 IE 用户只能用亮色吧，我最后还是选择了 CSS 变量。&lt;/p&gt;
&lt;h1 id=&quot;怎么你这破网站换个页面还要重新点一次？&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%80%8E%E4%B9%88%E4%BD%A0%E8%BF%99%E7%A0%B4%E7%BD%91%E7%AB%99%E6%8D%A2%E4%B8%AA%E9%A1%B5%E9%9D%A2%E8%BF%98%E8%A6%81%E9%87%8D%E6%96%B0%E7%82%B9%E4%B8%80%E6%AC%A1%EF%BC%9F&quot; title=&quot;怎么你这破网站换个页面还要重新点一次？&quot;&gt;&lt;/a&gt;怎么你这破网站换个页面还要重新点一次？&lt;/h1&gt;
&lt;p&gt;一切看起来都十分美好，直到我把一个暗色页面切成亮色然后点了个链接，下一个页面并不会理会我们上一个页面设置了什么主题，又变成了暗色。每个页面点一下切换按钮也太烦人了，我们得来点持久化。&lt;/p&gt;
&lt;p&gt;某个域名想在用户的浏览器里存点是完全可行的，使用 &lt;code&gt;localStorage&lt;/code&gt; 就行了，就是简单的键值对。但是这样我们就有了多种可能切换亮暗的动作：&lt;code&gt;localStorage&lt;/code&gt; 里面存的选项，网页加载时浏览器媒体查询的结果，用户点了网页上的切换按钮，用户点了系统切换亮暗的设置。这些的判断顺序要好好处理一下，不然某些就会被忽视掉变成“我点了怎么不动啊！！！”。&lt;/p&gt;
&lt;p&gt;经过我考虑一下之后，这个玩意的逻辑应该是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假如 &lt;code&gt;localStorage&lt;/code&gt; 里面没有值，用户是首次打开网站，此时读取媒体查询按照系统的主题设置。&lt;/li&gt;
&lt;li&gt;否则说明用户之前打开过网站，已经有他自己的喜好了，按照 &lt;code&gt;localStorage&lt;/code&gt; 里面的值设置。&lt;/li&gt;
&lt;li&gt;上两个步骤结束之后注册一个媒体查询监听器，用于响应用户修改系统设置。&lt;/li&gt;
&lt;li&gt;注册一个按钮监听器，用于响应用户点击网页切换按钮设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上 1 和 2 的顺序不能反了，并且每一个设置动作里都要把这次设置的值写入 &lt;code&gt;localStorage&lt;/code&gt; 用于后续加载用户的选择。&lt;/p&gt;
&lt;p&gt;现在看起来一切都很满意，是时候发布了！&lt;/p&gt;
&lt;h1 id=&quot;用户：啊！我的眼睛！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E7%94%A8%E6%88%B7%EF%BC%9A%E5%95%8A%EF%BC%81%E6%88%91%E7%9A%84%E7%9C%BC%E7%9D%9B%EF%BC%81&quot; title=&quot;用户：啊！我的眼睛！&quot;&gt;&lt;/a&gt;用户：啊！我的眼睛！&lt;/h1&gt;
&lt;p&gt;我躺在床上用手机测试的时候又发现了一个问题。因为网页在生成的时候总有一个初始状态（JS 要等到 document 加载完成才开始处理 DOM，不像那些单页应用），假如我设置成暗色然后切换到别的页面，网页就会以亮色加载然后变成暗色，用户在晚上看起来就像是个闪光弹（伏拉什棒！）。&lt;/p&gt;
&lt;p&gt;其实没什么好的解决办法，因为这是传统 HTML 页面的限制之一，我也不想找有没有什么新的东西能解决这些问题，最后的方案其实相当简单，既然亮色到暗色会让人受不了，我搞成暗色到亮色不就行了。&lt;/p&gt;
&lt;p&gt;于是就是把模板里按钮的初始状态修改一下，渲染的时候出来的是 &lt;code&gt;data-theme=&quot;dark&quot;&lt;/code&gt;，假如用户选择亮色，加载页面时会有一个暗色到亮色的变化。反正我自己都不在意。&lt;/p&gt;
&lt;p&gt;更新（2020-08-06 18:23:00）：我后来阅读了一些其它主题的代码，看它们是怎么在不使用单页应用的前提下解决这个问题的，结果方法相当简单，我自己也想得到：不用等到 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 事件之后，反正只是修改 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 标签，直接在 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签里面编辑 &lt;code&gt;document.documentElement&lt;/code&gt; 是可以的，因为反正加载到 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 的时候肯定也已经加载到 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 了。所以就把修改这个属性和修改按钮的 DOM 分开了两部分，并且添加了一个 &lt;code&gt;storage&lt;/code&gt; 的监听器，这样假如打开了多个页面，一个页面切换其它页面也会跟随切换。&lt;/p&gt;
&lt;h1 id=&quot;不要过度设计！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E4%B8%8D%E8%A6%81%E8%BF%87%E5%BA%A6%E8%AE%BE%E8%AE%A1%EF%BC%81&quot; title=&quot;不要过度设计！&quot;&gt;&lt;/a&gt;不要过度设计！&lt;/h1&gt;
&lt;p&gt;经过这么一大堆折腾（代码行数++++++++），我甚至在想要不要支持每个页面单独设置亮暗初值，反正只要添加一个 front matter 然后在模板里判断一下嘛。不过后来想了想，就算有这么个功能又有什么用？实际意义几乎为零，徒增复杂度，所以还是不要过度设计了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/ARIA/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/tags/ARIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>修复更换 PCI-E 插槽后 Windows 下无线网卡的名称问题</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fix-Windows-Wireless-Adapter-Name/" />
    <id>https://sh.alynx.one/posts/Fix-Windows-Wireless-Adapter-Name/</id>
    
    <published>2020-06-28T11:02:00.000Z</published>
    
    
    <updated>2020-06-28T11:02:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;这是一篇其实没什么逻辑也没什么技术的文章，但踩到这个坑又很头痛，所以记录一下。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;这是一篇其实没什么逻辑也没什么技术的文章，但踩到这个坑又很头痛，所以记录一下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我用的是一张 PCI-E 的网卡，占据一个 PCI-Ex1 的插槽，对于一个主流的 ATX 主板来说有三个选择，第二条 x16 长度的插槽上面的一个和下面的两个，由于显卡一般会插在第一条 x16 上，所以如果插在第二条 x16 长度上面的那个，会挡住一部分显卡风扇，所以我一开始插在了第二条 x16 长度插槽下面的第一个插槽。这样也是有点问题的，因为这里 x16 和 x1 之间并没有留出一个槽的空位，一般主流显卡又都是双槽的，虽然我不太可能在机箱里塞第二张显卡，但是这么装直接就干掉了这种可能性，所以我一直想把无线网卡换到最底下的插槽。（这一部分比较乱，但是装过机的直接上网搜一下主流 ATX 主板的图就能理解了。）&lt;/p&gt;
&lt;p&gt;之前由于最后一个插槽挡板的螺丝拧的太紧我一直没换，今天买了一个柄比较粗比较省力的螺丝刀，终于拧下来螺丝把网卡换了个插槽。开机之后 Linux 下其实没什么问题，检测设备和持久化命名都正常工作了。不过 Network Manager 似乎认为更换了设备，所以建议删掉之前的连接配置重新连接网络，之后一切都正常。&lt;/p&gt;
&lt;p&gt;切到 Windows 发现不太对劲，首先就是我的 WiFi 适配器名字变成了 &lt;code&gt;WLAN 2&lt;/code&gt;，想要重命名成 &lt;code&gt;WLAN&lt;/code&gt; 又提示已经存在，但是我又看不到，点进去发现它选择的无线网卡名字后面多了个 &lt;code&gt;#2&lt;/code&gt; 的后缀，总之我也不知道怎么回事，但是强迫症觉得很难受，明明我只有一张网卡啊。&lt;/p&gt;
&lt;p&gt;上网搜索了一下，首先是在设备管理器的查看菜单里选择显示隐藏的设备，这样就会发现一个灰色的没有后缀的网卡，我也不知道 Windows 为什么要存一个隐藏的之前存在现在不存在的 PCI-E 设备，首先按照网上的说法卸载掉这个设备然后重启，再开机就没有这个隐藏设备了。&lt;/p&gt;
&lt;p&gt;接下来需要去掉 &lt;code&gt;#2&lt;/code&gt; 的后缀，让 Windows 把这个插槽里的卡认成唯一的一张，这里就十分晦涩，Windows 试图隐藏起这个逻辑，但导致了一个令强迫症十分不爽的问题。我搜索了一下，发现了一个 &lt;a href=&quot;https://wenku.baidu.com/view/275565c68bd63186bcebbc96.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;百度文库文档&lt;/a&gt; 提供的方案。&lt;/p&gt;
&lt;p&gt;首先打开注册表编辑器定位到 &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\_ControlSet001\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}\Descriptions&lt;/code&gt; 这一项，然后在右侧找到你无线网卡的名称，里面的值应该是 &lt;code&gt;2&lt;/code&gt;，改成 &lt;code&gt;1&lt;/code&gt;，然后卸载网卡设备，然后重启，应该就解决了，而且因为设备名字恢复了，&lt;code&gt;WLAN 2&lt;/code&gt; 也应该变回 &lt;code&gt;WLAN&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;所以其实这篇文章并没有什么逻辑和技术，但是 Windows 自作主张非要保存一个隐藏的不存在的设备，实在是令人头痛，又没什么明显的解决方式，所以也只好记下来以防再次被恶心到。&lt;/p&gt;
&lt;p&gt;更新：Arch Linux CN offtopic Telegram 群组里面叫 Give Way 的网友表示并不需要这么复杂，只要把两个无线网卡的设备都卸载掉重启就可以了。理论上确实是如此，但我没机会再试了，遇到相同问题的朋友可以试试。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="网络" label="网络" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/" />
    
    
    <category term="网络" label="网络" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%BB%9C/" />
    
    <category term="Windows" label="Windows" scheme="https://sh.alynx.one/tags/Windows/" />
    
  </entry>
  
  
  
  <entry>
    <title>让你们的主题商店离我远点！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Taking-Your-Theme-Store-Away/" />
    <id>https://sh.alynx.one/posts/Taking-Your-Theme-Store-Away/</id>
    
    <published>2019-12-18T08:17:00.000Z</published>
    
    
    <updated>2019-12-18T08:17:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我不觉得我是个刻薄的人，但对于一些实在令我讨厌的人，不把他们的名字挂出来就是我最后的怜悯。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我不觉得我是个刻薄的人，但对于一些实在令我讨厌的人，不把他们的名字挂出来就是我最后的怜悯。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;已经有不止一个人询问过我有关把博客主题移植到其他生成器上的问题了，这实际上是超出我范围的工作，因为我并不熟悉他们的生成器。但如果有人这样询问我（当然最好的方式是发 issue），我一般会先了解一下他说的生成器，然后解释是因为我没有时间或者我不熟悉目标技术栈。&lt;/p&gt;
&lt;p&gt;我还记得的最远范围是某个 Gridea 的用户发邮件问我怎么把我的主题用到他这个生成器上。某种程度上我觉得他要么是真的无知要么就是装成无知然后提一些在技术上很显而易见的问题来气人（我今天新学的词叫 troll），于是我去查了一下 Gridea，是个一条龙的基于 Vue 的图形化博客系统。对我足够熟悉的人可能知道我不喜欢把博客做成单页应用的样子，而且在我理解里博客生成器就应该是一个比较简单的命令行工具，而不是一个图形化数据库管理工具。尽管我不太喜欢这个项目和它的宣传方式，但万一对方真的是个并不了解这些的小白用户呢？我回复的语气可能并不是十分客气，但我还是解释了一下博客主题和生成器的关系，以及我不了解 Gridea 的技术栈也不是很喜欢这个项目，所以没办法写一个 收费/免费 的主题给这个项目。当然最后结果相对还不错，他也理解我给他的解释。&lt;/p&gt;
&lt;p&gt;但是我最近又收到一封标题为“诚邀合作事宜”的邮件，为了不破坏我第一句的承诺，我修改了部分名词：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很喜欢你博客的风格，可否为Cxxxxx-CMS开发一套（免费/付费）主题，然后发布到Cxxxxx商店里面？&lt;/p&gt;
&lt;p&gt;CxxxxxJS：是一款顶级NodeJS全栈业务开发框架, 基于KoaJS + EggJS + VueJS + Framework7
Cxxxxx-CMS：是基于CxxxxxJS全栈业务开发框架开发的动静结合的CMS，可以快速构建企业网站、博客、社区、商城等Web应用
Cxxxxx商店：包括品类广泛的各类模块，满足不同场景的开发需求&lt;/p&gt;
&lt;p&gt;CxxxxxJS介绍：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/introduce.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/introduce.html&lt;/a&gt;
Cxxxxx-CMS介绍：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/cms-introduce.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/cms-introduce.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cxxxxx商店运营模式：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/store.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/store.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我也不是个专业的前端工程师，现在不是，将来大概也不是前端“全栈”工程师，但我还是能懂这封邮件的内容。俗话说“文无第一，武无第二”，程序员的圈子里这句话应该也十分受用，所以我通读全文之后，目光就落在了“顶级”两个字上面。毕竟去掉套话之后，满足这类泛泛功能的项目也不少，所以还是先看看“顶级”比较有意思。&lt;/p&gt;
&lt;p&gt;在 Google 搜索这个 Cxxxxx 之后，还是有一些相关度比较高的内容的，出于个人习惯，我直接点开了他在 GitHub 上的仓库。既然是“顶级”框架，想必受益者众多，star 数量高达……108 个（截止昨日 18:00）。&lt;/p&gt;
&lt;p&gt;这就十分可笑了，虽然我也不是什么大牛，但是这个数量级 star 的仓库也有，虽然 star 不能说明代码质量，但是说明“顶级”这种人气形容词拿来正合适，如果我有这么个仓库，我肯定不会腆着脸在宣传语里加“顶级”二字。然后在大概阅读了一下文档和官网之后，我觉得就是个普通的 CMS，而且我也不认为静态博客生成器需要和 CMS 结合起来，我更希望静态博客生成器像编译器。而说到 JS 框架的话，既然都基于 &lt;code&gt;KoaJS&lt;/code&gt;、&lt;code&gt;EggJS&lt;/code&gt;、&lt;code&gt;VueJS&lt;/code&gt; 了，我想不出还能在这些套娃外面再套什么娃（禁止套娃！）。&lt;/p&gt;
&lt;p&gt;于是我就回了一封有点嘲讽意味的邮件（我知道可能换个人不会说这种话，不过这种情况稍微嘲讽一下也没什么错吧）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前几天有个意思和你差不多的，但他没你这么能吹，他就是另一个博客生成器的普通用户。&lt;/p&gt;
&lt;p&gt;可能我这话有点刻薄，但假如我自己有一个 100 个 star 的项目，我不会在宣传语里用 &lt;strong&gt;顶级&lt;/strong&gt; 这种形容词。&lt;/p&gt;
&lt;p&gt;写博客是我个人爱好，换句话说就是我也没打算靠这个玩意赚钱，就是自己用着爽然后开源出来有人喜欢随便用。我也没觉得自己技术强到可以靠这个吃饭了。&lt;/p&gt;
&lt;p&gt;既然是“诚邀”，那我觉得应该先看看我博客主题吧，不然容易让人觉得你是爬个 Hexo 主题作者列表然后群发邮件的哎。如果真看了就知道我这个主题的技术栈和你这个项目完全不搭。我的定位是静态博客生成器哎，我也不是很懂这种 CMS 或者 Koa Egg Vue，对这种快速批量构建网站没兴趣，毕竟个人博客嘛，随便折腾折腾才好玩。&lt;/p&gt;
&lt;p&gt;因此我建议你另请高明，或者真有兴趣，Fork 我的主题随便改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我就去忙别的去了，手头正好有个奇葩 Bug。我想这下大概清净了，没想到过一会又来了一封邮件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这就是一般大学生傲慢的地方了。如果是业务爱好者，我不好说什么。如果是一位志于软件开发的同行，就会一个静态博客生成器有什么可炫耀的呢？只怕你还真没有好好看看CxxxxxJS的文档了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这话说的很讨人厌哎。我脾气还算好，实在懒得一点点找出这话里有问题的地方反驳他，就随便回了一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我再说一遍，我可没有给我自己的哪个项目加上“顶级”两个字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后他又来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你可以细细思考这个问题：我用顶级二字就把你伤到了吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Arch Linux CN 群里的群友建议我直接拉黑算了，我也这么想的，但是晚上回去闲的没事翻了翻，发现了其他的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Taking-Your-Theme-Store-Away/1.png&quot; alt=&quot;骚扰证据&quot;&gt;&lt;/p&gt;
&lt;p&gt;好啊！你还敢说你是“诚邀”！还真被我说中了，明明就是爬了 Hexo 主题列表挨个作者群发！一开始邮件是我略有刻薄，不想再逐条反驳他，但看到这个我实在是 &lt;strong&gt;口区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先对于这类“主题商店”，细细想想就知道不对劲，不仅仅这一个项目，还有别的没什么用户又跟你说邀请你驻入商店也是，他说他是诚邀作者设计一款主题放在他商店收费，可是主题作者真的拿到好处了吗？主题做的好，&lt;strong&gt;作者拿到的钱是用户掏的&lt;/strong&gt;，&lt;strong&gt;而用户的使用习惯和黏性是落在他的项目上的&lt;/strong&gt;！图里的有些主题我都看过，真的是非常优秀的作者，从作者角度想不得到任何好处地加入某一项目，也会希望这一项目的人气能给自己带来一些用户口碑，而这个项目很显然不满足！&lt;strong&gt;好一招空手套白狼！&lt;/strong&gt;用户的钱三七分成，豪绅的钱……豪绅现在连钱都不用掏了，全靠一张嘴吹一吹？&lt;/p&gt;
&lt;p&gt;比如 Hexo、Jekyll、Hugo、Pelican 的主题页面（你愿意叫商店也行），都是作者自己主动提交的，为什么？因为这些广受好评的项目，可以为主题作者吸引人气，所以作者才会主动“合作”！&lt;/p&gt;
&lt;p&gt;其次说句不客气的，这类 CMS 项目说到底是拼工作量的东西，我也不是没写过。如果作者就是谦虚的说“我写了个 CMS，希望大家能给点意见使用一下”，我一个一般大学生哪里来的毛病非要嘲讽你？我最起码还得心里叨咕一句作者做这种项目坚持下来不容易，先支持一下劳动量再说。可是既然您把自己放在“顶级”的位子上，而且还看不起我，我也就不说什么客套话了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种项目 V2EX 上一天能刷个十来个，有些就是很诚恳用来练手刷简历的，有些则是这种没有痛点制造痛点也要上的&lt;/strong&gt;。我还再仔细搜了一遍这个项目，发现了好几篇什么掘金知乎&lt;strong&gt;甚至还真有 V2EX&lt;/strong&gt; 上作者发的宣传帖，什么“动静结合”、“全栈开发利器”、“开发业务实战”，这种套话一套一套的。V2EX 帖子就 6 个回帖，有人表示不理解，本来 Hexo 是个静态博客生成器，为啥非得搞个动静结合解决痛点呢？然后作者复读机上身又复制了一下这类套话，换我我也不接着看了。类似我这种静态博客用户就是不想要“后台管理系统”才用静态博客生成器的，这个“痛点”我怎么理解呢？&lt;/p&gt;
&lt;p&gt;“一般大学生傲慢的地方”，这话说的真是让人恶心啊，一般大学生怎么了呢？一般大学生哪里傲慢了呢？一般大学生是不会在自己项目上用“顶级”二字做宣传的。“就会一个静态博客生成器有什么可炫耀的”，我倒是想问问这位同行（呕，请别叫我前端全栈工程师啊各位，我知道自己还不合格呢），您在哪里看到我炫耀啦？我也不在知乎掘金 V2EX 发宣传帖，我甚至还没来得及在我自己博客上介绍一下，我还经常说我这个有写地方写的还不够好，一边学习一边继续编写代码解决我自己的问题，请问您在哪听见我炫耀的？&lt;strong&gt;莫非是我在隔壁宿舍和同学聊天吹水时候跟他吹了一下您听见了？如果真是这样，我还得告您搞窃听呢。&lt;/strong&gt;哦对了，我也不是什么就会一个静态博客生成器，我写生成器是为了解决我自己遇到的痛点的，这只是我涉及领域的一小部分，如果您真的仔细看了我的博客我的 GitHub，就知道我不是只搞前端，反而我看您 GitHub 都是 EggJS 的插件来着，真是令人眼花缭乱啊。&lt;/p&gt;
&lt;p&gt;什么你说让我看文档？文档有什么好看的，你想写什么就写什么，我也能把文档写出花来，那就能欺骗我自己项目本来没解决别人什么痛点嘛？&lt;/p&gt;
&lt;p&gt;让我细细思考？我看是您用了“顶级”二字，被我伤到了吧。都是写点胶水代码的玩意，我生成器还没用 Koa、Egg、Vue 这种框架呢，库是别人写的，框架逻辑都是我自己的，我 &lt;strong&gt;细细思考&lt;/strong&gt; 一下真的很好奇在三大框架（甚至还有个企业级框架）上面能套出什么框架呢？如果你愿意一层一层一层的剥开我的心？本来我不想扯技术方面的，可是别的方面也没看到这个项目对主题作者有什么优势和好处啊！&lt;/p&gt;
&lt;p&gt;我要时时刻刻提醒我自己，我就是个一般大学生，不懂的东西还有很多，也不能学这种说话语气，不然会被人当成知乎上那种讨人厌的家长，就是自己本来也没什么见识还在年轻人面前的死要面子那种，年轻人说点什么就贬低他什么。&lt;/p&gt;
&lt;p&gt;我个人是不习惯在知乎掘金 V2EX 上写帖子骗眼球的，所以就写到我自己博客上了，想必“一般大学生”的博客，估计也没什么人看吧！如果您真的介意，还是那句话，“文无第一，武无第二”，评论区或者在您的博客上，放马过来，反驳我这篇文章，我不介意的。但是，我真的很厌恶往别人仓库刷这种“诚邀合作事宜”的 issue，issue 是用来说代码相关问题的也算是程序员的自我修养之一了吧。我写这个也是希望万一有主题作者看到了别上当了，这不是“诚邀”，是“白嫖”作者人气。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    
    <category term="空手套白狼" label="空手套白狼" scheme="https://sh.alynx.one/tags/%E7%A9%BA%E6%89%8B%E5%A5%97%E7%99%BD%E7%8B%BC/" />
    
    <category term="全靠一张嘴" label="全靠一张嘴" scheme="https://sh.alynx.one/tags/%E5%85%A8%E9%9D%A0%E4%B8%80%E5%BC%A0%E5%98%B4/" />
    
    <category term="你这是瞧谁不起" label="你这是瞧谁不起" scheme="https://sh.alynx.one/tags/%E4%BD%A0%E8%BF%99%E6%98%AF%E7%9E%A7%E8%B0%81%E4%B8%8D%E8%B5%B7/" />
    
  </entry>
  
  
  
  <entry>
    <title>装机小记</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/My-Desktop-PC/" />
    <id>https://sh.alynx.one/posts/My-Desktop-PC/</id>
    
    <published>2019-11-25T02:14:00.000Z</published>
    
    
    <updated>2020-10-12T03:00:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;由于笔记本散热和性能实在是不适合打游戏（有一说一，Optimus 双显卡还是没有直接单卡来得爽），所以很早就想组装一台台式机。特别是最近一直和高中同桌玩 Dota2，我的笔记本如果直播 Dota2，直播推流就会十分卡顿，而我又不想像 CSGO 一样降低画质玩。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;由于笔记本散热和性能实在是不适合打游戏（有一说一，Optimus 双显卡还是没有直接单卡来得爽），所以很早就想组装一台台式机。特别是最近一直和高中同桌玩 Dota2，我的笔记本如果直播 Dota2，直播推流就会十分卡顿，而我又不想像 CSGO 一样降低画质玩。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;作为计算机专业的学生，当然不打算直接淘宝整机啦。经过一番挑选和参考别人意见，最后成套配置是下面这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU：AMD Ryzen5 3600X&lt;/li&gt;
&lt;li&gt;主板：微星 X570 A-PRO 套装 2349&lt;/li&gt;
&lt;li&gt;显卡：NVIDIA Geforce RTX 2070 SUPER 4300（之前是 七彩虹 RTX 2060 战斧 6G 2199）&lt;/li&gt;
&lt;li&gt;显卡支架：酷冷至尊 显卡支撑架 70&lt;/li&gt;
&lt;li&gt;内存：铂胜 C9BJZ 颗粒 白马甲 DDR4 3000 8G x4 1000&lt;/li&gt;
&lt;li&gt;网卡：Intel AX200 150&lt;/li&gt;
&lt;li&gt;固态硬盘：三星 970 EVO Plus 512G 769&lt;/li&gt;
&lt;li&gt;固态硬盘：英睿达 MX500 1TB 799&lt;/li&gt;
&lt;li&gt;机械硬盘：东芝 P300 2TB 400&lt;/li&gt;
&lt;li&gt;电源：海韵 CORE GX650 650W 金牌 549（特价）&lt;/li&gt;
&lt;li&gt;CPU 散热：利民 AK120 145（之前是 超频三 东海x5 89）&lt;/li&gt;
&lt;li&gt;M.2 散热：利民 M.2 硬盘散热片 39&lt;/li&gt;
&lt;li&gt;机箱：先马 鲁班1 209&lt;/li&gt;
&lt;li&gt;机箱风扇：利民 TL-C12R-S x2 + 利民 TL-C12S 418（TL-C12R-S 只有 299 的三联包）（之前是 Arctic F12 PWM 温控 x3 120）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总计 11197。（有些具体价格我记不清了，而且京东价格总是波动。）性价比一般，因为我在其它人觉得没必要的地方分了很多预算比如主板风扇和硬盘，选 B450M 和西数的 NVMe 以及随便买个不带温控但是带灯的风扇的大有人在。&lt;/p&gt;
&lt;p&gt;选这样一套配置其实有原因，可能很多人觉得为什么要给 R5 配 X570 这种高端主板，不如换成 B450 然后把预算加到别的上面。但按照我朋友的使用经验，4 代和以前的 AMD 芯片组存在 USB 兼容性问题，而且我装好机器后就在 Arch Linux CN 群里看到有人遇到这种问题，5 代似乎重新设计了 USB 控制器，目前一切正常。&lt;/p&gt;
&lt;p&gt;如果仅仅是打游戏也可以把 R5-3600X + X570 换成 i5-9600KF + Z390，大概可以便宜一点然后升级一下显卡？我觉得差价是不够 2060 换 2060S 的。或者如果要求不高换成 R5-3600 也行。但 R5-3600(X) 是 12 线程而 i5-9600KF 只有 6 线程，所以我还是选择了 Ryzen，反正 AMD CPU 最近表现都很不错，没必要给 Intel 掏更多的钱。如果你在京东买，建议自己翻翻店铺，一般买主板 CPU 套装更便宜，但是它不会摆出来……&lt;/p&gt;
&lt;p&gt;显卡一开始我是打算买个 1999 的 GTX 1660Ti 的，反正我玩的游戏也不需要光线追踪（难道真相不是本来就没几个游戏支持光线追踪嘛？），然而看到七彩虹最便宜的 2060 正在特价 2199，果断少买一条内存，加钱上这个。反正 1999 的 1660Ti 也是便宜货，而且看了一下视频似乎这块卡也不是丐中丐中丐，质量还可以（同价位索泰铭瑄也不能说是什么高端货吧？），反正内存可以再插新的，而显卡二手不值钱。什么你说 A 卡？虽然 A 卡对于 Linux 的驱动支持更好一点，但是 N 卡也不是不能用，而且我要开直播的话 NVENC 编码挺香的，而且对我的 Steam 库存来说 N 卡也更友好一点（但是骂老黄还是要骂的）。另外虽然我不做机器学习，但万一室友毕设需要的话，反正我上班也不用台式机，装个 CUDA 让他 SSH 上去用岂不是你好我好大家好。&lt;/p&gt;
&lt;p&gt;内存其实没什么特别要求，不过由于 Ryzen 的设计，频率越高越好，但按照这一代的设计，最佳频率是 3600 左右，再高反而会下降，我是买不起那么奢侈的内存，甚至 3200 的都买不起，但这款 3000 的也不错，据说颗粒是镁光创下超频记录的那一批，所以就买了四条。我也不需要 RGB，这款的马甲还挺好看的。当然 3000 是 XMP 频率，需要在 BIOS 里打开 XMP，不然默认只有 2400。&lt;/p&gt;
&lt;p&gt;硬盘不多说了，买 MX500 还是看中一个稳，我还是不放心买同价位国产白片……而且作为一个 2016 年就在笔记本上使用 NVMe SSD 的人，表示并没感觉出 NVME 和 SATA 有什么使用差别……我也不渲染视频，写写代码打打游戏都不卡。但是后来打脸了，公司发了新年福利于是还是上了个 NVMe 硬盘。顺便还配了个无线网卡用来接蓝牙和 WiFi，似乎 Intel AX200 是对 Linux 支持比较好的，就随便买了个 PCI-E 的插上了（御三家集齐了！）（ATX 的好处终于用上了，多出来的 PCI-E 随便插）。&lt;/p&gt;
&lt;p&gt;电源有点买亏了，买完了发现长城同系列 550W 的电源当时也是 329，都怪京东迷一样的定价策略，好在我这一套功耗并不是很高，当然最后趁着福利 + 打折还是换成了海韵一元一瓦的金牌全模组，带我这套绰绰有余。开始我听说原装散热器也能压住 3600X，所以就没打算换，但后来发现刀法还是精准啊，3600X 带的散热器竟然不是铜芯的，再加上 Ryzen 三代的电压控制比较激进，待机温度有时候超过 50，打游戏时候机箱上方有点烤腿，所以还是换了个塔式散热器，风道科学了不少，温度控制也更好了。而且 AMD 原装风扇转速太高，3000rpm 的时候机箱都在震，换了之后安静了很多。顺便安原装散热器时候拆下来的螺丝卡扣不要扔，万一换塔式散热器，好多都是需要装在这个卡扣上的。&lt;/p&gt;
&lt;p&gt;说到机箱和风扇我就一肚子气！本着对京东自营品质和速度的信赖，我全套都是在京东买的，结果拿到手全部安装上之后发现机箱开机跳线是短路的，插上电源就开机，开一会因为短路主板以为你在长按电源又关了！开始我还以为是主板坏了，结果发现螺丝刀手动碰一下开机跳线开关是可以正常开机的！于是又费了九牛二虎之力拆下来退货，主板散热器显卡都在盒子里椅子上放了两天，还好新机箱没问题，但是我买风扇的时候又给我发了个断轴的！东哥呀东哥，我拿你当兄弟，你拿我当代价？你是盯上我了？虽然我平时说你两句坏话但是对京东的服务还是好评的，但是经过这次之后我还是得重新考虑考虑了……顺便据说启航者 S5 这个机箱前面板音频口有的是 HD Audio 有的是老版 AC97，涉嫌虚假宣传，如果你遇到 AC97 的大概可以换货，麻烦一点，不过反正便宜货就这样子，我的抽奖抽到 HD Audio 了。但是这个机箱设计的很抠门，比如主板装上了就没法在上面走 CPU 电源线了，有两个走线口直接被 ATX 主板盖住，所以主板和显卡的电源线只能从一个口里挤出去，然后固态硬盘就在这个口下面所以也很难接线……而且机箱侧板是个黑色半透明的亚克力（那就别宣传透明啊！），金属外壳感觉也不是很厚实。所以最后还是换了先马的鲁班 1，各种设计都宽松了许多，装起来也很好看。&lt;/p&gt;
&lt;p&gt;其他的外设我自己都有，显示器就是之前买的优派 XG2402，1080p@144Hz 并且自带扬声器，鼠标就卓威 EC1-B CSGO 特别版（这个版本已经停产了，而且有偶尔指天/指地的 bug，建议买新的 EC1/2 或者 DIVINA 版本），键盘则是前段时间买的 ikbc C87 红轴，便宜还好用。&lt;/p&gt;
&lt;p&gt;顺便由于我手残以及力气小和室友跃跃欲试，很多东西都是他装的，非常感谢。话说回来装这东西还真是个力气活，毕竟接口都有防呆设计仔细看看不会装错，但是真的很紧很难拔……非常担心把主板搞坏了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/1.jpg&quot; alt=&quot;装好的完全体照片&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：避免你们说我灵魂走线，重新整理了一下，线太硬了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/2.jpg&quot; alt=&quot;重新走线正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/3.jpg&quot; alt=&quot;重新走线背面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：内存插满。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/4.jpg&quot; alt=&quot;内存插满&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：NVMe + 蓝牙无线网卡的完全体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/5.jpg&quot; alt=&quot;完全体&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个机箱 CPU 线走上面是要把主板拿下来才能穿过去的，而且右边两个有硅胶垫的孔 ATX 完全不能用，只能用一个孔，而且不能把线固定在机箱中间，很难盖上。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;再更新：新机箱比原来的好看多了也宽敞多了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/6.jpg&quot; alt=&quot;正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/7.jpg&quot; alt=&quot;背面&quot;&gt;&lt;/p&gt;
&lt;p&gt;公司的蜥蜴（明明是变色龙！）玩偶太高了，显卡下面放不开，挂着我又不放心，盖盖子之前还是拿出来了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：换上了公版 2070 SUPER 和利民 AK120。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/9.jpg&quot; alt=&quot;显卡&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/10.jpg&quot; alt=&quot;全景&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：冬天到了，还是换了几个支持 ARGB 的风扇，我个人不喜欢蓝光紫光夜店土嗨风，所以就弄了点温暖的颜色假装是个电暖气。前面是利民 TL-C12R-S，后面是利民 TL-C12S，虽然是三联包，但是似乎螺丝有问题，有一个风扇螺纹被拧花了，而且后面的风扇竟然少一个角上的橡胶减震垫，于是我就没装拧花的那个，并且把它的减震垫安装到后面了。反正考虑到我最下面是机械硬盘，装上这个风扇风道也不畅通，而且那里并没有什么需要散热的设备，电源风道是独立的。每把风扇两根线，ARGB 线要串联，PWM 线要一分三，而且有前有后，风扇线还有编织保护套，还要防止线材打到风扇扇叶。理线花了好久，最后 &lt;del&gt;把他们用扎带固定到下面和前面空的风扇挂架上&lt;/del&gt; 还是走背线了，刚好够长。而且我还有三个 SATA 硬盘打算换一下 SATA 线……我真的想不出来那些水冷排且上下左右全都是 ARGB 风扇的人怎么理线的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/11.jpg&quot; alt=&quot;正面看灯光&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/12.jpg&quot; alt=&quot;侧面看灯光&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/13.jpg&quot; alt=&quot;风扇线不在下面啦&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/14.jpg&quot; alt=&quot;最终的背线效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;我不会告诉你其实我是想调出我 TB 至宝的颜色：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/15.jpg&quot; alt=&quot;TB 至宝&quot;&gt;&lt;/p&gt;
&lt;p&gt;一开始我以为需要用 OpenRGB 这个项目才能在 Linux 下控制颜色，但是这种 ARGB 风扇好像有存储机制，会自动记住上次的设置。于是就在 Windows 下面安装了一个有一大堆乱七八糟组件和功能的 MSI Dragon Center，其实我只需要调成长亮，然后重启进 Linux 颜色就一直是我设置的，然后我想关掉 Dragon Center 的自启动因为反正也用不到，但是微星的软件自己拉跨，重启进 Linux 灯光不变，重启进 Windows 又变呼吸彩虹灯光了。最后发现 Dragon Center 里面有一个类似“覆盖第三方RGB软件”的选项……好像他把他自己上次存储的结果也当第三方软件了，关掉就好了。原理我猜因为 Dragon Center 只是个 Client，真正控制颜色的是他某个 SDK 里面的 Daemon，这个选项的意思其实就是 Daemon 每次启动都按照 Dragon Center 设置的颜色重新设置风扇就实现覆盖功能了……但是 Dragon Center 的启动被我关了所以就默认了，不管了，统统关掉就 OK。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下来是喜闻乐见的 debug 时间，首先是 Linux 下的，相对比较好调：&lt;/p&gt;
&lt;p&gt;三代 Ryzen 有一个 &lt;a href=&quot;https://www.infoq.cn/article/BRebwaBfJ9eP28X9wQQc&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;每次都返回 0xFFFFFFFF 作为随机数的 BUG&lt;/a&gt;，在我这主要影响 wireguard，巧的是购买前几天我刚读过这篇文章，AMD 已经发了新的固件修正错误，建议更新到主板厂家提供的最新 BIOS 版本一般即可解决，如果主板厂家最新的 BIOS 还没更新固件建议联系售后催一下。&lt;/p&gt;
&lt;p&gt;在我这不知道为什么 GDM 有时候没法自动启动，但是手动切 tty start 又可以显示，查了一下 &lt;a href=&quot;https://wiki.archlinux.org/index.php/GDM#GDM_freezes_with_systemd&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;ArchWiki 的 GDM 页面&lt;/a&gt; 发现有解决方案，但是并没有原因，搜索了一下也没发现原因是什么。&lt;/p&gt;
&lt;p&gt;我还发现有时候刚开机没多久很快就关机会卡在什么 systemd-udevd 进程没结束，最后 event loop failed + timed out，大概要卡好几分钟才关机，但如果你用一会再关机就没问题。检查好几次关机日志没发现问题，后来群友火眼金睛对比了完整日志发现有个叫 &lt;code&gt;ucsi_ccg&lt;/code&gt; 的模块开机加载了两分钟，猜测是这个的问题，搜索一下发现是 &lt;a href=&quot;https://github.com/torvalds/linux/blob/da94001239cceb93c132a31928d6ddc4214862d5/drivers/usb/typec/ucsi/ucsi_ccg.c&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;5.3 内核里 NVIDIA 添加的相关代码&lt;/a&gt;，用来控制 NVIDIA 显卡上的 Type-C 接口的，可是我这块显卡根本就没提供 Type-C 接口！（以及很多笔记本内置的有输出的 N 卡也有这个问题。）临时在 &lt;code&gt;/etc/modprobe.d/&lt;/code&gt; 里加了个 &lt;code&gt;blacklist ucsi_ccg&lt;/code&gt; 的 conf 屏蔽了这个，好像没什么不良影响……&lt;/p&gt;
&lt;p&gt;然后是奇怪的 Windows 的问题，我一开始装的 LTSC，不知道怎么回事输入法没了……折腾无果只能重装。以及现在除了不要联网装 Windows 之外（否则会强制你登录微软账户然后用你名字拼音前五位做用户名），还得不要联网装 NVIDIA 驱动，否则 Win10 自动更新驱动会给你安装 DCH 版的，虽然没什么影响（只是在 NVIDIA 官网升级驱动时候不能选标准选 DCH），但是就是让人很不爽。声卡驱动要装主板厂商的，Win10 自带的只能输出，不能接麦克风录音，然后如果麦克风声音很小就打开 Realtek 的声音控制程序，在右上角齿轮里取消掉什么把所有输入结合到一起的设定（什么乱七八糟的玩意！）。还有要关掉快速启动，不然直接开机会卡在黑屏一个鼠标光标……反正就很烦人。&lt;/p&gt;
&lt;p&gt;更新：还有一个奇怪的问题是 Win10 关机重启也要卡很久，上网搜了一下全是一些忽悠小白的办法，经过我不懈搜索发现了一个熟悉的名字 &lt;code&gt;UCSI&lt;/code&gt;！微软承认存在 &lt;code&gt;UCSI&lt;/code&gt; 问题，既然又是这个 &lt;code&gt;UCSI&lt;/code&gt;，多半还是 NVIDIA Type-C 的问题！反正我没这个接口，果断重新安装 N 卡驱动，选择清洁安装（删除旧驱动）并不勾选 Type-C Driver，问题解决……&lt;/p&gt;
&lt;p&gt;最后既然设备到位了，大概就每周一三四五晚上八点半在 &lt;a href=&quot;https://live.bilibili.com/4312992&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Bilibili 4312991 直播间&lt;/a&gt; 播一个半小时游戏，反正我玩什么播什么，大概就 CSGO Dota2 PUBG 什么的吧，尼尔也有可能，反正不是恶心反胃的就可以。周末随缘直播，如果没什么事情白天就播一会，周二可能晚一点开播因为有课。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
  </entry>
  
  
  
  <entry>
    <title>X 和 Wayland 的主要区别</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Difference-between-X-and-Wayland/" />
    <id>https://sh.alynx.one/posts/Difference-between-X-and-Wayland/</id>
    
    <published>2019-11-13T05:31:33.000Z</published>
    
    
    <updated>2019-11-13T05:31:33.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;最近在写一个 Wayland Compositor，虽然我以前大概知道这是什么，但是并不是很清楚它和 Xserver 有什么区别，虽然 &lt;a href=&quot;https://farseerfc.me/compositor-in-X-and-compositext.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;fc 老师的这篇文章&lt;/a&gt; 写的相当不错，但我一点也不懂 X 所以看的迷迷糊糊。偶然读了 &lt;a href=&quot;https://magcius.github.io/xplain/article/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这篇文章&lt;/a&gt; 发现十分不错，但因为是英文文章读起来很累，打算把一些理解的内容记下来。顺便说一下，原文是带示例的，效果非常不错，建议有时间的人慢慢看一遍。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;最近在写一个 Wayland Compositor，虽然我以前大概知道这是什么，但是并不是很清楚它和 Xserver 有什么区别，虽然 &lt;a href=&quot;https://farseerfc.me/compositor-in-X-and-compositext.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;fc 老师的这篇文章&lt;/a&gt; 写的相当不错，但我一点也不懂 X 所以看的迷迷糊糊。偶然读了 &lt;a href=&quot;https://magcius.github.io/xplain/article/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这篇文章&lt;/a&gt; 发现十分不错，但因为是英文文章读起来很累，打算把一些理解的内容记下来。顺便说一下，原文是带示例的，效果非常不错，建议有时间的人慢慢看一遍。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我相信很多人在搜索 Wayland 的时候都看过这两张著名的图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wayland.freedesktop.org/x-architecture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wayland.freedesktop.org/wayland-architecture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但我觉得可能看了也不明白，怎么把 Xserver 砍掉就提高性能了？为什么没有见到 window manager？为什么桌面环境需要去支持 Wayland？&lt;/p&gt;
&lt;p&gt;Wikipedia 上还有一些奇奇怪怪的图片比如这种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/c2/Linux_Graphics_Stack_2013.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在加上所有介绍 Wayland 的文章都会扯上 DRM，EGL，GLES 之类的，如果不懂这些就完全绕进去了，比如我就看到过有人问 Wayland 用 OpenGL ES 那用 OpenGL 的游戏是不是就跑不了了之类的。&lt;/p&gt;
&lt;p&gt;这一切都得从头说起。&lt;/p&gt;
&lt;p&gt;X 协议设计于 1980 年代，那时候窗口界面刚刚起步，人们还没什么 3D 特效一类的想法，而且机能也不允许，放到今天任何一个有点桌面基础的人都能理解应该给每个窗口一个 buffer 然后把这些 buffer 里的 texture 贴出来的设计逻辑，但 &lt;strong&gt;那时候可没那么多内存让你给每个窗口一个 buffer&lt;/strong&gt;。所以就如同各种常见的领域一样，有个小天才一拍脑子想，反正 &lt;strong&gt;最后显示到桌面上的都是一个屏幕大小&lt;/strong&gt;，我们只要准备这么大一块内存就行了嘛！换句话说，每个窗口的 buffer 要去掉自己被覆盖住的内存，整体内存大小就是可控的，&lt;strong&gt;在内存里是直接没有被覆盖的部分的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不得不说这位的思路在当时还是很有意义的，加上窗口大小都是矩形的假设，计算实际显示区域并不难，于是 Xserver 就是这样设计的。它维护一个屏幕大小的 buffer 自己计算窗口的实际位置，发生了变化（比如一个窗口盖住另一个），就给变化的窗口发一个重绘信号，这个窗口再发出绘图申请，&lt;strong&gt;直接绘制到 Xserver 的 buffer 里&lt;/strong&gt;。由于 Xserver 知道所有窗口的位置，它就可以重定向鼠标键盘输入过去。然后具体的窗口移动缩放交给 window manager，它再把改过的位置回报给 Xserver。&lt;/p&gt;
&lt;p&gt;一切事情都变得很美好，直到某天一个人提出一个问题：我想要半透明的终端！&lt;/p&gt;
&lt;p&gt;程序员是不屑于解决提出问题的人的，如果用现代程序员的思维，做一下 alpha 混合其实很简单，只要 Xserver 能读取上层窗口的颜色和下层窗口的颜色就行了，可是你还记得当年的小天才吗？Xserver 说不太好意思，对于 &lt;strong&gt;一个像素我内存里只有一层，就是最上面显示的那个窗口&lt;/strong&gt;……并且积习难改，我们不能改这个 feature……你想上下混合？死宅不要整天做梦，这是老祖宗留下来的不能改啊。&lt;/p&gt;
&lt;p&gt;如果你用过没开启 混成 Compositing 的 XFCE 和半透明的 XFCE-Terminal，你会发现它是可以透出窗口下面的壁纸的，先别着急喊我骗子，你在终端下面放一个别的窗口试试？神奇的现象发生了，终端显示的还是壁纸……&lt;/p&gt;
&lt;p&gt;上有政策下有对策嘛，一些终端作者想到反正壁纸总是固定的，我读取壁纸图片，取出终端所在的位置，然后在我窗口做个 alpha 混合不就行了？但是人不能自己骗自己啊，这是个客户端的假透明，我们要学习 GNOME 开发者的思维：不够好就砍掉。（大雾&lt;/p&gt;
&lt;p&gt;X 一看不行啊，那我们改一下协议吧，加一个叫 混成器 compositor 的东西，如果你写了这个东西，X 就不是直接更新他自己的内存 buffer 了，而是交给混成器。混成器可以获取一系列窗口的内容，让它们都画到不同的 buffer 里面（内存终于够大了啊！），再把它们处理了丢到屏幕上去。Xserver 只是要求 compositor 最后返回一整个屏幕（通常是，也可以小一点）然后给这个直接贴到最上面去（可以简单理解为混成器画好一整张就行了，别的都不管了）。&lt;/p&gt;
&lt;p&gt;理论上来说，混成器想怎么放这些窗口就怎么放这些窗口，就算想把他们丢到屏幕外边都行，反正你最后返回一个图就行了，Xserver 也不管是不是涩图。&lt;/p&gt;
&lt;p&gt;但是有个尴尬的事情，输出给你管了，输入你管不着啊！之前说了 Xserver 自己按照自己存的窗口位置分配输入，你把窗口挪走了，Xserver 可还是按照自己记录的窗口位置分配输入的，如果你想自己处理窗口位置分配输入，好嘛，Xserver 里面的代码你再复制到你混成器里一份吧！&lt;/p&gt;
&lt;p&gt;所以实际上 compositor 里面怎么做的呢？我最后处理完的窗口，位置和 Xserver 记录的位置还得一样，然后 Xserver 给我那个返回整张屏幕的顶层窗口，我就不接收输入了，这样直接透过顶层点到下面，就和窗口位置对应了（什么乱七八糟的破玩意啊！）。如果你要做个动画呢？你做动画的时候，Xserver 那边记录的位置可不跟你变（要是变，按照 X 的设计你这数据得跑好几个来回），你的鼠标点击在这时候是不准的，传不到窗口里面。&lt;/p&gt;
&lt;p&gt;这些 compositor 都是各个桌面环境做的，他们一般都集成到自己的 window manager 里了。&lt;/p&gt;
&lt;p&gt;而且随着时间发展，越来越多的 Xserver 和 client 是跑在同一个机器上的，很多 client 想自己利用显卡处理图形，就有人在协议上打洞，Xserver 做的越来越少了，更多的事情 client 自己都做了。&lt;/p&gt;
&lt;p&gt;你还想再往 X 协议上糊一层吗？别糊了兄弟，你这也太挫了！一开始 X 的设计是提供机制而非策略，Xserver 自己是符合了（然后除了 Xorg 其他实现都死了），和 Xserver 配合的可是被他绑的死死的比如 compositor，性能翻了几倍还得拉着这些历史垃圾跑，Xserver 终于活成了自己最讨厌的样子。&lt;/p&gt;
&lt;p&gt;Wayland 做的事情很简单，反正 compositor 都做这么多了，那直接把 Xserver 的功能也丢给 compositor 吧！Compositor 下层接的是 DRM 控制渲染，libinput 控制输入，GBM/EGLStreams 控制内存管理，上层更简单了，每个窗口丢给我一个 texture，我负责安排你们这些 texture 放在哪里，然后我按照我安排的位置，告诉你们鼠标进谁窗口了键盘进谁窗口了。然后因为要把这些 texture 混合到屏幕上，一般都用 OpenGL 的硬件加速，但在 Linux 下创建 OpenGL Context 的 GLX 库是和 X 绑定的，所以一般大家都用 OpenGL ES Context 的库 EGL。这个库只干扰最后合成图片时候的事情，至于你的 texture 用的是 OpenGL 还是 OpenGL ES 还是 CPU 画的都没有关系，现在 Wayland 一概不管了，你自己客户端处理自己的内容吧，我又不是 Xserver！&lt;/p&gt;
&lt;p&gt;所以对于 GNOME 和 KDE 等等而言，现在他们打交道的一个是内核一个是窗口，而不是以前一样和 Xserver 打交道了，省了数据交换，同时自己可以自由控制窗口输入输出面积。Xorg 应该被淘汰不是因为功能性原因，而是因为它的设计在当时很聪明，但现在只是历史包袱，实在太挫了。&lt;/p&gt;
&lt;p&gt;看完这篇文章建议回去阅读开头的两个链接，可以了解更多的实现细节，现在再看就不会那么混乱了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    
    <category term="Wayland" label="Wayland" scheme="https://sh.alynx.one/tags/Wayland/" />
    
  </entry>
  
  
  
  <entry>
    <title>蜗牛星际安装 Arch Linux 作为 NAS</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/SnailSpace-as-NAS/" />
    <id>https://sh.alynx.one/posts/SnailSpace-as-NAS/</id>
    
    <published>2019-10-07T09:01:00.000Z</published>
    
    
    <updated>2019-10-07T09:01:00.000Z</updated>
    
    
    <summary type="html">
      &lt;h1 id=&quot;需求&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E9%9C%80%E6%B1%82&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;
&lt;p&gt;以前我一直使用树莓派 + 移动硬盘做 Samba 服务器，好处是完全静音，功耗很低，但是树莓派 2 的网络性能差强人意，并且 USB 2.0 的速度也赶不上移动硬盘的速度，看电影什么的只是能看，要花好长时间缓冲，并且我一直开着，对树莓派的电源也不是很放心。特别是我还拆下来一块笔记本上的 1TB 机械硬盘，完全没法装在树莓派上。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;h1 id=&quot;需求&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E9%9C%80%E6%B1%82&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;
&lt;p&gt;以前我一直使用树莓派 + 移动硬盘做 Samba 服务器，好处是完全静音，功耗很低，但是树莓派 2 的网络性能差强人意，并且 USB 2.0 的速度也赶不上移动硬盘的速度，看电影什么的只是能看，要花好长时间缓冲，并且我一直开着，对树莓派的电源也不是很放心。特别是我还拆下来一块笔记本上的 1TB 机械硬盘，完全没法装在树莓派上。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;有点想买一台 NAS，但是看看群晖的价格实在接受不能，然后又看到说群晖把系统放在用户的磁盘里加速读写一类的，其实这些对我来说不太重要，但群晖是个定制化程度很高的 Linux，虽然用起来有很多便利的功能，比如官方的内网穿透（服务器似乎在台湾，速度不快），比较成熟的 btrfs 使用之类的，但比起这些我更想要一台全功能的 Linux 服务器，这样不仅可以作为存储，还可以 SSH 连接上去做一些简单工作。作为一个比较熟练的 Linux 用户，我不需要什么 Webui 或者 App 来访问文件，Solid Explorer 和 VLC 组合起来访问 Samba 好用得很。&lt;/p&gt;
&lt;p&gt;机缘巧合我看到隔壁的同学弄了台 D 款的蜗牛星际矿渣，研究一下之后觉得可以上车，正好 Arch CN 群里 &lt;a href=&quot;https://nichi.co/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@NickCao&lt;/a&gt; 打算出掉买了回来没时间玩的蜗牛 A 款，于是坐地铁到五道口一起喝了杯咖啡然后当面交易了一下。&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E4%BB%8B%E7%BB%8D&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;
&lt;p&gt;蜗牛星际的矿渣是怎么来的呢？简单说就是忽悠别人说这个机器可以挖矿，打着区块链旗号骗人买机器，当然这个机器其实并不需要挖矿，所谓的挖矿就是简单的 App，让你以为自己挖出矿了（毕竟宣传说不用插电也能挖），为了降低成本机器全部都是用现成的山寨货，所以机箱造型是 NAS，而且还带硬盘背板，就是因为这个很成熟。成本不到一千块的机器五千块一台卖给受骗者，受骗者为了挖矿都是十几台几十台的买，然后放小道消息说要涨价到八千块榨干受骗者钱包，最后国际惯例圈钱跑路，受骗者血本无归。&lt;/p&gt;
&lt;blockquote class=&quot;center-quote&quot;&gt;做人还是得懂点计算机。&lt;/blockquote&gt;

&lt;p&gt;这个机器有好多型号，细节差距也有很多，网上有现成的帖子分析，我就不分析了，反正我这一台是 A 款单网口绿主板，妥妥的千兆。而且似乎背板有 PCI 槽，不过主板又没有 PCI 接口就不管了。A 款还有个特点是硬盘架侧面可以放个 2.5 寸硬盘，正好装上我拆下来的笔记本硬盘。&lt;/p&gt;
&lt;h1 id=&quot;硬件处理&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E7%A1%AC%E4%BB%B6%E5%A4%84%E7%90%86&quot; title=&quot;硬件处理&quot;&gt;&lt;/a&gt;硬件处理&lt;/h1&gt;
&lt;h2 id=&quot;更换电源&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E6%9B%B4%E6%8D%A2%E7%94%B5%E6%BA%90&quot; title=&quot;更换电源&quot;&gt;&lt;/a&gt;更换电源&lt;/h2&gt;
&lt;p&gt;手头这一台运气比较好，是 zumax 的 150W 电源，虽然都说这个是所有各种电源里最好的，但是接口只是刚刚够，没有多余的，没办法给侧面硬盘供电。再说都是山寨货谁又比谁强到哪里。按照隔壁老司机的推荐淘宝买了益衡 250W 的 Flex 电源（也叫小 1u 电源）替换掉，花了 250 软妹币左右，感觉车速稳了很多，而且多出了许多接口。安装时候需要把原来电源上后面用来装到侧面的铁片拆掉，然后上下翻转才能装上蜗牛里面的支撑片，然后主板有一长一方两个供电口都插上，背板用的大 4pin 接口，不太够长，把卖家赠送的两条大 4pin 延长线都接上就可以了，然后取一个 SATA 供电线给侧面的硬盘。&lt;/p&gt;
&lt;h2 id=&quot;更换风扇&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E6%9B%B4%E6%8D%A2%E9%A3%8E%E6%89%87&quot; title=&quot;更换风扇&quot;&gt;&lt;/a&gt;更换风扇&lt;/h2&gt;
&lt;p&gt;蜗牛自带的风扇声音很大，因此需要更换一个静音风扇，A 款用的是 8cm 的 3pin 风扇，不支持调速，BCD 都是 12cm 的。8cm 不太好买，开始我在京东找到两个超频三的风扇，一个 2200 转一个 1400 转，标定噪音都是 18dB，于是就买了 2200 转，没想到转速上来了噪音也更大，正好之前在淘宝买了另一个超频三皓月（下面上图），1500 转应该问题不大，装上发现声音小了，但是蜗牛背板有个铆钉，这个 LED 风扇尺寸稍微大一点，正好顶着铆钉。没办法还是换了京东 1400 转的那款，噪音合适，尺寸也合适，蜗牛本来发热也不严重。因此 &lt;strong&gt;建议大家购买 1500 转左右不带 LED 灯效正常尺寸的&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;alert-green&quot;&gt;更换时候记得把原来蜗牛风扇上用来防止线缆伸进风扇里的塑料防护片拧下来装到新风扇没有阻拦的一侧，这一侧朝里，安装之后蜗牛向外吹风。&lt;/div&gt;

&lt;div class=&quot;alert-red&quot;&gt;这个防护片不要拧太紧，以免把它拧裂了，这种是和机箱配套卖的，淘宝上有卖那种金属的防护网，但是都是厂家批发，不太好买。&lt;/div&gt;

&lt;p&gt;你问我怎么知道的？当然是大力出悲剧拧裂了然后没办法只能 502 直接粘风扇边上了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再次提醒各位注意不要买下图的带灯条的风扇。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/SnailSpace-as-NAS/1.jpg&quot; alt=&quot;大了一圈的风扇&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/2.jpg&quot; alt=&quot;装上之后的效果&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装侧面25寸硬盘&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E5%AE%89%E8%A3%85%E4%BE%A7%E9%9D%A225%E5%AF%B8%E7%A1%AC%E7%9B%98&quot; title=&quot;安装侧面25寸硬盘&quot;&gt;&lt;/a&gt;安装侧面 2.5 寸硬盘&lt;/h2&gt;
&lt;p&gt;蜗牛自带一个 16G 的 mSATA 硬盘，速度比 U 盘还慢，而且据说用着用着就坏了，很多人都拿这个做引导盘放系统，但我不打算用，直接拧下四个螺丝把主板抽出来，然后拧掉 mSATA 杂牌硬盘。&lt;/p&gt;
&lt;p&gt;因为四个硬盘托连接的 SATA 口是扩展的，不支持引导，但是 &lt;strong&gt;实际上蜗牛主板正中间上还有一个 SATA2 的口可以引导&lt;/strong&gt;，正好连接我的笔记本硬盘，自己插上一根 SATA 线把主板装回去即可。&lt;/p&gt;
&lt;p&gt;硬盘本体安装时候需要两个小螺丝固定硬盘一侧，另外一侧是卡住的，不需要螺丝。然后把电源线和刚才插的 SATA 线插到硬盘上面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/SnailSpace-as-NAS/5.jpg&quot; alt=&quot;笔记本硬盘&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/6.jpg&quot; alt=&quot;安装位置示意&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;仓库盘安装&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E4%BB%93%E5%BA%93%E7%9B%98%E5%AE%89%E8%A3%85&quot; title=&quot;仓库盘安装&quot;&gt;&lt;/a&gt;仓库盘安装&lt;/h2&gt;
&lt;p&gt;我还在京东购买了一块 2TB 的西数紫盘和一块 2TB 的东芝 P300 硬盘，没有买 NAS 专用盘是因为太贵了。而其他便宜的比如西数蓝盘和希捷酷鱼只便宜了十几块，但是却是大缓存叠瓦式（SMR）硬盘，性能非常差，紫盘和 P300 则是标准的 64M 缓存垂直式（PMR）硬盘，价格也比较实惠。建议自行搜索叠瓦式硬盘了解不推荐的原因。&lt;del&gt;考虑了一下还是不做 RAID1 了，经济条件不允许，而且本来 RAID 是为了高可用不是为了备份，如果是硬件损坏估计两块盘一起炸了，不如冷备份&lt;/del&gt; 还是做了 RAID1（真香！）。&lt;/p&gt;
&lt;p&gt;往硬盘架安装硬盘需要四个沉孔螺丝分别锁在两侧，当然我这种硬件渣渣其实是不知道啥是沉孔螺丝的，具体多大多粗我也不懂，我装 2.5 硬盘的螺丝是同学买大疆编程小车多出来的内六角，尺寸正好，至于 3.5 硬盘是隔壁老司机送给我的装机剩下的，反正车速很稳，如果自己买的话京东淘宝好像都有装机用的成套螺丝，建议顺手买一套，不要螺丝钉难倒程序员。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/SnailSpace-as-NAS/4.jpg&quot; alt=&quot;西数带包装&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/14.jpg&quot; alt=&quot;东芝带包装&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/13.jpg&quot; alt=&quot;打开外包装之后&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/12.jpg&quot; alt=&quot;取出来正面&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/11.jpg&quot; alt=&quot;取出来背面&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/10.jpg&quot; alt=&quot;硬盘托侧面螺丝&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/8.jpg&quot; alt=&quot;西数装上硬盘托正面&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/9.jpg&quot; alt=&quot;东芝装上硬盘托正面&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/7.jpg&quot; alt=&quot;从硬盘架上拔出来一半&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;软件处理&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E8%BD%AF%E4%BB%B6%E5%A4%84%E7%90%86&quot; title=&quot;软件处理&quot;&gt;&lt;/a&gt;软件处理&lt;/h1&gt;
&lt;h2 id=&quot;分区&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E5%88%86%E5%8C%BA&quot; title=&quot;分区&quot;&gt;&lt;/a&gt;分区&lt;/h2&gt;
&lt;p&gt;软件部分就十分舒服自在了，接显示器网线键盘开机按 F7 进入 BIOS 设置 UEFI 模式从 U 盘启动，然后进入 Archiso 按照 &lt;a href=&quot;https://wiki.archlinux.org/index.php/Installation_guide&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;安装指南&lt;/a&gt; 安装系统（据说他们最近在处理 base 组，建议随时跟进 wiki，我就不复制了），分区的时候我是在能引导的 2.5 寸硬盘上建立了 ESP，然后其他空间全部用作 LVM，1T 硬盘的剩余空间作为一个 pv，&lt;del&gt;并且给 2T 的硬盘分了三个区做 pv（万一我哪天脑子抽了想缩个分区出来呢？）&lt;/del&gt;，然后建立 vg，建立给根目录和家目录的 lv，然后创建 ext4 文件系统。这一段参照 wiki 对应页面就行了，命令十分简明直观，我第一次用就成功了。配置好的效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/SnailSpace-as-NAS/3.jpg&quot; alt=&quot;分区状况&quot;&gt;&lt;/p&gt;
&lt;p&gt;至于 2T 的硬盘考虑了一下还是打算再加一块硬盘做 RAID1，不然连续跨设备 lvm 坏了一个就全坏了，由于 mdadm 需要两块设备都在才能建立，&lt;del&gt;但我手头只有一块&lt;/del&gt; 决定的时候手头只有一块，于是在 fc 老师建议下决定上 btrfs（而且这货似乎支持多块不同容量硬盘的 RAID1，保证每个文件都在两块盘上有备份）。按照 fc 老师多年使用经验似乎 btrfs 也没那么不可靠。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;然后我在某东买了一块东芝 2T 64M 7200 转的机械硬盘，到手之后打算加入 btrfs 里面，建立 RAID1，btrfs 的好处就在于这个可以先弄一块之后渐进修改，而且看起来目前没什么大问题的样子（按我的理解并行读取的性能问题大概是用来并行加速的，但是实际上 RAID1 不并行读取也可以读出数据吧）。&lt;/del&gt; 虽然我本来也可以把数据移出来然后建 mdadm，但是不排除以后再加盘做 RAID 10，似乎 mdadm 没法直接转换的样子？&lt;/p&gt;
&lt;p&gt;买回来硬盘之后想想反正两块都没啥数据（搬出去了），索性直接格式化成 btrfs，不然也可以在已有一块 btrfs 设备之后 add 然后 balance，就可以修改策为 RAID1，格式化命令很简单就这样：&lt;/p&gt;
&lt;figure data-raw=&quot;# mkfs.btrfs -m raid1 -d raid1 /dev/sdXY /dev/sdZV&quot; data-info=&quot;language-plain&quot; data-lang=&quot;plain&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-plain&quot;&gt;# mkfs.btrfs -m raid1 -d raid1 /dev/sdXY /dev/sdZV&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;-m raid1&lt;/code&gt; 是指 metadata 要做 RAID1 备份，&lt;code&gt;-d raid1&lt;/code&gt; 是指 data 也要 RAID1 备份，然后需要跟两个设备，推荐是一样大的，挂载时候就随便挂一个设备就行了，btrfs 会自己执行 RAID1 策略的。&lt;/p&gt;
&lt;h2 id=&quot;启动配置&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE&quot; title=&quot;启动配置&quot;&gt;&lt;/a&gt;启动配置&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;/etc/mkinitcpio.conf&lt;/code&gt; 里需要给 HOOKS 添加 lvm2，然后运行 &lt;code&gt;mkinitcpio -p linux&lt;/code&gt;，这样生成的 initramfs 才能支持 LVM。我还给 MODULES 添加了和 intel 显卡有关的部分（虽然可能用不到了），具体修改的位置如下：&lt;/p&gt;
&lt;figure data-raw=&quot;MODULES=(intel_agp i915)
HOOKS=(base udev autodetect modconf block lvm2 filesystems keyboard fsck)&quot; data-info=&quot;language-bash&quot; data-lang=&quot;bash&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;MODULES=(intel_agp i915)
HOOKS=(base udev autodetect modconf block lvm2 filesystems keyboard fsck)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;安装 bootloader 的时候我直接用了 systemd-boot，我在自己笔记本上也用的这个，功能够用了就没考虑安装 GRUB，编写 entry 时候内核参数里的 root 可以写 &lt;code&gt;/dev/vg0/rootlv&lt;/code&gt; 也可以写 &lt;code&gt;/dev/mapper/vg0-rootlv&lt;/code&gt;（这里中文 wiki 和英文 wiki 分别是这俩，亲测都可以），比如我的就是下面这样：&lt;/p&gt;
&lt;figure data-raw=&quot;title    Arch Linux
linux    /vmlinuz-linux
initrd    /intel-ucode.img
initrd    /initramfs-linux.img
options    root=/dev/vg0/rootlv rw add_efi_memmap&quot; data-info=&quot;language-plain&quot; data-lang=&quot;plain&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-plain&quot;&gt;title    Arch Linux
linux    /vmlinuz-linux
initrd    /intel-ucode.img
initrd    /initramfs-linux.img
options    root=/dev/vg0/rootlv rw add_efi_memmap&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;最近 systemd-boot 添加了什么校验设置，在蜗牛上会报错，直接 chroot 进去安装根本装不上，临时解决方案是退出 chroot，然后用 Archiso 里的 &lt;code&gt;bootctl&lt;/code&gt; 安装到 &lt;code&gt;/mnt/boot&lt;/code&gt;，虽然有点 dirty，但是能用？不过还是会报个错，但是启动需要的文件已经安装上了，不管它也能用，只不过每次重启还是会说校验失败，目测是个 bug。&lt;/p&gt;
&lt;h2 id=&quot;网络配置&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE&quot; title=&quot;网络配置&quot;&gt;&lt;/a&gt;网络配置&lt;/h2&gt;
&lt;p&gt;然后由于 NAS 的网络不会经常变化，&lt;del&gt;所以联网的部分也直接用 systemd-networkd 管理了，没必要上 NetworkManager&lt;/del&gt; 我装桌面了所以还是用了 NetworkManager！不过这部分也留着好了。直接创建 &lt;code&gt;/etc/systemd/network/wired.network&lt;/code&gt;，写入如下内容：&lt;/p&gt;
&lt;figure data-raw=&quot;[Match]
Name=en*

[Network]
DHCP=ipv4&quot; data-info=&quot;language-ini&quot; data-lang=&quot;ini&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-ini&quot;&gt;[Match]
Name=en*

[Network]
DHCP=ipv4&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;意思是对于所有以 &lt;code&gt;en&lt;/code&gt; 开头的网卡使用 DHCPv4，然后 &lt;code&gt;systemctl enable --now systemd-networkd systemd-resolved&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;NetworkManager 就很简单，直接安装然后 &lt;code&gt;systemctl enable NetworkManager --now&lt;/code&gt; 应该就行了！&lt;/p&gt;
&lt;h2 id=&quot;Samba配置&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#Samba%E9%85%8D%E7%BD%AE&quot; title=&quot;Samba配置&quot;&gt;&lt;/a&gt;Samba 配置&lt;/h2&gt;
&lt;p&gt;btrfs 的子卷看起来很像普通目录，但是又可以分别直接挂载，不需要先挂载设备然后再用 &lt;code&gt;mount --rbind&lt;/code&gt;。于是建了 &lt;code&gt;/data&lt;/code&gt; 和 &lt;code&gt;/data/alynx&lt;/code&gt; 两个子卷，&lt;code&gt;/data&lt;/code&gt; 就挂载到 &lt;code&gt;/data&lt;/code&gt;，&lt;code&gt;/data/alynx&lt;/code&gt; 挂载到我家目录下面。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/etc/samba/smb.conf&lt;/code&gt; 添加如下配置，就可以分别通过 &lt;code&gt;home&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 访问每个用户在 &lt;code&gt;/home&lt;/code&gt; 和 &lt;code&gt;/data&lt;/code&gt; 下面的同名文件夹了，&lt;code&gt;%u&lt;/code&gt; 代表的就是连接的用户名。（当然权限要你自己处理一下。）&lt;/p&gt;
&lt;figure data-raw=&quot;[home]
   comment = Home Directories
   browseable = yes
   writeable = yes
   path = /home/%u

[data]
   comment = Data Directories
   browseable = yes
   writeable = yes
   path = /data/%u&quot; data-info=&quot;language-ini&quot; data-lang=&quot;ini&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-ini&quot;&gt;[home]
   comment = Home Directories
   browseable = yes
   writeable = yes
   path = /home/%u

[data]
   comment = Data Directories
   browseable = yes
   writeable = yes
   path = /data/%u&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;其它的配置基本都是正常操作参照 Arch Wiki，&lt;del&gt;我打算以后插新硬盘直接加进 LVM 加给 &lt;code&gt;/home&lt;/code&gt;，省得还得操心挂载到哪里&lt;/del&gt; 决定单独安排 btrfs 数据区了，参见上面。在外面访问我选择配置 WireGuard，参照我 &lt;a href=&quot;/posts/SnailSpace-as-NAS/WireGuard-Usage/&quot;&gt;这篇文章&lt;/a&gt; 就可以了，如果只是 SSH 远程控制一下效果还可以。&lt;/p&gt;
&lt;h1 id=&quot;效果&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E6%95%88%E6%9E%9C&quot; title=&quot;效果&quot;&gt;&lt;/a&gt;效果&lt;/h1&gt;
&lt;p&gt;笔记本插了有线之后可以测试千兆对拷，我的路由器还是大一时候买的 WNDR3800，虽然很旧，但四个有线全部都是千兆口（当时价格和配置差不多的极路由 3 只有一个内网千兆好像），&lt;del&gt;samba 拷贝速度轻松达到 110M/s 的满速，甚至比蜗牛的 USB3.0 还快&lt;/del&gt; 用了 btrfs 之后似乎速度只有 80M/s 左右了，或者 Windows 和 Linux 下面 Samba 对拷速度显示有区别？110M/s 是我在 Windows 下面测出来的。&lt;/p&gt;
&lt;p&gt;蜗牛后面两个 USB3.0 只有下面的那个是真的，上面的也就 2.0 速度，下面的跑满了也就 80 到 90M/s，我的 U 盘是 CZ80，放笔记本上比这快多了，而且有时候上面那个也可以跑到 70M/s，具体原因不知道，如果是真的土豪建议直接换主板算了，非土豪完全可以插笔记本然后网络拷进蜗牛，比这奇葩接口还快。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/Arch%20Linux/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/tags/Arch%20Linux/" />
    
    <category term="蜗牛星际" label="蜗牛星际" scheme="https://sh.alynx.one/tags/%E8%9C%97%E7%89%9B%E6%98%9F%E9%99%85/" />
    
  </entry>
  
  
  
  <entry>
    <title>前端博客搜索引擎</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Frontend-Blog-Search/" />
    <id>https://sh.alynx.one/posts/Frontend-Blog-Search/</id>
    
    <published>2019-09-18T07:24:00.000Z</published>
    
    
    <updated>2020-08-15T10:25:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;本来我的博客有一个前端搜索框，当输入文字时就在侧边栏展开搜索结果，虽然看起来很时髦，但也不能算是什么食用啊不实用的设计方式。而且一开始我觉得既然没有后端处理请求，也就没法单独打开一个专门搜索页面了。&lt;/p&gt;
&lt;p&gt;但是这个设计引发了 &lt;a href=&quot;https://blog.lilydjwg.me/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@依云&lt;/a&gt; 的吐槽，有一个单独的搜索页面并且对每个搜索结果有专门的 URL 看起来还是个挺合理的需求。但第一我不知道怎么实现第二我一直觉得能用就行所以开始并没有改。不过依云给我发了 Python 文档的搜索实现，让我突然想明白其实按照标准的 HTML 和 JavaScript 是可以实现无后端的搜索引擎的，然后就动手实现了一个。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;本来我的博客有一个前端搜索框，当输入文字时就在侧边栏展开搜索结果，虽然看起来很时髦，但也不能算是什么食用啊不实用的设计方式。而且一开始我觉得既然没有后端处理请求，也就没法单独打开一个专门搜索页面了。&lt;/p&gt;
&lt;p&gt;但是这个设计引发了 &lt;a href=&quot;https://blog.lilydjwg.me/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@依云&lt;/a&gt; 的吐槽，有一个单独的搜索页面并且对每个搜索结果有专门的 URL 看起来还是个挺合理的需求。但第一我不知道怎么实现第二我一直觉得能用就行所以开始并没有改。不过依云给我发了 Python 文档的搜索实现，让我突然想明白其实按照标准的 HTML 和 JavaScript 是可以实现无后端的搜索引擎的，然后就动手实现了一个。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;首先既然要搜索那还是得有个索引或者数据库，比较简单的方案就是把所有文章的标题 URL 和内容丢到一个 json 文件里面，这个功能在 Hexo 里可以使用 &lt;code&gt;hexo-generator-search&lt;/code&gt; 实现，我也给我的 Hikaru 添加了这个生成器，用来生成 JSON。&lt;/p&gt;
&lt;p&gt;首先第一件事是实现搜索跳转页面，这一步只要简单的使用 HTML 表单就能实现，首先将我的搜索框改造为如下格式：&lt;/p&gt;
&lt;figure data-raw=&quot;&lt;form action=&amp;quot;{{ getPath(&amp;quot;search.html&amp;quot;) }}&amp;quot; method=&amp;quot;get&amp;quot;&gt;
  &lt;button type=&amp;quot;submit&amp;quot; class=&amp;quot;search-submit&amp;quot; aria-label=&amp;quot;{{ __(&amp;quot;search&amp;quot;) }}&amp;quot;&gt;
    &lt;i class=&amp;quot;fas fa-search&amp;quot;&gt;&lt;/i&gt;
  &lt;/button&gt;
  &lt;input type=&amp;quot;search&amp;quot; id=&amp;quot;search-input&amp;quot; class=&amp;quot;search-input&amp;quot; name=&amp;quot;q&amp;quot; results=&amp;quot;0&amp;quot; placeholder=&amp;quot;{{ __(&amp;quot;search&amp;quot;) }}&amp;quot; aria-label=&amp;quot;{{ __(&amp;quot;search&amp;quot;) }}&amp;quot;&gt;
&lt;/form&gt;&quot; data-info=&quot;language-html&quot; data-lang=&quot;html&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;form action=&quot;{{ getPath(&quot;search.html&quot;) }}&quot; method=&quot;get&quot;&amp;gt;
  &amp;lt;button type=&quot;submit&quot; class=&quot;search-submit&quot; aria-label=&quot;{{ __(&quot;search&quot;) }}&quot;&amp;gt;
    &amp;lt;i class=&quot;fas fa-search&quot;&amp;gt;&amp;lt;/i&amp;gt;
  &amp;lt;/button&amp;gt;
  &amp;lt;input type=&quot;search&quot; id=&quot;search-input&quot; class=&quot;search-input&quot; name=&quot;q&quot; results=&quot;0&quot; placeholder=&quot;{{ __(&quot;search&quot;) }}&quot; aria-label=&quot;{{ __(&quot;search&quot;) }}&quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;使用 &lt;code&gt;button&lt;/code&gt; 而不是 &lt;code&gt;input&lt;/code&gt; 的原因是我想用我的图标做搜索按钮，反正 &lt;code&gt;&amp;lt;input type=&quot;submit&quot;&amp;gt;&lt;/code&gt; 只是个特化的 &lt;code&gt;button&lt;/code&gt;。理论上来说不放按钮靠回车提交也是 OK，但是觉得这样又会被某些用户批评不友好了……&lt;/p&gt;
&lt;p&gt;搜索框就很简单，&lt;code&gt;name=&quot;q&quot;&lt;/code&gt; 表示生成的 query string 里 keywords 的 key 是 &lt;code&gt;q&lt;/code&gt;，然后按照表单写法会被提交到 &lt;code&gt;search.html&lt;/code&gt;，理论上来说搜索应该发 GET 请求所以就是 &lt;code&gt;method=&quot;get&quot;&lt;/code&gt;，当然 POST 就实现不了复制链接查看搜索结果了。&lt;/p&gt;
&lt;p&gt;这个表单就是标准的 HTML 表单，不需要用 JavaScript 处理。生成的 GET 请求的 URL 类似于 &lt;code&gt;/search.html?q=xxx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后接下来是处理请求了，既然是发送到 &lt;code&gt;search.html&lt;/code&gt;，对于静态后端肯定是要返回这个页面的，那就得先创建页面，然后对这个页面进行特殊处理，这里我同样利用生成器生成一个 layout 设置成 &lt;code&gt;search&lt;/code&gt; 的页面，然后就可以单独给它编写模板添加处理部分了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;search.html&lt;/code&gt; 加载之后是可以通过 &lt;code&gt;window.location.search&lt;/code&gt; 获取到 query string 的，然后我加载我修改过的 &lt;code&gt;search.js&lt;/code&gt;（&lt;a href=&quot;/js/search.js&quot;&gt;这里&lt;/a&gt;），用它处理搜索过程。同时在页面里添加了一个 container 用来放置检索结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;search.js&lt;/code&gt; 其实没什么黑科技，毕竟我们的难点就是在无后端情况下处理关键词和数据库，关键词已经用 &lt;code&gt;window.location.search&lt;/code&gt; 拿到了，解析一下然后只要通过 ajax/fetch 请求数据就行了，封装 ajax 的代码网上到处都是，实在不行用 jQuery 也成。&lt;/p&gt;
&lt;p&gt;然后剔除重复关键词主要是为了优化一下性能，接下来我的解决方案就是简单粗暴 &lt;code&gt;indexOf()&lt;/code&gt;，不要跟我提什么算法什么优化，短平快实现效果，我是个实用主义者，目前这一步其实还没有成为瓶颈。&lt;/p&gt;
&lt;p&gt;然后对于原版文件我的改进主要是按匹配次数排序，文章出现关键词越多则排序越靠前，相对可以提高效率。&lt;/p&gt;
&lt;p&gt;接下来使用正则表达式给关键词加上 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;，这样显示起来比较显眼。最后把字符串拼起来显示就好了。其实这里的算法还有点意思，比如假如两个关键词出现的位置中间大于多少个字符则插入省略号，否则合并两个的上下文，具体实现也可以参照代码。&lt;/p&gt;
&lt;p&gt;如果有性能瓶颈的话，多半也会先出现在 ajax，不过目前我文章还没有多到加载不出来的情况，也许可以靠分块加载解决？&lt;/p&gt;
&lt;p&gt;更新（2020-08-15 18:25:00）：我给代码添加了简单的分块支持。由于这里需要主题和生成器约定好路径，不太适合让生成器自动生成路径，所以采用了一个简单的方法就是让用户在设置文件里手动指定几个 JSON 文件的路径，然后生成器只是读取一下配置，假如是数组就分块写到指定好的路径里面。然后前端查找的时候分别异步查找每个文件并合并排序结果，理论来说大概会有性能提升？&lt;/p&gt;
&lt;p&gt;最后我加了个简单的 SpinKit 动画，在查询结束之前先跑一下提升用户体验。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/ARIA/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="搜索" label="搜索" scheme="https://sh.alynx.one/tags/%E6%90%9C%E7%B4%A2/" />
    
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/tags/JavaScript/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/tags/ARIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>Linux 用户的月饼食用手册</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Linux-Mooncake-Jokes/" />
    <id>https://sh.alynx.one/posts/Linux-Mooncake-Jokes/</id>
    
    <published>2019-09-13T10:47:00.000Z</published>
    
    
    <updated>2019-09-13T10:47:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;中秋节到了，Arch Linux CN 社区里富有生活情趣（？）的用户们聚在一起，开始讨论起如何食用月饼。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;中秋节到了，Arch Linux CN 社区里富有生活情趣（？）的用户们聚在一起，开始讨论起如何食用月饼。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Gentoo 用户需要自己编译月饼，并且可以设置不同的 USE 编译不同口味。（farseerfc，outvi 和 AlynxZhou）&lt;/li&gt;
&lt;li&gt;Debian 用户习惯将月饼拆成月饼馅、月饼皮和月饼油分别打包食用。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Arch Linux 用户喜欢购买 Debian 的月饼，然后将月饼馅、月饼皮和月饼油拆开自行组装并打包。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Manjaro 用戶買來 Arch 組裝好的 Debian 月餅然後敲了個花紋上去重新裝了起來。（farseerfc）&lt;/li&gt;
&lt;li&gt;Manjaro 用户经常吃了 Arch Linux 的月饼然后抱怨这个月饼为什么不是 Manjaro 牌的。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;CentOS 的月饼过期了。（KRyuJo）但总有人喜欢这个传统口味，不想换。甚至有人资助 RedHat 厨师学校传承老字号。（whyme）&lt;/li&gt;
&lt;li&gt;RedHat：我们将通过电话联系在线指导您服用月饼。（ArielAxionL）&lt;/li&gt;
&lt;li&gt;openSUSE 用户也喜欢将月饼拆成月饼馅、月饼皮和月饼油分别打包食用，但他们通常编写一个 &lt;code&gt;月饼.spec&lt;/code&gt; 文件，然后将买来的月饼原料和此文件一同上传到 Open Build Service 而不是自己打包月饼。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;随后 openSUSE 的月饼被冻结了，存放到 SUSE Linux Enterprise 的冰箱里。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Ubuntu 的月饼馅过期了，但是依旧没有更新。（wuliao00）&lt;/li&gt;
&lt;li&gt;Ubuntu 的月饼包装写着豆沙，用户咬了一口发现是五仁，大喊“内部错误！”。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Deepin 用户表示吃月饼时应该配点红酒（wine）。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;LFS 用戶發現需要先自己製作用於製作月餅的工具。（YHNdnzj）然后开始阅读“如何开办一家月饼工厂”。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Antergos 用户收到了一个不幸的消息“此品牌已破产”。（AlynxZhou）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随后话题变得奇怪了起来，不再仅限于常见的 Linux 发行版。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows 10 用户您好！感谢您选购本公司最新发行的月饼，不过要敬告您的是，您的月饼马上就要过期了。（lilydjwg）&lt;/li&gt;
&lt;li&gt;Windows 用户的冰箱被锁死了，因为“Windows 正在等待月饼”。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;iOS 用户只能购买苹果自家的月饼，买别家月饼苹果抽成 30%。（outvi）&lt;/li&gt;
&lt;li&gt;Google 表示对于月饼生产商收取 25 美元的生产费。（AlynxZhou）除非你只吃没有馅料的 YOSP。（oldherl）&lt;/li&gt;
&lt;li&gt;Python 用户用 &lt;code&gt;pip&lt;/code&gt; 安装了一个月饼，然后发现自己安装的月饼明年就过期了。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;NodeJS 用户用 &lt;code&gt;npm&lt;/code&gt; 安装了一个月饼，然后发现整个月饼流水线出现在了自己的厨房里。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Docker 用户发现自己的月饼比别家重很多，但没什么东西，而且吃月饼需要 root。（outvi）&lt;/li&gt;
&lt;li&gt;Nintendo Switch 用户购买了月饼卡带然后由于太苦无法下咽。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Java 用户发现自己需要先安装一个月饼食用环境来食用月饼。（AlynxZhou）特别是还不知道装哪个版本。（outvi）更要命的是还区分 OpenMooncake 和 OracleMooncake。（Rocket1184）&lt;/li&gt;
&lt;li&gt;Steam 用户发现自己的月饼上多了绿色的 -40% 标签。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Epic：月饼独占一年！（KRyuJo）&lt;/li&gt;
&lt;li&gt;Go 用户把所有月饼当作一种月饼（&lt;code&gt;interface {}&lt;/code&gt;）。（Sherlock_Holo）&lt;/li&gt;
&lt;li&gt;Rust 用户表示月饼的保质期很短（离开视线就被 drop 了）。（Sherlock_Holo）Rust 家的月饼可以多人一起看着，但是吃的时候不仅只能有一个人吃，而且别人不能看。有人不信邪，使用 unsafe 魔法看到了正在吃月饼的人，然后整个世界崩塌了。（lilydjwg）&lt;/li&gt;
&lt;li&gt;systemd 用户正在策划将月饼改名为 &lt;code&gt;systemd-月饼&lt;/code&gt; 的投票。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;C++ 用户表示月饼馅还不在厨房里。（wuliao00）建议食用 &lt;code&gt;boost::月饼&lt;/code&gt;。（Rocket1184）&lt;/li&gt;
&lt;li&gt;fish 用户正在重写他们的 &lt;code&gt;/etc/profile&lt;/code&gt;，没有时间吃月饼。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;TensorFlow 用户依赖他们的 NVIDIA GPU 来识别月饼皮上的文字。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;C# 用户的月饼做起来像 Java，吃起来像 Java，区别则是用户嘴里一直喊“我们的月饼比java好，而且终于开源了（一部分）！”。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Vala 用户发现自己的月饼是 GLib 承包给 C 牌月饼的贴牌产品。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;C 用戶不仅要自己制作月饼，还要在月饼制作过程中关注加工机器的操作问题，例如如何防止月饼馅料溢出。更重要的是这些操作都是纯手动完成的。（wnereiz）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/Linux/" />
    
    <category term="笑话" label="笑话" scheme="https://sh.alynx.one/categories/Linux/%E7%AC%91%E8%AF%9D/" />
    
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    
    <category term="月饼" label="月饼" scheme="https://sh.alynx.one/tags/%E6%9C%88%E9%A5%BC/" />
    
  </entry>
  
  
  
  <entry>
    <title>可能只适合我自己的 RIME 配置</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/My-RIME/" />
    <id>https://sh.alynx.one/posts/My-RIME/</id>
    
    <published>2019-08-19T07:16:00.000Z</published>
    
    
    <updated>2019-08-19T07:16:00.000Z</updated>
    
    
    <summary type="html">
      &lt;h1 id=&quot;为什么我要折腾这个&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E6%8A%98%E8%85%BE%E8%BF%99%E4%B8%AA&quot; title=&quot;为什么我要折腾这个&quot;&gt;&lt;/a&gt;为什么我要折腾这个&lt;/h1&gt;
&lt;p&gt;在第 n 次忍受不了 RIME 的奇怪操作逻辑之后，我终于决定彻底教育一下这个不听话的输入法，考虑到已经有 n - 1 次失败的前提，做这个决定并不容易。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;h1 id=&quot;为什么我要折腾这个&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E6%8A%98%E8%85%BE%E8%BF%99%E4%B8%AA&quot; title=&quot;为什么我要折腾这个&quot;&gt;&lt;/a&gt;为什么我要折腾这个&lt;/h1&gt;
&lt;p&gt;在第 n 次忍受不了 RIME 的奇怪操作逻辑之后，我终于决定彻底教育一下这个不听话的输入法，考虑到已经有 n - 1 次失败的前提，做这个决定并不容易。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;首先说明我是 Linux 用户，使用 ibus-rime 做输入引擎，所以使用什么小狼毫鼠须管或者 fcitx-rime 的如果发现不好用最好别烦我，那些我都没用过。（不好意思因为配置这玩意有点暴躁。）&lt;/p&gt;
&lt;p&gt;然后我要吐槽一下 RIME 的文档，完全没有一致的类似 API 手册的东西，而且全繁体加上佛振独特的说话风格读起来真的很累，然后这个项目习惯又是起一大堆奇奇怪怪的名字（虽然我有时候也这样）。假如你想修改一点配置，读了文档里的示例“我懂了，巴拉巴拉”，打开配置一看一堆乱七八糟的就懵了。&lt;/p&gt;
&lt;p&gt;然后就是网上“致第一次用 RIME 的你”、“也致第一次用 RIME 的你”，我都看过了，首先他们不用 ibus-rime，其次文章内容毕竟有限，每个人需求不一样，有些我需要的地方他们一笔带过了。&lt;/p&gt;
&lt;p&gt;RIME 的拼音功能确实很好用（虽然有时候它和我对于词组的想法不太一样），我的需求其实只有几项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一些 RIME 默认的中国人几乎都用不到的中文标点直接改成英文标点，这个在书写 Markdown 的时候简直折磨死我了，有几个人会输入全角井号？？？打个标题真的很麻烦。&lt;/li&gt;
&lt;li&gt;有些符号键在其他输入法里约定俗成的就直接输出特定的中文符号，RIME 的默认操作是弹出选择菜单，完全没这个必要，弹出菜单还需要二次选择而且打断了我的按键操作，需要英文标点时候直接切为英文就好了。&lt;/li&gt;
&lt;li&gt;关掉 RIME 的中英混输功能，在候选框输入英文字母真的很打断思路，我要输入英文要么就是打代码要么就是打单词，反正都不需要输入法，RIME 来就是给我找麻烦。&lt;/li&gt;
&lt;li&gt;还有一些奇奇怪怪的 RIME 的键位设置，偏偏要和其他输入法不一样，我已经习惯了那些操作，RIME 的键位只会降低输入速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面介绍一下我的配置，只需要两个文件就可以，我没有对朙月拼音的配置做修改，只是修改了默认配置。&lt;/p&gt;
&lt;p&gt;首先建立一个干净的 RIME 配置环境，直接移走 &lt;code&gt;~/.config/ibus/rime&lt;/code&gt; 然后执行 &lt;code&gt;ibus-daemon -rdx&lt;/code&gt; 重新生成（就是它文档里扯的部署部署部署）一套配置，由于我用的都是内置输入法所以也不需要什么乱七八糟的东风破 RIME Kit 地球拼音之类的。&lt;/p&gt;
&lt;p&gt;然后你进去 &lt;code&gt;~/.config/ibus/rime&lt;/code&gt; 新版大概有以下几个东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目录 &lt;code&gt;build&lt;/code&gt;：&lt;del&gt;里面放了各种 RIME 的默认配置，我们不需要动这个。&lt;/del&gt; 很好，我搞错了，原来它是从 &lt;code&gt;/usr/share/rime-data/&lt;/code&gt; 和 &lt;code&gt;~/.config/ibus/rime/&lt;/code&gt; 下面加载不带 custom 的文件，然后再读取 custom 文件给之前的文件打 patch，最后生成到 &lt;code&gt;build&lt;/code&gt; 目录下面。&lt;/li&gt;
&lt;li&gt;目录 &lt;code&gt;luna_pinyin.userdb&lt;/code&gt;：看起来像是朙月拼音的词库，当然也不用修改。&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;installation.yaml&lt;/code&gt;：我猜不用管。&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;user.yaml&lt;/code&gt;：我猜也不用管。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;各种乱七八糟操作逻辑的配置&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E5%90%84%E7%A7%8D%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E6%93%8D%E4%BD%9C%E9%80%BB%E8%BE%91%E7%9A%84%E9%85%8D%E7%BD%AE&quot; title=&quot;各种乱七八糟操作逻辑的配置&quot;&gt;&lt;/a&gt;各种乱七八糟操作逻辑的配置&lt;/h1&gt;
&lt;p&gt;按照 RIME 打 patch 的配置方式我们需要在这个目录下创建一个叫 &lt;code&gt;default.custom.yaml&lt;/code&gt; 的文件，这样就可以给 &lt;code&gt;/usr/share/rime-data/default.yaml&lt;/code&gt; 这个文件 patch 辣，当然你得先会写 YAML。第一行首先写个叫 &lt;code&gt;patch:&lt;/code&gt; 的 key，RIME 要求这样，所有的自定义配置都是在 &lt;code&gt;patch&lt;/code&gt; 字段下面。&lt;/p&gt;
&lt;p&gt;怎么确定要修改的 key 名字呢？&lt;del&gt;我这里的都是在 &lt;code&gt;build/default.yaml&lt;/code&gt; 下面找到的，&lt;/del&gt; 因为 patch 的是 &lt;code&gt;/usr/share/rime-data/default.yaml&lt;/code&gt; 所以就去看这个辣，之前又写错了，那个其实是生成的文件。你也可以试试其他的 YAML 文件。&lt;/p&gt;
&lt;p&gt;RIME 的文档说什么要用 &lt;code&gt;/&lt;/code&gt; 把不同层次的 key 折叠成一个比如 &lt;code&gt;ascii_composer/switch_key&lt;/code&gt;，亲测无所谓，我就爱展开了写完整的 YAML，这样更规范。&lt;/p&gt;
&lt;p&gt;然后首先第一步我要修改输入法列表，我只用朙月拼音简化字模式就行了：&lt;/p&gt;
&lt;figure data-raw=&quot;patch:
  schema_list:
    - schema: &amp;quot;luna_pinyin_simp&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;patch:
  schema_list:
    - schema: &quot;luna_pinyin_simp&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后就是改掉那个自作聪明的英文输入模式：&lt;/p&gt;
&lt;figure data-raw=&quot;  ascii_composer:
    # 按 CapsLock 输出大写英文字母。
    good_old_caps_lock: true
    # `inline_ascii` 在输入框内插入英文。
    # `commit_text` 候选文字上屏并切换至英文。
    # `commit_code` 输入拼音上屏并切换至英文。
    # `clear` 清除拼音并切换至英文。
    # `noop` 屏蔽此按键。
    switch_key:
      # 如果你设置 `Caps_Lock` 为 `noop`，
      # 一个奇怪的问题是退格键不能用了，除非取消大写锁定。
      # 所以我直接设置文字上屏了。
      Caps_Lock: &amp;quot;commit_text&amp;quot;
      Shift_L: &amp;quot;commit_code&amp;quot;
      Shift_R: &amp;quot;commit_code&amp;quot;
      Control_L: &amp;quot;noop&amp;quot;
      Control_R: &amp;quot;noop&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  ascii_composer:
    # 按 CapsLock 输出大写英文字母。
    good_old_caps_lock: true
    # `inline_ascii` 在输入框内插入英文。
    # `commit_text` 候选文字上屏并切换至英文。
    # `commit_code` 输入拼音上屏并切换至英文。
    # `clear` 清除拼音并切换至英文。
    # `noop` 屏蔽此按键。
    switch_key:
      # 如果你设置 `Caps_Lock` 为 `noop`，
      # 一个奇怪的问题是退格键不能用了，除非取消大写锁定。
      # 所以我直接设置文字上屏了。
      Caps_Lock: &quot;commit_text&quot;
      Shift_L: &quot;commit_code&quot;
      Shift_R: &quot;commit_code&quot;
      Control_L: &quot;noop&quot;
      Control_R: &quot;noop&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;大部分坑我都写在注释里了可以自己看。&lt;/p&gt;
&lt;p&gt;然后我看那个设置选单也不是很爽，我习惯简体字，这个也可以自己改：&lt;/p&gt;
&lt;figure data-raw=&quot;  switcher:
    # 改掉原来的繁体字标题。
    caption: &amp;quot;【设置菜单】&amp;quot;
    # 用半角斜线而不是奇丑无比的全角斜线做分隔符。
    option_list_separator: &amp;quot;/&amp;quot;
    # 屏蔽 Ctrl-s 开启菜单，只允许 Ctrl-` 和 F4。
    hotkeys:
      # - &amp;quot;Control+s&amp;quot;
      - &amp;quot;Control+grave&amp;quot;
      - &amp;quot;F4&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  switcher:
    # 改掉原来的繁体字标题。
    caption: &quot;【设置菜单】&quot;
    # 用半角斜线而不是奇丑无比的全角斜线做分隔符。
    option_list_separator: &quot;/&quot;
    # 屏蔽 Ctrl-s 开启菜单，只允许 Ctrl-` 和 F4。
    hotkeys:
      # - &quot;Control+s&quot;
      - &quot;Control+grave&quot;
      - &quot;F4&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后就是改掉它奇怪的键位，Emacs 键位挺好的，但是有几个不知道为什么用不了，再者就是为什么按向左是跳一个字拼音向右是跳一个字母？&lt;/p&gt;
&lt;figure data-raw=&quot;  key_binder:
    bindings:
      # Emacs 键位，我喜欢。
      # 可是谁给我解释一下为什么 Left 是按字拼音跳而 Right 是按字母跳？
      - accept: &amp;quot;Control+p&amp;quot;
        send: &amp;quot;Up&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+n&amp;quot;
        send: &amp;quot;Down&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+b&amp;quot;
        send: &amp;quot;Left&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+f&amp;quot;
        send: &amp;quot;Right&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Alt+b&amp;quot;
        send: &amp;quot;Shift+Left&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Alt+f&amp;quot;
        send: &amp;quot;Shift+Right&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+a&amp;quot;
        send: &amp;quot;Home&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+e&amp;quot;
        send: &amp;quot;End&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+d&amp;quot;
        send: &amp;quot;Delete&amp;quot;
        when: &amp;quot;composing&amp;quot;
      # 这个用不了，不过估计也用不到。
      # - accept: &amp;quot;Control+k&amp;quot;
      #   send: &amp;quot;Shift+Delete&amp;quot;
      #   when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+h&amp;quot;
        send: &amp;quot;BackSpace&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Alt+h&amp;quot;
        send: &amp;quot;Shift+BackSpace&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+g&amp;quot;
        send: &amp;quot;Escape&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+bracketleft&amp;quot;
        send: &amp;quot;Escape&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Alt+v&amp;quot;
        send: &amp;quot;Page_Up&amp;quot;
        when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Control+v&amp;quot;
        send: &amp;quot;Page_Down&amp;quot;
        when: &amp;quot;composing&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  key_binder:
    bindings:
      # Emacs 键位，我喜欢。
      # 可是谁给我解释一下为什么 Left 是按字拼音跳而 Right 是按字母跳？
      - accept: &quot;Control+p&quot;
        send: &quot;Up&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+n&quot;
        send: &quot;Down&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+b&quot;
        send: &quot;Left&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+f&quot;
        send: &quot;Right&quot;
        when: &quot;composing&quot;
      - accept: &quot;Alt+b&quot;
        send: &quot;Shift+Left&quot;
        when: &quot;composing&quot;
      - accept: &quot;Alt+f&quot;
        send: &quot;Shift+Right&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+a&quot;
        send: &quot;Home&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+e&quot;
        send: &quot;End&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+d&quot;
        send: &quot;Delete&quot;
        when: &quot;composing&quot;
      # 这个用不了，不过估计也用不到。
      # - accept: &quot;Control+k&quot;
      #   send: &quot;Shift+Delete&quot;
      #   when: &quot;composing&quot;
      - accept: &quot;Control+h&quot;
        send: &quot;BackSpace&quot;
        when: &quot;composing&quot;
      - accept: &quot;Alt+h&quot;
        send: &quot;Shift+BackSpace&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+g&quot;
        send: &quot;Escape&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+bracketleft&quot;
        send: &quot;Escape&quot;
        when: &quot;composing&quot;
      - accept: &quot;Alt+v&quot;
        send: &quot;Page_Up&quot;
        when: &quot;composing&quot;
      - accept: &quot;Control+v&quot;
        send: &quot;Page_Down&quot;
        when: &quot;composing&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;还没完，我觉得正常人不会用 Tab 在拼音之间切换，除非你一次输入一句话（那你不觉得候选框太小了看着累吗？？？），设置 Tab 为跳候选词更自然一点，但我也不知道为什么 Shift-Tab 用不了：&lt;/p&gt;
&lt;figure data-raw=&quot;      # 正常人不会用 Tab 切换拼音光标的，相信我。用它切换选项更快。
      # - accept: &amp;quot;ISO_Left_Tab&amp;quot;
      #   send: &amp;quot;Shift+Left&amp;quot;
      #   when: &amp;quot;composing&amp;quot;
      # - accept: &amp;quot;Shift+Tab&amp;quot;
      #   send: &amp;quot;Shift+Left&amp;quot;
      #   when: &amp;quot;composing&amp;quot;
      # - accept: &amp;quot;Tab&amp;quot;
      #   send: &amp;quot;Shift+Right&amp;quot;
      #   when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Tab&amp;quot;
        send: &amp;quot;Down&amp;quot;
        when: &amp;quot;has_menu&amp;quot;
      - accept: &amp;quot;ISO_Left_Tab&amp;quot;
        send: &amp;quot;Up&amp;quot;
        when: &amp;quot;has_menu&amp;quot;
      # 鬼知道为什么这个也用不了！
      - accept: &amp;quot;Shift+Tab&amp;quot;
        send: &amp;quot;Up&amp;quot;
        when: &amp;quot;has_menu&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;      # 正常人不会用 Tab 切换拼音光标的，相信我。用它切换选项更快。
      # - accept: &quot;ISO_Left_Tab&quot;
      #   send: &quot;Shift+Left&quot;
      #   when: &quot;composing&quot;
      # - accept: &quot;Shift+Tab&quot;
      #   send: &quot;Shift+Left&quot;
      #   when: &quot;composing&quot;
      # - accept: &quot;Tab&quot;
      #   send: &quot;Shift+Right&quot;
      #   when: &quot;composing&quot;
      - accept: &quot;Tab&quot;
        send: &quot;Down&quot;
        when: &quot;has_menu&quot;
      - accept: &quot;ISO_Left_Tab&quot;
        send: &quot;Up&quot;
        when: &quot;has_menu&quot;
      # 鬼知道为什么这个也用不了！
      - accept: &quot;Shift+Tab&quot;
        send: &quot;Up&quot;
        when: &quot;has_menu&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;以及我觉得正常人不用逗号和句号翻页，毕竟下面的默认设置是逗号句号直接上屏，你设置了翻页也没啥卵用，反正我用减号等号或者上下，不过方括号也不错就是了：&lt;/p&gt;
&lt;figure data-raw=&quot;      - accept: &amp;quot;minus&amp;quot;
        send: &amp;quot;Page_Up&amp;quot;
        when: &amp;quot;has_menu&amp;quot;
      - accept: &amp;quot;equal&amp;quot;
        send: &amp;quot;Page_Down&amp;quot;
        when: &amp;quot;has_menu&amp;quot;
      - accept: &amp;quot;bracketleft&amp;quot;
        send: &amp;quot;Page_Up&amp;quot;
        when: &amp;quot;has_menu&amp;quot;
      - accept: &amp;quot;bracketright&amp;quot;
        send: &amp;quot;Page_Down&amp;quot;
        when: &amp;quot;has_menu&amp;quot;
      # 我觉得正常人不应该用逗号和句号翻页。
      # - accept: &amp;quot;comma&amp;quot;
      #   send: &amp;quot;Page_Up&amp;quot;
      #   when: &amp;quot;paging&amp;quot;
      # - accept: &amp;quot;period&amp;quot;
      #   send: &amp;quot;Page_Down&amp;quot;
      #   when: &amp;quot;has_menu&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;      - accept: &quot;minus&quot;
        send: &quot;Page_Up&quot;
        when: &quot;has_menu&quot;
      - accept: &quot;equal&quot;
        send: &quot;Page_Down&quot;
        when: &quot;has_menu&quot;
      - accept: &quot;bracketleft&quot;
        send: &quot;Page_Up&quot;
        when: &quot;has_menu&quot;
      - accept: &quot;bracketright&quot;
        send: &quot;Page_Down&quot;
        when: &quot;has_menu&quot;
      # 我觉得正常人不应该用逗号和句号翻页。
      # - accept: &quot;comma&quot;
      #   send: &quot;Page_Up&quot;
      #   when: &quot;paging&quot;
      # - accept: &quot;period&quot;
      #   send: &quot;Page_Down&quot;
      #   when: &quot;has_menu&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;最后就是那一堆乱七八糟的快捷键了，鬼才记得住，有那时间直接翻菜单就行了，那个 Shift+Space 就是我动不动就变成全角的罪魁祸首，全部不要：&lt;/p&gt;
&lt;figure data-raw=&quot;      # 鬼才记得住这么多乱七八糟的快捷键，我翻菜单比背这玩意快多了。
      # - accept: &amp;quot;Control+Shift+1&amp;quot;
      #   select: &amp;quot;.next&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+2&amp;quot;
      #   toggle: &amp;quot;ascii_mode&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+3&amp;quot;
      #   toggle: &amp;quot;full_shape&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+4&amp;quot;
      #   toggle: simplification
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+5&amp;quot;
      #   toggle: &amp;quot;extended_charset&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+exclam&amp;quot;
      #   select: &amp;quot;&amp;quot;.next&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+at&amp;quot;
      #   toggle: &amp;quot;ascii_mode&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+numbersign&amp;quot;
      #   toggle: &amp;quot;full_shape&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+dollar&amp;quot;
      #   toggle: &amp;quot;simplification&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+Shift+percent&amp;quot;
      #   toggle: &amp;quot;extended_charset&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # 你就是那个经常害我变成全角的罪魁祸首！
      # - accept: &amp;quot;Shift+space&amp;quot;
      #   toggle: &amp;quot;full_shape&amp;quot;
      #   when: &amp;quot;always&amp;quot;
      # - accept: &amp;quot;Control+period&amp;quot;
      #   toggle: &amp;quot;ascii_punct&amp;quot;
      #   when: &amp;quot;always&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;      # 鬼才记得住这么多乱七八糟的快捷键，我翻菜单比背这玩意快多了。
      # - accept: &quot;Control+Shift+1&quot;
      #   select: &quot;.next&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+2&quot;
      #   toggle: &quot;ascii_mode&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+3&quot;
      #   toggle: &quot;full_shape&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+4&quot;
      #   toggle: simplification
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+5&quot;
      #   toggle: &quot;extended_charset&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+exclam&quot;
      #   select: &quot;&quot;.next&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+at&quot;
      #   toggle: &quot;ascii_mode&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+numbersign&quot;
      #   toggle: &quot;full_shape&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+dollar&quot;
      #   toggle: &quot;simplification&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+Shift+percent&quot;
      #   toggle: &quot;extended_charset&quot;
      #   when: &quot;always&quot;
      # 你就是那个经常害我变成全角的罪魁祸首！
      # - accept: &quot;Shift+space&quot;
      #   toggle: &quot;full_shape&quot;
      #   when: &quot;always&quot;
      # - accept: &quot;Control+period&quot;
      #   toggle: &quot;ascii_punct&quot;
      #   when: &quot;always&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我自己是不习惯写 inline 的字典和列表，都写的展开的。&lt;/p&gt;
&lt;p&gt;然后是符号设置了，因为我们上面取消了逗号句号翻页，所以这里也就不用显式写 commit 直接上屏了。然后我去掉了一大堆菜单，我输入井号星号波浪线百分号就是想要英文标点，你给我弹个菜单我还得多确认好麻烦的。以及我觉得真的没人用那个巨长的全角斜杠，输入斜杠就是为了斜杠，什么通过朙月拼音命令输入假名有意义吗？我为什么不直接切日语输入法呢？另一些标点在中文语境下直接输出中文标点就好了，需要英文标点时候我敲一下 Shift 比看菜单选容易多了！比如书名号，竖线输出人名中间的点，反斜杠输出顿号之类的。&lt;/p&gt;
&lt;p&gt;由于我不是金融行业的，我就把一些英文标点常见但对应中文标点也可能会用到的都丢到了 &lt;code&gt;$&lt;/code&gt; 的菜单里面：&lt;/p&gt;
&lt;figure data-raw=&quot;  # 为了方便编写 Markdown，把一些奇怪的写中文根本用不到的符号弹出菜单改成直接输出英文符号。
  # 另一些直接默认输出中文符号，需要英文符号可以切换英文输入。
  # 有关 `&amp;quot;!&amp;quot;: {commit: &amp;quot;！&amp;quot;}` 的写法含义是你设置这个键为翻页按键了，
  # 但是你又想在输入拼音出现选单之后输入这个按键直接上屏（常见的逗号句号问号叹号），
  # 我觉得这是多此一举，为什么你非要拿这几个符号翻页？反正我不用。
  # 乱七八糟的符号都塞给 `$` 就好了反正我不是会计不用天天输入 `￥`。
  punctuator:
    # 我不会使用全角英文的，我觉得其他程序员也不会。
    # 但是中文的标点又是全角的，所以我就只留下半角然后改它的标点。
    half_shape:
      &amp;quot;!&amp;quot;: &amp;quot;！&amp;quot;
      &amp;quot;\&amp;quot;&amp;quot;:
        pair:
          - &amp;quot;“&amp;quot;
          - &amp;quot;”&amp;quot;
      &amp;quot;#&amp;quot;: &amp;quot;#&amp;quot;
      &amp;quot;$&amp;quot;:
        - &amp;quot;￥&amp;quot;
        - &amp;quot;$&amp;quot;
        - &amp;quot;€&amp;quot;
        - &amp;quot;～&amp;quot;
        - &amp;quot;×&amp;quot;
        - &amp;quot;÷&amp;quot;
        - &amp;quot;°&amp;quot;
        - &amp;quot;℃&amp;quot;
        - &amp;quot;‰&amp;quot;
        - &amp;quot;‱&amp;quot;
        - &amp;quot;℉&amp;quot;
        - &amp;quot;©&amp;quot;
        - &amp;quot;®&amp;quot;
      &amp;quot;%&amp;quot;: &amp;quot;%&amp;quot;
      &amp;quot;&amp;amp;&amp;quot;: &amp;quot;&amp;amp;&amp;quot;
      &amp;quot;&#039;&amp;quot;:
        pair:
          - &amp;quot;‘&amp;quot;
          - &amp;quot;’&amp;quot;
      &amp;quot;*&amp;quot;: &amp;quot;*&amp;quot;
      &amp;quot;+&amp;quot;: &amp;quot;+&amp;quot;
      &amp;quot;,&amp;quot;: &amp;quot;，&amp;quot;
      &amp;quot;-&amp;quot;: &amp;quot;-&amp;quot;
      &amp;quot;.&amp;quot;: &amp;quot;。&amp;quot;
      &amp;quot;/&amp;quot;: &amp;quot;/&amp;quot;
      &amp;quot;\\&amp;quot;: &amp;quot;、&amp;quot;
      &amp;quot;:&amp;quot;: &amp;quot;：&amp;quot;
      &amp;quot;;&amp;quot;: &amp;quot;；&amp;quot;
      &amp;quot;=&amp;quot;: &amp;quot;=&amp;quot;
      &amp;quot;?&amp;quot;: &amp;quot;？&amp;quot;
      &amp;quot;@&amp;quot;: &amp;quot;@&amp;quot;
      &amp;quot;(&amp;quot;: &amp;quot;（&amp;quot;
      &amp;quot;)&amp;quot;: &amp;quot;）&amp;quot;
      &amp;quot;[&amp;quot;: &amp;quot;【&amp;quot;
      &amp;quot;]&amp;quot;: &amp;quot;】&amp;quot;
      &amp;quot;{&amp;quot;: &amp;quot;「&amp;quot;
      &amp;quot;}&amp;quot;: &amp;quot;」&amp;quot;
      &amp;quot;&lt;&amp;quot;: &amp;quot;《&amp;quot;
      &amp;quot;&gt;&amp;quot;: &amp;quot;》&amp;quot;
      &amp;quot;^&amp;quot;: &amp;quot;……&amp;quot;
      &amp;quot;_&amp;quot;: &amp;quot;——&amp;quot;
      &amp;quot;`&amp;quot;: &amp;quot;`&amp;quot;
      &amp;quot;|&amp;quot;: &amp;quot;·&amp;quot;
      &amp;quot;~&amp;quot;: &amp;quot;~&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  # 为了方便编写 Markdown，把一些奇怪的写中文根本用不到的符号弹出菜单改成直接输出英文符号。
  # 另一些直接默认输出中文符号，需要英文符号可以切换英文输入。
  # 有关 `&quot;!&quot;: {commit: &quot;！&quot;}` 的写法含义是你设置这个键为翻页按键了，
  # 但是你又想在输入拼音出现选单之后输入这个按键直接上屏（常见的逗号句号问号叹号），
  # 我觉得这是多此一举，为什么你非要拿这几个符号翻页？反正我不用。
  # 乱七八糟的符号都塞给 `$` 就好了反正我不是会计不用天天输入 `￥`。
  punctuator:
    # 我不会使用全角英文的，我觉得其他程序员也不会。
    # 但是中文的标点又是全角的，所以我就只留下半角然后改它的标点。
    half_shape:
      &quot;!&quot;: &quot;！&quot;
      &quot;\&quot;&quot;:
        pair:
          - &quot;“&quot;
          - &quot;”&quot;
      &quot;#&quot;: &quot;#&quot;
      &quot;$&quot;:
        - &quot;￥&quot;
        - &quot;$&quot;
        - &quot;€&quot;
        - &quot;～&quot;
        - &quot;×&quot;
        - &quot;÷&quot;
        - &quot;°&quot;
        - &quot;℃&quot;
        - &quot;‰&quot;
        - &quot;‱&quot;
        - &quot;℉&quot;
        - &quot;©&quot;
        - &quot;®&quot;
      &quot;%&quot;: &quot;%&quot;
      &quot;&amp;amp;&quot;: &quot;&amp;amp;&quot;
      &quot;&#039;&quot;:
        pair:
          - &quot;‘&quot;
          - &quot;’&quot;
      &quot;*&quot;: &quot;*&quot;
      &quot;+&quot;: &quot;+&quot;
      &quot;,&quot;: &quot;，&quot;
      &quot;-&quot;: &quot;-&quot;
      &quot;.&quot;: &quot;。&quot;
      &quot;/&quot;: &quot;/&quot;
      &quot;\\&quot;: &quot;、&quot;
      &quot;:&quot;: &quot;：&quot;
      &quot;;&quot;: &quot;；&quot;
      &quot;=&quot;: &quot;=&quot;
      &quot;?&quot;: &quot;？&quot;
      &quot;@&quot;: &quot;@&quot;
      &quot;(&quot;: &quot;（&quot;
      &quot;)&quot;: &quot;）&quot;
      &quot;[&quot;: &quot;【&quot;
      &quot;]&quot;: &quot;】&quot;
      &quot;{&quot;: &quot;「&quot;
      &quot;}&quot;: &quot;」&quot;
      &quot;&amp;lt;&quot;: &quot;《&quot;
      &quot;&amp;gt;&quot;: &quot;》&quot;
      &quot;^&quot;: &quot;……&quot;
      &quot;_&quot;: &quot;——&quot;
      &quot;`&quot;: &quot;`&quot;
      &quot;|&quot;: &quot;·&quot;
      &quot;~&quot;: &quot;~&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;总之写完这些配置 &lt;strong&gt;之后要手动移除 &lt;code&gt;~/.config/ibus/rime/build/&lt;/code&gt; 这个生成目录&lt;/strong&gt; 再执行 &lt;code&gt;ibus-daemon -rdx&lt;/code&gt; 就可以应用了，现在 RIME 用起来就更让我愉快了，接下来就是慢慢养词库就行了。&lt;/p&gt;
&lt;h1 id=&quot;有关为什么ibus-rime总是竖着的&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E6%9C%89%E5%85%B3%E4%B8%BA%E4%BB%80%E4%B9%88ibus-rime%E6%80%BB%E6%98%AF%E7%AB%96%E7%9D%80%E7%9A%84&quot; title=&quot;有关为什么ibus-rime总是竖着的&quot;&gt;&lt;/a&gt;有关为什么 ibus-rime 总是竖着的&lt;/h1&gt;
&lt;p&gt;ibus-rime 是读取 rime 配置而不是 ibus 配置来设置横竖这一点本身就很离谱了，然后由于 bug 啦其他奇奇怪怪的原因啦好像很难搞清楚，我最近终于搞清楚啦！其实也不是很麻烦。&lt;/p&gt;
&lt;p&gt;ibus-rime 会读一个叫做 &lt;code&gt;ibus_rime.yaml&lt;/code&gt; 的配置文件，有这么一个配置可以让他变成横着的：&lt;/p&gt;
&lt;figure data-raw=&quot;style:
  horizontal: true&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;style:
  horizontal: true&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;可能看了之前的你会和我一样想那就打个 patch 到 &lt;code&gt;ibus_rime.custom.yaml&lt;/code&gt; 不就行了嘛！但是不行，为什么呢？因为不管是 rime 还是 librime 还是 ibus-rime 都没有提供 &lt;code&gt;/usr/share/rime-data/ibus_rime.yaml&lt;/code&gt; 的文件，所以你的 patch 找不到被打的文件，那就不会被生成到 &lt;code&gt;build&lt;/code&gt; 目录里。&lt;/p&gt;
&lt;p&gt;不要忘了之前说 rime 会读取 &lt;code&gt;~/.config/ibus/rime/&lt;/code&gt; 下面的 yaml，所以其实只要自己建立 &lt;code&gt;~/.config/ibus/rime/ibus_rime.yaml&lt;/code&gt; 写入那段配置就可以啦，因为本来也没有所以就不用打 patch 了，或者你在那两个位置建立一个空的 &lt;code&gt;ibus_rime.yaml&lt;/code&gt; 然后再打 patch 也行……&lt;/p&gt;
&lt;p&gt;不要忘了删掉 &lt;code&gt;build&lt;/code&gt; 目录再 &lt;code&gt;ibus-daemon -rdx&lt;/code&gt;。&lt;/p&gt;
&lt;h1 id=&quot;下载&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E4%B8%8B%E8%BD%BD&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h1&gt;
&lt;p&gt;如果你想试一试我的配置，其实就两个文件，&lt;a href=&quot;/posts/My-RIME/default.custom.yaml&quot;&gt;default.custom.yaml&lt;/a&gt; 和 &lt;a href=&quot;/posts/My-RIME/ibus_rime.yaml&quot;&gt;ibus_rime.yaml&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="输入法" label="输入法" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BE%93%E5%85%A5%E6%B3%95/" />
    
    <category term="RIME" label="RIME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BE%93%E5%85%A5%E6%B3%95/RIME/" />
    
    
    <category term="输入法" label="输入法" scheme="https://sh.alynx.one/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" />
    
    <category term="RIME" label="RIME" scheme="https://sh.alynx.one/tags/RIME/" />
    
  </entry>
  
  
  
  <entry>
    <title>翻译：我很幸运，但你不是。</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/I-Am-Lucky-You-Are-Not/" />
    <id>https://sh.alynx.one/posts/I-Am-Lucky-You-Are-Not/</id>
    
    <published>2019-07-31T07:24:00.000Z</published>
    
    
    <updated>2019-07-31T07:24:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;这是一篇 &lt;a href=&quot;https://dev.to/jeromegamez&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Jérôme Gamez&lt;/a&gt; 的文章 &lt;a href=&quot;https://dev.to/jeromegamez/i-am-lucky-you-are-not-2eco&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;I am lucky, you are not.&lt;/a&gt; 的简体中文翻译。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;这是一篇 &lt;a href=&quot;https://dev.to/jeromegamez&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Jérôme Gamez&lt;/a&gt; 的文章 &lt;a href=&quot;https://dev.to/jeromegamez/i-am-lucky-you-are-not-2eco&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;I am lucky, you are not.&lt;/a&gt; 的简体中文翻译。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;你好，我的名字是杰罗姆（Jérôme）！对于分享名字我感觉很自在，因为我住在德国，并且我也不总是对我们国家的政府感到高兴。&lt;/p&gt;
&lt;p&gt;对于我能公开谈论此类事情，而不需要感到对我的言论产生的反响感到恐惧，我感觉很幸运。并且我拥有 &lt;em&gt;甚至都不需要考虑&lt;/em&gt; 需要考虑我有多么幸运的奢侈的权利（这里的重复是有意为之）。&lt;/p&gt;
&lt;p&gt;通过最近在 &lt;a href=&quot;https://discord.gg/nbgVfty&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Discord 社区&lt;/a&gt; 有关 &lt;a href=&quot;https://github.com/kreait/firebase-php&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;PHP 的 Firebase Admin SDK&lt;/a&gt; 的讨论，我才意识到以上这些事情。&lt;/p&gt;
&lt;p&gt;某位成员试图通过这个 SDK 去访问 Firebase API，但是却触发了一个既没有详细信息也没有说明错误来源的异常。事实上原因是因为他们在中国而且忘记了给代码运行的环境设置代理。是个可以修复的问题。&lt;/p&gt;
&lt;p&gt;当我在忙于在 SDK 里实现连接错误处理的时候（这是一件我以往甚至没有考虑过去做的事情，因为我在一个很幸运的位置，处于一个拥有普及且无限制的互联网连接的国家里），另一位社区成员补充说到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@jeromegamez：看看我处在一个多么令人愉悦的情形：由于美国贸易管制法律限制，您的 GitHub 账户已被限制。对于个人账户，您可能仅仅拥有用于个人交流的对于免费的 GitHub 公开仓库服务的受限访问权限。请阅读有关 GitHub 和贸易管制的文章以获取更多信息。如果您确信您的账户是被错误地标为受限，请发起申诉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他们曾经有某次在自己祖国不通过 VPN 或代理直接访问 GitHub，然后立刻被标为受限，现在无法访问自己的私有仓库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这太差劲了……你们会为这个申请判决吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是这样幼稚地回复的，没意识到他们的申诉当然无法成功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@jeromegamez：非常不幸，你没法选择在哪出生！在大概 200 来个国家里面我就处在一个疯狂的国家里。在内部的审查制度和制裁开始之后我通常使用 VPN，拿 whatsapp 举例，有些时候我没法上传图片于是我需要使用代理或 VPN。正常来说你可以通过使用 VPN 来使用像 Nvidia.com 或者 Android.developers.com 等等国际服务，但是这次不太一样，如果你曾经用某些地方的 IP 地址访问过他们的服务，他们直接阻拦你自己。至少我仍然可以使用公开仓库，并且希望我能备份我的私有仓库！
至于申请判决，作为这些国家的公民我没法做这件事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在私有频道继续了我们的对话，他们和我聊了他们出身的国家（这是个通常让他们感到不适的话题），他们为此努力并且在公开频道展示了这些以便引起注意。&lt;/p&gt;
&lt;p&gt;人们像我一样（特别来说像我：白人、男性、欧洲人、有一份薪水不错的工作并且可以访问任何我需要和大部分想要的事物）看待这个世界并且对在一些令人不那么舒适的地方正在发生的事情感到不满和恐惧。&lt;/p&gt;
&lt;p&gt;但是还有可能成为更令人不适、敌对或者危险的地方，并且像你或我一样的人正在那生活。&lt;/p&gt;
&lt;p&gt;当我在为了躲避酷暑而努力时，有些人在努力谋生。&lt;/p&gt;
&lt;p&gt;当我因为不能在互联网平台上使用我中意的用户名而感到气愤时，有些人在确保他们的用户名不会透露太多他们的个人信息。&lt;/p&gt;
&lt;p&gt;当政府 A 在制裁国家 B，在制裁导致的后果中挣扎的是那些国家的平民百姓，而不是领导者。&lt;/p&gt;
&lt;p&gt;当我在尽力唤起人们注意的时候，有些人在尽力活下去。&lt;/p&gt;
&lt;p&gt;这不代表我们的个人问题是不相干的，但我认为，认识到我们中的大多数是幸运地出生在一个好地方，并且也有好多人不像我们这么幸运，是十分重要的。&lt;/p&gt;
&lt;p&gt;最起码我们可以做的是以尊敬、礼貌和同情对待他人，而不在乎他们的出身和背景。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="随记" label="随记" scheme="https://sh.alynx.one/categories/%E9%9A%8F%E8%AE%B0/" />
    
    
    <category term="随记" label="随记" scheme="https://sh.alynx.one/tags/%E9%9A%8F%E8%AE%B0/" />
    
  </entry>
  
  
  
  <entry>
    <title>在 Pixel C 上安装 Lineage OS</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Pixel-C-Lineage/" />
    <id>https://sh.alynx.one/posts/Pixel-C-Lineage/</id>
    
    <published>2019-07-24T09:24:00.000Z</published>
    
    
    <updated>2019-07-24T09:24:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;Pixel C 刚出来的时候我就很喜欢，但无奈价格太贵，同时 Android M 不能说是很好的利用平板电脑硬件。由于咕鸽战略失误，现在 Pixel C 已经变成热门洋垃圾了，所以在咸鱼捡了一台玩玩。&lt;/p&gt;
&lt;p&gt;官方系统升级只支持到 8.1（真的好意思起名叫 Pixel），Lineage OS 支持也是到 8.1（LOS 版本号就是 15.1，没有 Bug），所有的 9.0 都是 Unofficial 的，不过反正我就拿来看看文档，所以直接刷 LOS 15.1 Official 了（为什么不刷官方？因为我手机不想刷第三方，就拿平板过过瘾）。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;Pixel C 刚出来的时候我就很喜欢，但无奈价格太贵，同时 Android M 不能说是很好的利用平板电脑硬件。由于咕鸽战略失误，现在 Pixel C 已经变成热门洋垃圾了，所以在咸鱼捡了一台玩玩。&lt;/p&gt;
&lt;p&gt;官方系统升级只支持到 8.1（真的好意思起名叫 Pixel），Lineage OS 支持也是到 8.1（LOS 版本号就是 15.1，没有 Bug），所有的 9.0 都是 Unofficial 的，不过反正我就拿来看看文档，所以直接刷 LOS 15.1 Official 了（为什么不刷官方？因为我手机不想刷第三方，就拿平板过过瘾）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;由于刷机时候没拍照片我就不上图了，到手时候已经解锁了，不过既然是亲儿子想必也不会像一些国内厂商一样恶心你。按照 Lineage OS 的说法就是打开开发者选项里 &lt;code&gt;允许 OEM 解锁&lt;/code&gt; 和 &lt;code&gt;允许 USB 调试&lt;/code&gt;，按住 &lt;code&gt;音量下&lt;/code&gt; + &lt;code&gt;电源&lt;/code&gt; 直到重启进入 bootloader，然后连接电脑，&lt;code&gt;fastboot devices&lt;/code&gt;，如果检测到了就 &lt;code&gt;fastboot oem unlock&lt;/code&gt;，然后结束之后重启。（会清除所有数据，并且解锁之后每次开机会在 bootloader 停止 30 秒）。&lt;/p&gt;
&lt;p&gt;首先是去 &lt;a href=&quot;https://download.lineageos.org/dragon&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Lineage OS 官网&lt;/a&gt; 下载给 Pixel C（代号 dragon）的 nightly build ZIP。&lt;/p&gt;
&lt;p&gt;然后去 &lt;a href=&quot;https://drive.google.com/drive/folders/0By6p5AdQfavBUTZmNWJoaU1iazg&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这个 Google Drive&lt;/a&gt; 下载开发者提供的 &lt;code&gt;vendor.img&lt;/code&gt;。（&lt;strong&gt;务必要下载这个，如果有不止一个就选择最新的，因为 ROM 里不包含 vendor，其他下载的版本又和 ROM 包不匹配。&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;然后去 &lt;a href=&quot;https://dl.twrp.me/dragon/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;TWRP 官网&lt;/a&gt; 下载给 Pixel C 用的 Recovery。&lt;/p&gt;
&lt;p&gt;需要 Google Apps 就去 &lt;a href=&quot;https://opengapps.org&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Open GApps&lt;/a&gt; 下一个 ZIP，我用的是 &lt;code&gt;ARM64&lt;/code&gt; -&amp;gt; &lt;code&gt;8.1&lt;/code&gt; -&amp;gt; &lt;code&gt;stock&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你需要 Magisk 就自己去下载一个。&lt;/p&gt;
&lt;p&gt;把这些都放好，在自己电脑上安装 &lt;code&gt;adb&lt;/code&gt; 和 &lt;code&gt;fastboot&lt;/code&gt;，然后打开 &lt;code&gt;允许 USB 调试&lt;/code&gt;。按住 &lt;code&gt;音量下&lt;/code&gt; + &lt;code&gt;电源&lt;/code&gt; 直到重启进入 bootloader，然后 &lt;code&gt;fastboot flash recovery TWRP-IMG-FILE&lt;/code&gt; 刷入 TWRP，然后再按住 &lt;code&gt;音量下&lt;/code&gt; + &lt;code&gt;电源&lt;/code&gt; 直到重启进入 bootloader，选择 Recovery Mode 确认 TWRP 已经刷进去了。&lt;/p&gt;
&lt;p&gt;接下来在 TWRP 里面全部 wipe（syste, data, cache, sdcard），然后接上电脑用 &lt;code&gt;adb push FILE /sdcard/&lt;/code&gt; 把下好的 ROM ZIP、&lt;code&gt;verdor.img&lt;/code&gt; 和 OpenGApps ZIP 都 push 到 sdcard 里面。&lt;/p&gt;
&lt;p&gt;然后选择 Install 刷入 Lineage 的 ZIP。**接下来选择右侧 Install IMG，刷入下好的 &lt;code&gt;vendor.img&lt;/code&gt;**，然后刷入 OpenGApps 和 Magisk，重启。如果刷入 Magisk 的话会自动重启两次再进入向导。&lt;/p&gt;
&lt;p&gt;如果你日后某次更新提示 vendor 不匹配，那就去上面的咕鸽硬盘看看有没有新的刷进去就行了。&lt;/p&gt;
&lt;p&gt;接下来就是熟悉的开机向导了。&lt;/p&gt;
&lt;p&gt;大致来说作为洋垃圾这个平板还很划算，除了屏幕下端因为接键盘的磁铁的缘故会发黄（通病）、太多磕碰容易花屏（设计缺陷，购买要买少磕碰的），屏幕素质很好尺寸也很大，看文档看 PPT 看五线谱都是绝配（我期末就是用这个看 PPT 复习的超级爽）。但是毕竟是 3 年前的产品，3 GB RAM 不是很够多任务，同时 CPU 性能也不是特别高，甚至窗口特效都会卡（老黄的芯片优化好烂），但是这台机器是 NVIDIA 的芯片，GPU 性能强劲，打开开发者选项里 &lt;code&gt;禁用 HW 叠加层&lt;/code&gt;，使用 GPU 进行窗口混成特效就不卡了。&lt;/p&gt;
&lt;p&gt;游戏性能很弱，大部分游戏都没有对这台机器 GPU 优化，CPU 和内存以及 IO 性能也不高（毕竟三年前），但是玩 FGO 意外的不卡，而且还让我用 &lt;strong&gt;维护送的石头&lt;/strong&gt; &lt;strong&gt;单抽&lt;/strong&gt; &lt;strong&gt;连续&lt;/strong&gt; 出了 &lt;strong&gt;老福&lt;/strong&gt; 和 &lt;strong&gt;心心念念的蓝呆&lt;/strong&gt;！！！要知道就算把买平板的钱都氪进去也才不到两单，要靠这些石头来双黄蛋简直是白日做梦啊！&lt;/p&gt;
&lt;p&gt;除了垃圾 B 站 APP 不支持横屏以外，大部分对我影响都不是很大，所谓生态烂其实对我这种资深 Android 用户也没什么大影响，毕竟我对它分工很明确。日常用起来 Lineage OS 也没什么问题，升级只要傻瓜化点击就 OK 了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    
    <category term="Android" label="Android" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/Android/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Android" label="Android" scheme="https://sh.alynx.one/tags/Android/" />
    
  </entry>
  
  
  
  <entry>
    <title>雲雀</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Hibari/" />
    <id>https://sh.alynx.one/posts/Hibari/</id>
    
    <published>2019-07-15T01:02:00.000Z</published>
    
    
    <updated>2019-07-15T01:02:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;ロード・エルメロイⅡ世の事件簿 -魔眼蒐集列車 Grace note- ED&lt;/p&gt;
&lt;p&gt;五线谱（带歌词）点击链接下载：&lt;a href=&quot;/posts/Hibari/hibari.pdf&quot;&gt;PDF 格式&lt;/a&gt;、&lt;a href=&quot;/posts/Hibari/hibari.mscz&quot;&gt;MSCZ 格式&lt;/a&gt;（需使用 MuseScore3 打开）。&lt;/p&gt;
&lt;p&gt;歌词参考自微博用户 &lt;a href=&quot;https://weibo.com/u/5699383914&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@小蟲子的覺魂&lt;/a&gt;。曲谱由我自己听写。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;ロード・エルメロイⅡ世の事件簿 -魔眼蒐集列車 Grace note- ED&lt;/p&gt;
&lt;p&gt;五线谱（带歌词）点击链接下载：&lt;a href=&quot;/posts/Hibari/hibari.pdf&quot;&gt;PDF 格式&lt;/a&gt;、&lt;a href=&quot;/posts/Hibari/hibari.mscz&quot;&gt;MSCZ 格式&lt;/a&gt;（需使用 MuseScore3 打开）。&lt;/p&gt;
&lt;p&gt;歌词参考自微博用户 &lt;a href=&quot;https://weibo.com/u/5699383914&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@小蟲子的覺魂&lt;/a&gt;。曲谱由我自己听写。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;说实话好久没听到这么有梶浦由记风格的曲子了。&lt;em&gt;花の唄&lt;/em&gt; 和 &lt;em&gt;I beg you&lt;/em&gt; 都不算是我特别能接受的风格，二世事件簿大概是一月份放了第一集，但我那时候坚守“不看新番”的原则错过了……不过还好，第二集才算正式的放出 OP 和 ED。无人声OP对于梶浦由记来说根本不算什么难题，相对来说 ED 就更有惊喜了，不管是对小灰还是对韦伯都很好体现出了人物身上的故事感。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;当然令人欣喜的绝对不是这个番又多了一个呆毛。&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;刷了两次 HF2 之后听到这个真是治愈啊啊啊啊啊，HF2 黑呆和 B 叔打戏看出了 EVA 旧剧场版明日香大战量产机的感觉，明明画面很热血，但是就是给人绝望感。&lt;/p&gt;
&lt;p&gt;下面是数字谱：&lt;/p&gt;
&lt;figure data-raw=&quot;[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]

67 [#1 #1 #1 2 #1] 7 [3] 67 [#1 #1 #1 #4#4 33] 7
67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67
[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]
[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5]

[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]
[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]
[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]
[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]

[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]

67 [#1 #1#1 2 #1] 77[3] 67 [#1 #1 #1 #4 33] 7
67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67
[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]
[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5 6#5#4]

[#4#56 7]{#1}[#4] [#4#56 7]{32#1}[76 #4#56 7]{#1}[#4 76#5 3 #4#56]
[6#5 #4#56 7]{#1}[#4] {#43 #1}[7]{#1} [76#5#4] [76#5#5] [#567]{#1}

[#4#566#4 #4#566#4 #4#5676 #5#4#5 #566]
[6#5 #4#566#4 #4#566#4 #4#5676 #5#4#5 #566]
[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]
[6#5#4 #43 3#1] [6#5#4 #4#43 3]
[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]
[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]
[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]
[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]
[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]

67 [#1 #1 #1 2 #1] 7 [3] 67 [#1 #1 #1 #4#4 33] 7
67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67
[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]
[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5]

[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]
[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]
[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]
[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]

[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]

67 [#1 #1#1 2 #1] 77[3] 67 [#1 #1 #1 #4 33] 7
67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67
[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]
[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5 6#5#4]

[#4#56 7]{#1}[#4] [#4#56 7]{32#1}[76 #4#56 7]{#1}[#4 76#5 3 #4#56]
[6#5 #4#56 7]{#1}[#4] {#43 #1}[7]{#1} [76#5#4] [76#5#5] [#567]{#1}

[#4#566#4 #4#566#4 #4#5676 #5#4#5 #566]
[6#5 #4#566#4 #4#566#4 #4#5676 #5#4#5 #566]
[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]
[6#5#4 #43 3#1] [6#5#4 #4#43 3]
[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]
[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]
[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]
[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]
[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="音乐" label="音乐" scheme="https://sh.alynx.one/categories/%E9%9F%B3%E4%B9%90/" />
    
    <category term="曲谱" label="曲谱" scheme="https://sh.alynx.one/categories/%E9%9F%B3%E4%B9%90/%E6%9B%B2%E8%B0%B1/" />
    
    
    <category term="音乐" label="音乐" scheme="https://sh.alynx.one/tags/%E9%9F%B3%E4%B9%90/" />
    
    <category term="曲谱" label="曲谱" scheme="https://sh.alynx.one/tags/%E6%9B%B2%E8%B0%B1/" />
    
    <category term="梶浦由紀" label="梶浦由紀" scheme="https://sh.alynx.one/tags/%E6%A2%B6%E6%B5%A6%E7%94%B1%E7%B4%80/" />
    
  </entry>
  
  
  
  <entry>
    <title>六月，如梦一般的日子</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/June-or-Dream/" />
    <id>https://sh.alynx.one/posts/June-or-Dream/</id>
    
    <published>2019-06-27T08:18:00.000Z</published>
    
    
    <updated>2019-06-27T08:18:00.000Z</updated>
    
    
    <summary type="html">
      &lt;blockquote&gt;
&lt;p&gt;One day I wake up,
finding that I am on one of the most crazy trips in my life.
It has been into my dream for many times,
but now it comes into reality,
which becomes the best birthday present.&lt;/p&gt;
&lt;/blockquote&gt;

    </summary>
    
    
    <content type="html">
      &lt;blockquote&gt;
&lt;p&gt;One day I wake up,
finding that I am on one of the most crazy trips in my life.
It has been into my dream for many times,
but now it comes into reality,
which becomes the best birthday present.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;距离上次更新大概一个半月了，主要是因为考试周太忙所以没心情写博客。实际上有好多东西可以写。&lt;/p&gt;
&lt;p&gt;首先是端午节去了沈阳，不过很遗憾的是我不太喜欢拍景点照片（当然这也不是什么重点内容），所以只有一些稀松平常的照片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/June-or-Dream/photo3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/June-or-Dream/photo6.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/June-or-Dream/photo5.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后是有关实习的内容了，很幸运的拿到了 SUSE 北京的实习，环境超级好，而且最关键的还是找到一个自己比较感兴趣又有了解的实习。&lt;/p&gt;
&lt;p&gt;接下来就是 FGO 抽卡！盼了一年之后终于如愿以偿抽到了蓝呆！而且还是先出老福然后连续出蓝呆！没有看到金卡面之前完全没有意识到是什么，就算看到金卡还以为又是兰斯洛特或者式姐（兰斯洛特四宝的我），结果翻过来的时候完全呆住了不知道该怎么反应（抽到老福的快乐还没过去）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/June-or-Dream/photo2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/June-or-Dream/photo1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;以及买到了 Yuki Kajiura Live 15 上海的票（因此变得超级贫穷），虽然对我这个纯 Kalafina 粉来说性价比不是很高，但由于没去过 Kalafina 的 Live（并且再也没有了）而十分后悔，因此抱着这样的想法毅然决然的自己买了票，也算是圆多年的梦吧，毕竟可以说我整个的音乐审美都来自于梶浦由纪和 Kalafina。&lt;/p&gt;
&lt;p&gt;最后附上沈阳故宫墙里奇怪的石头照片。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/June-or-Dream/photo4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="随记" label="随记" scheme="https://sh.alynx.one/categories/%E9%9A%8F%E8%AE%B0/" />
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E9%9A%8F%E8%AE%B0/%E7%94%9F%E6%B4%BB/" />
    
    
    <category term="随记" label="随记" scheme="https://sh.alynx.one/tags/%E9%9A%8F%E8%AE%B0/" />
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/tags/%E7%94%9F%E6%B4%BB/" />
    
  </entry>
  
  
  
  <entry>
    <title>Arch Linux 安装 UnityHub 的临时方案</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Archlinux-UnityHub/" />
    <id>https://sh.alynx.one/posts/Archlinux-UnityHub/</id>
    
    <published>2019-05-10T14:09:00.000Z</published>
    
    
    <updated>2019-05-10T14:09:00.000Z</updated>
    
    
    <summary type="html">
      如果你直接使用 AUR 里 UnityHub 的 PKGBUILD 安装会出一些问题。解决方案也很简单。 首先似乎 PKGBUILD 下载的版本很奇怪，不管你在 Unity 论坛里哪个链接下载的版本其实都是一个，并且和 PKGBUILD 里面的不一样，解决方法就是自己计算一下 m…
    </summary>
    
    
    <content type="html">
      &lt;p&gt;如果你直接使用 AUR 里 UnityHub 的 PKGBUILD 安装会出一些问题。解决方案也很简单。&lt;/p&gt;
&lt;p&gt;首先似乎 PKGBUILD 下载的版本很奇怪，不管你在 Unity 论坛里哪个链接下载的版本其实都是一个，并且和 PKGBUILD 里面的不一样，解决方法就是自己计算一下 md5 然后替换掉 PKGBUILD 里面的 md5sums。&lt;/p&gt;
&lt;p&gt;第二个就是 PKGBUILD 里面最后有这几句：&lt;/p&gt;
&lt;figure data-raw=&quot;# Fix 7z permissions
chmod +x &amp;quot;${pkgdir}/opt/${pkgname}/resources&amp;quot; \
         &amp;quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked&amp;quot; \
         &amp;quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external&amp;quot; \
         &amp;quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z&amp;quot; \
         &amp;quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64&amp;quot; \
         &amp;quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64/7z&amp;quot;&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;# Fix 7z permissions
chmod +x &quot;${pkgdir}/opt/${pkgname}/resources&quot; \
         &quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked&quot; \
         &quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external&quot; \
         &quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z&quot; \
         &quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64&quot; \
         &quot;${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64/7z&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;但解压出来实际上没这些文件，然后就会报错，注释掉就好了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/Arch%20Linux/" />
    
    
    <category term="UnityHub" label="UnityHub" scheme="https://sh.alynx.one/tags/UnityHub/" />
    
  </entry>
  
  
  
  <entry>
    <title>不要拿愚蠢的广告来污染我的邮箱</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Do-Not-Fill-My-Email-with-Silly-Ads/" />
    <id>https://sh.alynx.one/posts/Do-Not-Fill-My-Email-with-Silly-Ads/</id>
    
    <published>2019-05-04T10:27:00.000Z</published>
    
    
    <updated>2020-10-23T01:16:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;一个多月没更新了，这次要写的不是什么技术问题，而是技术的附属问题。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;一个多月没更新了，这次要写的不是什么技术问题，而是技术的附属问题。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;一切问题的起源是邮箱里出现的这两封邮件：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/email1.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/email2.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;当你使用的邮箱服务是按某种数字顺序批量注册用户名的时候，你就没办法避免这种情况，不止我自己，而是很多人都收到这种邮件，没办法，谁叫邮箱都是连号的，甚至不需要写脚本，只要用 Excel 拖一下就能生成一大串邮箱地址，毫无技术含量。&lt;/p&gt;
&lt;p&gt;从哪里开始呢？今天我不打算讨论写这么个 app 的技术问题，因为不管怎么说写这么一个系统也不是个简单的活，还是要尊重别人的劳动成果。但除了技术问题，别的问题就一大堆了。&lt;/p&gt;
&lt;h1 id=&quot;我不想下载&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E6%88%91%E4%B8%8D%E6%83%B3%E4%B8%8B%E8%BD%BD&quot; title=&quot;我不想下载&quot;&gt;&lt;/a&gt;我不想下载&lt;/h1&gt;
&lt;p&gt;没错，最大的问题其实是我看了这个东西以后根本没有下载的欲望，甚至连让我下载下来找找里面有哪些技术缺陷的欲望都没有。我也不是什么专业的传播学者或广告设计者，但从一个用户的角度而言就没有使用欲望——而且这种现象也不止我自己。&lt;/p&gt;
&lt;h1 id=&quot;你的情怀和我有什么关系&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E4%BD%A0%E7%9A%84%E6%83%85%E6%80%80%E5%92%8C%E6%88%91%E6%9C%89%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB&quot; title=&quot;你的情怀和我有什么关系&quot;&gt;&lt;/a&gt;你的情怀和我有什么关系&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;今年春半，凝聚了团队无数努力和心血的项目终于开启了测试阶段。这对于我们整个团队来说都是一个饱含着拼搏意义和激动情绪的时刻。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一个想要靠卖弄情怀来宣传聊天软件的人叫罗永浩，结果如何呢？提起罗永浩大家还是首先想到 TNT、打脸，有几个想到聊天宝（&lt;strong&gt;原子弹短信&lt;/strong&gt;）的？罗老师的原子弹短信一开始可是给用户发红包的，这年头光卖情怀可不行，大家都喜欢红包。&lt;/p&gt;
&lt;p&gt;我知道你们实现了目标非常开心，但能不能冷静下来再发广告，这句话放在这里除了浪费几 Byte 流量之外，对用户了解你的应用有什么帮助嘛？&lt;/p&gt;
&lt;h1 id=&quot;AI不是万能形容词&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#AI%E4%B8%8D%E6%98%AF%E4%B8%87%E8%83%BD%E5%BD%A2%E5%AE%B9%E8%AF%8D&quot; title=&quot;AI不是万能形容词&quot;&gt;&lt;/a&gt;AI 不是万能形容词&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Dreamua 是首款 AI 社交应用。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果你做了个图片识别程序，你打个标签叫 AI 识图，那我觉得你的可信度有 90%，毕竟有很多现成的例子了。&lt;/p&gt;
&lt;p&gt;如果你做了个文本翻译程序，你打个标签叫 AI 翻译，那我觉得你的可信度有 70%，因为有几家财大气粗的公司在做，虽然效果不一定太好。&lt;/p&gt;
&lt;p&gt;如果你做了个自动驾驶程序，你打个标签叫 AI 驾驶，那你的可信度取决于你是不是在特斯拉上班。&lt;/p&gt;
&lt;p&gt;如果你非得叫 AI 社交……AI 社交了，还要我干什么？社交是人与人之间的互动哎，你这个 AI 社交，AI 在里面扮演什么角色呢？AI 能猜出来“今晚月色真美”的潜台词嘛？要是能猜出来，全世界的翻译官都失业了。&lt;/p&gt;
&lt;p&gt;写广告的人不懂的话可以问问程序员，最起码程序员应该懂。&lt;/p&gt;
&lt;h1 id=&quot;求你别搞假大空&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E6%B1%82%E4%BD%A0%E5%88%AB%E6%90%9E%E5%81%87%E5%A4%A7%E7%A9%BA&quot; title=&quot;求你别搞假大空&quot;&gt;&lt;/a&gt;求你别搞假大空&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;我们想了很久的slogan，最后把它决定为“Dreamua—遇见宇宙中最契合的TA”。
“宇宙”、“契合”是很宏大的词，但是我们希望可以和你一起，实现这个slogan的意义。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果语文老师没教你避免假大空，那软件工程老师应该教过你怎么写文档，&lt;strong&gt;请问你们这个软件是想让我和外星生物配种嘛？&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;edu邮箱就很靠谱吗&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#edu%E9%82%AE%E7%AE%B1%E5%B0%B1%E5%BE%88%E9%9D%A0%E8%B0%B1%E5%90%97&quot; title=&quot;edu邮箱就很靠谱吗&quot;&gt;&lt;/a&gt;edu 邮箱就很靠谱吗&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Dreamua是一个仅对edu邮箱用户开放的高校社交App，其核心和灵魂是AI社交。注册Dreamua 账号无需填写复杂简介，仅需一个edu邮箱，一张头像，一个昵称。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;废话，&lt;strong&gt;edu 邮箱要是那么靠谱，我就不会收到这个邮件了&lt;/strong&gt;——毕竟发件人也是 edu 邮箱。&lt;/p&gt;
&lt;p&gt;一个 edu 邮箱能说明什么呢？学号？学校？这个邮箱的主人可能已经毕业了，比如发邮件的这位 14xxxxxx，你是留级了在读大五？&lt;/p&gt;
&lt;p&gt;知道为什么我用 edu 邮箱申请 GitHub 学生认证不给过吗？就是因为国内的 edu 邮箱管理太松散了，完全没办法辨别真伪。那既然邮箱不能验证我是不是学生，再加一张头像一个昵称就能验证我是不是学生了吗？&lt;/p&gt;
&lt;p&gt;如果你们下次还想发广告，我觉得可以去淘宝搜索一下“教育 邮箱”，多买几个马甲，别总用一个，添加黑名单很容易的，大家只是太懒而已。&lt;/p&gt;
&lt;h1 id=&quot;说话能不能说准了&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E8%AF%B4%E8%AF%9D%E8%83%BD%E4%B8%8D%E8%83%BD%E8%AF%B4%E5%87%86%E4%BA%86&quot; title=&quot;说话能不能说准了&quot;&gt;&lt;/a&gt;说话能不能说准了&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Dreamua是一个仅对edu邮箱用户开放的高校社交App。
Dreamua 测试版仅面向 edu 邮箱用户开放。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;第一封邮件告诉我这个社交 app 只对高校学生开放。第二封就告诉我是测试版仅面向 edu 邮箱——那以后呢？&lt;/p&gt;
&lt;h1 id=&quot;生人社交本身就是伪命题&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E7%94%9F%E4%BA%BA%E7%A4%BE%E4%BA%A4%E6%9C%AC%E8%BA%AB%E5%B0%B1%E6%98%AF%E4%BC%AA%E5%91%BD%E9%A2%98&quot; title=&quot;生人社交本身就是伪命题&quot;&gt;&lt;/a&gt;生人社交本身就是伪命题&lt;/h1&gt;
&lt;p&gt;求求你了我们真的不是没社交就会孤独到死。不是每个人每个晚上都睡不着觉拿着微信疯狂摇一摇。我有自己认识的人，我可以认识我认识的人认识的人，我甚至看到有趣的人也可以直接上去要联系方式——或者我干脆就不想和别人说话。&lt;/p&gt;
&lt;p&gt;从小到大不爱和人说话的同学我见得多了，他们活得好好的，也没见谁需要下个 app“寻找志趣相投的伙伴”。&lt;strong&gt;实在不行的话，我还有沙雕网友呢。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;我为什么非要用你的&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E6%88%91%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9D%9E%E8%A6%81%E7%94%A8%E4%BD%A0%E7%9A%84&quot; title=&quot;我为什么非要用你的&quot;&gt;&lt;/a&gt;我为什么非要用你的&lt;/h1&gt;
&lt;p&gt;我倒不是说微信微博 QQ 做的比你们技术好，但每个人都或多或少的被这些或者其他 app 黏着。本身这些东西已经够用了，我看不到需要切换到第 N + 1 个 app 来和别人说话的任何理由，特别是对于我们这些生活在地球外面的人，想切换就更艰难了。&lt;/p&gt;
&lt;p&gt;原子弹短信的尸体还在墙头上挂着呢，支付宝也有聊天功能，除了聊天框里的“转账”按钮，你按过别的吗？&lt;/p&gt;
&lt;h1 id=&quot;Play商店搜不到&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#Play%E5%95%86%E5%BA%97%E6%90%9C%E4%B8%8D%E5%88%B0&quot; title=&quot;Play商店搜不到&quot;&gt;&lt;/a&gt;Play 商店搜不到&lt;/h1&gt;
&lt;p&gt;这一条可能有些不接地气，但对 Android 用户来说，Play 商店是最可靠的程序来源，就如同苹果的 App Store 一样。只有 Play 会定期检查手机里的 app 是不是有安全问题，其它的国内商店根本没有安全保证——拍个身份证照片注册就安全了吗？&lt;/p&gt;
&lt;p&gt;我看到你们的 app 提交了 App Store，所以应该不差那 25 美元提交 Play Store 吧，毕竟我自己的开源 app 也掏了 25 上了 Play 呢。&lt;/p&gt;
&lt;h1 id=&quot;官网没有可用信息&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E5%AE%98%E7%BD%91%E6%B2%A1%E6%9C%89%E5%8F%AF%E7%94%A8%E4%BF%A1%E6%81%AF&quot; title=&quot;官网没有可用信息&quot;&gt;&lt;/a&gt;官网没有可用信息&lt;/h1&gt;
&lt;p&gt;还好我能够在 Google 搜索到 &lt;a href=&quot;https://www.dreamua.com/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://www.dreamua.com/&lt;/a&gt;，但这个页面逻辑和我自己的 app 页面 &lt;a href=&quot;https://livewallpaper.alynx.xyz/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://livewallpaper.alynx.xyz/&lt;/a&gt; 逻辑差不多嘛——就一个简单的静态页面，分几个段落，写一些半通不通的话（“年轻有朝气的初创团队，致力于打造一家有影响力、有社会责任感的互联网科技公司。”这话怎么读怎么奇怪）。既然你都注册公司了，多写几个页面问题不大吧。你们是公司，我可是一个人单打独斗写的 app，不至于和我一样套开源 bootstrap 主题吧！&lt;/p&gt;
&lt;p&gt;顺便，上面写诞生于高校宿舍，下面又写有 Uber、Facebook、Amazon、腾讯等知名互联网公司工作经验……大概能是真的，就是会让人觉得开发之后已经换了一波人一样，再说，腾讯出来的人写个前端页面不难吧。&lt;/p&gt;
&lt;h1 id=&quot;化再浓的妆也没用&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E5%8C%96%E5%86%8D%E6%B5%93%E7%9A%84%E5%A6%86%E4%B9%9F%E6%B2%A1%E7%94%A8&quot; title=&quot;化再浓的妆也没用&quot;&gt;&lt;/a&gt;化再浓的妆也没用&lt;/h1&gt;
&lt;p&gt;说实在的，我对用户群体的评估可能有点失误，真的有人告诉我他们的室友下载了这个 app，后一句就是喜闻乐见的“想通过这玩意脱单”。&lt;/p&gt;
&lt;p&gt;你看看你看看，人家用户都摆明了自己的需求了，就不要写什么“将宇宙中的一座座孤岛连成一片星海”了。单身直男们也该思索一下了，为什么夏目漱石说“今晚月色真美”是表白，你说“今晚月色真美”就是华为 P30 Pro 的高端黑了，你看王跃琨一下子就被开除了！太晦涩难懂是没法脱单的！&lt;/p&gt;
&lt;h1 id=&quot;真的别再卖情怀了&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E7%9C%9F%E7%9A%84%E5%88%AB%E5%86%8D%E5%8D%96%E6%83%85%E6%80%80%E4%BA%86&quot; title=&quot;真的别再卖情怀了&quot;&gt;&lt;/a&gt;真的别再卖情怀了&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;首先谢谢你打开这封信。
我们是交大的一个学生团队，我们和你们一样在学活吃渔粉，在球场踢足球，在傍晚看明湖鸭。
Dreamua 诞生于高校宿舍。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;说真的，你这样会让别人对我们宿舍里这些同学的真实水平产生怀疑——我觉得我们学校的教学还是偏重于踏踏实实讲理论老老实实学技术的，而不是选个厮杀的你死我活的行业（你们的对手不止有探探陌陌 Soul 其实还有微信微博 QQ 甚至是 Bilibili 和网易云音乐）来创业，写一堆乱七八糟的文案卖情怀。&lt;/p&gt;
&lt;p&gt;以前好像有个公众号，文案风格如出一辙，也挺喜欢卖情怀的，结果清华评特奖的时候从简历上被人挖出来婊说实际什么都没做。我觉得这种事情给人留的印象挺差的，所以还是别卖情怀了，能好好写文案就好好写，写不出来吃点渔粉踢会足球看看鸭鸭可能就有灵感了。&lt;/p&gt;
&lt;h1 id=&quot;百度没收录我的网站&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Do-Not-Fill-My-Email-with-Silly-Ads/#%E7%99%BE%E5%BA%A6%E6%B2%A1%E6%94%B6%E5%BD%95%E6%88%91%E7%9A%84%E7%BD%91%E7%AB%99&quot; title=&quot;百度没收录我的网站&quot;&gt;&lt;/a&gt;百度没收录我的网站&lt;/h1&gt;
&lt;p&gt;最近那个《旗帜鲜明地反对李彦宏当选工程院院士》挺出名的。我先声明一下，我的网站放在地球上，谷歌必应收录了我的网站而百度搜狗 360 这种辣鸡引擎没有收录，特别是百度还把山寨我的站点放在了搜索结果首页上。所以百度和我没什么利害关系，我也就不担心这种问题。&lt;/p&gt;
&lt;p&gt;至于腾讯封了《旗帜鲜明》我也不太担心，毕竟我这人不喜欢用微信，连公众号都没有，生平最烦举报党。&lt;/p&gt;
&lt;p&gt;我恰好想起来今天是我建站的三周年零一个月整，114777 个点击量不算太多，但从第一篇文章开始我的目标就没变过——“网站是属于自己的，我可以记录我自己的想法，喜不喜欢则是你的自由”。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020-10-23）：&lt;a href=&quot;https://www.dreamua.com/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://www.dreamua.com/&lt;/a&gt; 已经打不开了，看来应该是创业失败了吧！而我的网站依然活着，是不是可以大声说出那句“你死我都未死！”了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="随记" label="随记" scheme="https://sh.alynx.one/categories/%E9%9A%8F%E8%AE%B0/" />
    
    <category term="无题" label="无题" scheme="https://sh.alynx.one/categories/%E9%9A%8F%E8%AE%B0/%E6%97%A0%E9%A2%98/" />
    
    
    <category term="愤怒" label="愤怒" scheme="https://sh.alynx.one/tags/%E6%84%A4%E6%80%92/" />
    
    <category term="吐槽" label="吐槽" scheme="https://sh.alynx.one/tags/%E5%90%90%E6%A7%BD/" />
    
  </entry>
  
  
</feed>
