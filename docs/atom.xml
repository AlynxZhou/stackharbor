<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喵's StackHarbor</title>
  <subtitle>Whisper to the World</subtitle>
  <icon>https://sh.alynx.one/images/Mikoto_Karon_White.webp</icon>
  <link rel="self" type="application/atom+xml" href="https://sh.alynx.one/atom.xml" />
  
  <link rel="alternate" type="text/html" href="https://sh.alynx.one/" />
  
  <updated>2021-04-25T06:50:00.000Z</updated>
  
  <id>https://sh.alynx.one/</id>
  
  <author>
    <name>Alynx Zhou</name>
    <email>alynx.zhou@gmail.com</email>
  </author>
  
  <generator uri="https://github.com/AlynxZhou/hikaru-generator-feed/" version="v2.3.4">Hikaru Generator Feed</generator>
  
  
  
  
  
  <entry>
    <title>新项目和新相机和新住处</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/New-Project-New-Camera-New-Home/" />
    <id>https://sh.alynx.one/posts/New-Project-New-Camera-New-Home/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-04-25T06:50:00.000Z</published>
    
    
    <updated>2021-04-25T06:50:00.000Z</updated>
    
    
    <summary type="html">
      本来之前是想等新开的项目搞差不多了就来更新博客，结果没想到越写 TODO 越多一直搞到这个月才搞定，所以到现在才更新。 新项目 从家里回来北京之后第一件事情就是 SUSE 的 HackWeek，我之前大致想好了要做什么，我用过 screenkey 这个项目，但它使用了 X11 的…
    </summary>
    
    
    <content type="html">
      &lt;p&gt;本来之前是想等新开的项目搞差不多了就来更新博客，结果没想到越写 TODO 越多一直搞到这个月才搞定，所以到现在才更新。&lt;/p&gt;
&lt;h1 id=&quot;新项目&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/New-Project-New-Camera-New-Home/#%E6%96%B0%E9%A1%B9%E7%9B%AE&quot; title=&quot;新项目&quot;&gt;&lt;/a&gt;新项目&lt;/h1&gt;
&lt;p&gt;从家里回来北京之后第一件事情就是 SUSE 的 HackWeek，我之前大致想好了要做什么，我用过 screenkey 这个项目，但它使用了 X11 的 API，所以不支持 Wayland，我简单调查了一下，发现其实是可以绕过显示部分直接读取输入设备的事件的，于是就打算造一个替代品。&lt;/p&gt;
&lt;p&gt;读取键盘事件的部分其实很容易，简单试了一下就完成了。但是反而是显示部分比较难搞。一开始我打算用刚发布稳定版的 GTK4，结果发现 GTK4 在 NVIDIA 驱动的 Wayland 会话下面反而是有问题的，只能回退到没问题的 GTK3。我原本以为一周的时间做出一个能用的程序还是挺充足的，但是后来发现中间有各种各样的问题和奇怪的 work around。比如涉及到 GObject 对象在什么时候释放，有些文档说的也不是很清楚。以及因为要用单独的子进程执行需要 root 权限的后端读取输入事件和用单独的子线程查询后端输出带来的进程/线程间通信问题。篇幅有限，打算后续再开一篇博客来介绍这里面的经验。在一周的时间里勉强做出了能用的 demo 参加了 HackWeek 的成果展示环节（给有始有终的参与者的小礼物大概还放在我公司的桌子上，我都不知道是什么，因为一直没去取），然后用了几周打游戏的时间整理代码里面的问题（主要是各种资源释放），以及做一下翻译工作和打包工作，终于在上周达到基本稳定了。如果有兴趣，可以访问 &lt;a href=&quot;https://showmethekey.alynx.one/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://showmethekey.alynx.one/&lt;/a&gt; 或者观看 &lt;a href=&quot;https://www.bilibili.com/video/BV1EB4y1A7QN&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;我发在 B 站上的介绍视频&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;新相机&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/New-Project-New-Camera-New-Home/#%E6%96%B0%E7%9B%B8%E6%9C%BA&quot; title=&quot;新相机&quot;&gt;&lt;/a&gt;新相机&lt;/h1&gt;
&lt;p&gt;之前一直想提升视频的画质，但是还有一个想法是想玩玩摄影，因为平时周末经常是起得很晚然后在家里玩游戏，感觉也挺无聊的，所以打算买个相机，这样周末就有理由出去走走了。拍出来什么东西无所谓，主要是找点乐趣。然后朋友建议我买黑卡，虽然这个玩意确实很黑科技，但我并不是太感兴趣。很久以前我家里有一个数码相机，不是卡片机，是一个能变焦变很长的型号，但是后来智能手机出现之后就很快的不用它了，因为没有手机轻便的同时也没有足够的专业程度。所以我对相机的看法就是要么就搞高级一点的，肯定不会被手机取代，要么就用手机算了，而且说实话最高端的黑卡价格也都达到微单的价格区间了。考虑到要拿来录视频，很多录视频的 UP 主选择的都是微单而不是单反，再查找了一下发现很多人都用的索尼 A73，那选一个大家都在用的总是错不了的吧，于是初步选定了目标。然后又开始考虑是 A73 还是 A7C，虽然很多人对于 A7C 只是缩小体积然后价格却比 A73 高感到不满，但我阅读了一个对比表格之后，觉得还是 A7C 更适合我这种有录视频需求的人，于是就选择了 A7C。&lt;/p&gt;
&lt;p&gt;我个人是对 A7C 相比 A73 砍掉的部分没什么需求的，只看参数很容易会变成那种“这个也想要那个也想要”的情况，虽然作为消费者而言，当然是希望厂家提供越多的功能越好。但是在只有这几个选项的情况下还是得考虑需求做一下取舍。比如去掉 MicroUSB 接口导致只能接一些 USB-C 接口的配件，看了看配件价格，短期内我大概是不会考虑这些配件的……去掉前拨轮和摇杆对我来说也不是不能接受，毕竟触摸对焦也挺好用的。虽然少了很多自定义按键，但是方向键现在都是可以自定义的，其实差别也不大。反而轻巧的体积和翻转屏，以及没有录制时间限制于我来说很重要。有人说没有双卡槽不够专业，万一给别人录东西丢了数据没有冗余，但可以预见的未来我不会靠这玩意获得收入，录我自己的话丢了也不算什么无法挽回的后果（反正自己选的）。&lt;/p&gt;
&lt;p&gt;看点作品？虽然我就是随便拍拍，还是有几张觉得好看的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/New-Project-New-Camera-New-Home/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前去五棵松玩，想试试夜拍效果，结果套头的焦段显然不够拍月亮，不过回家看看感觉这张图还不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/New-Project-New-Camera-New-Home/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;某天吃完饭散步，坐在长椅上拍了一张，莫名觉得很好看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/New-Project-New-Camera-New-Home/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前经常来我窗口咕咕咕叫吵我清梦的珠颈斑鸠，我管它叫大鸽，经常我拿着相机走到窗口它跑了，这张一开始其实拍到了部分室内，导致窗外的部分有点过曝，不过好在 RAW 可以调整，拉低了一些曝光然后裁掉窗户周围的部分，就变得很生动了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/New-Project-New-Camera-New-Home/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近大鸽不怎么来了，是不是因为楼下在锯树，大鸽的家没了？（虽然我对珠颈斑鸠再造一个窝需要花的时间表示怀疑。）&lt;/p&gt;
&lt;p&gt;买完了 A7C 莫名开始种草 A7S3，4K 60 帧看起来真诱人啊……1080P 60 帧和 4K 30 帧只能二选一到底是谁想出来的牙膏啊！&lt;/p&gt;
&lt;p&gt;说起来最近拍照片之后发现存储空间的需求还是很大啊，虽然我两块 2T 的机械应该还足以满足短期内的需求。最近挖矿导致大容量硬盘也涨价了，估计更新存储设备也不太现实，还是有空精简一下吧。NAS 的问题我也考虑过，但是后来想想还是放弃了把星际蜗牛重新搞起来的想法，因为看了很多视频/数码 UP 工作室的介绍之后意识到 NAS 比起存储的用途，更大的用途还是共享，比如多个剪辑师可以同时访问 NAS 上面的一份素材，不用在每台电脑上都复制一份。但我显然没这个需求也没这个网速，只是存储一些数据的话，还是直接插台式机里面比较方便吧！&lt;/p&gt;
&lt;p&gt;顺便我朋友一直怂恿我买一个大光圈定焦镜头，我也确实心动了，比较了一下之后打算先入 FE 55 F1.8 ZA，然后再考虑 FE 24-105 G F4 代替套头，不过因为一些原因还是暂时搁置了，原因的话就是下一部分。&lt;/p&gt;
&lt;h1 id=&quot;新住处&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/New-Project-New-Camera-New-Home/#%E6%96%B0%E4%BD%8F%E5%A4%84&quot; title=&quot;新住处&quot;&gt;&lt;/a&gt;新住处&lt;/h1&gt;
&lt;p&gt;当初因为时间比较紧所以选的这个住处，有几个不太满意的地方：房间太小了，放下柜子床电脑桌就没什么地方了。为了节约空间我是把桌子沿着床边摆的，我自己坐在桌子和衣柜之间，所以如果我要打开衣柜找东西就要把椅子推到桌子下面。然后在我 B 站录的视频里也能看出来，有朋友不止一次吐槽过我录视频环境过于混乱了。房子太旧了，实在是让人连做饭的想法都没，又破又旧，同时上班的话也比较麻烦，不是说交通不便，而是这个房子在一个院子的深处，出门坐公交或者去超市都要走很长一段距离。再加上我的卧室是直接挨着楼道，隔音又比较差，有时候午睡就会被上下楼的脚步声打扰。以及说实话我想要个稍微便宜点的房子，谁不想呢？&lt;/p&gt;
&lt;p&gt;所以今年快到期的时候我就在考虑搬家的问题。我们现在还是在家办公的状态，所以相对来说位置不太重要，虽然还是想尽可能找个上班方便的地方。但是很少有人和我一个方向上班，所以折腾了很久。本来是打算搬到更西南边的，甚至这一个月跑了好几个不同地方看房子，但是都因为各种原因没有选中，比如同学上班太远，周围没什么生活设施（虽然就在路边但是出门走好远好远才有超市到底是怎么搞的啊，为什么北京这边经常小区靠着路的一侧都是围墙，没有什么商业网点之类的，真的很没生活感），离地铁站太远，小区门禁是人脸识别（谁允许你们随便采集人脸信息的，而且约朋友来我家还要登记算几个意思啊）。而且想一起合租的同学以后可能考了教师资格证之后回老家工作，那样到时候就要再找人合租，我实在是不抱信心，所以还是决定再找别人合租。&lt;/p&gt;
&lt;p&gt;最后和有猫的孙老师在交大附近找了另一个房子。看了一上午最后直接选中的原因只有一个：实在是太新了，刚装修完，非常干净，而且卫生间和厨房都有采光。让我这个饱受破旧和阴暗厨房之苦的人非常满意。同时面积分配也非常科学，孙老师希望要有阳台的卧室，养猫比较方便，我希望卧室面积别太小，这样我录视频的时候把电脑桌当作背景，可以有一定的景深，让桌子在焦外就不会显得太乱。很多房子都是有阳台的卧室大得不得了而另一个卧室只能放个床，这个房子的次卧则不一样，有充足的地方放桌子。所以我们就敲定了这个，兜兜转转还是没离开学校周边。&lt;/p&gt;
&lt;p&gt;当然也没有完美的事情，满足了空间和干净和隔音（卧室并不是直接挨着楼道），价格和位置也就不能太强求了，交通的话看起来还好，离路边不会太远，大学周围也不至于太荒凉吧（街头生活感本来就和整齐不沾边，城市到底是让大人物拿来看的地方还是让小人物生活的地方呢？）。虽然考虑到更高的房租+中介费让我感到心疼肉疼（感觉镜头离自己远去了）……但是安慰自己多花几百块买来了刚装修完崭新的房子其实也很赚了对吧！&lt;/p&gt;
&lt;p&gt;所以希望接下来能轻松地搬家，毕竟我东西还是挺多的，有了空间就可以仔细布置一下了，让视频看起来更精致一点。&lt;/p&gt;
&lt;p&gt;总之还是要对生活有希望吧。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/tags/%E7%94%9F%E6%B4%BB/" />
    
  </entry>
  
  
  
  <entry>
    <title>运行在 JACK 上层的 PulseAudio</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Run-PulseAudio-on-Top-of-JACK/" />
    <id>https://sh.alynx.one/posts/Run-PulseAudio-on-Top-of-JACK/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-02-18T02:51:11.000Z</published>
    
    
    <updated>2021-02-18T02:51:11.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;很多朋友都知道我除了是个程序员以外还是个乐器玩家，很久之前因为想要录音上网了解了一下需要购买专门的麦克风声卡从此掉进深坑一发不可收拾。当然 Linux 用户在购买硬件之前需要做好功课，大概 16 年左右我还在上高中的时候用我还凑合的英语水平翻了几个 Linux 音乐论坛最后决定买一台 Focusrite Scarlett 2i4（不过它后来似乎更新了几个版本所以我购买的变成了 1st Gen），我不太清楚除了更换了接口之后还有什么奇怪的改动没有，所以这里就不盲目推荐大家买更新的型号了，反正声卡这玩意够用的话也不太需要追新。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;很多朋友都知道我除了是个程序员以外还是个乐器玩家，很久之前因为想要录音上网了解了一下需要购买专门的麦克风声卡从此掉进深坑一发不可收拾。当然 Linux 用户在购买硬件之前需要做好功课，大概 16 年左右我还在上高中的时候用我还凑合的英语水平翻了几个 Linux 音乐论坛最后决定买一台 Focusrite Scarlett 2i4（不过它后来似乎更新了几个版本所以我购买的变成了 1st Gen），我不太清楚除了更换了接口之后还有什么奇怪的改动没有，所以这里就不盲目推荐大家买更新的型号了，反正声卡这玩意够用的话也不太需要追新。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;做功课的时候还了解到常见的 Linux 桌面采用的都是 PulseAudio，但专业录音为了追求更低的延迟所以都使用 JACK，于是简单学习了一下，发现只要打开 Qjackctl 选择设备然后启动，Audacity 就可以选择使用 JACK 设备了。系统的其它软件仍然通过 PulseAudio 输出到板载声卡，不会冲突，基本满足我的需求也就没研究过其它的。&lt;/p&gt;
&lt;p&gt;但是最近直播的时候总有人说我的耳机麦克风不太灵敏，我想了想不如干脆把录音用的声卡和话筒利用上，整个系统直接采用 2i4 作为默认声卡？但是虽然 PulseAudio 可以直接控制 2i4，软件的兼容性却不太好，比如 Audacity 启动的时候即使没有运行 JACK 它似乎也会尝试通过 JACK 连接 2i4 于是导致缓慢的启动和几下破音。于是只能采用网上常见的方案也就是把 PulseAudio 的音频输出到 JACK，但我觉得其实这样不太准确因为音频是既有输出又有输入的，所以我的标题是把 PulseAudio 运行在 JACK 上层。当然还有一种方案是采用 PipeWire，打算自己替代 PulseAudio 和 JACK 一桶浆糊的新项目，它欺骗程序让它们以为它就是 JACK 和 PulseAudio，但虽然我是个 GNOME Dev，我对这个不太感冒。有个常见的笑话是“现在有 N 个不那么好用的系统了，我们写个新的把它们全部替代掉！然后现在有 N + 1 个不那么好用的系统了！”。JACK 对于专业用户来说很好用，而专业用户通常是不太喜欢变化的，所以我不太期待 PipeWire 替代 JACK。&lt;/p&gt;
&lt;p&gt;有人说 Linux 的音频系统比意大利面条还复杂，这倒不能说错，因为假如你看维基百科上那张巨恐怖的图的话确实是这样。但本质上来说音频不过是把信号丢给声卡，所以只要是个能写声卡的软件都可以叫音频系统嘛，也就不奇怪那张图那么复杂，实际上在现代的 Linux 桌面通常都集成 PulseAudio，我们也没必要去研究那些边边角角的奇怪方案，于是整个结构其实很清晰，一般的用户看到的都是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/typical-desktop.png&quot; alt=&quot;typical-desktop&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后作为对比，我之前的方式是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/mine-old.png&quot; alt=&quot;mine-old&quot;&gt;&lt;/p&gt;
&lt;p&gt;而这篇文章要达到的目的则是下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/mine-new.png&quot; alt=&quot;mine-new&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然实际上假如你理解了这个结构的话，其实也没必要只用一个声卡，完全可以用独立声卡录音用板载声卡输出，只是 JACK 是绑定独立声卡的，于是就像下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/some-interesting-things.png&quot; alt=&quot;some-interesting-things&quot;&gt;&lt;/p&gt;
&lt;p&gt;总之这样做的依据在于 JACK 被我们绑定了独立声卡，然后利用 PulseAudio 设置不同的输入输出设备控制基于 PulseAudio 的桌面程序的输入输出，同时它还可以把自己作为 JACK 的客户端。而具体到与声卡交互，则全部都是内核里面的 ALSA 组件控制的。这里没有涉及到使用 ALSA 用户态组件的客户端程序，因为 PulseAudio 会把自己伪装成 ALSA 的客户态组件，于是这些老旧的程序就被连接到了 PulseAudio 上面从而无法直接占据声卡了。&lt;/p&gt;
&lt;p&gt;了解原理之后就可以具体操作，首先需要安装 jack2，这个软件包包含的是 JACK 的组件，必须要装 jack2 因为 jack1 不支持 DBus 所以也就没办法和桌面交互了。安装 qjackctl 来控制 JACK，然后安装 pulseaudio-jack，这是让 PulseAudio 作为 JACK 客户端的兼容层。&lt;/p&gt;
&lt;p&gt;然后需要启动 Qjackctl，在 Setup 的 Settings 选项卡里面选择 Advanced，将 Input Device 和 Output Device 全都设置为 2i4（应该就是 hw:USB 那一项），然后切换到 Misc 选项卡，像下图那样设置 Others 部分（基本就是除了 Keep child windows always on top 的全都勾上），这样就可以做到毫无感觉的启动 JACK（只要打开 Qjackctl 它就在后台启动 JACK，退出 Qjackctl 也只是退到后台）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/misc-tab.png&quot; alt=&quot;misc-tab&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样再次启动 Qjackctl，应该 JACK 就已经在控制 2i4 了，PulseAudio 应该会自动把 2i4 的控制权交给 JACK，省了不少事情。对于一些原生支持 JACK 的客户端程序来说这已经足够了，比如 Ardour 或者 Audacity，它们不经过 PulseAudio，直接连接到 JACK。接下来需要调整的是那些基于 PulseAudio 的客户端程序。&lt;/p&gt;
&lt;p&gt;然后打开你桌面环境的音频控制器，比如我是 GNOME 就是 GNOME Control Center 里面的 Sound 选项卡，这里基本都是集成的 PulseAudio 控制，把 Input Device 设置成 Jack Source，于是 2i4 上的麦克风的录音便通过 JACK 传到 PulseAudio 再传到 PulseAudio 的客户端程序比如 OBS Studio 和 Firefox。然后如果你想让 PulseAudio 的客户端程序把音频输出到 2i4 上的耳机里面，那就将 Output Device 设置为 Jack sink，这样其实 PulseAudio 就是运行在 JACK 上层。&lt;/p&gt;
&lt;p&gt;最后你需要设置 JACK 在登录时启动，这样 PulseAudio 才能找到 JACK，这个很简单，因为我们已经设置 Qjackctl 无感启动 JACK 了，那只要将 Qjackctl 设置为自动启动即可，比如 GNOME 用户可以在 GNOME Tweaks 里面设置。&lt;/p&gt;
&lt;p&gt;当然，一般的家庭录音用户都是单声道麦克风，某些客户端程序需要自己手动设置，比如 OBS Studio 需要在 Advanced Sound Properties 里面勾选 Mono。&lt;/p&gt;
&lt;p&gt;如果你遇到了一些奇怪的明明已经设置 PulseAudio 重定向到 JACK 却没有声音的情况，可能是因为你某些软件或者插件带了奇怪的设置，建议先重置它们试试。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    
    <category term="音频" label="音频" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/%E9%9F%B3%E9%A2%91/" />
    
    
    <category term="录音" label="录音" scheme="https://sh.alynx.one/tags/%E5%BD%95%E9%9F%B3/" />
    
    <category term="PulseAudio" label="PulseAudio" scheme="https://sh.alynx.one/tags/PulseAudio/" />
    
    <category term="JACK" label="JACK" scheme="https://sh.alynx.one/tags/JACK/" />
    
  </entry>
  
  
  
  <entry>
    <title>StackHarbor 的 2020 尾记</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/2020-Tail/" />
    <id>https://sh.alynx.one/posts/2020-Tail/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-01-04T09:21:33.000Z</published>
    
    
    <updated>2021-01-04T09:21:33.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我最近思考了一下，总是记不起来去年的总结写了什么，结果翻了一下博客发现我的记忆力是对的——我去年还真的就忘了写总结。&lt;/p&gt;
&lt;p&gt;今年的总结因为各种原因写的稍微晚了一点，不过总之还算是写了，比忘记写要好得多吧！&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我最近思考了一下，总是记不起来去年的总结写了什么，结果翻了一下博客发现我的记忆力是对的——我去年还真的就忘了写总结。&lt;/p&gt;
&lt;p&gt;今年的总结因为各种原因写的稍微晚了一点，不过总之还算是写了，比忘记写要好得多吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;以前小时候总是觉得一年过得很慢，要过很久才到新一年放烟花吃饺子，但是现在觉得一年过得很快，可能要忙的事情多了就会觉得时间不够用。但我一般来说又不觉得自己做了什么值得记录的事情，看到别人的博客年终总结写的特别充实，又是自己出国求学又是自己找实习转正的，但是到了我自己总觉得这些也没什么好写的。再加上我是个相当讨厌计划的人，所以也没什么“检查自己一年的完成度”的机会。&lt;/p&gt;
&lt;p&gt;不过我在那些不错的年终总结里面还是学到了一些东西，所以打算也写点类似的。不过我虽然是程序员，写文章还是习惯从头到尾写，不擅长做那些分类加标题的事情，所以就想到哪写到哪。&lt;/p&gt;
&lt;p&gt;2020 年感觉最不错的事情大概是加入某绿色蜥蜴工作，虽然这个严格来说从 2019 年就开始了，但是我去年忘记写总结了……多亏了同学的推荐得到了一份实习，面试感觉很好，没有考什么我特别不擅长的算法题而是一些实践性的知识，这个我还是挺擅长的。然后同事也都相当好相处，一开始是测试相关的工作，也了解了很多测试方面的知识，甚至还写了点 perl（虽然只了解皮毛），总之是很有意思的经历，然后更意外的是领导居然主动问我有没有什么别的感兴趣的领域，因为我一直是 GNOME 用户所以对 GNOME 维护挺感兴趣的，结果后面就转到 GNOME 组去实习了（这也太好了吧天哪）。然后就是快毕业了需要准备正式工作，一般来说这边没有类似国内互联网企业那样招一大堆实习生然后给几个转正名额竞（yang）争（gu）的途径，并且他们也几乎不进行校招，对毕业生和社招一视同仁，虽然我个人很想在这工作，但是如果想留下来的话还挺看运气的。这时候领导又和我说正好组里有空缺职位，可以安排面试，只要能保证一直实习到正式入职就可以了，于是又十分幸运的毕业之后正式入职。总之能在自己感兴趣的领域做工作已经是十分幸运了，然后待遇相对来说也不错，特别是看多了加班猝死的新闻，心里更加满足了……同事也都很友善，而且都是技术类型的，做的又都是开源相关，平时也很聊得来。今年整体来说不是那么容易找工作的，我都要反思我为什么那么幸运了……顺便由于疫情原因，我司今年一直是在家办公状态，也节省了好多通勤的时间金钱……&lt;/p&gt;
&lt;p&gt;在找工作这方面我实在是没什么经验可谈，我太靠运气了……如果非要说的话，就是平时自己多学习多写写程序吧……&lt;/p&gt;
&lt;p&gt;因为工作的原因今年一直是自己在外面住的，房租好贵啊……至于自己住虽然挺安静的但也挺麻烦的……把东西从学校搬出来也花了不少麻烦。&lt;/p&gt;
&lt;p&gt;今年个人项目方面没做什么新东西，去年把 Hikaru 从 CoffeeScript 换成 JavaScript 之后基本就只是写文档、加测试、改功能，大改是去掉了 cheerio 改成自己实现了一部分功能，谁叫他们一年不……主题方面给 ARIA 做了个大改是去掉了 jQuery 加上了暗色模式，当然我自己看起来界面并没有什么变化。大一时候写的 FlipClock 努努力改成了 CMake，然后这样就可以跨平台做成 Windows 屏保了。顺便了解了一下怎么在 Android 上面运行 SDL，做了个 Android 的 FlipClock。而至于我的弹钢琴页面和 Telegram Bot，我已经忘记是今年还是去年写的了……&lt;/p&gt;
&lt;p&gt;今年折腾了一遍我的电脑，因为终于有时间和钱玩自己的台式机了，仔细想想好像把之前的能换的都换了，27 寸的显示器对没有双屏空间的人来说提升了不少工作效率，5800X 打游戏也很爽，就是钱包不太舒服……&lt;/p&gt;
&lt;p&gt;口琴方面今年年末又高产起来了，而且开始剪视频，发现达芬奇可以在 Linux 下面用（虽然有些限制）（Adobe 看看人家！），而且还挺流畅的，于是看了影视飓风的达芬奇教程学了一些基本的剪辑知识，为了用的更舒服还闲鱼买了个加密狗（假货很多，安全下车），今后可能剪视频的频率会逐渐增多，就当练习新技能了。&lt;/p&gt;
&lt;p&gt;手机打算再用一年，今年手机厂商出的都是什么垃圾？我现在也想清楚了反正手机又不能给我带来收入，有这个钱还不如投资到台式机上，希望各种换手机患者也考虑一下，我现在是能用就行了。除非哪个厂家出一个摄像头不丑还有耳机孔最好还是直屏系统不要乱删乱改的旗舰机。&lt;/p&gt;
&lt;p&gt;动漫除了看电磁炮 T 以外就是看了紫罗兰永恒花园，一开始很多人吹导致我对这个比较反感，实际看了以后觉得还是很不错的，所以吹得太过果然会招黑吗……电磁炮 T 总之中规中矩，能有第三部已经很不错了，我还想看第四部……、&lt;/p&gt;
&lt;p&gt;认识了一些新朋友，同时很多老朋友也都有各自要忙的事情，总之几乎没什么人一起打游戏了……不过经常能和蓝猫她们一起出去玩还是避免了成为死宅的命运，本来我都打算在家打游戏跨年了，最后和蓝猫狐狸一起吃了海底捞，虽然三点才回家导致第二天犯了鼻炎，不过还是非常开心。&lt;/p&gt;
&lt;p&gt;年末通关了 Titanfall 2，剧情很短，中规中矩，但是就已经是非常不错了，除了操作不适合我这个手残以外都很适合我。今年几乎没怎么玩 CSGO，但是下班之后有很多空余时间基本都投入在 Dota 2 上面了，虽然我也看很久 Dota 2 了，但是玩起来确实很难……不过我这一年一直都沉迷在中单光一直播里面，已经成了我玩 Dota 2 的动力了……现在多少也算入门了，虽然偶尔还是操作不过来，但至少明白是个怎么回事了。中单光一的直播真的很好看！正人君子，皮又好看，说话又好听，打游戏厉害，又很温柔。一开始我只是看他打 Dota，反正讲围棋我又看不懂，但我发现他读围棋棋手传记有意思多了，已经进入追小说模式了……拖到现在才写年终总结也是因为坐了 16 个小时的火车跑到上海去看 VirtuaReal 的第一次线下 Live，不过互动环节没抽到我实在是令人沮丧，我太非了，那么多人根本没我的机会呜呜呜呜呜……&lt;/p&gt;
&lt;p&gt;就写这些吧，希望 2021 年大家的生活都能变得顺利！&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    
    
    <category term="时光飞逝" label="时光飞逝" scheme="https://sh.alynx.one/tags/%E6%97%B6%E5%85%89%E9%A3%9E%E9%80%9D/" />
    
  </entry>
  
  
  
  <entry>
    <title>解决 Spleeter 愚蠢的依赖问题</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fix-Silly-Spleeter-Dependencies/" />
    <id>https://sh.alynx.one/posts/Fix-Silly-Spleeter-Dependencies/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-11-26T08:43:12.000Z</published>
    
    
    <updated>2020-11-26T08:43:12.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我倒不是对机器学习有什么莫名的偏见。事实上有些只能用机器学习搞定的东西我也很支持用机器学习解决，比如 waifu2x 这种增加图片分辨率的或者 Spleeter 这种分离人声和伴奏的，用传统的分离人声的方法就是不能完美解决这类问题，而机器学习模糊分类则可以无限接近完美解决。我讨厌的有两个，一个是传统方法很好解决的东西非要用机器学习解决，另一个是混乱的机器学习项目，后者更严重。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我倒不是对机器学习有什么莫名的偏见。事实上有些只能用机器学习搞定的东西我也很支持用机器学习解决，比如 waifu2x 这种增加图片分辨率的或者 Spleeter 这种分离人声和伴奏的，用传统的分离人声的方法就是不能完美解决这类问题，而机器学习模糊分类则可以无限接近完美解决。我讨厌的有两个，一个是传统方法很好解决的东西非要用机器学习解决，另一个是混乱的机器学习项目，后者更严重。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;不知道是因为什么原因，许多机器学习从业者似乎都缺乏整理代码和依赖的能力——能轻松地把一个这类开源项目打包简直是奇迹，更多时候别提打包了，你想自己安装然后跑起来都不太现实，哪怕是同样做机器学习的其他人也有这样的苦恼：实现者似乎把论文写好然后在自己电脑上能跑起来就心满意足了，丢出来一份没什么文档的代码，不折腾几天根本不知道这坨代码需要装些什么才能跑起来。对我这种洁癖用户就更严重了，我可不希望 pip 在我的系统里塞一堆乱七八糟的东西，这个需要其他项目才能避免全局安装的程序比起 npm 真是差远了，解决依赖的能力也远不如 pacman 和 npm。&lt;/p&gt;
&lt;p&gt;然后有人发明了 conda 和 docker 这样的 &lt;del&gt;辣鸡&lt;/del&gt; 项目来拯救其他的辣鸡，但事实上不过是变得更糟而已——它们给了一些懒人名正言顺不维护项目的借口——反正我丢一个 conda 配置或者 docker 文件上去，你们拉上一大堆和我一样的过期依赖就能跑了，至于占了你多少硬盘，干不干净，关我什么事？如果不是物理限制，恐怕这些懒人会把整个宇宙都塞进去。而且他们再也不会管版本更新，什么 tensorflow 2 与我何干？用了我的 docker 你的系统里就会有几百个不同的过期的 tensorflow 1，买硬盘就完了呗？这和买显卡就完了呗还真是一路货色，这样依赖商业公司的产品，总有一天感觉会被割韭菜。&lt;/p&gt;
&lt;p&gt;今天我用到的这个 Spleeter 某种意义上也是这样的一坨辣鸡，它的仓库里面的 README 是完全过时的，但这起码是件好事：代码还在更新。只是你按照文档是没办法顺利的搞定它的，我总结了一下我的解决方案，可能不适合其他人，但我大概知道怎么解决了。&lt;/p&gt;
&lt;p&gt;这个文档有多离谱呢？它说你如果使用 GPU 加速的版本，必须从 conda-forge 安装，pip 和 GitHub 的版本都只有 CPU——那你这也是按揭开源？然后整个文档没有一个地方告诉我我需要单独下载训练好的模型才能跑起来，直接运行程序则丢一个段错误——可能他们搞机器学习的人觉得下模型是常识不需要说吧。&lt;/p&gt;
&lt;p&gt;如果直接按它的方法运行 &lt;code&gt;conda install -c conda-forge spleeter-gpu&lt;/code&gt;，你会得到一个不能用 GPU 的 GPU 版，这实在是太搞笑了。我捏着鼻子用 conda 就是为了能让你一步把这一坨东西给我弄好，现在你说你弄不好？&lt;/p&gt;
&lt;p&gt;但是有一点好处就是实际上他们的代码已经更新到支持 tensorflow 2 了，所以其实完全不需要用那个过期的 conda-forge 的版本，你完全可以直接在 Python 3.8 里面 &lt;code&gt;pip install spleeter-gpu&lt;/code&gt; 安装最新的版本——然后我又遇到了依赖问题，我的一些系统软件包依赖 numpy，然后 Arch 官方源里的 numpy 版本还是比 spleeter-gpu 依赖的 tensorflow 依赖的 numpy 版本新——你们写 Python 的人真麻烦，版本号兼容性是可以随便 break 的吗？&lt;/p&gt;
&lt;p&gt;所以这时候我还是用 conda 解决，总之就是搞一个和系统独立的虚拟环境（npm：这不应该是内置功能吗？还需要用商业软件？）。总之&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;去 TUNA 搞一个 Miniconda 3 最新的安装包来&lt;/a&gt;，然后直接安装，看着它往你的 shell 配置里塞一坨辣鸡（我把实际用到的命令拿出来做了个 alias，这样就可以只在我需要的时候打开 conda 了）。&lt;/p&gt;
&lt;p&gt;为什么使用 miniconda 而不是 anaconda？因为 anaconda 带的那个图形界面根本用不了，miniconda 够用了。&lt;/p&gt;
&lt;p&gt;然后创建一个 Python 3.8 的环境，高了低了都不行，真是难伺候，同时别忘了带上 cuda 和 cudnn，不然它一声不吭的就会只能用 CPU：&lt;/p&gt;
&lt;figure data-raw=&quot;$ conda create -n spleeter python=3.8 cudatoolkit cudnn&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ conda create -n spleeter python=3.8 cudatoolkit cudnn&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;cuda 不叫 cuda，叫 cudatoolkit 就离谱。&lt;/p&gt;
&lt;p&gt;然后切进去：&lt;/p&gt;
&lt;figure data-raw=&quot;$ conda activate spleeter&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ conda activate spleeter&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后装 &lt;code&gt;spleeter-gpu&lt;/code&gt; 到 conda 新创建的这个 Python 环境：&lt;/p&gt;
&lt;figure data-raw=&quot;$ pip install spleeter-gpu&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ pip install spleeter-gpu&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;所有的依赖应该 pip 都会解决，但这个弱智有时候还会说我本机已经装了 numpy 1.19.4，比 tensorflow 需要的版本高，但我都创建虚拟环境了你还读取我系统的干嘛？不过其实好像也不影响使用，或者此时可以 &lt;code&gt;pip install numpy==1.18.5&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后到 &lt;a href=&quot;https://github.com/deezer/spleeter/releases&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/deezer/spleeter/releases&lt;/a&gt; 去下载训练好的模型，这也是个弱智的地方：哪有 tar 打包不把目录本身打进去的？然后还得给这个程序创建一个工作目录，因为它是写死的到当前目录下面的 &lt;code&gt;pretrained_models&lt;/code&gt; 下面去找模型。&lt;/p&gt;
&lt;figure data-raw=&quot;$ mkdir -p spleeter/pretrained_models
$ cd spleeter/pretrained_models&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ mkdir -p spleeter/pretrained_models
$ cd spleeter/pretrained_models&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我这里用 2stems 的模型示范，因为我只需要分离人声和伴奏：&lt;/p&gt;
&lt;figure data-raw=&quot;$ wget -c &#039;https://github.com/deezer/spleeter/releases/download/v1.4.0/2stems.tar.gz&#039;
$ mkdir 2stems
$ cd 2stems
$ tar -xpvzf ../2stems.tar.gz&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ wget -c &#039;https://github.com/deezer/spleeter/releases/download/v1.4.0/2stems.tar.gz&#039;
$ mkdir 2stems
$ cd 2stems
$ tar -xpvzf ../2stems.tar.gz&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为他们打 tar 包时候没把目录打进去，所以别忘了自己创建目录！&lt;/p&gt;
&lt;p&gt;然后回到你的工作目录就可以用了，我这里结构是 &lt;code&gt;spleeter/pretrained_models/2stems&lt;/code&gt; 所以工作目录就是 &lt;code&gt;spleeter&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;$ cd ../../
$ spleeter separate -i 你要处理的歌曲 -p spleeter:2stems -o 输出目录 -B tensorflow&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ cd ../../
$ spleeter separate -i 你要处理的歌曲 -p spleeter:2stems -o 输出目录 -B tensorflow&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你想使用其他的几个模型，那就把 2stems 改成其他模型的名字，但是这里还有个开发者脑子抽了的地方：带有 &lt;code&gt;-finetune&lt;/code&gt; 的是高品质模型，它们的模型目录名字应该是比如 &lt;code&gt;2stems-finetune&lt;/code&gt;，但是参数名字却不是这个而是 &lt;code&gt;-p spleeter:2stems-16kHz&lt;/code&gt;，文档里当然是没找到的，我觉得应该揍开发者一顿让他老实写文档（不过我又看了一下，这个 finetune 对于分离音轨没什么用好像）。&lt;/p&gt;
&lt;p&gt;我这里必须使用 &lt;code&gt;-B tensorflow&lt;/code&gt; 才会走显卡加速。&lt;/p&gt;
&lt;p&gt;用完了就可以 &lt;code&gt;conda deactivate&lt;/code&gt; 退出虚拟环境，要用的时候别忘了 &lt;code&gt;conda activate spleeter&lt;/code&gt; 切换进来，&lt;/p&gt;
&lt;p&gt;遇到类似问题的同学可以参考我的文章，但是因为这个处理过程影响因素太多了，如果你的不能用我也没什么办法。&lt;/p&gt;
&lt;p&gt;回头一看，这个项目犯了一大堆禁忌：难以解决的依赖，写死的模型路径还有匮乏的文档，导致配环境就要配一大堆。当然，好在他们还是在努力更新跟上依赖而不是撒手不管让它慢慢死去，并且功能非常好。真正对开发者友好应该是不需要配环境的，比如在 Linux 下面开发软件，包管理已经帮你考虑好各种依赖了。只有像 Windows 或者 Android 这种不以开发者为中心或者是许多机器学习项目这种“数据好看就行”的地方才会有这么多麻烦。真的很希望这些人能补一点务实的基础，不要让他们的软件这么难用。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    
    <category term="Python" label="Python" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/Python/" />
    
    
    <category term="Python" label="Python" scheme="https://sh.alynx.one/tags/Python/" />
    
    <category term="Spleeter" label="Spleeter" scheme="https://sh.alynx.one/tags/Spleeter/" />
    
  </entry>
  
  
  
  <entry>
    <title>奇怪的书名和我和吐槽</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Strange-Book-Names/" />
    <id>https://sh.alynx.one/posts/Strange-Book-Names/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-10-06T09:48:00.000Z</published>
    
    
    <updated>2020-10-06T09:48:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;好久没更新非技术类博文了。可能很多人不但丢掉了阅读的习惯，连书店都不去了，书店都沦为练习册店，学生们更加对书店敬而远之，这种恶性循环实在是可悲又无趣的事情。&lt;/p&gt;
&lt;p&gt;今天和同学一起去了书店，在常规意义的书店而非练习册店的部分发现了一些有趣或奇怪的书名，很有槽点，让人想要吐槽。于是拍了点照片发到这里。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;好久没更新非技术类博文了。可能很多人不但丢掉了阅读的习惯，连书店都不去了，书店都沦为练习册店，学生们更加对书店敬而远之，这种恶性循环实在是可悲又无趣的事情。&lt;/p&gt;
&lt;p&gt;今天和同学一起去了书店，在常规意义的书店而非练习册店的部分发现了一些有趣或奇怪的书名，很有槽点，让人想要吐槽。于是拍了点照片发到这里。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;套娃型&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E5%A5%97%E5%A8%83%E5%9E%8B&quot; title=&quot;套娃型&quot;&gt;&lt;/a&gt;套娃型&lt;/h1&gt;
&lt;p&gt;此类书名非常适合套娃，比如这本《如何阅读一本书》，且不说阅读方法因人而异且随经验变化，单就这个名字还可以有《如何阅读如何阅读一本书》、《如何阅读如何阅读如何阅读一本书》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/1.jpg&quot; alt=&quot;如何阅读一本书&quot;&gt;&lt;/p&gt;
&lt;p&gt;我以为只有当代为搏销量疯狂吸引眼球的作者会起这种名字，然而接下来我看到了一本《木心谈木心》。虽然我不太清楚木心是谁，但似乎是个有名的作者。这书名总是让我想后续会不会有《木心谈木心谈木心》、《木心谈木心谈木心谈木心》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/2.jpg&quot; alt=&quot;木心谈木心&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;性转型&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E6%80%A7%E8%BD%AC%E5%9E%8B&quot; title=&quot;性转型&quot;&gt;&lt;/a&gt;性转型&lt;/h1&gt;
&lt;p&gt;这本书的名字非常奇特，她叫做《少女福尔摩斯》，作为半资深福尔摩斯迷和半资深月球氪金母X，我只能说型月都没敢做的这作者做了。由于原作实在是珠玉在前，写老福的故事已经很难了，性转老福怕是难上加难，建议寄一本给蘑菇看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/3.jpg&quot; alt=&quot;少女福尔摩斯&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;蹭热度型&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E8%B9%AD%E7%83%AD%E5%BA%A6%E5%9E%8B&quot; title=&quot;蹭热度型&quot;&gt;&lt;/a&gt;蹭热度型&lt;/h1&gt;
&lt;p&gt;这位叫蒋勋的作者在书架上占据了一片，又是说唐诗又是说宋词，一会谈莫奈一会谈高达哦不是梵高和达芬奇，想必上知天文下知地理。&lt;strong&gt;不过这书脊把这些名人加粗放在下面，让我总是有一种这是个达芬奇/梵高/莫奈的著作、作品标题叫做蒋勋的感觉。&lt;/strong&gt; 不知道这个叫蒋勋的作品是不是样样通样样松呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/4.jpg&quot; alt=&quot;蒋勋&quot;&gt;&lt;/p&gt;
&lt;p&gt;还有这本《逝水年华》，连我的输入法都怀疑我是不是想输入《追忆似水年华》，敢问作者是不是有点大舌头，让出版社的编辑听错了标题？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/5.jpg&quot; alt=&quot;逝水年华&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;连锁反应型&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E8%BF%9E%E9%94%81%E5%8F%8D%E5%BA%94%E5%9E%8B&quot; title=&quot;连锁反应型&quot;&gt;&lt;/a&gt;连锁反应型&lt;/h1&gt;
&lt;p&gt;《知更鸟》吗？大家都说有本书想杀你，不知道与你是什么关系？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/6.jpg&quot; alt=&quot;知更鸟&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然《重返美丽新世界》和《美丽新世界》是一个作者，但总让我想起狗尾续貂，不知道是不是我错了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/7.jpg&quot; alt=&quot;美丽新世界&quot;&gt;&lt;/p&gt;
&lt;p&gt;好家伙，你把《24个比利》放在这，那他们肯定会打架的，不过叫《比利打群架》比《比利战争》更好吧，无谓夸大不可取，要实事求是。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/8.jpg&quot; alt=&quot;比利&quot;&gt;&lt;/p&gt;
&lt;p&gt;《面包树上的女人》怎么啦？她没怎么，《面包树出走了》，那可真是个离奇的故事，但是你这内容就不知道是不是好故事了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/9.jpg&quot; alt=&quot;面包树&quot;&gt;&lt;/p&gt;
&lt;p&gt;我以为文学大家不屑于做这种在标题上吸引人的无聊事情，毕竟内容才是王道。我也不是有意冒犯杨绛先生，但是《洗澡》做书名已经是太随意了，再整一本《洗澡之后》是不是过分了？还是说这是出书的不负责任的编辑洗澡前洗澡后决定的两本文集的名字？那这就说得通了。但是说实话《洗澡》、《洗澡之后》接下来摆一本《暗示》是不是店员的恶趣味？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/10.jpg&quot; alt=&quot;洗澡&quot;&gt;&lt;/p&gt;
&lt;p&gt;希望看了我文章的朋友不要给我评论“一看到白胳膊……”，我老实承认我不是一个完全脱离了低级趣味的人，写这文章也是让大家开心一下，毕竟实事求是更重要。我也希望写书的作者们都实事求是一点，内容不行，靠标题党吸引人肯定是经不起考验的。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/tags/%E7%94%9F%E6%B4%BB/" />
    
  </entry>
  
  
  
  <entry>
    <title>固定 GNOME Shell 的输入法列表</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fixed-IME-List-for-GNOME-Shell/" />
    <id>https://sh.alynx.one/posts/Fixed-IME-List-for-GNOME-Shell/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-09-26T02:40:00.000Z</published>
    
    
    <updated>2020-09-26T02:40:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;GNOME Shell 有个令人很不爽的“特性”，它的输入法列表使用的是最近使用优先排列。也就是说当你有三个或以上输入法的时候，比如我，我有英文简体中文和日语输入法，我经常在中英之间切换，这没什么，前两个总是中英所以按一次就可以在这两个之间切换，但假如我偶尔用了一次日语输入法，我的列表就被打乱了，我不清楚按几下才能切回中文，并且再切到英文也得看一眼才能知道。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;GNOME Shell 有个令人很不爽的“特性”，它的输入法列表使用的是最近使用优先排列。也就是说当你有三个或以上输入法的时候，比如我，我有英文简体中文和日语输入法，我经常在中英之间切换，这没什么，前两个总是中英所以按一次就可以在这两个之间切换，但假如我偶尔用了一次日语输入法，我的列表就被打乱了，我不清楚按几下才能切回中文，并且再切到英文也得看一眼才能知道。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我不是很理解这个特性存在的意义，设置里面是可以手动调节输入法的顺序的，我明明调成了我想要的顺序，你就给我这个顺序好了，这样我闭着眼睛不用动脑子都能猜出来要按几下，比如从英文到日语按两下，中文到日语按一下等等。可能有些人的脑子长得比较擅长模拟最近使用优先排列？反正我不行。&lt;/p&gt;
&lt;p&gt;既然感觉不爽那就动手处理一下好了，最近看了一些有关写 GNOME Shell 扩展的文档，所以写个扩展解决一下就可以了。为什么不直接提交给上游？因为上游一开始是固定顺序的，但是很久以前某个人加了这个“特性”，现在如果提个请求说删掉这个特性，势必会陷入一场“用户到底是喜欢最近使用优先排列还是固定排列”的争论，这肯定很难得出结论（毕竟大部分的人实际上是不需要使用输入法的英语用户以及只有两种输入法的用户！），并且按照 GNOME 上游的习惯他们也是不愿意为了这个多添加一个开关的。所以比起在拉锯战上浪费时间，先搞一个能用的才是我的风格。至于升级之后扩展挂掉……不就是在上游里和其他代码一起被重构和我自己单独重构的区别吗？只要我还在用应该就会持续更新了。&lt;/p&gt;
&lt;p&gt;具体的解决方法比较 dirty，是我从别的扩展里学来的：把 GNOME Shell 里面的类的原型上的方法替换成自己的，就可以修改实例调用时的函数了（也算 JS 特性之一），不过不要用箭头函数，因为显然我们希望 &lt;code&gt;this&lt;/code&gt; 是调用时的上下文也就是实例，而不是绑定到当前上下文。&lt;/p&gt;
&lt;p&gt;因为这算是我第一个扩展所以也多少记录一下踩的坑。&lt;/p&gt;
&lt;p&gt;首先 Gjs 的导入和 Node.js 的导入是不一样的，它通过一个 &lt;code&gt;imports&lt;/code&gt; 对象引入其他库，比如通过 GI 导入的就在 &lt;code&gt;gi&lt;/code&gt; 下面，因为是 GNOME Shell 扩展所以可以访问 GNOME Shell 的 JS 库，就是简单地把 JS 路径换成对象的 key 然后 JS 文件里所有的 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;function&lt;/code&gt; 都会被导出。比如导入 &lt;code&gt;Main&lt;/code&gt; 就是 &lt;code&gt;imports.ui.main.Main&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后就是怎么知道要修改什么以及如何获取到相关对象，不过因为 GNOME Shell JS 部分经常重构，也没什么完整的文档，反正只能多花时间看代码吧，而且它的结构其实比看起来的要复杂，所以经常需要仔细翻来翻去的。比如 GNOME Shell 的输入法部分很多人认为是需要修改 iBus，实际上 GNOME Shell 只是调用 iBus 作为后端，自己处理状态和界面，这部分的代码都在 &lt;code&gt;js/ui/status/keyboard.js&lt;/code&gt; 里面。&lt;/p&gt;
&lt;p&gt;扩展主要有 &lt;code&gt;init()&lt;/code&gt;，&lt;code&gt;enable()&lt;/code&gt; 和 &lt;code&gt;disable()&lt;/code&gt; 三个函数，&lt;code&gt;init()&lt;/code&gt; 在 GNOME Shell 加载扩展时候调用，我这个显然不需要。&lt;code&gt;enable()&lt;/code&gt; 是你在 Extensions app 里面打开开关时候调用的，&lt;code&gt;disable()&lt;/code&gt; 是关掉开关时候调用的。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;enable()&lt;/code&gt; 里面有几个需要我修改的地方，一个是阻止 &lt;code&gt;InputSourceManager&lt;/code&gt; 在输入法切换之后的最近使用优先排列，解决方法很简单，需要自己替换掉 &lt;code&gt;_currentInputSourceChanged&lt;/code&gt; 函数，注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L447-453&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L447-453&lt;/a&gt; 这一段更新代码。&lt;/p&gt;
&lt;p&gt;当然光有这个还是不行的，这样假如你是先切换过再打开扩展，实际上列表是你开启扩展之前的状态而不是用户设置的顺序，所以我们还需要在打开扩展之后更新它的列表，让它直接读取用户设置。更新列表的函数是 &lt;code&gt;_updateMruSources&lt;/code&gt;，假如检测到当前列表为空，会先从一个缓存的 gsettings 里读取之前存储的最近使用优先排列列表，这显然是很恶心的所以要注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L504-522&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L504-522&lt;/a&gt; 这一段。之后它会先加载当前列表里的，然后再把用户列表里增加的当前列表里没有的加到后面，因为我们已经决定要清空当前列表并且不加载 gsettings 里面的缓存，所以这个当前列表肯定是空，那直接加用户列表就行了，所以注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L525-533&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L525-533&lt;/a&gt;。这样我们后续只要清空 &lt;code&gt;_mruSources&lt;/code&gt; 设置 &lt;code&gt;_mruSourcesBackup&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 然后调用 &lt;code&gt;_updateMruSources&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;然后我们需要获取运行时的这个 &lt;code&gt;InputSourceManager&lt;/code&gt; 实例，这个实例没有被绑定到 &lt;code&gt;Main&lt;/code&gt; 对象上，不过我阅读代码发现它是个单例模式，就是说在 &lt;code&gt;js/ui/status/keyboard.js&lt;/code&gt; 有一个 &lt;code&gt;_inputSourceManager&lt;/code&gt; 变量，然后有个 &lt;code&gt;getInputSourceManager()&lt;/code&gt; 的函数，被调用时候如果有就返回 &lt;code&gt;_inputSourceManager&lt;/code&gt; 否则创建一个赋值返回，其他代码都用的这个，所以我们也导入这个就行了。&lt;/p&gt;
&lt;p&gt;然后你会发现另一个弱智的地方，怎么每次按下切换键，切换框都是从第一个切换到第二个？不是应该从我当前的切换到下一个吗？这个对于当前输入法总在第一个的最近使用优先排列是可以的，但在我们这个场景选中的并不总是第一个，所以需要修改。这部分函数是 &lt;code&gt;_switchInputSource&lt;/code&gt;，可以看到它只是展示了一个 &lt;code&gt;InputSourcePopup&lt;/code&gt;，而 &lt;code&gt;InputSourcePopup&lt;/code&gt; 继承的是 &lt;code&gt;imports.ui.switcherPopup.SwitcherPopup&lt;/code&gt;，这个类有一个叫做 &lt;code&gt;_selectedIndex&lt;/code&gt; 的变量用于选择下一个上一个时候的计算，而且它默认是 0！不能通过参数初始化！真是头秃，不过我们可以在创建完切换框但展示之前单独设置这个值就行了，所以我在 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L412&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L412&lt;/a&gt; 的下一行插入如下代码：&lt;/p&gt;
&lt;figure data-raw=&quot;if (this._currentSource != null) {
  popup._selectedIndex = this._mruSources.indexOf(this._currentSource);
}&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;if (this._currentSource != null) {
  popup._selectedIndex = this._mruSources.indexOf(this._currentSource);
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为我们不一定总有 &lt;code&gt;_currentSource&lt;/code&gt; 所以还是要检查一下，如果没有的话让它从 0 开始也无所谓。&lt;/p&gt;
&lt;p&gt;然后还有一个比较头痛的是快捷键是绑定的回调函数，回调函数又绑定了 &lt;code&gt;this&lt;/code&gt;，所以我们光修改原型是改不了被回调的函数的，这个也简单，我们需要读一下 &lt;code&gt;InputSourceManager&lt;/code&gt; 的 &lt;code&gt;constructor&lt;/code&gt; 的代码，然后删掉它在 &lt;code&gt;Main.wm&lt;/code&gt; 里面绑定的组合键重新绑定成我们的，就是这样：&lt;/p&gt;
&lt;figure data-raw=&quot;Main.wm.removeKeybinding(&amp;quot;switch-input-source&amp;quot;);
_inputSourceManager._keybindingAction =
  Main.wm.addKeybinding(
    &amp;quot;switch-input-source&amp;quot;,
    new Gio.Settings({&amp;quot;schema_id&amp;quot;: &amp;quot;org.gnome.desktop.wm.keybindings&amp;quot;}),
    Meta.KeyBindingFlags.NONE,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );
Main.wm.removeKeybinding(&amp;quot;switch-input-source-backward&amp;quot;);
_inputSourceManager._keybindingActionBackward =
  Main.wm.addKeybinding(
    &amp;quot;switch-input-source-backward&amp;quot;,
    new Gio.Settings({&amp;quot;schema_id&amp;quot;: &amp;quot;org.gnome.desktop.wm.keybindings&amp;quot;}),
    Meta.KeyBindingFlags.IS_REVERSED,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;Main.wm.removeKeybinding(&quot;switch-input-source&quot;);
_inputSourceManager._keybindingAction =
  Main.wm.addKeybinding(
    &quot;switch-input-source&quot;,
    new Gio.Settings({&quot;schema_id&quot;: &quot;org.gnome.desktop.wm.keybindings&quot;}),
    Meta.KeyBindingFlags.NONE,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );
Main.wm.removeKeybinding(&quot;switch-input-source-backward&quot;);
_inputSourceManager._keybindingActionBackward =
  Main.wm.addKeybinding(
    &quot;switch-input-source-backward&quot;,
    new Gio.Settings({&quot;schema_id&quot;: &quot;org.gnome.desktop.wm.keybindings&quot;}),
    Meta.KeyBindingFlags.IS_REVERSED,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;同样我们也不要忘记绑定 &lt;code&gt;this&lt;/code&gt;，实际上我们希望调用的时候绑定的 &lt;code&gt;this&lt;/code&gt; 是那个单例，那直接 &lt;code&gt;bind&lt;/code&gt; 它就好了。&lt;/p&gt;
&lt;p&gt;但是你会发现这个弱智的家伙没有按我们想象的工作！这是什么意思！仔细阅读代码之后我发现有如下逻辑：你按下的第一次组合键其实并不是算在那个弹框的按键回调里面，而是我们通过构造函数传递进去的，然后它分析这个传进去的按键是哪一种，调用 &lt;code&gt;_initialSelection&lt;/code&gt; 执行第一次切换，而这个家伙更弱智了！明明有 &lt;code&gt;_selectedIndex&lt;/code&gt; 它不用，竟然用硬编码的倒数第一个和第一个！真有你的啊！我不太敢修改 &lt;code&gt;SwitcherPopup&lt;/code&gt; 因为还有别的东西使用它，那就修改 &lt;code&gt;InputSourcePopup&lt;/code&gt; 这个子类吧，其实就是把 &lt;code&gt;InputSourcePopup.prototype._initialSelection&lt;/code&gt; 这个函数原来的的 &lt;code&gt;this._select(this._items.length - 1);&lt;/code&gt; 换成 &lt;code&gt;this._select(this._previous());&lt;/code&gt;，&lt;code&gt;this._select(1)&lt;/code&gt; 换成 &lt;code&gt;this._select(this._next())&lt;/code&gt;（1 其实是 0 + 1 的意思），不但功能增加了，可读性也提升了！&lt;/p&gt;
&lt;p&gt;现在搭配起来应该和我们的需求一致了！但假如我关掉扩展之后希望列表是打开之前的状态怎么办！还记得之前说的那个 &lt;code&gt;_updateMruSources&lt;/code&gt; 会读取 gsettings 吗？这个 gsettings 实际上在每次切换输入法的时候都会写入当前状态，那我们只要让它开启扩展时候不要写入，关掉扩展恢复的时候再更新不就读取了之前的状态吗。所以需要修改 &lt;code&gt;InputSourceManager.prototype._updateMruSettings&lt;/code&gt;，注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L432-438&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L432-438&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;总结一下其实就是在 &lt;code&gt;enable&lt;/code&gt; 的时候修改这些函数，然后获取单例，重新绑定快捷键，然后清空当前的列表重新更新列表，然后为了避免 bug，我们总是激活列表里的第一个输入法：&lt;/p&gt;
&lt;figure data-raw=&quot;if (_inputSourceManager._mruSources.length &gt; 0) {
  _inputSourceManager._mruSources[0].activate(true);
}&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;if (_inputSourceManager._mruSources.length &amp;gt; 0) {
  _inputSourceManager._mruSources[0].activate(true);
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;disable&lt;/code&gt; 的时候同样是把函数修改回去，然后获取单例，重新绑定快捷键这样它又绑成了原来的函数，然后清空当前的列表重新更新列表这样它就恢复到开启之前的顺序了，接下来同样地，因为最近使用优先列表的第一个元素肯定是正在用的，所以我们也还是激活第一个输入法就可以了。&lt;/p&gt;
&lt;p&gt;完整的项目参见 &lt;a href=&quot;https://github.com/AlynxZhou/gnome-shell-extension-fixed-ime-list/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;GitHub&lt;/a&gt;，Arch Linux 用户也可以从 AUR 或者 Arch Linux CN 源安装 &lt;code&gt;gnome-shell-extension-fixed-ime-list&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    
    
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    
  </entry>
  
  
  
  <entry>
    <title>GObject 备忘录</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/GObject-Reminder/" />
    <id>https://sh.alynx.one/posts/GObject-Reminder/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-09-05T01:23:00.000Z</published>
    
    
    <updated>2020-09-05T01:23:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;说来惭愧，我一直记不太清 GObject 到底是怎么用的，毕竟作为一个写过 C++ 和 Python 然后常用 JS 的人来说，面向对象的实现是非常自然的，不需要考虑为什么。所以我总是看着一大堆类型转换和分散的定义以及各种 chain up 感到眩晕。而 GObject 的文档写的也相当分散，有种管中窥豹之感。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;说来惭愧，我一直记不太清 GObject 到底是怎么用的，毕竟作为一个写过 C++ 和 Python 然后常用 JS 的人来说，面向对象的实现是非常自然的，不需要考虑为什么。所以我总是看着一大堆类型转换和分散的定义以及各种 chain up 感到眩晕。而 GObject 的文档写的也相当分散，有种管中窥豹之感。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;有同学觉得其实把函数变成指针放在结构体里看起来就面向对象了，以前我也这么觉得，但是显然这样不能实现继承封装等等特性，GObject 独特之处在于它实现了这些，并且是和语言独立的。当然，要想在一个没有这些概念的语言里面做到这些，就有很多需要自己手动处理和函数库处理的地方，就是因为有些隐藏了起来有些又要自己做，才让它看起来像古老的黑魔法。&lt;/p&gt;
&lt;p&gt;最近我尝试做了一个小项目，以便搞清楚如何按照 GObject 的模式编写一些继承封装的代码。&lt;/p&gt;
&lt;p&gt;首先得给项目起名字，因为 GObject 要求你的命名符合一定的约定，其中一个前缀是项目名，不过这个 简单，就叫 &lt;code&gt;test&lt;/code&gt; 好了，然后做一个基类叫 &lt;code&gt;animal&lt;/code&gt;，于是就有了 &lt;code&gt;test-animal.h&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#ifndef __TEST_ANIMAL_H__
#define __TEST_ANIMAL_H__

#include &lt;glib-object.h&gt;

G_BEGIN_DECLS

// 这个玩意必须要手动定义。
#define TEST_TYPE_ANIMAL test_animal_get_type()
// 这个玩意会展开成一大堆函数声明、typedef 什么的，
// 所以我们只要按约定定义结构体实现函数。
G_DECLARE_DERIVABLE_TYPE(TestAnimal, test_animal, TEST, ANIMAL, GObject)

// 但是上面那个玩意其实不会给你搞一个类结构体出来，
// 而且这个因为是给其他文件用的所以必须写在头文件里，
// 不然人家怎么知道你有什么虚函数！
struct _TestAnimalClass {
    GObjectClass parent_class;
    // 定义一个可以继承的函数。
    void (*print)(TestAnimal *animal);
    gpointer padding[12];
};

// 因为上面的 class 里面定义了，这个只是调用那个。
void test_animal_print(TestAnimal *animal);
// 这个玩意得手动定义，是个不可继承的公开函数。
TestAnimal *test_animal_new(gchar *animal_name);

G_END_DECLS

#endif&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#ifndef __TEST_ANIMAL_H__
#define __TEST_ANIMAL_H__

#include &amp;lt;glib-object.h&amp;gt;

G_BEGIN_DECLS

// 这个玩意必须要手动定义。
#define TEST_TYPE_ANIMAL test_animal_get_type()
// 这个玩意会展开成一大堆函数声明、typedef 什么的，
// 所以我们只要按约定定义结构体实现函数。
G_DECLARE_DERIVABLE_TYPE(TestAnimal, test_animal, TEST, ANIMAL, GObject)

// 但是上面那个玩意其实不会给你搞一个类结构体出来，
// 而且这个因为是给其他文件用的所以必须写在头文件里，
// 不然人家怎么知道你有什么虚函数！
struct _TestAnimalClass {
    GObjectClass parent_class;
    // 定义一个可以继承的函数。
    void (*print)(TestAnimal *animal);
    gpointer padding[12];
};

// 因为上面的 class 里面定义了，这个只是调用那个。
void test_animal_print(TestAnimal *animal);
// 这个玩意得手动定义，是个不可继承的公开函数。
TestAnimal *test_animal_new(gchar *animal_name);

G_END_DECLS

#endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为代码里写了很多注释所以我这里就不再啰嗦一遍了，说点里面没写的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 表示你声明了一个可以继承的类，也就是说你需要自己弄一个虚函数表出来。有时候你会在某个 GObject 的项目里定义了一大堆宏（比如 GTK 就不爱用这个而是手动定义），其实它们和 &lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 做了一样的工作，因为总要做，就写了个宏实现。这个并不会给你定义具体的类结构体（其实就是虚函数表，用来存放所有可以继承重载的函数），所以我们要按照约定自己写一个 &lt;code&gt;_TestAnimalClass&lt;/code&gt; 的结构体，在类型名字前面加下划线作为结构体名也是约定俗成的，&lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 会展开出一句 &lt;code&gt;typedef struct _TestAnimalClass TestAnimalClass&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个类结构体约定第一个元素是它的父类型的类结构体——这其实意味着我们复制了一份父类型的虚函数表出来，于是我们就可以覆盖父类型的方法而不修改原本的父类型。这一句可能比较难懂，不过后面还有关联。&lt;/p&gt;
&lt;p&gt;这个类结构体存放的并不是实例的变量，它有点类似于 JS 里面的原型，这样我们就不需要给每一个生成的实例复制一份虚函数了，它们共用一个虚函数表。&lt;/p&gt;
&lt;p&gt;然后会有一个 &lt;code&gt;test-animal.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-animal.h&amp;quot;

// Derivable 类型会自动帮你定义实例结构体，
// 所以你想夹带点私货就得自己搞个 Private 类型。
typedef struct {
    gchar *animal_name;
} TestAnimalPrivate;

// 这个也会展开一大堆声明什么的。
G_DEFINE_TYPE_WITH_PRIVATE(TestAnimal, test_animal, G_TYPE_OBJECT)

// 要想通过 new 函数直接初始化一些值就需要搞点属性。
enum {
    PROP_0,
    PROP_ANIMAL_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        if (priv-&gt;animal_name)
            g_free(priv-&gt;animal_name);
        // 所以其实我们是在设置属性的时候更新私有成员。
        priv-&gt;animal_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        // 所以你看属性这个名称和我们想的属性不一样，
        // 其他语言里面属性就是成员，能存点东西，
        // 但这里好像属性只是成员的一个代理，
        // 具体的东西存在成员里面，通过属性设置。
        g_value_set_string(value, priv-&gt;animal_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 给子类提供一个默认的实现，这样它就不是一个纯虚函数了。
static void print_impl(TestAnimal *animal)
{
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);
    g_message(&amp;quot;I am an Animal called %s.&amp;quot;, priv-&gt;animal_name);
}

static void test_animal_class_init(TestAnimalClass *animal_class)
{
    // 首先我们覆盖这个类里面的 GObject 类的方法，
    // 你调用 GObject 的函数，他会先获取参数的 GObject 类，
    // 那就获取到我们这个了，然后具体的实现就是我们覆盖的这个。
    GObjectClass *object_class = G_OBJECT_CLASS(animal_class);
    object_class-&gt;get_property = get_property_impl;
    object_class-&gt;set_property = set_property_impl;

    // 给虚方法设置默认实现。
    animal_class-&gt;print = print_impl;

    obj_properties[PROP_ANIMAL_NAME] = g_param_spec_string(
        &amp;quot;animal-name&amp;quot;,
        &amp;quot;Animal Name&amp;quot;,
        &amp;quot;Name of Animal&amp;quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_animal_init(TestAnimal *animal)
{
}

void test_animal_print(TestAnimal *animal)
{
    // 你看其实这里和 GObject 类设置属性的原理是一样的。
    // 子类调用这个函数，实际上获取到的是子类自己那个 Animal 类，
    // 于是他只要覆盖自己的那个 Animal 类，调用的就是他自己的。
    TestAnimalClass *animal_class;
    animal_class = TEST_ANIMAL_GET_CLASS(animal);
    g_return_if_fail(animal_class-&gt;print != NULL);
    animal_class-&gt;print(animal);
}

TestAnimal *test_animal_new(gchar *animal_name)
{
    g_return_val_if_fail(animal_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_ANIMAL,
        &amp;quot;animal-name&amp;quot;, animal_name,
        NULL
    );
}&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-animal.h&quot;

// Derivable 类型会自动帮你定义实例结构体，
// 所以你想夹带点私货就得自己搞个 Private 类型。
typedef struct {
    gchar *animal_name;
} TestAnimalPrivate;

// 这个也会展开一大堆声明什么的。
G_DEFINE_TYPE_WITH_PRIVATE(TestAnimal, test_animal, G_TYPE_OBJECT)

// 要想通过 new 函数直接初始化一些值就需要搞点属性。
enum {
    PROP_0,
    PROP_ANIMAL_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        if (priv-&amp;gt;animal_name)
            g_free(priv-&amp;gt;animal_name);
        // 所以其实我们是在设置属性的时候更新私有成员。
        priv-&amp;gt;animal_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        // 所以你看属性这个名称和我们想的属性不一样，
        // 其他语言里面属性就是成员，能存点东西，
        // 但这里好像属性只是成员的一个代理，
        // 具体的东西存在成员里面，通过属性设置。
        g_value_set_string(value, priv-&amp;gt;animal_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 给子类提供一个默认的实现，这样它就不是一个纯虚函数了。
static void print_impl(TestAnimal *animal)
{
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);
    g_message(&quot;I am an Animal called %s.&quot;, priv-&amp;gt;animal_name);
}

static void test_animal_class_init(TestAnimalClass *animal_class)
{
    // 首先我们覆盖这个类里面的 GObject 类的方法，
    // 你调用 GObject 的函数，他会先获取参数的 GObject 类，
    // 那就获取到我们这个了，然后具体的实现就是我们覆盖的这个。
    GObjectClass *object_class = G_OBJECT_CLASS(animal_class);
    object_class-&amp;gt;get_property = get_property_impl;
    object_class-&amp;gt;set_property = set_property_impl;

    // 给虚方法设置默认实现。
    animal_class-&amp;gt;print = print_impl;

    obj_properties[PROP_ANIMAL_NAME] = g_param_spec_string(
        &quot;animal-name&quot;,
        &quot;Animal Name&quot;,
        &quot;Name of Animal&quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_animal_init(TestAnimal *animal)
{
}

void test_animal_print(TestAnimal *animal)
{
    // 你看其实这里和 GObject 类设置属性的原理是一样的。
    // 子类调用这个函数，实际上获取到的是子类自己那个 Animal 类，
    // 于是他只要覆盖自己的那个 Animal 类，调用的就是他自己的。
    TestAnimalClass *animal_class;
    animal_class = TEST_ANIMAL_GET_CLASS(animal);
    g_return_if_fail(animal_class-&amp;gt;print != NULL);
    animal_class-&amp;gt;print(animal);
}

TestAnimal *test_animal_new(gchar *animal_name)
{
    g_return_val_if_fail(animal_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_ANIMAL,
        &quot;animal-name&quot;, animal_name,
        NULL
    );
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;理论上来说我们直接往实例结构体里添加成员作为私有成员就可以，但是在头文件里定义实例结构体，其它文件是可以看到实例结构体的成员的，所以 &lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 不允许我们这么做。&lt;/p&gt;
&lt;p&gt;但有一个省事的宏 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt;，它要求我们做一个 Private 类型，里面存放我们想要的任何私有元素，它不会被继承，并且因为定义在 &lt;code&gt;.c&lt;/code&gt; 文件里所以也不会被其它文件看到。它还会提供一些 GObject 内置类型系统的实现函数（不然 GObject 系统怎么知道你建了哪些类型！），还有一些只在实现里面用到的定义。当然 Private 类型的名字也是约定好的。&lt;/p&gt;
&lt;p&gt;多说一句，按照 GTK 的代码实现，其实 Private 最后就是在实例结构体里面定义了一个叫 &lt;code&gt;priv&lt;/code&gt; 的指针，类型是自己定义的 Private 类型，因为 GTK 是手写的头文件定义然后用的 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt; 同时又没产生冲突，其实你也可以完全不理会这两个宏，全都自己写，只要保证类结构体和实例结构体的第一个成员是父类结构体和父实例结构体就可以了。但是 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt; 提供了一个 &lt;code&gt;项目名_类型名_get_instance_private&lt;/code&gt; 的函数，我们就不用直接访问 &lt;code&gt;priv&lt;/code&gt; 成员了。&lt;/p&gt;
&lt;p&gt;在使用 &lt;code&gt;g_object_new&lt;/code&gt; 新建一个对象的时候可以通过 key-value 的方式设置一些初始值，这个其实是通过 GObject 提供的 property 功能实现的，因为 C 并没有哈希表这种东西。这个过程很繁琐但也很固定，其实就是实现其它语言里面传一个对象作为构造函数参数然后以此设置私有成员初始值的功能。property 就是参数，具体的内容还是存在初始值里面的，不过其实你也可以通过 property 访问具体的值。这里很容易理解成 property 有自己单独的存储空间，其实不是。property 是可以继承的，所以子类可以同时设置父类和自己的 property。&lt;/p&gt;
&lt;p&gt;然后我们要接触到第一个重载的部分了，因为 &lt;code&gt;TestAnimal&lt;/code&gt; 继承了 GObject，所以我们要重载掉它类结构体里面的父类结构体的 &lt;code&gt;set_property&lt;/code&gt; 和 &lt;code&gt;get_property&lt;/code&gt; 函数。过程也很简单，GObject 要求我们实现两个函数 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt; 和 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt;，其中前者就是让我们初始化类结构体用的。首先进行一个类型转换把 &lt;code&gt;TestAnimalClass&lt;/code&gt; 转换成 &lt;code&gt;GObjectClass&lt;/code&gt;（为什么可以强转？那你先思考一下为什么定义类结构体时候第一个元素是父类结构体？就是因为要这样才能进行类型转换，本质上是个套娃），然后直接赋值。这样假如有人对我们这个类型执行 &lt;code&gt;g_object_set_property&lt;/code&gt;，实际上是调用的我们重载过的函数（为什么？怎么做到的？往下看）。&lt;/p&gt;
&lt;p&gt;那其实我们知道如何覆盖父类的方法，但运行的时候是如何动态重载到我们自己的函数的也不清楚，我们先搞定我们自己的那个虚函数，其实很简单，我们定义具体的方法的时候（指 &lt;code&gt;test_animal_print&lt;/code&gt;），不要让它实现具体的逻辑，而是让它通过参数的实例执行虚函数表里的函数就可以了。这需要一个自动生成的 &lt;code&gt;项目名_类型名_GET_CLASS&lt;/code&gt; 的宏，它的作用是通过一个实例查找到 &lt;strong&gt;这个实例本身&lt;/strong&gt; 对应的类结构体，然后就可以运行虚函数了。比如我给 &lt;code&gt;g_object_set_property&lt;/code&gt; 传一个 &lt;code&gt;TestAnimal&lt;/code&gt;，那我们调用的其实是 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的第一个成员那个 &lt;code&gt;GObjectClass&lt;/code&gt; 的 &lt;code&gt;set_property&lt;/code&gt;，这个已经被我们改成自己的了，于是就实现了一个 &lt;del&gt;不那么直观的&lt;/del&gt; 重载。&lt;/p&gt;
&lt;p&gt;当然假如我们不想写一个纯虚函数，可以在 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt; 里面设置一个初值，这样假如子类没有重载，调用的就是这个。&lt;/p&gt;
&lt;p&gt;那你可能要问假如我有一个不想被重载的函数呢，那你就不要跳虚函数表了，直接写逻辑就可以了。&lt;/p&gt;
&lt;p&gt;接下来我们终于可以写子类的，首先就是 &lt;code&gt;test-cat.h&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#ifndef __TEST_CAT_H__
#define __TEST_CAT_H__

#include &lt;glib-object.h&gt;
#include &amp;quot;test-animal.h&amp;quot;

G_BEGIN_DECLS

#define TEST_TYPE_CAT test_cat_get_type()
// Final 类型就不用写类结构体啦，反正那个最大的用处是用来写可以继承的虚函数。
G_DECLARE_FINAL_TYPE(TestCat, test_cat, TEST, CAT, TestAnimal);

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name);

G_END_DECLS

#endif&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#ifndef __TEST_CAT_H__
#define __TEST_CAT_H__

#include &amp;lt;glib-object.h&amp;gt;
#include &quot;test-animal.h&quot;

G_BEGIN_DECLS

#define TEST_TYPE_CAT test_cat_get_type()
// Final 类型就不用写类结构体啦，反正那个最大的用处是用来写可以继承的虚函数。
G_DECLARE_FINAL_TYPE(TestCat, test_cat, TEST, CAT, TestAnimal);

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name);

G_END_DECLS

#endif&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;TestCat&lt;/code&gt; 是继承 &lt;code&gt;TestAnimal&lt;/code&gt; 的，并且我们不想让它被继承，所以它就不需要写类结构体了（因为虚函数表是用来重载的，没有继承当然也没有重载）。&lt;/p&gt;
&lt;p&gt;所以接下来就直接到实现部分了，在 &lt;code&gt;test-cat.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-cat.h&amp;quot;

// Final 类型也没有 Private，但是它自己本身就是容器嘛！
// 所以实例结构体就给你自己写了。
// 当然别的文件不需要知道你有什么私货所以不要写在头文件里。
struct _TestCat {
    TestAnimal parent_instance;
    gchar *cat_name;
};

G_DEFINE_TYPE(TestCat, test_cat, TEST_TYPE_ANIMAL)

enum {
    PROP_0,
    PROP_CAT_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        if (cat-&gt;cat_name)
            g_free(cat-&gt;cat_name);
        cat-&gt;cat_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        g_value_set_string(value, cat-&gt;cat_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 那我们不想要默认的实现就可以覆盖掉自己的。
static void print_impl(TestAnimal *animal)
{
    TestCat *cat = TEST_CAT(animal);
    g_message(&amp;quot;I am a Cat called %s.&amp;quot;, cat-&gt;cat_name);
    // 这个自动生成的 parent 变量指向的是真正的父类！
    // 因为我们自己带的父类结构体被我们覆盖了，所以这里给你一个访问正主的机会。
    // 它是个 gpointer 所以你得手动设置类型。
    // 其实你的子类如果是完全覆盖父类的功能其实我觉得不用写这一句了。
    // 但是有时候你的子类是在父类上面增加功能就得写。
    // 这不就是 super 指针嘛！
    TEST_ANIMAL_CLASS(test_cat_parent_class)-&gt;print(animal);
}

static void test_cat_class_init(TestCatClass *cat_class)
{
    GObjectClass *object_class = G_OBJECT_CLASS(cat_class);
    object_class-&gt;get_property = get_property_impl;
    object_class-&gt;set_property = set_property_impl;

    // 干掉我们自己的这个父类结构体里面带的内置实现，
    // 这样父类的函数调用的其实是我们自己的这个实现。
    // 那你看你一会让父类调用自己一会又让自己调用父类可真是麻烦。
    TestAnimalClass *animal_class = TEST_ANIMAL_CLASS(cat_class);
    animal_class-&gt;print = print_impl;

    obj_properties[PROP_CAT_NAME] = g_param_spec_string(
        &amp;quot;cat-name&amp;quot;,
        &amp;quot;Cat Name&amp;quot;,
        &amp;quot;Name of Cat&amp;quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_cat_init(TestCat *cat)
{
}

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name)
{
    g_return_val_if_fail(animal_name != NULL &amp;amp;&amp;amp; cat_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_CAT,
        &amp;quot;animal-name&amp;quot;, animal_name,
        &amp;quot;cat-name&amp;quot;, cat_name,
        NULL
    );
}&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-cat.h&quot;

// Final 类型也没有 Private，但是它自己本身就是容器嘛！
// 所以实例结构体就给你自己写了。
// 当然别的文件不需要知道你有什么私货所以不要写在头文件里。
struct _TestCat {
    TestAnimal parent_instance;
    gchar *cat_name;
};

G_DEFINE_TYPE(TestCat, test_cat, TEST_TYPE_ANIMAL)

enum {
    PROP_0,
    PROP_CAT_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        if (cat-&amp;gt;cat_name)
            g_free(cat-&amp;gt;cat_name);
        cat-&amp;gt;cat_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        g_value_set_string(value, cat-&amp;gt;cat_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 那我们不想要默认的实现就可以覆盖掉自己的。
static void print_impl(TestAnimal *animal)
{
    TestCat *cat = TEST_CAT(animal);
    g_message(&quot;I am a Cat called %s.&quot;, cat-&amp;gt;cat_name);
    // 这个自动生成的 parent 变量指向的是真正的父类！
    // 因为我们自己带的父类结构体被我们覆盖了，所以这里给你一个访问正主的机会。
    // 它是个 gpointer 所以你得手动设置类型。
    // 其实你的子类如果是完全覆盖父类的功能其实我觉得不用写这一句了。
    // 但是有时候你的子类是在父类上面增加功能就得写。
    // 这不就是 super 指针嘛！
    TEST_ANIMAL_CLASS(test_cat_parent_class)-&amp;gt;print(animal);
}

static void test_cat_class_init(TestCatClass *cat_class)
{
    GObjectClass *object_class = G_OBJECT_CLASS(cat_class);
    object_class-&amp;gt;get_property = get_property_impl;
    object_class-&amp;gt;set_property = set_property_impl;

    // 干掉我们自己的这个父类结构体里面带的内置实现，
    // 这样父类的函数调用的其实是我们自己的这个实现。
    // 那你看你一会让父类调用自己一会又让自己调用父类可真是麻烦。
    TestAnimalClass *animal_class = TEST_ANIMAL_CLASS(cat_class);
    animal_class-&amp;gt;print = print_impl;

    obj_properties[PROP_CAT_NAME] = g_param_spec_string(
        &quot;cat-name&quot;,
        &quot;Cat Name&quot;,
        &quot;Name of Cat&quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_cat_init(TestCat *cat)
{
}

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name)
{
    g_return_val_if_fail(animal_name != NULL &amp;amp;&amp;amp; cat_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_CAT,
        &quot;animal-name&quot;, animal_name,
        &quot;cat-name&quot;, cat_name,
        NULL
    );
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Final 类型没有 Private，因为它自己就是 Private，所以这个定义实例结构体的权力交给了你，直接在里面写私有成员即可，但是不要忘了套娃（指第一个成员一定要是父实例结构体）。&lt;/p&gt;
&lt;p&gt;然后就是设置我们自己的 property 并重载 GObject 的虚函数，当然你可能会说这样父类型的 property 不就丢了吗？其实 property 是放在 GObject 系统单独的一个表里，需要的时候它去查询，并且会考虑父类型的继承链，所以我们不需要考虑重载时候覆盖掉父类型的问题。&lt;/p&gt;
&lt;p&gt;接下来就是重载父类型提供给我们的虚函数也就是 &lt;code&gt;TestCatClass.print&lt;/code&gt; 了！当然首先是把我们自己的类结构体里面的父类结构体的虚函数换掉。&lt;/p&gt;
&lt;p&gt;在写我们自己重载的函数的时候，一个比较重要的事情是 chain up，也就是最后一行那个 &lt;code&gt;TEST_ANIMAL_CLASS(test_cat_parent_class)-&amp;gt;print(animal);&lt;/code&gt;，有时候你重载只是做了一些子类自己的处理，然后还是需要父类提供的处理函数的，这该怎么办？你可能会说类结构体里面不是有个父类结构体了吗？但那个已经被我们覆盖了！你这样不就是咬自己尾巴的猫吗？&lt;/p&gt;
&lt;p&gt;当我们自己解决不了的时候就得 GObject 解决了，&lt;code&gt;G_DEFINE_TYPE&lt;/code&gt; 会提供一个 &lt;code&gt;项目名_类型名_parent_class&lt;/code&gt; 的指针定义，这个指向的是那个真正的唯一的 &lt;strong&gt;不是我们自己包含的&lt;/strong&gt; 那个父类结构体！也就是说对于子类和父类继承而言，有两个父类结构体，一个是父类自己作为一个类的那个，另一个是子类为了实现重载包含的那个，这个访问的就是前者。&lt;/p&gt;
&lt;p&gt;当然这个类型其实是个 &lt;code&gt;gpointer&lt;/code&gt; 所以我们还得自己转换一下类型，然后只要调用方法就可以了（这不就是 super 指针嘛）。&lt;/p&gt;
&lt;p&gt;最后我们写一个测试的程序 &lt;code&gt;main.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-animal.h&amp;quot;
#include &amp;quot;test-cat.h&amp;quot;

int main(int argc, char *argv[])
{
    TestAnimal *animal = test_animal_new(&amp;quot;animal1&amp;quot;);
    TestCat *cat = test_cat_new(&amp;quot;animal2&amp;quot;, &amp;quot;cat1&amp;quot;);
    test_animal_print(animal);
    test_animal_print(TEST_ANIMAL(cat));
    return 0;
}&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-animal.h&quot;
#include &quot;test-cat.h&quot;

int main(int argc, char *argv[])
{
    TestAnimal *animal = test_animal_new(&quot;animal1&quot;);
    TestCat *cat = test_cat_new(&quot;animal2&quot;, &quot;cat1&quot;);
    test_animal_print(animal);
    test_animal_print(TEST_ANIMAL(cat));
    return 0;
}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后用这个 &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;CC := cc
OBJECTS := main.o test-animal.o test-cat.o
CFLAGS := `pkg-config --cflags gobject-2.0`
LIBS := `pkg-config --libs gobject-2.0`

all: ${OBJECTS}
    ${CC} -o test ${OBJECTS} ${LIBS}

main.o: test-animal.h test-cat.h
    ${CC} -c main.c ${CFLAGS}

test-animal.o:
    ${CC} -c test-animal.c ${CFLAGS}

test-cat.o: test-animal.h
    ${CC} -c test-cat.c ${CFLAGS}

.PHONY: clean
clean:
    -rm test ${OBJECTS}&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;CC := cc
OBJECTS := main.o test-animal.o test-cat.o
CFLAGS := `pkg-config --cflags gobject-2.0`
LIBS := `pkg-config --libs gobject-2.0`

all: ${OBJECTS}
    ${CC} -o test ${OBJECTS} ${LIBS}

main.o: test-animal.h test-cat.h
    ${CC} -c main.c ${CFLAGS}

test-animal.o:
    ${CC} -c test-animal.c ${CFLAGS}

test-cat.o: test-animal.h
    ${CC} -c test-cat.c ${CFLAGS}

.PHONY: clean
clean:
    -rm test ${OBJECTS}&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;运行的结果是这样的：&lt;/p&gt;
&lt;figure data-raw=&quot;** Message: 11:23:25.727: I am an Animal called animal1.
** Message: 11:23:25.729: I am a Cat called cat1.
** Message: 11:23:25.729: I am an Animal called animal2.&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;** Message: 11:23:25.727: I am an Animal called animal1.
** Message: 11:23:25.729: I am a Cat called cat1.
** Message: 11:23:25.729: I am an Animal called animal2.&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;你可以看到第一行是父类也就是 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的函数的输出。第二行是 &lt;code&gt;TestCatClass&lt;/code&gt; 重载的函数的输出，第三行则是 &lt;code&gt;TestCatClass&lt;/code&gt; 重载的函数 chain up 到 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的输出，但是输出的是子类继承的父类的属性！&lt;/p&gt;
&lt;p&gt;最后有关我到底该声明成子类还是父类以及传参时候要不要类型转换：其实在这个 GObject 的样例里面看起来是无所谓的，类型转换可行不可行其实取决于具体 new 的是什么，而不是声明的指针是什么，所以其实声明成父类和子类都没有关系，类型转换也主要是为了满足 C 语言对指针类型和函数声明的要求罢了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    
    
    <category term="GObject" label="GObject" scheme="https://sh.alynx.one/tags/GObject/" />
    
  </entry>
  
  
  
  <entry>
    <title>基于 GitHub Issue 的前端评论框</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Frontend-GitHub-Issue-Based-Comment/" />
    <id>https://sh.alynx.one/posts/Frontend-GitHub-Issue-Based-Comment/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-08-15T10:25:00.000Z</published>
    
    
    <updated>2020-08-18T04:25:00.000Z</updated>
    
    
    <summary type="html">
      &lt;h1 id=&quot;造轮子是病，得治。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E9%80%A0%E8%BD%AE%E5%AD%90%E6%98%AF%E7%97%85%EF%BC%8C%E5%BE%97%E6%B2%BB%E3%80%82&quot; title=&quot;造轮子是病，得治。&quot;&gt;&lt;/a&gt;造轮子是病，得治。&lt;/h1&gt;
&lt;p&gt;自从造了 &lt;a href=&quot;/posts/Frontend-Blog-Search/&quot;&gt;前端博客搜索引擎&lt;/a&gt; 的轮子之后，我对自己的能力有了极大的信心，同时也掌握了一些有趣的用法，于是把枪口瞄准了下一个我看着不顺眼的地方——评论框。&lt;/p&gt;
&lt;p&gt;（这标题怎么写的和毕业论文似的！）&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;h1 id=&quot;造轮子是病，得治。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E9%80%A0%E8%BD%AE%E5%AD%90%E6%98%AF%E7%97%85%EF%BC%8C%E5%BE%97%E6%B2%BB%E3%80%82&quot; title=&quot;造轮子是病，得治。&quot;&gt;&lt;/a&gt;造轮子是病，得治。&lt;/h1&gt;
&lt;p&gt;自从造了 &lt;a href=&quot;/posts/Frontend-Blog-Search/&quot;&gt;前端博客搜索引擎&lt;/a&gt; 的轮子之后，我对自己的能力有了极大的信心，同时也掌握了一些有趣的用法，于是把枪口瞄准了下一个我看着不顺眼的地方——评论框。&lt;/p&gt;
&lt;p&gt;（这标题怎么写的和毕业论文似的！）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;轮子也不是白造的。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E8%BD%AE%E5%AD%90%E4%B9%9F%E4%B8%8D%E6%98%AF%E7%99%BD%E9%80%A0%E7%9A%84%E3%80%82&quot; title=&quot;轮子也不是白造的。&quot;&gt;&lt;/a&gt;轮子也不是白造的。&lt;/h1&gt;
&lt;p&gt;从我建站以来我的评论框就命途多舛，Disqus 虽然是最著名的评论系统，但是在国内访问不太顺畅。多说火了一段时间之后便关门大吉，HyperComments 则在我用了一段时间后发邮件提示要收费了，于是我之前的评论便华丽流失。而对于 Valine 这种基于 LeanCloud 的评论系统，我对 LeanCloud 不甚了解所以也不想尝试（而且 Valine 现在似乎转向闭源了，当初也许是个正确的决定）。然后赶上 Gitment 和 Gitalk 火了起来，大家意识到 GitHub Issue 正是个放评论的好地方。但是由于 &lt;a href=&quot;https://github.com/iissnan/hexo-theme-next/pull/1634#issuecomment-313596649&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Gitment 和 Gitalk 采用他们自己的服务器实现博客评论框提交——转发到 GitHub API 的实现&lt;/a&gt;，以及 &lt;a href=&quot;https://www.v2ex.com/t/535608&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;采用的 OAuth App 权限过高&lt;/a&gt;，有人怀疑这不太安全，于是我也没太敢参与。后来遇到 &lt;a href=&quot;https://github.com/wzpan/comment.js&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;comment.js&lt;/a&gt; 这个项目，它绕过了提交评论的问题——直接给一个到 GitHub Issue 的评论框的链接就可以了。于是我就开始用这个，至于什么 utterances 这种用 GitHub App 降低权限的评论系统，我也懒得尝试了。&lt;/p&gt;
&lt;p&gt;但我为什么决定替换掉 comment.js 我已经记不清楚了，可能是为了对主题的显示有更好的掌握吧，毕竟它带有自己的 CSS 样式而且经常和我的冲突，也可能是因为它迟迟没提供像 Disqus 一样查找每篇文章评论数目的功能，不过它现在已经不再维护了，所以我也算是未雨绸缪。&lt;/p&gt;
&lt;h1 id=&quot;事情本该很简单。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E4%BA%8B%E6%83%85%E6%9C%AC%E8%AF%A5%E5%BE%88%E7%AE%80%E5%8D%95%E3%80%82&quot; title=&quot;事情本该很简单。&quot;&gt;&lt;/a&gt;事情本该很简单。&lt;/h1&gt;
&lt;p&gt;研究了一下原理其实并不是很难，首先就是从 GitHub 的 API 上 ajax 获取数据，然后操作 DOM 添进去就可以了，所以我就先阅读了 &lt;a href=&quot;https://docs.github.com/en/rest/reference/issues&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;GitHub API 的文档&lt;/a&gt;，总之还算容易，只要先获取一个仓库的 issue 列表，然后按照某种方法在里面查找相关的 issue，如果没有就渲染一个到新建 issue 的链接，否则获取该 issue 的全部评论并显示就可以了。&lt;/p&gt;
&lt;p&gt;查找 issue 的 key 也算容易，我给它做成了函数参数，然后在主题模板里填一个每个页面唯一的字符串就行了，比如文章标题，然后新生成 issue 页面时候就把这个作为 issue 的标题，这样查找 GitHub Issue 页面时候也比较容易看。然后 GitHub 把 PR 也视为 issue，这个不要紧，收到数组之后过滤一下就好了。而显示数目我琢磨了一下其实也没什么难的嘛！我都获取到所有 issue 的信息了。做一个新的函数，主题作者在页面上放置一系列空的元素并设置好 class 属性，然后同样地把每个页面唯一的字符串设置成这些元素的属性（Disqus 也是这样的），加载函数时候把 class 作为参数传进去，分别从 issue 列表里查找对应的标题就可以了。还有一个奇葩问题是 GitHub issue 的 comments 指的是除了顶楼以外的评论，但很显然看起来不是这样的，这个也简单，直接把顶楼加到数组里就成了嘛。剩下就是艰苦的在浏览器里刀耕火种写 JS 拼 HTML 字符串发 ajax 请求写嵌套回调（没有 async/await 也太痛苦了吧！。&lt;/p&gt;
&lt;p&gt;一切正常工作了一段时间一后我发现不太对劲，怎么评论太多的时候显示不全呢？仔细查了一下发现 GitHub API 是强制分页的，也就是说不管你怎么设置，最多一次只能获取 100 条评论，默认则是 30 条，本来我不太想给博客加评论分页功能的，现在看来是 GitHub 被迫让我加啊。当然这个并不是最痛苦的，最痛苦的是它查找仓库的 issue 列表的时候也是强制分页的！这就麻烦了，还记得我们之前说要获取到列表之后查找标题吗？获取不到完整列表还怎么查找啊！&lt;/p&gt;
&lt;p&gt;当然你可以说按顺序多查几页不就行了嘛，这就是它分页难受的地方了！ajax 是异步的啊亲！你不会想让我一个 for 循环几个 ajax 还指望优雅的等他们结束了再跑查找吧！我知道能用 &lt;code&gt;Promise.all()&lt;/code&gt; 解决，但是由于我大发慈悲的支持使用 IE11 的用户（微软我&amp;amp;A%￥S&amp;amp;……省略一千字儒雅随和），所以我的函数是基于回调的，那也没什么办法。而且这样首先你得读一下仓库信息才能知道有多少个 open 的 issue（没错只能算 open 的不能算 close 的！所以在后面查 issue 的时候我也不得不筛选掉 close 的，不过这大概也许是个 feature？），然后自己计算有多少页。最后我只能造了一个不那么优雅的尾递归回调（反正就那个意思），不过它工作的不错，这样我就可以获取到全部的 issue 列表了。&lt;/p&gt;
&lt;p&gt;然后后面其实还是差不多，至于评论分页又不一样了，既然 GitHub 只有分页 API，我也就半推半就啊不是将计就计吧。我才不要继续获取全部评论了，我也每次直接获取 GitHub 那边的一页就行了，每页个数则由主题作者传参进来。至于如何确定我要哪一页呢？和搜索功能一样，继续前端解析 query string 呗。根据 issue 评论总数计算一下有几页，然后生成几个链接放在页尾，每次加载时候解析一下参数确定当前页是哪个即可。当然，不要忘了 issue 顶楼不算评论，计算分页的时候也不要给它加进去！而且既然是这么分页，我也懒得把顶楼算在里面了（不然真的麻烦的要死啊后面分页和每页个数全乱了），所以假如你设置每页 10 个评论，那第一页其实有 11 个，别烦我，代码在那，不满意自己改……然后继续刀耕火种……&lt;/p&gt;
&lt;p&gt;为了减轻负担，我没有实现太多的功能，比如时间戳我没有搞成什么几分钟几小时前，这种东西又不清晰又浪费带宽，我只搞了&lt;del&gt;基于 marked 的 Markdown 渲染（必须的）和&lt;/del&gt;语法高亮，Markdown 渲染不是必须的，因为你可以 &lt;a href=&quot;https://docs.github.com/en/rest/overview/media-types#comment-body-properties&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;设置 header 让 GitHub 直接返回 HTML&lt;/a&gt;。为了保证效果统一，这个 JS 只是建立了 HTML 布局，给每个元素添加了 class，具体的样式则完全是主题自己编写的，所以配合起来也比较好看。&lt;/p&gt;
&lt;p&gt;最后的效果其实还可以，完整的脚本就是 &lt;a href=&quot;/js/comment.js&quot;&gt;这个网站在用的 JS&lt;/a&gt;，具体和主题的整合方法就慢慢翻 ARIA 的模板吧。唯一的缺点是 GitHub API 的频率限制太低，按照这个弱智的 issue 列表分页的话又不得不多一次读取仓库有多少 issue 的请求，假如你的 issue 太多估计也是问题？不过应该不会有那么多博文吧！我只有调试脚本的时候遇到过被 GitHub 提示等会的问题，所以对于访问者应该没什么影响。有影响以后再想解决办法（或者没办法）。&lt;/p&gt;
&lt;p&gt;也许最好的办法是解决掉需求——要什么评论框？不就是破事水？如果有问题想联系作者电子邮件又不是不能用！（逃&lt;/p&gt;
&lt;h1 id=&quot;其实你知道，烦恼（bug）会解决烦恼（bug）。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E5%85%B6%E5%AE%9E%E4%BD%A0%E7%9F%A5%E9%81%93%EF%BC%8C%E7%83%A6%E6%81%BC%EF%BC%88bug%EF%BC%89%E4%BC%9A%E8%A7%A3%E5%86%B3%E7%83%A6%E6%81%BC%EF%BC%88bug%EF%BC%89%E3%80%82&quot; title=&quot;其实你知道，烦恼（bug）会解决烦恼（bug）。&quot;&gt;&lt;/a&gt;其实你知道，烦恼（bug）会解决烦恼（bug）。&lt;/h1&gt;
&lt;div class=&quot;alert-green&quot;&gt;这一部分更新于 2020-08-17 10:34:00。&lt;/div&gt;

&lt;p&gt;GitHub API 推荐用户 &lt;a href=&quot;https://docs.github.com/en/rest/overview/resources-in-the-rest-api#conditional-requests&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;缓存之前的请求响应，然后根据缓存的响应的 Header 里面的 ETag 发送请求查询是否过期，若未过期则返回一个不消耗频率限制次数的 304 状态码&lt;/a&gt;。我心想这也简单，那就在前端搞一个缓存就可以了。&lt;/p&gt;
&lt;p&gt;然后我搜索了一番找到了 CacheStorage，看起来它是唯一一个跨标签页的基于 Session 的正宗的前端缓存。但是很显然 IE 又不支持，而且这个 API 基于 Promise 并且只能缓存 Response 对象，也就是说没办法简单的通过在 XHR 的时候判断一下跳过不支持的情况，要 Polyfill 则需要引入完整的 Promise 和 fetch/Response，所以我们做了一个&lt;del&gt;艰难&lt;/del&gt;容易的决定——是时候去掉 IE 支持了！&lt;/p&gt;
&lt;p&gt;于是我把请求 API 的函数改成了如下操作：&lt;/p&gt;
&lt;figure data-raw=&quot;let cachePromise = window.caches.open(&amp;quot;cacheName&amp;quot;);

// Fetching JSON with cache for GitHub API.
const cachedFetchJSON = (path, opts = {}) =&gt; {
  let cachedResponse = null;
  return cachePromise.then((cache) =&gt; {
    return cache.match(path);
  }).then((response) =&gt; {
    // No cache or no ETag, just re-fetch;
    if (response == null || !response.headers.has(&amp;quot;ETag&amp;quot;)) {
      return window.fetch(path, opts);
    }
    // Ask GitHub API whether cache is outdated.
    cachedResponse = response;
    opts[&amp;quot;headers&amp;quot;] = opts[&amp;quot;headers&amp;quot;] || {};
    opts[&amp;quot;headers&amp;quot;][&amp;quot;If-None-Match&amp;quot;] = cachedResponse.headers.get(&amp;quot;ETag&amp;quot;);
    return window.fetch(path, opts);
  }).then((response) =&gt; {
    if (response.status === 200) {
      // No cache or cache outdated and succeed.
      // Update cache.
      cachePromise.then((cache) =&gt; {
        return cache.put(path, response);
      });
      // Cache needs an unconsumed response,
      // so we clone respone before consume it.
      return response.clone().json();
    } else if (response.status === 304 &amp;amp;&amp;amp; cachedResponse != null) {
      // Not modified so use cache.
      return cachedResponse.clone().json();
    } else {
      // fetch does not reject on HTTP error, so we do this manually.
      throw new Error(&amp;quot;Unexpected HTTP status code &amp;quot; + response.status);
    }
  });
};&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;let cachePromise = window.caches.open(&quot;cacheName&quot;);

// Fetching JSON with cache for GitHub API.
const cachedFetchJSON = (path, opts = {}) =&amp;gt; {
  let cachedResponse = null;
  return cachePromise.then((cache) =&amp;gt; {
    return cache.match(path);
  }).then((response) =&amp;gt; {
    // No cache or no ETag, just re-fetch;
    if (response == null || !response.headers.has(&quot;ETag&quot;)) {
      return window.fetch(path, opts);
    }
    // Ask GitHub API whether cache is outdated.
    cachedResponse = response;
    opts[&quot;headers&quot;] = opts[&quot;headers&quot;] || {};
    opts[&quot;headers&quot;][&quot;If-None-Match&quot;] = cachedResponse.headers.get(&quot;ETag&quot;);
    return window.fetch(path, opts);
  }).then((response) =&amp;gt; {
    if (response.status === 200) {
      // No cache or cache outdated and succeed.
      // Update cache.
      cachePromise.then((cache) =&amp;gt; {
        return cache.put(path, response);
      });
      // Cache needs an unconsumed response,
      // so we clone respone before consume it.
      return response.clone().json();
    } else if (response.status === 304 &amp;amp;&amp;amp; cachedResponse != null) {
      // Not modified so use cache.
      return cachedResponse.clone().json();
    } else {
      // fetch does not reject on HTTP error, so we do this manually.
      throw new Error(&quot;Unexpected HTTP status code &quot; + response.status);
    }
  });
};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当然理想很丰满现实很骨感，在不支持 CacheStorage 的浏览器里要 fallback 到不带缓存的版本，本来我以为很简单，但是……（下面开启吐槽时间。）&lt;/p&gt;
&lt;blockquote class=&quot;center-quote&quot;&gt;支持 IE 的前端的痛苦都是相似的，不支持 IE 的前端则各有各的痛苦。&lt;/blockquote&gt;

&lt;p&gt;为什么非 HTTPS + localhost 不能用 CacheStorage 啊，难道他们没考虑过在电脑上开发然后手机访问测试移动版吗？还是说他们打算在手机上起一个开发服务器？为什么 Firefox 在非 HTTPS 时限制 CacheStorage 的方法是在 Promise 里 reject 一个 Error 从而导致这个过程变成了异步的？为什么 CacheStorage 只能缓存 Response 而不是任意数据结构？Safari 不能完整支持 Response 对象也就算了，为什么移动版 Chrome 和 Firefox 也不支持？合着你们 fetch 返回的 Response 还不是 Response？这世界到底怎么了……&lt;/p&gt;
&lt;p&gt;所以最后需要一个长长的基于 Promise 的判断加载函数：&lt;/p&gt;
&lt;figure data-raw=&quot;// 加载评论的时候才加载缓存。
let cachePromise = null;

let fetchJSON = uncachedFetchJSON;

const loadCache = (name) =&gt; {
  // Unlike in .then(),
  // we must explicit resolve and reject in a Promise&#039;s execuator.
  return new Promise((resolve, reject) =&gt; {
    if (cachePromise != null &amp;amp;&amp;amp; fetchJSON !== uncachedFetchJSON) {
      return reject(new Error(&amp;quot;Cache is already loaded!&amp;quot;));
    }
    // Old version browsers does not support Response.
    if (window.Response == null) {
      return reject(
        new Error(&amp;quot;Old version browsers does not support Response.&amp;quot;)
      );
    }
    const testResponse = new window.Response();
    // Safari and most mobile browsers do not support `Response.clone()`.
    if (testResponse.headers == null || testResponse.clone == null) {
      return reject(new Error(
        &amp;quot;Safari and most mobile browsers do not support `Response.clone()`.&amp;quot;
      ));
    }
    // Chromium and Safari set `window.caches` to `undefined` if not HTTPS.
    if (window.caches == null) {
      return reject(new Error(
        &amp;quot;Chromium and Safari set `window.caches` to `undefined` if not HTTPS.&amp;quot;
      ));
    }
    window.caches.open(&amp;quot;CacheStorageTest&amp;quot;).then((cache) =&gt; {
      fetchJSON = cachedFetchJSON;
      cachePromise = window.caches.open(name);
      return window.caches.delete(&amp;quot;CacheStorageTest&amp;quot;);
    }).then(() =&gt; {
      return resolve();
    }).catch((error) =&gt; {
      // Firefox throws `SecurityError` if not HTTPS.
      console.error(error);
      return reject(new Error(&amp;quot;Firefox throws `SecurityError` if not HTTPS.&amp;quot;));
    });
  }).catch((error) =&gt; {
    console.error(error);
  });
};&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;// 加载评论的时候才加载缓存。
let cachePromise = null;

let fetchJSON = uncachedFetchJSON;

const loadCache = (name) =&amp;gt; {
  // Unlike in .then(),
  // we must explicit resolve and reject in a Promise&#039;s execuator.
  return new Promise((resolve, reject) =&amp;gt; {
    if (cachePromise != null &amp;amp;&amp;amp; fetchJSON !== uncachedFetchJSON) {
      return reject(new Error(&quot;Cache is already loaded!&quot;));
    }
    // Old version browsers does not support Response.
    if (window.Response == null) {
      return reject(
        new Error(&quot;Old version browsers does not support Response.&quot;)
      );
    }
    const testResponse = new window.Response();
    // Safari and most mobile browsers do not support `Response.clone()`.
    if (testResponse.headers == null || testResponse.clone == null) {
      return reject(new Error(
        &quot;Safari and most mobile browsers do not support `Response.clone()`.&quot;
      ));
    }
    // Chromium and Safari set `window.caches` to `undefined` if not HTTPS.
    if (window.caches == null) {
      return reject(new Error(
        &quot;Chromium and Safari set `window.caches` to `undefined` if not HTTPS.&quot;
      ));
    }
    window.caches.open(&quot;CacheStorageTest&quot;).then((cache) =&amp;gt; {
      fetchJSON = cachedFetchJSON;
      cachePromise = window.caches.open(name);
      return window.caches.delete(&quot;CacheStorageTest&quot;);
    }).then(() =&amp;gt; {
      return resolve();
    }).catch((error) =&amp;gt; {
      // Firefox throws `SecurityError` if not HTTPS.
      console.error(error);
      return reject(new Error(&quot;Firefox throws `SecurityError` if not HTTPS.&quot;));
    });
  }).catch((error) =&amp;gt; {
    console.error(error);
  });
};&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;不管怎么样现在这个网站在支持 CacheStorage 和 Response 的浏览器上（似乎也就桌面版 Chrome/Firefox……）是缓存 GitHub API 的结果了，打开 DevTools 切到 Network 面板可以看到 GitHub API 返回的是 304 而不是 200，其他浏览器则 fallback 到无缓存的 fetch。当然其他浏览器不包含 IE 咯。&lt;/p&gt;
&lt;h1 id=&quot;由俭入奢易，由奢入俭难。&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E7%94%B1%E4%BF%AD%E5%85%A5%E5%A5%A2%E6%98%93%EF%BC%8C%E7%94%B1%E5%A5%A2%E5%85%A5%E4%BF%AD%E9%9A%BE%E3%80%82&quot; title=&quot;由俭入奢易，由奢入俭难。&quot;&gt;&lt;/a&gt;由俭入奢易，由奢入俭难。&lt;/h1&gt;
&lt;div class=&quot;alert-green&quot;&gt;这一部分更新于 2020-08-18 12:25:00。&lt;/div&gt;

&lt;p&gt;我后来又仔细想了想，其实要兼容 IE 还是有办法的，首先 &lt;code&gt;fetch&lt;/code&gt; 和 &lt;code&gt;Promise&lt;/code&gt; 都有成熟的 polyfill，甚至 &lt;code&gt;URLSearchParams&lt;/code&gt; 也有，只要写一段脚本在不支持的时候加载他们就可以了。然后去掉所有 IE 不支持的 ES6 特性，比如箭头函数、模板字符串、&lt;code&gt;for…of…&lt;/code&gt; 循环以及 MapReduce（IE 竟然支持 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 真是惊到我了）。但是能做到并不意味着一定要做，人总是还要向前看的，现在是 2020 年，连罪魁祸首始作俑者微软都放弃了 IE，就算是照顾用户量，IE 用户也是可以忽略的那一部分了。既然我已经用 ES6 重写了，就不要想再让我为这种历史垃圾放弃我得到的好处了，从我开始写主题到现在丢掉 IE 支持也算是仁至义尽了，所以为什么不让这些用户支持一下 Firefox 呢？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/ARIA/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="评论" label="评论" scheme="https://sh.alynx.one/tags/%E8%AF%84%E8%AE%BA/" />
    
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/tags/JavaScript/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/tags/ARIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>和 cheerio 说再见！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Drop-Cheerio/" />
    <id>https://sh.alynx.one/posts/Drop-Cheerio/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-08-04T13:06:00.000Z</published>
    
    
    <updated>2020-08-04T13:06:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我早就想把 cheerio 从 Hikaru 的依赖里移出去了，倒不是我对他的功能有什么不满，但是一年不更新 NPM 上的包也太恶心了吧！&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我早就想把 cheerio 从 Hikaru 的依赖里移出去了，倒不是我对他的功能有什么不满，但是一年不更新 NPM 上的包也太恶心了吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我的生成器使用 cheerio 的地方主要有两个，一是给标题生成喵点并依次生成 TOC，二是检查文章里相对路径的图片和链接引用并改成绝对路径，否则如果截取之后放在首页的摘要包含图片的话，会因为当前页面的地址变化而不工作。后者也是我自己编写生成器的原因之一，就是因为像 Hexo 或者 Hugo 这种已有的生成器内部并没有考虑，只能通过插件解决，我在写 Hexo 主题时嵌入了一个使用正则表达式的脚本，但相比之下我觉得还是一个能理解 HTML 的库更加可靠。所以后来我选了 cheerio 来做解析和修改以实现这些功能。&lt;/p&gt;
&lt;p&gt;但是 cheerio 有一个 &lt;a href=&quot;https://github.com/cheeriojs/cheerio/issues/1198&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;很古怪的 bug&lt;/a&gt;，存在于它目前在 NPM 上最新的版本 &lt;code&gt;1.0.0-rc3&lt;/code&gt; 上。假如你使用 cheerio 解析并编辑包含中文的 HTML 的话，导出字符串时所有的中文都被编码成了 HTML 实体，导致进行下一步处理比如用 &lt;code&gt;substring&lt;/code&gt; 截断的话，字符串长度变化了，而且可能会在文字中间截断。假如你使用 &lt;code&gt;decodeEntities: false&lt;/code&gt; 的话，原本文档里的 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; 一类的字符反而会被 cheerio 导出成 &lt;code&gt;&amp;lt;&lt;/code&gt;，变成一团乱麻。&lt;/p&gt;
&lt;p&gt;这个 bug 非常古怪并且我花了一段时间来研究它，上一个版本 &lt;code&gt;0.22.0&lt;/code&gt; 使用 &lt;code&gt;decodeEntities: false&lt;/code&gt; 是没有这个问题的。最后发现原因是 cheerio 在 &lt;code&gt;1.0.0-rc1&lt;/code&gt; 开始引入 parse5 代替原本的 htmlparser2 作为默认的 HTML 解析器，而 parse5 在解析时并不会使用 &lt;code&gt;decodeEntities&lt;/code&gt; 这个参数，比如你输入 &lt;code&gt;&amp;amp;lt;&lt;/code&gt;，parse5 解析时会在节点里存储原本的值 &lt;code&gt;&amp;lt;&lt;/code&gt;，但 cheerio 在序列化的时候还是会依赖这个参数进行编码，所以假如传递 &lt;code&gt;false&lt;/code&gt; 进去，cheerio 就不会主动进行 encode，导致最后出来的是 &lt;code&gt;&amp;lt;&lt;/code&gt;。而 htmlparser2 会按照这个参数选择解不解码，所以也不会发生这种错误。&lt;/p&gt;
&lt;p&gt;那这么看起来是 parse5 的问题？并不！parse5 有自己的序列化函数，和自己的解析函数是配套的，所以只要使用 parse5 的序列化函数就不会存在这个问题了。&lt;/p&gt;
&lt;p&gt;最后总结起来修复的办法也有很多：首先其实序列化的时候并不需要将所有元素都编码成 HTML 实体，只要对几个字符进行转义即可，我提交了这样的 PR，但因为 cheerio 和它自己的序列化库 dom-serializer 是两个仓库，不是很好处理，而且其实也没有从根源上解决 htmlparser2 和 parse5 表现不一致的问题。cheerio 后来的提交中采用的是简单办法，假如使用 parse5 解析就继续使用 parse5 序列化就好了。&lt;/p&gt;
&lt;p&gt;但是这个提交之后并没有发布到 NPM 上，NPM 挂的一直是有问题的 &lt;code&gt;1.0.0-rc3&lt;/code&gt; 版本，至于原因呢很简单，他们打算释出第一个稳定版本 &lt;code&gt;1.0.0&lt;/code&gt;，所以要等到所有 TODO 都解决了再发新版本！&lt;/p&gt;
&lt;p&gt;搞毛啊老哥，你这样放着有 bug 的版本是把用户做宝搞吗？而且你是个函数库，下面好多人依赖你处理 DOM 呢，NodeJS 上提供 jQuery 模式的函数库大概也没什么别的替代品了，一堆项目在 issue 里问你就给个这破理由？&lt;/p&gt;
&lt;p&gt;我选择的是锁死 &lt;code&gt;0.22.0&lt;/code&gt; 版本，其他下游的项目也都各自做了 workaround，要么安装 GitHub 上的 &lt;code&gt;1.0.0&lt;/code&gt; 分支要么回退版本。但总之都让强迫症很不爽啊！&lt;/p&gt;
&lt;p&gt;大家等他发稳定版就这么等了一年，在这一年间有些项目比如 &lt;a href=&quot;https://github.com/hexojs/hexo/issues/3677&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Hexo 直接抛弃了 cheerio 用正则处理 HTML&lt;/a&gt;，虽然他们主要是为了性能。我倒不是那么在乎生成器的性能（真的在乎的话我就该去用 Hugo，而且我也不敢说我自己的代码写的很好）。&lt;/p&gt;
&lt;p&gt;晚上睡觉前我突然想到假如只是过滤链接和图片并检查他们的属性的话其实不需要 jQuery 一样的 API，只需要能理解 HTML，那找个简单的解析器就可以了。而且第二天正好读了 &lt;a href=&quot;https://blog.phoenixlzx.com/2017/02/18/dont-ask-me-why-invent-another-planet-river-of-news/#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;卷老师的这篇博文&lt;/a&gt;，发现和我想的也差不多。于是就开始动手。&lt;/p&gt;
&lt;p&gt;卷老师用的 sanitize-html 对我来说不太合适，因为我的静态生成器并不需要过滤内容——都是 Markdown 生成的，而且不安全也是使用者自己故意写的，不是我的责任，生成器也没有不安全的 HTML 的运行环境。sanitize-html 和 cheerio 用的都是 htmlparser2 作为解析器，虽然它号称自己是跑得最快的 HTML 解析器，但经过之前那个问题我还是心有余悸。而且 htmlparser2 是非常简单的基于事件回调的解析器（就像 Python 自带的那个，我太久不写 Python 不记得叫什么了），不会给你构建树状结构也不包含序列化，自己写序列化就容易像之前那个 cheerio bug 一样出问题。所以我考察了一下 parse5 发现还不错，会构建树状结构，数据结构都写在文档里，同时就是简单的可以直接操作的 Object，至于速度虽然慢一点但我并不太在乎那 10 毫秒。&lt;/p&gt;
&lt;p&gt;于是我就先手动造了一些 wrapper 函数比如递归前置遍历一颗树来代替 cheerio 的 &lt;code&gt;$.each()&lt;/code&gt;，前置遍历正好是 HTML 文档自上往下的顺序，生成 TOC 的时候也是按照这个顺序来的，然后就是比如获取结点内文本的函数、获取属性和设置属性的函数之类的。至于插入结点我想了个巧妙的办法，因为 parse5 把最终解析到的文本作为单独的结点，我就直接在插入文本的函数里让 parse5 解析输入的 HTML，然后用得到的子结点替换被插入结点的子结点即可。&lt;/p&gt;
&lt;p&gt;随后我重写了生成 TOC，生成标题 ID 和检查文章里相对路径的图片和链接引用并改成绝对路径的函数。然后写了点简单的测试样例跑了一下发现没问题，就用它们替换掉 Hikaru 的 &lt;code&gt;utils.js&lt;/code&gt; 里面用 cheerio 的版本，然后修改了 process 代码。我造的这几个简单的 wrapper 完全符合我的要求，于是提交打版本号发布一气呵成，一年不更新的 cheerio 就从我的生成器里拜拜了。&lt;/p&gt;
&lt;p&gt;虽然嘴上说着不追求速度，但是凭我肉体的感觉还是多少快了一点儿，不过我也并不是很在乎生成的时间，感知真的不强，无所谓了。但我真的不能理解这种为了憋个大的不发版本把用户做宝搞的行为，就算是发个 &lt;code&gt;1.0.0-rc4&lt;/code&gt; 也比一年不发强吧！就算只是 make user happy 也好，何况面对的不是 user 而是其它项目的 dev 呢，都是同行，这行为算不算托大？反正我是习惯做了点改动就打个新版本，即使我自己安装的都是开发版本，我也希望能把我最新的修改送到用户手上，又不是 breaking change 或者什么不能随便更新的软件，打个小版本号至于那么难吗？？？&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="Hikaru" label="Hikaru" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/Hikaru/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="Hikaru" label="Hikaru" scheme="https://sh.alynx.one/tags/Hikaru/" />
    
  </entry>
  
  
  
  <entry>
    <title>给你的主题来点暗色！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Dark-Mode-in-Theme/" />
    <id>https://sh.alynx.one/posts/Dark-Mode-in-Theme/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-08-04T09:15:00.000Z</published>
    
    
    <updated>2020-08-07T02:50:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我自己对暗色模式其实是没什么兴趣的，因为设计一种配色就已经让我绞尽脑汁了，还要我设计另一种。但是我也确实意识到暗色模式在晚上玩手机实在是很方便，而且做这个也很流行，于是我也做了一个，只是因为我能做到。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我自己对暗色模式其实是没什么兴趣的，因为设计一种配色就已经让我绞尽脑汁了，还要我设计另一种。但是我也确实意识到暗色模式在晚上玩手机实在是很方便，而且做这个也很流行，于是我也做了一个，只是因为我能做到。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;跟着系统变色就行了吗？&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E8%B7%9F%E7%9D%80%E7%B3%BB%E7%BB%9F%E5%8F%98%E8%89%B2%E5%B0%B1%E8%A1%8C%E4%BA%86%E5%90%97%EF%BC%9F&quot; title=&quot;跟着系统变色就行了吗？&quot;&gt;&lt;/a&gt;跟着系统变色就行了吗？&lt;/h1&gt;
&lt;p&gt;现在的系统大概都支持暗色模式（Linux 的桌面环境早就有这种设置了，Firefox 可以直接读取我的系统设置，Android/iOS 也都有暗色模式开关），浏览器也紧跟潮流提供了 &lt;code&gt;@media&lt;/code&gt; 的 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;查询属性&lt;/a&gt;（IE：那……是……什……么……）。理论上来说只要简单地在 CSS 里面查询然后编写修改颜色的代码就可以了，问题只是如何修改颜色比较轻松。&lt;/p&gt;
&lt;h1 id=&quot;CSS变量是好东西！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#CSS%E5%8F%98%E9%87%8F%E6%98%AF%E5%A5%BD%E4%B8%9C%E8%A5%BF%EF%BC%81&quot; title=&quot;CSS变量是好东西！&quot;&gt;&lt;/a&gt;CSS 变量是好东西！&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;使用 CSS 变量&lt;/a&gt; 当然是最简单的解决方案了，就像我们平时编程一样使用变量作为 &lt;code&gt;color&lt;/code&gt; 和 &lt;code&gt;background&lt;/code&gt; 的值，然后在查询到暗色模式的代码块里给这些变量重新赋值，一切都十分简单有条理，而且最重要的是你不需要一个一个选择器查找有哪些需要变色的属性，所有的颜色变量都是放在一起的。&lt;/p&gt;
&lt;h1 id=&quot;真是恨死IE这废物了！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E7%9C%9F%E6%98%AF%E6%81%A8%E6%AD%BBIE%E8%BF%99%E5%BA%9F%E7%89%A9%E4%BA%86%EF%BC%81&quot; title=&quot;真是恨死IE这废物了！&quot;&gt;&lt;/a&gt;真是恨死 IE 这废物了！&lt;/h1&gt;
&lt;p&gt;虽然 IE 有很多不支持的选项，但是不支持 CSS 变量真是让我工作量剧增的一件事情。虽然我从不测试我的网站在 IE 上能否运行，但是在最新版 IE 上一般都是没问题的，因此我也会放弃一些最新版 IE 不支持的新特性，CSS 变量就是其中之一。&lt;/p&gt;
&lt;p&gt;既然没有办法用 CSS 变量，那就只能自己一个一个找选择器下面和颜色相关的属性，然后给它们重新设置属性了，真是找的人头晕眼花啊。&lt;/p&gt;
&lt;p&gt;可能有人会说你不是用 CSS 预处理器吗，预处理器不是也有变量吗？但是预处理器是在生成阶段把变量编译掉了啊！不方便到运行时（浏览器）里去替换变量。&lt;/p&gt;
&lt;h1 id=&quot;我就是想在暗色浏览器里用亮色啊！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E5%9C%A8%E6%9A%97%E8%89%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%94%A8%E4%BA%AE%E8%89%B2%E5%95%8A%EF%BC%81&quot; title=&quot;我就是想在暗色浏览器里用亮色啊！&quot;&gt;&lt;/a&gt;我就是想在暗色浏览器里用亮色啊！&lt;/h1&gt;
&lt;p&gt;在全部重新调整过颜色并能看之后（其实就是把浅色的色块换成深色，颜色层次基本不变，背景图搞个反色，至于那些彩色的按钮标签我实在没精力重新配色了，把透明度调低一点就好了），我自己还是比较喜欢自己一开始设计的样子，但我又是个习惯电脑全局暗色的人，这怎么能忍！&lt;/p&gt;
&lt;p&gt;CSS 的媒体属性不像一般的属性，只能是浏览器设置我们读取，没有办法用 JS 控制，于是也就没法简单地利用这个添加切换按钮。上网搜了半天也只有曲线救国的方案。&lt;/p&gt;
&lt;h1 id=&quot;曲线救国&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%9B%B2%E7%BA%BF%E6%95%91%E5%9B%BD&quot; title=&quot;曲线救国&quot;&gt;&lt;/a&gt;曲线救国&lt;/h1&gt;
&lt;p&gt;如果并不是想那么和系统的设置同步而只是给自己的网站添加切换的话，并不需要媒体查询。只要设计一个按钮给 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 添加删除 class/attribute 就行了。然后如果要和系统同步，在 JavaScript 里也有 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;相关的 API&lt;/a&gt; 可以做到查询和监听，在检测到变化的时候也修改 class/attribute 即可。&lt;/p&gt;
&lt;p&gt;我选择的是给 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 加 &lt;code&gt;data-theme=&quot;dark&quot;&lt;/code&gt; 或 &lt;code&gt;data-theme=&quot;light&quot;&lt;/code&gt; 属性，不选 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 是因为 WebKit 那些该死的不遵循标准的 scrollbar 伪类，文档没有说他们到底依附哪个元素，我尝试得到的是 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;。接下来只要把之前的 CSS 里面的媒体查询选择器改成 &lt;code&gt;html[data-theme=&quot;dark&quot;]&lt;/code&gt; 就行了。&lt;/p&gt;
&lt;p&gt;不过还要注意继承关系，这样写的话有些属性并不是继承外面的，而是在这个选择器里面就近继承。比如假如修改了 &lt;code&gt;html[data-theme=&quot;dark&quot;] a&lt;/code&gt; 的边框，那 &lt;code&gt;html[data-theme=&quot;dark&quot;] a.cls&lt;/code&gt; 的边框会优先继承这个，而不是 &lt;code&gt;a.cls&lt;/code&gt;。我知道有些人可能会笑我半懂不懂了，但是我确实遇到了这个问题，并且思考了一下找到了原因。&lt;/p&gt;
&lt;p&gt;还有一个比较尴尬的事情，我给一些元素设置了 &lt;code&gt;transition&lt;/code&gt; 用于 &lt;code&gt;:hover&lt;/code&gt; 之后加一个渐变颜色的效果，现在暗色模式也是修改颜色，导致这些元素会比其他元素慢变一下，没什么好办法因为你分不开两种 &lt;code&gt;color&lt;/code&gt; 变化。我的解决方案是一个一个找切换暗色模式时候会变属性的选择器，给它们也添加 &lt;code&gt;transition&lt;/code&gt;。效果还不错，不过 Chrome 在处理这种 CSS 动画时候竟然会掉帧？？？&lt;/p&gt;
&lt;p&gt;不管了，反正我用 Firefox，Firefox 效果好得很，完全不掉帧。&lt;/p&gt;
&lt;p&gt;更新（2020-08-07 10:50:00）：我怀疑 Chrome 想做新时代的 IE，其实并不是性能问题导致掉帧，WebKit 对于继承来的属性的 transition 存在问题，会导致不是同时变换而是有延迟的变换，效果糟透了，&lt;a href=&quot;https://stackoverflow.com/a/36779404&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;StackOverflow 上也有人遇到这个问题&lt;/a&gt;，看起来是 bug 并且不打算解决，而 Firefox 就没有这个问题。使用 CSS 变量在 WebKit 下效果会好一点，不过也不能给所有变色的元素加 transition，还是会卡，只能给 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 加一个，因为我的链接有 &lt;code&gt;:hover&lt;/code&gt; 时变色的 transition，都是 color 就没办法在那时 transition 而暗色模式时候不 transition。总之由于 WebKit 的存在导致没法让全部元素同步 transition，只能近似。两权相害取其轻，还是让 IE 用户只能用亮色吧，我最后还是选择了 CSS 变量。&lt;/p&gt;
&lt;h1 id=&quot;怎么你这破网站换个页面还要重新点一次？&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%80%8E%E4%B9%88%E4%BD%A0%E8%BF%99%E7%A0%B4%E7%BD%91%E7%AB%99%E6%8D%A2%E4%B8%AA%E9%A1%B5%E9%9D%A2%E8%BF%98%E8%A6%81%E9%87%8D%E6%96%B0%E7%82%B9%E4%B8%80%E6%AC%A1%EF%BC%9F&quot; title=&quot;怎么你这破网站换个页面还要重新点一次？&quot;&gt;&lt;/a&gt;怎么你这破网站换个页面还要重新点一次？&lt;/h1&gt;
&lt;p&gt;一切看起来都十分美好，直到我把一个暗色页面切成亮色然后点了个链接，下一个页面并不会理会我们上一个页面设置了什么主题，又变成了暗色。每个页面点一下切换按钮也太烦人了，我们得来点持久化。&lt;/p&gt;
&lt;p&gt;某个域名想在用户的浏览器里存点是完全可行的，使用 &lt;code&gt;localStorage&lt;/code&gt; 就行了，就是简单的键值对。但是这样我们就有了多种可能切换亮暗的动作：&lt;code&gt;localStorage&lt;/code&gt; 里面存的选项，网页加载时浏览器媒体查询的结果，用户点了网页上的切换按钮，用户点了系统切换亮暗的设置。这些的判断顺序要好好处理一下，不然某些就会被忽视掉变成“我点了怎么不动啊！！！”。&lt;/p&gt;
&lt;p&gt;经过我考虑一下之后，这个玩意的逻辑应该是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假如 &lt;code&gt;localStorage&lt;/code&gt; 里面没有值，用户是首次打开网站，此时读取媒体查询按照系统的主题设置。&lt;/li&gt;
&lt;li&gt;否则说明用户之前打开过网站，已经有他自己的喜好了，按照 &lt;code&gt;localStorage&lt;/code&gt; 里面的值设置。&lt;/li&gt;
&lt;li&gt;上两个步骤结束之后注册一个媒体查询监听器，用于响应用户修改系统设置。&lt;/li&gt;
&lt;li&gt;注册一个按钮监听器，用于响应用户点击网页切换按钮设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上 1 和 2 的顺序不能反了，并且每一个设置动作里都要把这次设置的值写入 &lt;code&gt;localStorage&lt;/code&gt; 用于后续加载用户的选择。&lt;/p&gt;
&lt;p&gt;现在看起来一切都很满意，是时候发布了！&lt;/p&gt;
&lt;h1 id=&quot;用户：啊！我的眼睛！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E7%94%A8%E6%88%B7%EF%BC%9A%E5%95%8A%EF%BC%81%E6%88%91%E7%9A%84%E7%9C%BC%E7%9D%9B%EF%BC%81&quot; title=&quot;用户：啊！我的眼睛！&quot;&gt;&lt;/a&gt;用户：啊！我的眼睛！&lt;/h1&gt;
&lt;p&gt;我躺在床上用手机测试的时候又发现了一个问题。因为网页在生成的时候总有一个初始状态（JS 要等到 document 加载完成才开始处理 DOM，不像那些单页应用），假如我设置成暗色然后切换到别的页面，网页就会以亮色加载然后变成暗色，用户在晚上看起来就像是个闪光弹（伏拉什棒！）。&lt;/p&gt;
&lt;p&gt;其实没什么好的解决办法，因为这是传统 HTML 页面的限制之一，我也不想找有没有什么新的东西能解决这些问题，最后的方案其实相当简单，既然亮色到暗色会让人受不了，我搞成暗色到亮色不就行了。&lt;/p&gt;
&lt;p&gt;于是就是把模板里按钮的初始状态修改一下，渲染的时候出来的是 &lt;code&gt;data-theme=&quot;dark&quot;&lt;/code&gt;，假如用户选择亮色，加载页面时会有一个暗色到亮色的变化。反正我自己都不在意。&lt;/p&gt;
&lt;p&gt;更新（2020-08-06 18:23:00）：我后来阅读了一些其它主题的代码，看它们是怎么在不使用单页应用的前提下解决这个问题的，结果方法相当简单，我自己也想得到：不用等到 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 事件之后，反正只是修改 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 标签，直接在 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签里面编辑 &lt;code&gt;document.documentElement&lt;/code&gt; 是可以的，因为反正加载到 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 的时候肯定也已经加载到 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 了。所以就把修改这个属性和修改按钮的 DOM 分开了两部分，并且添加了一个 &lt;code&gt;storage&lt;/code&gt; 的监听器，这样假如打开了多个页面，一个页面切换其它页面也会跟随切换。&lt;/p&gt;
&lt;h1 id=&quot;不要过度设计！&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E4%B8%8D%E8%A6%81%E8%BF%87%E5%BA%A6%E8%AE%BE%E8%AE%A1%EF%BC%81&quot; title=&quot;不要过度设计！&quot;&gt;&lt;/a&gt;不要过度设计！&lt;/h1&gt;
&lt;p&gt;经过这么一大堆折腾（代码行数++++++++），我甚至在想要不要支持每个页面单独设置亮暗初值，反正只要添加一个 front matter 然后在模板里判断一下嘛。不过后来想了想，就算有这么个功能又有什么用？实际意义几乎为零，徒增复杂度，所以还是不要过度设计了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/ARIA/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/tags/ARIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>修复更换 PCI-E 插槽后 Windows 下无线网卡的名称问题</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fix-Windows-Wireless-Adapter-Name/" />
    <id>https://sh.alynx.one/posts/Fix-Windows-Wireless-Adapter-Name/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-06-28T11:02:00.000Z</published>
    
    
    <updated>2020-06-28T11:02:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;这是一篇其实没什么逻辑也没什么技术的文章，但踩到这个坑又很头痛，所以记录一下。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;这是一篇其实没什么逻辑也没什么技术的文章，但踩到这个坑又很头痛，所以记录一下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我用的是一张 PCI-E 的网卡，占据一个 PCI-Ex1 的插槽，对于一个主流的 ATX 主板来说有三个选择，第二条 x16 长度的插槽上面的一个和下面的两个，由于显卡一般会插在第一条 x16 上，所以如果插在第二条 x16 长度上面的那个，会挡住一部分显卡风扇，所以我一开始插在了第二条 x16 长度插槽下面的第一个插槽。这样也是有点问题的，因为这里 x16 和 x1 之间并没有留出一个槽的空位，一般主流显卡又都是双槽的，虽然我不太可能在机箱里塞第二张显卡，但是这么装直接就干掉了这种可能性，所以我一直想把无线网卡换到最底下的插槽。（这一部分比较乱，但是装过机的直接上网搜一下主流 ATX 主板的图就能理解了。）&lt;/p&gt;
&lt;p&gt;之前由于最后一个插槽挡板的螺丝拧的太紧我一直没换，今天买了一个柄比较粗比较省力的螺丝刀，终于拧下来螺丝把网卡换了个插槽。开机之后 Linux 下其实没什么问题，检测设备和持久化命名都正常工作了。不过 Network Manager 似乎认为更换了设备，所以建议删掉之前的连接配置重新连接网络，之后一切都正常。&lt;/p&gt;
&lt;p&gt;切到 Windows 发现不太对劲，首先就是我的 WiFi 适配器名字变成了 &lt;code&gt;WLAN 2&lt;/code&gt;，想要重命名成 &lt;code&gt;WLAN&lt;/code&gt; 又提示已经存在，但是我又看不到，点进去发现它选择的无线网卡名字后面多了个 &lt;code&gt;#2&lt;/code&gt; 的后缀，总之我也不知道怎么回事，但是强迫症觉得很难受，明明我只有一张网卡啊。&lt;/p&gt;
&lt;p&gt;上网搜索了一下，首先是在设备管理器的查看菜单里选择显示隐藏的设备，这样就会发现一个灰色的没有后缀的网卡，我也不知道 Windows 为什么要存一个隐藏的之前存在现在不存在的 PCI-E 设备，首先按照网上的说法卸载掉这个设备然后重启，再开机就没有这个隐藏设备了。&lt;/p&gt;
&lt;p&gt;接下来需要去掉 &lt;code&gt;#2&lt;/code&gt; 的后缀，让 Windows 把这个插槽里的卡认成唯一的一张，这里就十分晦涩，Windows 试图隐藏起这个逻辑，但导致了一个令强迫症十分不爽的问题。我搜索了一下，发现了一个 &lt;a href=&quot;https://wenku.baidu.com/view/275565c68bd63186bcebbc96.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;百度文库文档&lt;/a&gt; 提供的方案。&lt;/p&gt;
&lt;p&gt;首先打开注册表编辑器定位到 &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\_ControlSet001\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}\Descriptions&lt;/code&gt; 这一项，然后在右侧找到你无线网卡的名称，里面的值应该是 &lt;code&gt;2&lt;/code&gt;，改成 &lt;code&gt;1&lt;/code&gt;，然后卸载网卡设备，然后重启，应该就解决了，而且因为设备名字恢复了，&lt;code&gt;WLAN 2&lt;/code&gt; 也应该变回 &lt;code&gt;WLAN&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;所以其实这篇文章并没有什么逻辑和技术，但是 Windows 自作主张非要保存一个隐藏的不存在的设备，实在是令人头痛，又没什么明显的解决方式，所以也只好记下来以防再次被恶心到。&lt;/p&gt;
&lt;p&gt;更新：Arch Linux CN offtopic Telegram 群组里面叫 Give Way 的网友表示并不需要这么复杂，只要把两个无线网卡的设备都卸载掉重启就可以了。理论上确实是如此，但我没机会再试了，遇到相同问题的朋友可以试试。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="网络" label="网络" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/" />
    
    
    <category term="网络" label="网络" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%BB%9C/" />
    
    <category term="Windows" label="Windows" scheme="https://sh.alynx.one/tags/Windows/" />
    
  </entry>
  
  
  
  <entry>
    <title>让你们的主题商店离我远点！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Taking-Your-Theme-Store-Away/" />
    <id>https://sh.alynx.one/posts/Taking-Your-Theme-Store-Away/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-12-18T08:17:00.000Z</published>
    
    
    <updated>2019-12-18T08:17:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我不觉得我是个刻薄的人，但对于一些实在令我讨厌的人，不把他们的名字挂出来就是我最后的怜悯。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我不觉得我是个刻薄的人，但对于一些实在令我讨厌的人，不把他们的名字挂出来就是我最后的怜悯。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;已经有不止一个人询问过我有关把博客主题移植到其他生成器上的问题了，这实际上是超出我范围的工作，因为我并不熟悉他们的生成器。但如果有人这样询问我（当然最好的方式是发 issue），我一般会先了解一下他说的生成器，然后解释是因为我没有时间或者我不熟悉目标技术栈。&lt;/p&gt;
&lt;p&gt;我还记得的最远范围是某个 Gridea 的用户发邮件问我怎么把我的主题用到他这个生成器上。某种程度上我觉得他要么是真的无知要么就是装成无知然后提一些在技术上很显而易见的问题来气人（我今天新学的词叫 troll），于是我去查了一下 Gridea，是个一条龙的基于 Vue 的图形化博客系统。对我足够熟悉的人可能知道我不喜欢把博客做成单页应用的样子，而且在我理解里博客生成器就应该是一个比较简单的命令行工具，而不是一个图形化数据库管理工具。尽管我不太喜欢这个项目和它的宣传方式，但万一对方真的是个并不了解这些的小白用户呢？我回复的语气可能并不是十分客气，但我还是解释了一下博客主题和生成器的关系，以及我不了解 Gridea 的技术栈也不是很喜欢这个项目，所以没办法写一个 收费/免费 的主题给这个项目。当然最后结果相对还不错，他也理解我给他的解释。&lt;/p&gt;
&lt;p&gt;但是我最近又收到一封标题为“诚邀合作事宜”的邮件，为了不破坏我第一句的承诺，我修改了部分名词：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很喜欢你博客的风格，可否为Cxxxxx-CMS开发一套（免费/付费）主题，然后发布到Cxxxxx商店里面？&lt;/p&gt;
&lt;p&gt;CxxxxxJS：是一款顶级NodeJS全栈业务开发框架, 基于KoaJS + EggJS + VueJS + Framework7
Cxxxxx-CMS：是基于CxxxxxJS全栈业务开发框架开发的动静结合的CMS，可以快速构建企业网站、博客、社区、商城等Web应用
Cxxxxx商店：包括品类广泛的各类模块，满足不同场景的开发需求&lt;/p&gt;
&lt;p&gt;CxxxxxJS介绍：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/introduce.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/introduce.html&lt;/a&gt;
Cxxxxx-CMS介绍：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/cms-introduce.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/cms-introduce.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cxxxxx商店运营模式：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/store.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/store.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我也不是个专业的前端工程师，现在不是，将来大概也不是前端“全栈”工程师，但我还是能懂这封邮件的内容。俗话说“文无第一，武无第二”，程序员的圈子里这句话应该也十分受用，所以我通读全文之后，目光就落在了“顶级”两个字上面。毕竟去掉套话之后，满足这类泛泛功能的项目也不少，所以还是先看看“顶级”比较有意思。&lt;/p&gt;
&lt;p&gt;在 Google 搜索这个 Cxxxxx 之后，还是有一些相关度比较高的内容的，出于个人习惯，我直接点开了他在 GitHub 上的仓库。既然是“顶级”框架，想必受益者众多，star 数量高达……108 个（截止昨日 18:00）。&lt;/p&gt;
&lt;p&gt;这就十分可笑了，虽然我也不是什么大牛，但是这个数量级 star 的仓库也有，虽然 star 不能说明代码质量，但是说明“顶级”这种人气形容词拿来正合适，如果我有这么个仓库，我肯定不会腆着脸在宣传语里加“顶级”二字。然后在大概阅读了一下文档和官网之后，我觉得就是个普通的 CMS，而且我也不认为静态博客生成器需要和 CMS 结合起来，我更希望静态博客生成器像编译器。而说到 JS 框架的话，既然都基于 &lt;code&gt;KoaJS&lt;/code&gt;、&lt;code&gt;EggJS&lt;/code&gt;、&lt;code&gt;VueJS&lt;/code&gt; 了，我想不出还能在这些套娃外面再套什么娃（禁止套娃！）。&lt;/p&gt;
&lt;p&gt;于是我就回了一封有点嘲讽意味的邮件（我知道可能换个人不会说这种话，不过这种情况稍微嘲讽一下也没什么错吧）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前几天有个意思和你差不多的，但他没你这么能吹，他就是另一个博客生成器的普通用户。&lt;/p&gt;
&lt;p&gt;可能我这话有点刻薄，但假如我自己有一个 100 个 star 的项目，我不会在宣传语里用 &lt;strong&gt;顶级&lt;/strong&gt; 这种形容词。&lt;/p&gt;
&lt;p&gt;写博客是我个人爱好，换句话说就是我也没打算靠这个玩意赚钱，就是自己用着爽然后开源出来有人喜欢随便用。我也没觉得自己技术强到可以靠这个吃饭了。&lt;/p&gt;
&lt;p&gt;既然是“诚邀”，那我觉得应该先看看我博客主题吧，不然容易让人觉得你是爬个 Hexo 主题作者列表然后群发邮件的哎。如果真看了就知道我这个主题的技术栈和你这个项目完全不搭。我的定位是静态博客生成器哎，我也不是很懂这种 CMS 或者 Koa Egg Vue，对这种快速批量构建网站没兴趣，毕竟个人博客嘛，随便折腾折腾才好玩。&lt;/p&gt;
&lt;p&gt;因此我建议你另请高明，或者真有兴趣，Fork 我的主题随便改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我就去忙别的去了，手头正好有个奇葩 Bug。我想这下大概清净了，没想到过一会又来了一封邮件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这就是一般大学生傲慢的地方了。如果是业务爱好者，我不好说什么。如果是一位志于软件开发的同行，就会一个静态博客生成器有什么可炫耀的呢？只怕你还真没有好好看看CxxxxxJS的文档了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这话说的很讨人厌哎。我脾气还算好，实在懒得一点点找出这话里有问题的地方反驳他，就随便回了一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我再说一遍，我可没有给我自己的哪个项目加上“顶级”两个字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后他又来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你可以细细思考这个问题：我用顶级二字就把你伤到了吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Arch Linux CN 群里的群友建议我直接拉黑算了，我也这么想的，但是晚上回去闲的没事翻了翻，发现了其他的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Taking-Your-Theme-Store-Away/1.png&quot; alt=&quot;骚扰证据&quot;&gt;&lt;/p&gt;
&lt;p&gt;好啊！你还敢说你是“诚邀”！还真被我说中了，明明就是爬了 Hexo 主题列表挨个作者群发！一开始邮件是我略有刻薄，不想再逐条反驳他，但看到这个我实在是 &lt;strong&gt;口区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先对于这类“主题商店”，细细想想就知道不对劲，不仅仅这一个项目，还有别的没什么用户又跟你说邀请你驻入商店也是，他说他是诚邀作者设计一款主题放在他商店收费，可是主题作者真的拿到好处了吗？主题做的好，&lt;strong&gt;作者拿到的钱是用户掏的&lt;/strong&gt;，&lt;strong&gt;而用户的使用习惯和黏性是落在他的项目上的&lt;/strong&gt;！图里的有些主题我都看过，真的是非常优秀的作者，从作者角度想不得到任何好处地加入某一项目，也会希望这一项目的人气能给自己带来一些用户口碑，而这个项目很显然不满足！&lt;strong&gt;好一招空手套白狼！&lt;/strong&gt;用户的钱三七分成，豪绅的钱……豪绅现在连钱都不用掏了，全靠一张嘴吹一吹？&lt;/p&gt;
&lt;p&gt;比如 Hexo、Jekyll、Hugo、Pelican 的主题页面（你愿意叫商店也行），都是作者自己主动提交的，为什么？因为这些广受好评的项目，可以为主题作者吸引人气，所以作者才会主动“合作”！&lt;/p&gt;
&lt;p&gt;其次说句不客气的，这类 CMS 项目说到底是拼工作量的东西，我也不是没写过。如果作者就是谦虚的说“我写了个 CMS，希望大家能给点意见使用一下”，我一个一般大学生哪里来的毛病非要嘲讽你？我最起码还得心里叨咕一句作者做这种项目坚持下来不容易，先支持一下劳动量再说。可是既然您把自己放在“顶级”的位子上，而且还看不起我，我也就不说什么客套话了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种项目 V2EX 上一天能刷个十来个，有些就是很诚恳用来练手刷简历的，有些则是这种没有痛点制造痛点也要上的&lt;/strong&gt;。我还再仔细搜了一遍这个项目，发现了好几篇什么掘金知乎&lt;strong&gt;甚至还真有 V2EX&lt;/strong&gt; 上作者发的宣传帖，什么“动静结合”、“全栈开发利器”、“开发业务实战”，这种套话一套一套的。V2EX 帖子就 6 个回帖，有人表示不理解，本来 Hexo 是个静态博客生成器，为啥非得搞个动静结合解决痛点呢？然后作者复读机上身又复制了一下这类套话，换我我也不接着看了。类似我这种静态博客用户就是不想要“后台管理系统”才用静态博客生成器的，这个“痛点”我怎么理解呢？&lt;/p&gt;
&lt;p&gt;“一般大学生傲慢的地方”，这话说的真是让人恶心啊，一般大学生怎么了呢？一般大学生哪里傲慢了呢？一般大学生是不会在自己项目上用“顶级”二字做宣传的。“就会一个静态博客生成器有什么可炫耀的”，我倒是想问问这位同行（呕，请别叫我前端全栈工程师啊各位，我知道自己还不合格呢），您在哪里看到我炫耀啦？我也不在知乎掘金 V2EX 发宣传帖，我甚至还没来得及在我自己博客上介绍一下，我还经常说我这个有写地方写的还不够好，一边学习一边继续编写代码解决我自己的问题，请问您在哪听见我炫耀的？&lt;strong&gt;莫非是我在隔壁宿舍和同学聊天吹水时候跟他吹了一下您听见了？如果真是这样，我还得告您搞窃听呢。&lt;/strong&gt;哦对了，我也不是什么就会一个静态博客生成器，我写生成器是为了解决我自己遇到的痛点的，这只是我涉及领域的一小部分，如果您真的仔细看了我的博客我的 GitHub，就知道我不是只搞前端，反而我看您 GitHub 都是 EggJS 的插件来着，真是令人眼花缭乱啊。&lt;/p&gt;
&lt;p&gt;什么你说让我看文档？文档有什么好看的，你想写什么就写什么，我也能把文档写出花来，那就能欺骗我自己项目本来没解决别人什么痛点嘛？&lt;/p&gt;
&lt;p&gt;让我细细思考？我看是您用了“顶级”二字，被我伤到了吧。都是写点胶水代码的玩意，我生成器还没用 Koa、Egg、Vue 这种框架呢，库是别人写的，框架逻辑都是我自己的，我 &lt;strong&gt;细细思考&lt;/strong&gt; 一下真的很好奇在三大框架（甚至还有个企业级框架）上面能套出什么框架呢？如果你愿意一层一层一层的剥开我的心？本来我不想扯技术方面的，可是别的方面也没看到这个项目对主题作者有什么优势和好处啊！&lt;/p&gt;
&lt;p&gt;我要时时刻刻提醒我自己，我就是个一般大学生，不懂的东西还有很多，也不能学这种说话语气，不然会被人当成知乎上那种讨人厌的家长，就是自己本来也没什么见识还在年轻人面前的死要面子那种，年轻人说点什么就贬低他什么。&lt;/p&gt;
&lt;p&gt;我个人是不习惯在知乎掘金 V2EX 上写帖子骗眼球的，所以就写到我自己博客上了，想必“一般大学生”的博客，估计也没什么人看吧！如果您真的介意，还是那句话，“文无第一，武无第二”，评论区或者在您的博客上，放马过来，反驳我这篇文章，我不介意的。但是，我真的很厌恶往别人仓库刷这种“诚邀合作事宜”的 issue，issue 是用来说代码相关问题的也算是程序员的自我修养之一了吧。我写这个也是希望万一有主题作者看到了别上当了，这不是“诚邀”，是“白嫖”作者人气。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    
    <category term="空手套白狼" label="空手套白狼" scheme="https://sh.alynx.one/tags/%E7%A9%BA%E6%89%8B%E5%A5%97%E7%99%BD%E7%8B%BC/" />
    
    <category term="全靠一张嘴" label="全靠一张嘴" scheme="https://sh.alynx.one/tags/%E5%85%A8%E9%9D%A0%E4%B8%80%E5%BC%A0%E5%98%B4/" />
    
    <category term="你这是瞧谁不起" label="你这是瞧谁不起" scheme="https://sh.alynx.one/tags/%E4%BD%A0%E8%BF%99%E6%98%AF%E7%9E%A7%E8%B0%81%E4%B8%8D%E8%B5%B7/" />
    
  </entry>
  
  
  
  <entry>
    <title>装机小记</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/My-Desktop-PC/" />
    <id>https://sh.alynx.one/posts/My-Desktop-PC/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-11-25T02:14:00.000Z</published>
    
    
    <updated>2021-01-15T11:46:45.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;由于笔记本散热和性能实在是不适合打游戏（有一说一，Optimus 双显卡还是没有直接单卡来得爽），所以很早就想组装一台台式机。特别是最近一直和高中同桌玩 Dota2，我的笔记本如果直播 Dota2，直播推流就会十分卡顿，而我又不想像 CSGO 一样降低画质玩。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;由于笔记本散热和性能实在是不适合打游戏（有一说一，Optimus 双显卡还是没有直接单卡来得爽），所以很早就想组装一台台式机。特别是最近一直和高中同桌玩 Dota2，我的笔记本如果直播 Dota2，直播推流就会十分卡顿，而我又不想像 CSGO 一样降低画质玩。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;作为计算机专业的学生，当然不打算直接淘宝整机啦。经过一番挑选和参考别人意见，最后成套配置是下面这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU：AMD Ryzen 7 5800X 3199（之前是 AMD Ryzen 5 3600X）&lt;/li&gt;
&lt;li&gt;主板：ROG STRIX X570-E GAMING 1999（特价）（之前是 微星 X570-A PRO 套装 2349）&lt;/li&gt;
&lt;li&gt;显卡：NVIDIA GeForce RTX 2070 SUPER 4300（之前是 七彩虹 RTX 2060 战斧 6G 2199）&lt;/li&gt;
&lt;li&gt;显卡支架：酷冷至尊 显卡支撑架 70&lt;/li&gt;
&lt;li&gt;内存：铂胜 C9BJZ 颗粒 白马甲 DDR4 3000 8G x4 1000&lt;/li&gt;
&lt;li&gt;网卡：Intel AX200（主板内置，之前是单独购买的花了 150）&lt;/li&gt;
&lt;li&gt;固态硬盘：三星 970 EVO Plus 512G 769&lt;/li&gt;
&lt;li&gt;固态硬盘：英睿达 MX500 2TB 1299&lt;/li&gt;
&lt;li&gt;机械硬盘：东芝 P300 2TB 400&lt;/li&gt;
&lt;li&gt;机械硬盘：西数 紫盘 2TB 400&lt;/li&gt;
&lt;li&gt;电源：海韵 CORE GX650 650W 金牌 549（特价）&lt;/li&gt;
&lt;li&gt;CPU 散热：利民 AK120 145（之前是 超频三 东海x5 89）&lt;/li&gt;
&lt;li&gt;M.2 散热：主板自带（之前是利民 M.2 硬盘散热片 39）&lt;/li&gt;
&lt;li&gt;机箱：Corsair 4000D 白色 629 （之前是 先马 鲁班1 209）&lt;/li&gt;
&lt;li&gt;机箱风扇：利民 TL-C12R-S x2 + 利民 TL-C12S 418（TL-C12R-S 只有 299 的三联包）（之前是 Arctic F12 PWM 温控 x3 120）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总计 15177。（有些具体价格我记不清了，而且京东价格总是波动。）性价比一般，因为我在其它人觉得没必要的地方分了很多预算比如主板风扇和硬盘，选 B450M 和西数的 NVMe 以及随便买个不带温控但是带灯的风扇的大有人在。&lt;/p&gt;
&lt;p&gt;选这样一套配置其实有原因，可能很多人觉得为什么要给 R5 配 X570 这种高端主板，不如换成 B450 然后把预算加到别的上面。但按照我朋友的使用经验，4 代和以前的 AMD 芯片组存在 USB 兼容性问题，而且我装好机器后就在 Arch Linux CN 群里看到有人遇到这种问题，5 代似乎重新设计了 USB 控制器，目前一切正常。虽然这大概是最丐的 X570，连前面板 USB C 的接口都不支持，但是带 3900X 以下的 CPU 还是没什么压力的，而且我的机箱也没前面板 USB C。唯一的问题是微星不太厚道，今年 B550 出来之后又搞了个 X570 Tomahawk，大概只贵了几百块但是却有比肩旗舰的供电能力和前面板 USB C 支持，所以不再推荐购买 X570-A PRO 和 X570 Gaming Edge 这两个低端款了。有这种好东西为什么不一开始就吐出来？？？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020 年 11 月 16 日）：AMD 发布了 Zen 3 系列的 CPU，游戏性能全面反超 Intel，对于我这种玩的都是吃 CPU 的游戏的用户来说实在是太香了，而且我一直想要 8 核心的 R7，于是买了首发的 R7-5800X，果然性能提升明显。然后正好有朋友的朋友打算装机买我换下来的 CPU 和主板，于是双十一为了 &lt;del&gt;更好的 RGB 效果&lt;/del&gt; 更好的供电支持换了 ROG 的 X570-E（东哥疯狂耍猴，本来我是想 Tomahawk 的，但是微星的几款真香主板都无货，而且我对微星土里土气的设计也审美疲劳了，1999 的打人国度带眼睛它不香吗）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果仅仅是打游戏也可以把 R5-3600X + X570 换成 i5-9600KF + Z390，大概可以便宜一点然后升级一下显卡？我觉得差价是不够 2060 换 2060S 的。或者如果要求不高换成 R5-3600 也行。但 R5-3600(X) 是 12 线程而 i5-9600KF 只有 6 线程，所以我还是选择了 Ryzen，反正 AMD CPU 最近表现都很不错，没必要给 Intel 掏更多的钱。如果你在京东买，建议自己翻翻店铺，一般买主板 CPU 套装更便宜，但是它不会摆出来……&lt;/p&gt;
&lt;p&gt;显卡一开始我是打算买个 1999 的 GTX 1660Ti 的，反正我玩的游戏也不需要光线追踪（难道真相不是本来就没几个游戏支持光线追踪嘛？），然而看到七彩虹最便宜的 2060 正在特价 2199，果断少买一条内存，加钱上这个。反正 1999 的 1660Ti 也是便宜货，而且看了一下视频似乎这块卡也不是丐中丐中丐，质量还可以（同价位索泰铭瑄也不能说是什么高端货吧？），反正内存可以再插新的，而显卡二手不值钱。什么你说 A 卡？虽然 A 卡对于 Linux 的驱动支持更好一点，但是 N 卡也不是不能用，而且我要开直播的话 NVENC 编码挺香的，而且对我的 Steam 库存来说 N 卡也更友好一点（但是骂老黄还是要骂的）。另外虽然我不做机器学习，但万一室友毕设需要的话，反正我上班也不用台式机，装个 CUDA 让他 SSH 上去用岂不是你好我好大家好。&lt;/p&gt;
&lt;p&gt;内存其实没什么特别要求，不过由于 Ryzen 的设计，频率越高越好，但按照这一代的设计，最佳频率是 3600 左右，再高反而会下降，我是买不起那么奢侈的内存，甚至 3200 的都买不起，但这款 3000 的也不错，据说颗粒是镁光创下超频记录的那一批，所以就买了四条。我也不需要 RGB，这款的马甲还挺好看的。当然 3000 是 XMP 频率，需要在 BIOS 里打开 XMP，不然默认只有 2400。最近抄了个 3600 16-19-19-36 的作业，结果四条内存轻轻松松就上去了，2K 下面 PUBG 大概提升了 20 FPS，还是挺爽的。&lt;/p&gt;
&lt;p&gt;硬盘不多说了，买 MX500 还是看中一个稳，我还是不放心买同价位国产白片……而且作为一个 2016 年就在笔记本上使用 NVMe SSD 的人，表示并没感觉出 NVME 和 SATA 有什么使用差别……我也不渲染视频，写写代码打打游戏都不卡。但是后来打脸了，公司发了新年福利于是还是上了个 NVMe 硬盘。顺便还配了个无线网卡用来接蓝牙和 WiFi，似乎 Intel AX200 是对 Linux 支持比较好的，就随便买了个 PCI-E 的插上了（御三家集齐了！）（ATX 的好处终于用上了，多出来的 PCI-E 随便插）。&lt;/p&gt;
&lt;p&gt;电源有点买亏了，买完了发现长城同系列 550W 的电源当时也是 329，都怪京东迷一样的定价策略，好在我这一套功耗并不是很高，当然最后趁着福利 + 打折还是换成了海韵一元一瓦的金牌全模组，带我这套绰绰有余。开始我听说原装散热器也能压住 3600X，所以就没打算换，但后来发现刀法还是精准啊，3600X 带的散热器竟然不是铜芯的，再加上 Ryzen 三代的电压控制比较激进，待机温度有时候超过 50，打游戏时候机箱上方有点烤腿，所以还是换了个塔式散热器，风道科学了不少，温度控制也更好了。而且 AMD 原装风扇转速太高，3000rpm 的时候机箱都在震，换了之后安静了很多。顺便安原装散热器时候拆下来的螺丝卡扣不要扔，万一换塔式散热器，好多都是需要装在这个卡扣上的。&lt;/p&gt;
&lt;p&gt;说到机箱和风扇我就一肚子气！本着对京东自营品质和速度的信赖，我全套都是在京东买的，结果拿到手全部安装上之后发现机箱开机跳线是短路的，插上电源就开机，开一会因为短路主板以为你在长按电源又关了！开始我还以为是主板坏了，结果发现螺丝刀手动碰一下开机跳线开关是可以正常开机的！于是又费了九牛二虎之力拆下来退货，主板散热器显卡都在盒子里椅子上放了两天，还好新机箱没问题，但是我买风扇的时候又给我发了个断轴的！东哥呀东哥，我拿你当兄弟，你拿我当代价？你是盯上我了？虽然我平时说你两句坏话但是对京东的服务还是好评的，但是经过这次之后我还是得重新考虑考虑了……顺便据说启航者 S5 这个机箱前面板音频口有的是 HD Audio 有的是老版 AC97，涉嫌虚假宣传，如果你遇到 AC97 的大概可以换货，麻烦一点，不过反正便宜货就这样子，我的抽奖抽到 HD Audio 了。但是这个机箱设计的很抠门，比如主板装上了就没法在上面走 CPU 电源线了，有两个走线口直接被 ATX 主板盖住，所以主板和显卡的电源线只能从一个口里挤出去，然后固态硬盘就在这个口下面所以也很难接线……而且机箱侧板是个黑色半透明的亚克力（那就别宣传透明啊！），金属外壳感觉也不是很厚实。所以最后还是换了先马的鲁班 1，各种设计都宽松了许多，装起来也很好看。&lt;/p&gt;
&lt;p&gt;其他的外设我自己都有，显示器 &lt;del&gt;就是之前买的优派 XG2402，1080p@144Hz 并且自带扬声器&lt;/del&gt; 换成了 DELL S2721DGF，27 寸的 2K@165Hz 屏幕，除了通病漏光以外都还不错，音箱外接了一个 JBL 的蜗牛一代（因为我觉得二代没有一代好看），鼠标就卓威 EC1-B CSGO 特别版（这个版本已经停产了，而且有偶尔指天/指地的 bug，建议买新的 EC1/2 或者 DIVINA 版本），键盘则是前段时间买的 ikbc C87 红轴，便宜还好用。&lt;/p&gt;
&lt;p&gt;顺便由于我手残以及力气小和室友跃跃欲试，很多东西都是他装的，非常感谢。话说回来装这东西还真是个力气活，毕竟接口都有防呆设计仔细看看不会装错，但是真的很紧很难拔……非常担心把主板搞坏了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/1.jpg&quot; alt=&quot;装好的完全体照片&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：避免你们说我灵魂走线，重新整理了一下，线太硬了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/2.jpg&quot; alt=&quot;重新走线正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/3.jpg&quot; alt=&quot;重新走线背面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：内存插满。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/4.jpg&quot; alt=&quot;内存插满&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：NVMe + 蓝牙无线网卡的完全体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/5.jpg&quot; alt=&quot;完全体&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个机箱 CPU 线走上面是要把主板拿下来才能穿过去的，而且右边两个有硅胶垫的孔 ATX 完全不能用，只能用一个孔，而且不能把线固定在机箱中间，很难盖上。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;再更新：新机箱比原来的好看多了也宽敞多了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/6.jpg&quot; alt=&quot;正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/7.jpg&quot; alt=&quot;背面&quot;&gt;&lt;/p&gt;
&lt;p&gt;公司的蜥蜴（明明是变色龙！）玩偶太高了，显卡下面放不开，挂着我又不放心，盖盖子之前还是拿出来了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：换上了公版 2070 SUPER 和利民 AK120。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/9.jpg&quot; alt=&quot;显卡&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/10.jpg&quot; alt=&quot;全景&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020 年 10 月 12 日）：冬天到了，还是换了几个支持 ARGB 的风扇，我个人不喜欢蓝光紫光夜店土嗨风，所以就弄了点温暖的颜色假装是个电暖气。前面是利民 TL-C12R-S，后面是利民 TL-C12S，虽然是三联包，但是似乎螺丝有问题，有一个风扇螺纹被拧花了，而且后面的风扇竟然少一个角上的橡胶减震垫，于是我就没装拧花的那个，并且把它的减震垫安装到后面了。反正考虑到我最下面是机械硬盘，装上这个风扇风道也不畅通，而且那里并没有什么需要散热的设备，电源风道是独立的。每把风扇两根线，ARGB 线要串联，PWM 线要一分三，而且有前有后，风扇线还有编织保护套，还要防止线材打到风扇扇叶。理线花了好久，最后 &lt;del&gt;把他们用扎带固定到下面和前面空的风扇挂架上&lt;/del&gt; 还是走背线了，刚好够长。而且我还有三个 SATA 硬盘打算换一下 SATA 线……我真的想不出来那些水冷排且上下左右全都是 ARGB 风扇的人怎么理线的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/11.jpg&quot; alt=&quot;正面看灯光&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/12.jpg&quot; alt=&quot;侧面看灯光&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/13.jpg&quot; alt=&quot;风扇线不在下面啦&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/14.jpg&quot; alt=&quot;最终的背线效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;我不会告诉你其实我是想调出我 TB 至宝的颜色：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/15.jpg&quot; alt=&quot;TB 至宝&quot;&gt;&lt;/p&gt;
&lt;p&gt;一开始我以为需要用 OpenRGB 这个项目才能在 Linux 下控制颜色，但是这种 ARGB 风扇好像有存储机制，会自动记住上次的设置。于是就在 Windows 下面安装了一个有一大堆乱七八糟组件和功能的 MSI Dragon Center，其实我只需要调成长亮，然后重启进 Linux 颜色就一直是我设置的，然后我想关掉 Dragon Center 的自启动因为反正也用不到，但是微星的软件自己拉跨，重启进 Linux 灯光不变，重启进 Windows 又变呼吸彩虹灯光了。最后发现 Dragon Center 里面有一个类似“覆盖第三方RGB软件”的选项……好像他把他自己上次存储的结果也当第三方软件了，关掉就好了。原理我猜因为 Dragon Center 只是个 Client，真正控制颜色的是他某个 SDK 里面的 Daemon，这个选项的意思其实就是 Daemon 每次启动都按照 Dragon Center 设置的颜色重新设置风扇就实现覆盖功能了……但是 Dragon Center 的启动被我关了所以就默认了，不管了，统统关掉就 OK。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020 年 11 月 16 日）：有了打人国度的眼睛感觉瞬间高贵了起来（大误）。&lt;/p&gt;
&lt;p&gt;老黄卡只有绿色一种颜色，于是只能整个机箱调个老黄绿来配合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/16.jpg&quot; alt=&quot;老黄绿了&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是我自己平时还是喜欢红色的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/17.jpg&quot; alt=&quot;平时灯光&quot;&gt;&lt;/p&gt;
&lt;p&gt;我发现主板的装饰灯正好在公版 SUPER 卡上产生倒影，很有意思。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/18.jpg&quot; alt=&quot;倒影&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个主板可以完美使用 OpenRGB，在 AUR 里安装之后把 &lt;code&gt;/usr/lib/udev/rules.d/60-openrgb.rules&lt;/code&gt; 复制到 &lt;code&gt;/etc/udev/rules.d&lt;/code&gt; 重启即可支持，不过对于 Addressable Header 上的设备也就是风扇或者灯条需要手动 resize zone 也就是填写灯珠个数，我用的利民 TL-C12S 系列经过尝试是 8 个灯珠。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020 年 12 月 1 日）：我之前有考虑过换个机箱，倒不是先马鲁班不符合我的需求了，而是一些细节问题，比如我这个玻璃侧板不那么平，有一个角翘起来一点。然后我的前面板角落里虽然我十分注意还是被我磕了一下。以及当初从宿舍搬出来的时候没有把机箱包装拿出来，以后搬家可能不方便……我一开始本来打算再买一个同款然后把侧板和前面板换了得了，然后那天发现前面 USB 2.0 接口接声卡会破音……于是打算换一个别的机箱。&lt;/p&gt;
&lt;p&gt;我个人其实比较喜欢白色的机箱，于是初步考察了一下，我很喜欢NZXT H1，但我又不可能装 ITX，然后 NZXT H710 看起来不错，我觉得很漂亮，而且我在 NGA 上看到过有人给它纯白色的前面板贴了个黑色的两仪式剪影贴纸很帅气，但是太大太贵了。为什么没选择 H510 呢，因为我有几个硬性需求，我日常使用总结出来的，是一般机箱评测和用户不会注意到的，比如最好不要显卡竖装（我个人肯定是不会竖装的），PCIE的螺丝锁孔也不要做成从机箱尾部凸出来的，其实这里的实际意思是机箱不要有太大的空洞，很多机箱的显卡竖装PCIE螺丝孔上面就那么开着口，凸出来的横着的PCIE螺丝孔虽然有一个覆盖物，但它总是不那么好用，于是这样排除掉了 NZXT H510， NZXT H510i 和 NZXT H710i。&lt;/p&gt;
&lt;p&gt;然后我也不想要钢化玻璃打孔固定的，这个大部分人应该也都不想要。我个人而言还不想要附带一个只有某些软件才能控制的控制器的机箱（点名 NZXT CAM），虽然 NZXT 的水冷确实非常漂亮，但我不放心把电脑这些基础的硬件交给一个需要联网还经常不一定能不能连得上而且只有进了 Windows 才能启动的废物控制软件——我是 Linux 用户。同理我也讨厌雷蛇和罗技难用的鼠标驱动程序。明明我可以用 BIOS 控制风扇/水泵转速，用主板的 ARGB 插针控制风扇，为什么非要用那么难用的软件？所以肯定只考虑 H710 不考虑 H710i。&lt;/p&gt;
&lt;p&gt;如果光是这些可能我就下单 H710 了，虽然贵一点，但是能满足需求也就不在乎了。可是我翻了翻各种帖子都提到了这个机箱的一个缺点：它的硬盘架需要用螺丝刀拧螺丝才能拆除。虽然现在两百块钱的机箱都能免工具调整硬盘仓了但我觉得理完线也没什么人总动机械硬盘所以这不是个问题，但是更严重的是许多人都说固定硬盘仓的螺丝非常难拧，甚至螺丝都花了也拧不下来。作为之前被笔记本内部拧花了的螺丝支配的恐惧的人，我可不要买个这样的样子货，于是只好放弃 NZXT。可能它的设计师平时是不用机械硬盘没有软件更新服务器连不上的问题也不在乎机箱开一大堆没有保护网的口的人吧！&lt;/p&gt;
&lt;p&gt;然后我又开始研究买什么，看了一下联力的鬼斧似乎很不错，虽然造型上比起 NZXT 要难看很多，但是和其它的机箱比起来也算是鹤立鸡群了。而且相比于 NZXT 只是好看来说，它在设计上就考虑到了更多的功能性的细节。比如有单独的重启键（可怜的硬盘灯已经被时代抛弃了）和 LED 控制键而且 LED 控制器可以设置为转发主板的 ARGB 信号（看看人家！），还有磁吸的合页式的玻璃侧板方便随时打开（对我这种强迫症太友好了，拧螺丝搬侧板好累），而且它的电源仓设置了单独的合页门！你可以从前面打开，然后硬盘仓设计成了 NAS 那种可以从前面拿出来的样式（甚至官方还有热插拔配件，彻底变身 NAS）（看看人家！），对折腾型用户不要太友好。但我最后还是没选它，因为我发现这个机箱第一个 PCIE 挡板和它上面的边框之间的缝隙太太太太太大了——你们厂家在这里多加两毫米宽度会赔本吗？而且后来我又想了想，合页式多半不能完全贴合（要给合页留出空间，所以还是算了）。&lt;/p&gt;
&lt;p&gt;然后我看到了海盗船新出的 4000D，纯白色的前面板 + 非外凸的 PCIE 螺丝孔 + 独立的重启键 + 滑动抽拉的硬盘仓 + 有卡口的侧板，虽然它只有一个前置 USB 3.0 和一个 Type-C，不过也不是不能接受，而且有独立的重启键（硬盘灯：四个人的接头我却不能拥有姓名）。虽然它也支持显卡竖装，但它显卡竖装的上面有一个封得比较严实的挡板，它的 PCIE 槽相对也没有太大缝隙（相对）。颜值虽然没有 NZXT H710 好看，但在简洁上也是吊打鬼斧了，于是决定入手这个。&lt;/p&gt;
&lt;p&gt;到手了也发现这个箱子还不算完美，主要的问题在于以下几个：电源仓上边的挡板强度不够，虽然没什么人会拿这个地方承重，但是比我之前的先马鲁班软得多也太差劲了吧！好在机箱其它承重的组件都过得去。然后就是 PCIE 的螺丝孔和显卡的孔有错位！需要很大力气按着才能勉强拧上螺丝，我用的可是公版显卡，你不能说公版卡孔位不标准吧！最后最后，这个机箱底板并没有多延伸出一块盖住侧板的底部！虽然侧板不需要这个位置辅助固定（它有很多卡口固定住），但是明明你顶板是有延伸的，为什么底板要在这里留一条缝隙？？？总而言之就是搬机箱时候要注意手不要抠到侧板和机箱这里的小缝隙（挺窄的，手多往中间伸一点就好了），但是还是会让人担心抠这里把侧板抠变形了。不过总之看下去也没有更合适的选择了，所以就将就吧。送的两个风扇是 3 pin 的，不能 PWM 调速，真是抠门啊海盗船。&lt;/p&gt;
&lt;p&gt;顺便还有个对我不是问题但对大部分人可能是问题的地方，这个机器的前面板里面有一大块金属防尘网，但是根据一些国外的评测，假如你在前面板装上风扇，可能会因为风扇吸气导致这个防尘网向里面贴而蹭到风扇扇叶。但是我装了三个反向进风的风扇在前边，风扇框架在防尘网一侧所以并不担心这个问题。我也推荐所有前面板不是透明玻璃的人在前面使用反向风扇，毕竟正常来说通过侧板看到机箱内部反向风扇的灯光才是最合适的（风扇框架不会出现在机箱内部）。并且说实话，前面板通风比美观更重要，真的没必要买玻璃前面板。&lt;/p&gt;
&lt;p&gt;于是装好了以后正面和背面就是这样的，不要和我说机箱不是留了理线槽了吗为什么不把主板电源线理进去，海韵的主板电源线又粗又硬，连用这块机箱的盖线板盖住都很勉强了，扭来扭去塞到那个理线槽里根本不可能，我也不想让它接头的部分受太大的力。这块主板 Type-C 的接头在内存附近，虽然这是主流位置，但对于直插的 Type-C 线缆来说弯线同样也很困难，别的理线倒没遇到什么大问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/19.jpg&quot; alt=&quot;正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/20.jpg&quot; alt=&quot;背面&quot;&gt;&lt;/p&gt;
&lt;p&gt;白色机箱里面反光要亮一些，但是有灰尘也更明显了……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/21.jpg&quot; alt=&quot;亮起来&quot;&gt;&lt;/p&gt;
&lt;p&gt;前面侧板的灯光效果很好看，没买 Airflow 版一个是因为它挖孔太多太乱，另一个原因是以后我也打算贴上贴纸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/22.jpg&quot; alt=&quot;前面&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天看到 NGA 上有人是风扇白光配红色 ROG LOGO，我也试了一下蛮好看的，就是感觉屋子里又冷了 10 度……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/23.jpg&quot; alt=&quot;白色&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/24.jpg&quot; alt=&quot;全景&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下来是喜闻乐见的 debug 时间，首先是 Linux 下的，相对比较好调：&lt;/p&gt;
&lt;p&gt;三代 Ryzen 有一个 &lt;a href=&quot;https://www.infoq.cn/article/BRebwaBfJ9eP28X9wQQc&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;每次都返回 0xFFFFFFFF 作为随机数的 BUG&lt;/a&gt;，在我这主要影响 wireguard，巧的是购买前几天我刚读过这篇文章，AMD 已经发了新的固件修正错误，建议更新到主板厂家提供的最新 BIOS 版本一般即可解决，如果主板厂家最新的 BIOS 还没更新固件建议联系售后催一下。&lt;/p&gt;
&lt;p&gt;在我这不知道为什么 GDM 有时候没法自动启动，但是手动切 tty start 又可以显示，查了一下 &lt;a href=&quot;https://wiki.archlinux.org/index.php/GDM#GDM_freezes_with_systemd&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;ArchWiki 的 GDM 页面&lt;/a&gt; 发现有解决方案，但是并没有原因，搜索了一下也没发现原因是什么。&lt;/p&gt;
&lt;p&gt;我还发现有时候刚开机没多久很快就关机会卡在什么 systemd-udevd 进程没结束，最后 event loop failed + timed out，大概要卡好几分钟才关机，但如果你用一会再关机就没问题。检查好几次关机日志没发现问题，后来群友火眼金睛对比了完整日志发现有个叫 &lt;code&gt;ucsi_ccg&lt;/code&gt; 的模块开机加载了两分钟，猜测是这个的问题，搜索一下发现是 &lt;a href=&quot;https://github.com/torvalds/linux/blob/da94001239cceb93c132a31928d6ddc4214862d5/drivers/usb/typec/ucsi/ucsi_ccg.c&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;5.3 内核里 NVIDIA 添加的相关代码&lt;/a&gt;，用来控制 NVIDIA 显卡上的 Type-C 接口的，可是我这块显卡根本就没提供 Type-C 接口！（以及很多笔记本内置的有输出的 N 卡也有这个问题。）临时在 &lt;code&gt;/etc/modprobe.d/&lt;/code&gt; 里加了个 &lt;code&gt;blacklist ucsi_ccg&lt;/code&gt; 的 conf 屏蔽了这个，好像没什么不良影响……&lt;/p&gt;
&lt;p&gt;然后是奇怪的 Windows 的问题，我一开始装的 LTSC，不知道怎么回事输入法没了……折腾无果只能重装。以及现在除了不要联网装 Windows 之外（否则会强制你登录微软账户然后用你名字拼音前五位做用户名），还得不要联网装 NVIDIA 驱动，否则 Win10 自动更新驱动会给你安装 DCH 版的，虽然没什么影响（只是在 NVIDIA 官网升级驱动时候不能选标准选 DCH），但是就是让人很不爽。声卡驱动要装主板厂商的，Win10 自带的只能输出，不能接麦克风录音，然后如果麦克风声音很小就打开 Realtek 的声音控制程序，在右上角齿轮里取消掉什么把所有输入结合到一起的设定（什么乱七八糟的玩意！）。还有要关掉快速启动，不然直接开机会卡在黑屏一个鼠标光标……反正就很烦人。&lt;/p&gt;
&lt;p&gt;更新：还有一个奇怪的问题是 Win10 关机重启也要卡很久，上网搜了一下全是一些忽悠小白的办法，经过我不懈搜索发现了一个熟悉的名字 &lt;code&gt;UCSI&lt;/code&gt;！微软承认存在 &lt;code&gt;UCSI&lt;/code&gt; 问题，既然又是这个 &lt;code&gt;UCSI&lt;/code&gt;，多半还是 NVIDIA Type-C 的问题！反正我没这个接口，果断重新安装 N 卡驱动，选择清洁安装（删除旧驱动）并不勾选 Type-C Driver，问题解决……&lt;/p&gt;
&lt;p&gt;最后既然设备到位了，大概就每周一三四五晚上八点半在 &lt;a href=&quot;https://live.bilibili.com/4312992&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Bilibili 4312991 直播间&lt;/a&gt; 播一个半小时游戏，反正我玩什么播什么，大概就 CSGO Dota2 PUBG 什么的吧，尼尔也有可能，反正不是恶心反胃的就可以。周末随缘直播，如果没什么事情白天就播一会，周二可能晚一点开播因为有课。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
  </entry>
  
  
  
  <entry>
    <title>X 和 Wayland 的主要区别</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Difference-between-X-and-Wayland/" />
    <id>https://sh.alynx.one/posts/Difference-between-X-and-Wayland/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-11-13T05:31:33.000Z</published>
    
    
    <updated>2019-11-13T05:31:33.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;最近在写一个 Wayland Compositor，虽然我以前大概知道这是什么，但是并不是很清楚它和 Xserver 有什么区别，虽然 &lt;a href=&quot;https://farseerfc.me/compositor-in-X-and-compositext.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;fc 老师的这篇文章&lt;/a&gt; 写的相当不错，但我一点也不懂 X 所以看的迷迷糊糊。偶然读了 &lt;a href=&quot;https://magcius.github.io/xplain/article/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这篇文章&lt;/a&gt; 发现十分不错，但因为是英文文章读起来很累，打算把一些理解的内容记下来。顺便说一下，原文是带示例的，效果非常不错，建议有时间的人慢慢看一遍。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;最近在写一个 Wayland Compositor，虽然我以前大概知道这是什么，但是并不是很清楚它和 Xserver 有什么区别，虽然 &lt;a href=&quot;https://farseerfc.me/compositor-in-X-and-compositext.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;fc 老师的这篇文章&lt;/a&gt; 写的相当不错，但我一点也不懂 X 所以看的迷迷糊糊。偶然读了 &lt;a href=&quot;https://magcius.github.io/xplain/article/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这篇文章&lt;/a&gt; 发现十分不错，但因为是英文文章读起来很累，打算把一些理解的内容记下来。顺便说一下，原文是带示例的，效果非常不错，建议有时间的人慢慢看一遍。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我相信很多人在搜索 Wayland 的时候都看过这两张著名的图片：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wayland.freedesktop.org/x-architecture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://wayland.freedesktop.org/wayland-architecture.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;但我觉得可能看了也不明白，怎么把 Xserver 砍掉就提高性能了？为什么没有见到 window manager？为什么桌面环境需要去支持 Wayland？&lt;/p&gt;
&lt;p&gt;Wikipedia 上还有一些奇奇怪怪的图片比如这种：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://upload.wikimedia.org/wikipedia/commons/c/c2/Linux_Graphics_Stack_2013.svg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在加上所有介绍 Wayland 的文章都会扯上 DRM，EGL，GLES 之类的，如果不懂这些就完全绕进去了，比如我就看到过有人问 Wayland 用 OpenGL ES 那用 OpenGL 的游戏是不是就跑不了了之类的。&lt;/p&gt;
&lt;p&gt;这一切都得从头说起。&lt;/p&gt;
&lt;p&gt;X 协议设计于 1980 年代，那时候窗口界面刚刚起步，人们还没什么 3D 特效一类的想法，而且机能也不允许，放到今天任何一个有点桌面基础的人都能理解应该给每个窗口一个 buffer 然后把这些 buffer 里的 texture 贴出来的设计逻辑，但 &lt;strong&gt;那时候可没那么多内存让你给每个窗口一个 buffer&lt;/strong&gt;。所以就如同各种常见的领域一样，有个小天才一拍脑子想，反正 &lt;strong&gt;最后显示到桌面上的都是一个屏幕大小&lt;/strong&gt;，我们只要准备这么大一块内存就行了嘛！换句话说，每个窗口的 buffer 要去掉自己被覆盖住的内存，整体内存大小就是可控的，&lt;strong&gt;在内存里是直接没有被覆盖的部分的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;不得不说这位的思路在当时还是很有意义的，加上窗口大小都是矩形的假设，计算实际显示区域并不难，于是 Xserver 就是这样设计的。它维护一个屏幕大小的 buffer 自己计算窗口的实际位置，发生了变化（比如一个窗口盖住另一个），就给变化的窗口发一个重绘信号，这个窗口再发出绘图申请，&lt;strong&gt;直接绘制到 Xserver 的 buffer 里&lt;/strong&gt;。由于 Xserver 知道所有窗口的位置，它就可以重定向鼠标键盘输入过去。然后具体的窗口移动缩放交给 window manager，它再把改过的位置回报给 Xserver。&lt;/p&gt;
&lt;p&gt;一切事情都变得很美好，直到某天一个人提出一个问题：我想要半透明的终端！&lt;/p&gt;
&lt;p&gt;程序员是不屑于解决提出问题的人的，如果用现代程序员的思维，做一下 alpha 混合其实很简单，只要 Xserver 能读取上层窗口的颜色和下层窗口的颜色就行了，可是你还记得当年的小天才吗？Xserver 说不太好意思，对于 &lt;strong&gt;一个像素我内存里只有一层，就是最上面显示的那个窗口&lt;/strong&gt;……并且积习难改，我们不能改这个 feature……你想上下混合？死宅不要整天做梦，这是老祖宗留下来的不能改啊。&lt;/p&gt;
&lt;p&gt;如果你用过没开启 混成 Compositing 的 XFCE 和半透明的 XFCE-Terminal，你会发现它是可以透出窗口下面的壁纸的，先别着急喊我骗子，你在终端下面放一个别的窗口试试？神奇的现象发生了，终端显示的还是壁纸……&lt;/p&gt;
&lt;p&gt;上有政策下有对策嘛，一些终端作者想到反正壁纸总是固定的，我读取壁纸图片，取出终端所在的位置，然后在我窗口做个 alpha 混合不就行了？但是人不能自己骗自己啊，这是个客户端的假透明，我们要学习 GNOME 开发者的思维：不够好就砍掉。（大雾&lt;/p&gt;
&lt;p&gt;X 一看不行啊，那我们改一下协议吧，加一个叫 混成器 compositor 的东西，如果你写了这个东西，X 就不是直接更新他自己的内存 buffer 了，而是交给混成器。混成器可以获取一系列窗口的内容，让它们都画到不同的 buffer 里面（内存终于够大了啊！），再把它们处理了丢到屏幕上去。Xserver 只是要求 compositor 最后返回一整个屏幕（通常是，也可以小一点）然后给这个直接贴到最上面去（可以简单理解为混成器画好一整张就行了，别的都不管了）。&lt;/p&gt;
&lt;p&gt;理论上来说，混成器想怎么放这些窗口就怎么放这些窗口，就算想把他们丢到屏幕外边都行，反正你最后返回一个图就行了，Xserver 也不管是不是涩图。&lt;/p&gt;
&lt;p&gt;但是有个尴尬的事情，输出给你管了，输入你管不着啊！之前说了 Xserver 自己按照自己存的窗口位置分配输入，你把窗口挪走了，Xserver 可还是按照自己记录的窗口位置分配输入的，如果你想自己处理窗口位置分配输入，好嘛，Xserver 里面的代码你再复制到你混成器里一份吧！&lt;/p&gt;
&lt;p&gt;所以实际上 compositor 里面怎么做的呢？我最后处理完的窗口，位置和 Xserver 记录的位置还得一样，然后 Xserver 给我那个返回整张屏幕的顶层窗口，我就不接收输入了，这样直接透过顶层点到下面，就和窗口位置对应了（什么乱七八糟的破玩意啊！）。如果你要做个动画呢？你做动画的时候，Xserver 那边记录的位置可不跟你变（要是变，按照 X 的设计你这数据得跑好几个来回），你的鼠标点击在这时候是不准的，传不到窗口里面。&lt;/p&gt;
&lt;p&gt;这些 compositor 都是各个桌面环境做的，他们一般都集成到自己的 window manager 里了。&lt;/p&gt;
&lt;p&gt;而且随着时间发展，越来越多的 Xserver 和 client 是跑在同一个机器上的，很多 client 想自己利用显卡处理图形，就有人在协议上打洞，Xserver 做的越来越少了，更多的事情 client 自己都做了。&lt;/p&gt;
&lt;p&gt;你还想再往 X 协议上糊一层吗？别糊了兄弟，你这也太挫了！一开始 X 的设计是提供机制而非策略，Xserver 自己是符合了（然后除了 Xorg 其他实现都死了），和 Xserver 配合的可是被他绑的死死的比如 compositor，性能翻了几倍还得拉着这些历史垃圾跑，Xserver 终于活成了自己最讨厌的样子。&lt;/p&gt;
&lt;p&gt;Wayland 做的事情很简单，反正 compositor 都做这么多了，那直接把 Xserver 的功能也丢给 compositor 吧！Compositor 下层接的是 DRM 控制渲染，libinput 控制输入，GBM/EGLStreams 控制内存管理，上层更简单了，每个窗口丢给我一个 texture，我负责安排你们这些 texture 放在哪里，然后我按照我安排的位置，告诉你们鼠标进谁窗口了键盘进谁窗口了。然后因为要把这些 texture 混合到屏幕上，一般都用 OpenGL 的硬件加速，但在 Linux 下创建 OpenGL Context 的 GLX 库是和 X 绑定的，所以一般大家都用 OpenGL ES Context 的库 EGL。这个库只干扰最后合成图片时候的事情，至于你的 texture 用的是 OpenGL 还是 OpenGL ES 还是 CPU 画的都没有关系，现在 Wayland 一概不管了，你自己客户端处理自己的内容吧，我又不是 Xserver！&lt;/p&gt;
&lt;p&gt;所以对于 GNOME 和 KDE 等等而言，现在他们打交道的一个是内核一个是窗口，而不是以前一样和 Xserver 打交道了，省了数据交换，同时自己可以自由控制窗口输入输出面积。Xorg 应该被淘汰不是因为功能性原因，而是因为它的设计在当时很聪明，但现在只是历史包袱，实在太挫了。&lt;/p&gt;
&lt;p&gt;看完这篇文章建议回去阅读开头的两个链接，可以了解更多的实现细节，现在再看就不会那么混乱了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    
    <category term="Wayland" label="Wayland" scheme="https://sh.alynx.one/tags/Wayland/" />
    
  </entry>
  
  
  
  <entry>
    <title>蜗牛星际安装 Arch Linux 作为 NAS</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/SnailSpace-as-NAS/" />
    <id>https://sh.alynx.one/posts/SnailSpace-as-NAS/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-10-07T09:01:00.000Z</published>
    
    
    <updated>2019-10-07T09:01:00.000Z</updated>
    
    
    <summary type="html">
      &lt;h1 id=&quot;需求&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E9%9C%80%E6%B1%82&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;
&lt;p&gt;以前我一直使用树莓派 + 移动硬盘做 Samba 服务器，好处是完全静音，功耗很低，但是树莓派 2 的网络性能差强人意，并且 USB 2.0 的速度也赶不上移动硬盘的速度，看电影什么的只是能看，要花好长时间缓冲，并且我一直开着，对树莓派的电源也不是很放心。特别是我还拆下来一块笔记本上的 1TB 机械硬盘，完全没法装在树莓派上。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;h1 id=&quot;需求&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E9%9C%80%E6%B1%82&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h1&gt;
&lt;p&gt;以前我一直使用树莓派 + 移动硬盘做 Samba 服务器，好处是完全静音，功耗很低，但是树莓派 2 的网络性能差强人意，并且 USB 2.0 的速度也赶不上移动硬盘的速度，看电影什么的只是能看，要花好长时间缓冲，并且我一直开着，对树莓派的电源也不是很放心。特别是我还拆下来一块笔记本上的 1TB 机械硬盘，完全没法装在树莓派上。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;有点想买一台 NAS，但是看看群晖的价格实在接受不能，然后又看到说群晖把系统放在用户的磁盘里加速读写一类的，其实这些对我来说不太重要，但群晖是个定制化程度很高的 Linux，虽然用起来有很多便利的功能，比如官方的内网穿透（服务器似乎在台湾，速度不快），比较成熟的 btrfs 使用之类的，但比起这些我更想要一台全功能的 Linux 服务器，这样不仅可以作为存储，还可以 SSH 连接上去做一些简单工作。作为一个比较熟练的 Linux 用户，我不需要什么 Webui 或者 App 来访问文件，Solid Explorer 和 VLC 组合起来访问 Samba 好用得很。&lt;/p&gt;
&lt;p&gt;机缘巧合我看到隔壁的同学弄了台 D 款的蜗牛星际矿渣，研究一下之后觉得可以上车，正好 Arch CN 群里 &lt;a href=&quot;https://nichi.co/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@NickCao&lt;/a&gt; 打算出掉买了回来没时间玩的蜗牛 A 款，于是坐地铁到五道口一起喝了杯咖啡然后当面交易了一下。&lt;/p&gt;
&lt;h1 id=&quot;介绍&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E4%BB%8B%E7%BB%8D&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;
&lt;p&gt;蜗牛星际的矿渣是怎么来的呢？简单说就是忽悠别人说这个机器可以挖矿，打着区块链旗号骗人买机器，当然这个机器其实并不需要挖矿，所谓的挖矿就是简单的 App，让你以为自己挖出矿了（毕竟宣传说不用插电也能挖），为了降低成本机器全部都是用现成的山寨货，所以机箱造型是 NAS，而且还带硬盘背板，就是因为这个很成熟。成本不到一千块的机器五千块一台卖给受骗者，受骗者为了挖矿都是十几台几十台的买，然后放小道消息说要涨价到八千块榨干受骗者钱包，最后国际惯例圈钱跑路，受骗者血本无归。&lt;/p&gt;
&lt;blockquote class=&quot;center-quote&quot;&gt;做人还是得懂点计算机。&lt;/blockquote&gt;

&lt;p&gt;这个机器有好多型号，细节差距也有很多，网上有现成的帖子分析，我就不分析了，反正我这一台是 A 款单网口绿主板，妥妥的千兆。而且似乎背板有 PCI 槽，不过主板又没有 PCI 接口就不管了。A 款还有个特点是硬盘架侧面可以放个 2.5 寸硬盘，正好装上我拆下来的笔记本硬盘。&lt;/p&gt;
&lt;h1 id=&quot;硬件处理&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E7%A1%AC%E4%BB%B6%E5%A4%84%E7%90%86&quot; title=&quot;硬件处理&quot;&gt;&lt;/a&gt;硬件处理&lt;/h1&gt;
&lt;h2 id=&quot;更换电源&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E6%9B%B4%E6%8D%A2%E7%94%B5%E6%BA%90&quot; title=&quot;更换电源&quot;&gt;&lt;/a&gt;更换电源&lt;/h2&gt;
&lt;p&gt;手头这一台运气比较好，是 zumax 的 150W 电源，虽然都说这个是所有各种电源里最好的，但是接口只是刚刚够，没有多余的，没办法给侧面硬盘供电。再说都是山寨货谁又比谁强到哪里。按照隔壁老司机的推荐淘宝买了益衡 250W 的 Flex 电源（也叫小 1u 电源）替换掉，花了 250 软妹币左右，感觉车速稳了很多，而且多出了许多接口。安装时候需要把原来电源上后面用来装到侧面的铁片拆掉，然后上下翻转才能装上蜗牛里面的支撑片，然后主板有一长一方两个供电口都插上，背板用的大 4pin 接口，不太够长，把卖家赠送的两条大 4pin 延长线都接上就可以了，然后取一个 SATA 供电线给侧面的硬盘。&lt;/p&gt;
&lt;h2 id=&quot;更换风扇&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E6%9B%B4%E6%8D%A2%E9%A3%8E%E6%89%87&quot; title=&quot;更换风扇&quot;&gt;&lt;/a&gt;更换风扇&lt;/h2&gt;
&lt;p&gt;蜗牛自带的风扇声音很大，因此需要更换一个静音风扇，A 款用的是 8cm 的 3pin 风扇，不支持调速，BCD 都是 12cm 的。8cm 不太好买，开始我在京东找到两个超频三的风扇，一个 2200 转一个 1400 转，标定噪音都是 18dB，于是就买了 2200 转，没想到转速上来了噪音也更大，正好之前在淘宝买了另一个超频三皓月（下面上图），1500 转应该问题不大，装上发现声音小了，但是蜗牛背板有个铆钉，这个 LED 风扇尺寸稍微大一点，正好顶着铆钉。没办法还是换了京东 1400 转的那款，噪音合适，尺寸也合适，蜗牛本来发热也不严重。因此 &lt;strong&gt;建议大家购买 1500 转左右不带 LED 灯效正常尺寸的&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&quot;alert-green&quot;&gt;更换时候记得把原来蜗牛风扇上用来防止线缆伸进风扇里的塑料防护片拧下来装到新风扇没有阻拦的一侧，这一侧朝里，安装之后蜗牛向外吹风。&lt;/div&gt;

&lt;div class=&quot;alert-red&quot;&gt;这个防护片不要拧太紧，以免把它拧裂了，这种是和机箱配套卖的，淘宝上有卖那种金属的防护网，但是都是厂家批发，不太好买。&lt;/div&gt;

&lt;p&gt;你问我怎么知道的？当然是大力出悲剧拧裂了然后没办法只能 502 直接粘风扇边上了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;再次提醒各位注意不要买下图的带灯条的风扇。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/SnailSpace-as-NAS/1.jpg&quot; alt=&quot;大了一圈的风扇&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/2.jpg&quot; alt=&quot;装上之后的效果&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装侧面25寸硬盘&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E5%AE%89%E8%A3%85%E4%BE%A7%E9%9D%A225%E5%AF%B8%E7%A1%AC%E7%9B%98&quot; title=&quot;安装侧面25寸硬盘&quot;&gt;&lt;/a&gt;安装侧面 2.5 寸硬盘&lt;/h2&gt;
&lt;p&gt;蜗牛自带一个 16G 的 mSATA 硬盘，速度比 U 盘还慢，而且据说用着用着就坏了，很多人都拿这个做引导盘放系统，但我不打算用，直接拧下四个螺丝把主板抽出来，然后拧掉 mSATA 杂牌硬盘。&lt;/p&gt;
&lt;p&gt;因为四个硬盘托连接的 SATA 口是扩展的，不支持引导，但是 &lt;strong&gt;实际上蜗牛主板正中间上还有一个 SATA2 的口可以引导&lt;/strong&gt;，正好连接我的笔记本硬盘，自己插上一根 SATA 线把主板装回去即可。&lt;/p&gt;
&lt;p&gt;硬盘本体安装时候需要两个小螺丝固定硬盘一侧，另外一侧是卡住的，不需要螺丝。然后把电源线和刚才插的 SATA 线插到硬盘上面。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/SnailSpace-as-NAS/5.jpg&quot; alt=&quot;笔记本硬盘&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/6.jpg&quot; alt=&quot;安装位置示意&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;仓库盘安装&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E4%BB%93%E5%BA%93%E7%9B%98%E5%AE%89%E8%A3%85&quot; title=&quot;仓库盘安装&quot;&gt;&lt;/a&gt;仓库盘安装&lt;/h2&gt;
&lt;p&gt;我还在京东购买了一块 2TB 的西数紫盘和一块 2TB 的东芝 P300 硬盘，没有买 NAS 专用盘是因为太贵了。而其他便宜的比如西数蓝盘和希捷酷鱼只便宜了十几块，但是却是大缓存叠瓦式（SMR）硬盘，性能非常差，紫盘和 P300 则是标准的 64M 缓存垂直式（PMR）硬盘，价格也比较实惠。建议自行搜索叠瓦式硬盘了解不推荐的原因。&lt;del&gt;考虑了一下还是不做 RAID1 了，经济条件不允许，而且本来 RAID 是为了高可用不是为了备份，如果是硬件损坏估计两块盘一起炸了，不如冷备份&lt;/del&gt; 还是做了 RAID1（真香！）。&lt;/p&gt;
&lt;p&gt;往硬盘架安装硬盘需要四个沉孔螺丝分别锁在两侧，当然我这种硬件渣渣其实是不知道啥是沉孔螺丝的，具体多大多粗我也不懂，我装 2.5 硬盘的螺丝是同学买大疆编程小车多出来的内六角，尺寸正好，至于 3.5 硬盘是隔壁老司机送给我的装机剩下的，反正车速很稳，如果自己买的话京东淘宝好像都有装机用的成套螺丝，建议顺手买一套，不要螺丝钉难倒程序员。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/SnailSpace-as-NAS/4.jpg&quot; alt=&quot;西数带包装&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/14.jpg&quot; alt=&quot;东芝带包装&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/13.jpg&quot; alt=&quot;打开外包装之后&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/12.jpg&quot; alt=&quot;取出来正面&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/11.jpg&quot; alt=&quot;取出来背面&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/10.jpg&quot; alt=&quot;硬盘托侧面螺丝&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/8.jpg&quot; alt=&quot;西数装上硬盘托正面&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/9.jpg&quot; alt=&quot;东芝装上硬盘托正面&quot;&gt;
&lt;img src=&quot;/posts/SnailSpace-as-NAS/7.jpg&quot; alt=&quot;从硬盘架上拔出来一半&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;软件处理&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E8%BD%AF%E4%BB%B6%E5%A4%84%E7%90%86&quot; title=&quot;软件处理&quot;&gt;&lt;/a&gt;软件处理&lt;/h1&gt;
&lt;h2 id=&quot;分区&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E5%88%86%E5%8C%BA&quot; title=&quot;分区&quot;&gt;&lt;/a&gt;分区&lt;/h2&gt;
&lt;p&gt;软件部分就十分舒服自在了，接显示器网线键盘开机按 F7 进入 BIOS 设置 UEFI 模式从 U 盘启动，然后进入 Archiso 按照 &lt;a href=&quot;https://wiki.archlinux.org/index.php/Installation_guide&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;安装指南&lt;/a&gt; 安装系统（据说他们最近在处理 base 组，建议随时跟进 wiki，我就不复制了），分区的时候我是在能引导的 2.5 寸硬盘上建立了 ESP，然后其他空间全部用作 LVM，1T 硬盘的剩余空间作为一个 pv，&lt;del&gt;并且给 2T 的硬盘分了三个区做 pv（万一我哪天脑子抽了想缩个分区出来呢？）&lt;/del&gt;，然后建立 vg，建立给根目录和家目录的 lv，然后创建 ext4 文件系统。这一段参照 wiki 对应页面就行了，命令十分简明直观，我第一次用就成功了。配置好的效果如图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/SnailSpace-as-NAS/3.jpg&quot; alt=&quot;分区状况&quot;&gt;&lt;/p&gt;
&lt;p&gt;至于 2T 的硬盘考虑了一下还是打算再加一块硬盘做 RAID1，不然连续跨设备 lvm 坏了一个就全坏了，由于 mdadm 需要两块设备都在才能建立，&lt;del&gt;但我手头只有一块&lt;/del&gt; 决定的时候手头只有一块，于是在 fc 老师建议下决定上 btrfs（而且这货似乎支持多块不同容量硬盘的 RAID1，保证每个文件都在两块盘上有备份）。按照 fc 老师多年使用经验似乎 btrfs 也没那么不可靠。&lt;/p&gt;
&lt;p&gt;&lt;del&gt;然后我在某东买了一块东芝 2T 64M 7200 转的机械硬盘，到手之后打算加入 btrfs 里面，建立 RAID1，btrfs 的好处就在于这个可以先弄一块之后渐进修改，而且看起来目前没什么大问题的样子（按我的理解并行读取的性能问题大概是用来并行加速的，但是实际上 RAID1 不并行读取也可以读出数据吧）。&lt;/del&gt; 虽然我本来也可以把数据移出来然后建 mdadm，但是不排除以后再加盘做 RAID 10，似乎 mdadm 没法直接转换的样子？&lt;/p&gt;
&lt;p&gt;买回来硬盘之后想想反正两块都没啥数据（搬出去了），索性直接格式化成 btrfs，不然也可以在已有一块 btrfs 设备之后 add 然后 balance，就可以修改策为 RAID1，格式化命令很简单就这样：&lt;/p&gt;
&lt;figure data-raw=&quot;# mkfs.btrfs -m raid1 -d raid1 /dev/sdXY /dev/sdZV&quot; data-info=&quot;language-plain&quot; data-lang=&quot;plain&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-plain&quot;&gt;# mkfs.btrfs -m raid1 -d raid1 /dev/sdXY /dev/sdZV&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;-m raid1&lt;/code&gt; 是指 metadata 要做 RAID1 备份，&lt;code&gt;-d raid1&lt;/code&gt; 是指 data 也要 RAID1 备份，然后需要跟两个设备，推荐是一样大的，挂载时候就随便挂一个设备就行了，btrfs 会自己执行 RAID1 策略的。&lt;/p&gt;
&lt;h2 id=&quot;启动配置&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E5%90%AF%E5%8A%A8%E9%85%8D%E7%BD%AE&quot; title=&quot;启动配置&quot;&gt;&lt;/a&gt;启动配置&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;/etc/mkinitcpio.conf&lt;/code&gt; 里需要给 HOOKS 添加 lvm2，然后运行 &lt;code&gt;mkinitcpio -p linux&lt;/code&gt;，这样生成的 initramfs 才能支持 LVM。我还给 MODULES 添加了和 intel 显卡有关的部分（虽然可能用不到了），具体修改的位置如下：&lt;/p&gt;
&lt;figure data-raw=&quot;MODULES=(intel_agp i915)
HOOKS=(base udev autodetect modconf block lvm2 filesystems keyboard fsck)&quot; data-info=&quot;language-bash&quot; data-lang=&quot;bash&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-bash&quot;&gt;MODULES=(intel_agp i915)
HOOKS=(base udev autodetect modconf block lvm2 filesystems keyboard fsck)&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;安装 bootloader 的时候我直接用了 systemd-boot，我在自己笔记本上也用的这个，功能够用了就没考虑安装 GRUB，编写 entry 时候内核参数里的 root 可以写 &lt;code&gt;/dev/vg0/rootlv&lt;/code&gt; 也可以写 &lt;code&gt;/dev/mapper/vg0-rootlv&lt;/code&gt;（这里中文 wiki 和英文 wiki 分别是这俩，亲测都可以），比如我的就是下面这样：&lt;/p&gt;
&lt;figure data-raw=&quot;title    Arch Linux
linux    /vmlinuz-linux
initrd    /intel-ucode.img
initrd    /initramfs-linux.img
options    root=/dev/vg0/rootlv rw add_efi_memmap&quot; data-info=&quot;language-plain&quot; data-lang=&quot;plain&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-plain&quot;&gt;title    Arch Linux
linux    /vmlinuz-linux
initrd    /intel-ucode.img
initrd    /initramfs-linux.img
options    root=/dev/vg0/rootlv rw add_efi_memmap&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;最近 systemd-boot 添加了什么校验设置，在蜗牛上会报错，直接 chroot 进去安装根本装不上，临时解决方案是退出 chroot，然后用 Archiso 里的 &lt;code&gt;bootctl&lt;/code&gt; 安装到 &lt;code&gt;/mnt/boot&lt;/code&gt;，虽然有点 dirty，但是能用？不过还是会报个错，但是启动需要的文件已经安装上了，不管它也能用，只不过每次重启还是会说校验失败，目测是个 bug。&lt;/p&gt;
&lt;h2 id=&quot;网络配置&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE&quot; title=&quot;网络配置&quot;&gt;&lt;/a&gt;网络配置&lt;/h2&gt;
&lt;p&gt;然后由于 NAS 的网络不会经常变化，&lt;del&gt;所以联网的部分也直接用 systemd-networkd 管理了，没必要上 NetworkManager&lt;/del&gt; 我装桌面了所以还是用了 NetworkManager！不过这部分也留着好了。直接创建 &lt;code&gt;/etc/systemd/network/wired.network&lt;/code&gt;，写入如下内容：&lt;/p&gt;
&lt;figure data-raw=&quot;[Match]
Name=en*

[Network]
DHCP=ipv4&quot; data-info=&quot;language-ini&quot; data-lang=&quot;ini&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-ini&quot;&gt;[Match]
Name=en*

[Network]
DHCP=ipv4&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;意思是对于所有以 &lt;code&gt;en&lt;/code&gt; 开头的网卡使用 DHCPv4，然后 &lt;code&gt;systemctl enable --now systemd-networkd systemd-resolved&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;NetworkManager 就很简单，直接安装然后 &lt;code&gt;systemctl enable NetworkManager --now&lt;/code&gt; 应该就行了！&lt;/p&gt;
&lt;h2 id=&quot;Samba配置&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#Samba%E9%85%8D%E7%BD%AE&quot; title=&quot;Samba配置&quot;&gt;&lt;/a&gt;Samba 配置&lt;/h2&gt;
&lt;p&gt;btrfs 的子卷看起来很像普通目录，但是又可以分别直接挂载，不需要先挂载设备然后再用 &lt;code&gt;mount --rbind&lt;/code&gt;。于是建了 &lt;code&gt;/data&lt;/code&gt; 和 &lt;code&gt;/data/alynx&lt;/code&gt; 两个子卷，&lt;code&gt;/data&lt;/code&gt; 就挂载到 &lt;code&gt;/data&lt;/code&gt;，&lt;code&gt;/data/alynx&lt;/code&gt; 挂载到我家目录下面。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;/etc/samba/smb.conf&lt;/code&gt; 添加如下配置，就可以分别通过 &lt;code&gt;home&lt;/code&gt; 和 &lt;code&gt;data&lt;/code&gt; 访问每个用户在 &lt;code&gt;/home&lt;/code&gt; 和 &lt;code&gt;/data&lt;/code&gt; 下面的同名文件夹了，&lt;code&gt;%u&lt;/code&gt; 代表的就是连接的用户名。（当然权限要你自己处理一下。）&lt;/p&gt;
&lt;figure data-raw=&quot;[home]
   comment = Home Directories
   browseable = yes
   writeable = yes
   path = /home/%u

[data]
   comment = Data Directories
   browseable = yes
   writeable = yes
   path = /data/%u&quot; data-info=&quot;language-ini&quot; data-lang=&quot;ini&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-ini&quot;&gt;[home]
   comment = Home Directories
   browseable = yes
   writeable = yes
   path = /home/%u

[data]
   comment = Data Directories
   browseable = yes
   writeable = yes
   path = /data/%u&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;其它的配置基本都是正常操作参照 Arch Wiki，&lt;del&gt;我打算以后插新硬盘直接加进 LVM 加给 &lt;code&gt;/home&lt;/code&gt;，省得还得操心挂载到哪里&lt;/del&gt; 决定单独安排 btrfs 数据区了，参见上面。在外面访问我选择配置 WireGuard，参照我 &lt;a href=&quot;/posts/SnailSpace-as-NAS/WireGuard-Usage/&quot;&gt;这篇文章&lt;/a&gt; 就可以了，如果只是 SSH 远程控制一下效果还可以。&lt;/p&gt;
&lt;h1 id=&quot;效果&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/SnailSpace-as-NAS/#%E6%95%88%E6%9E%9C&quot; title=&quot;效果&quot;&gt;&lt;/a&gt;效果&lt;/h1&gt;
&lt;p&gt;笔记本插了有线之后可以测试千兆对拷，我的路由器还是大一时候买的 WNDR3800，虽然很旧，但四个有线全部都是千兆口（当时价格和配置差不多的极路由 3 只有一个内网千兆好像），&lt;del&gt;samba 拷贝速度轻松达到 110M/s 的满速，甚至比蜗牛的 USB3.0 还快&lt;/del&gt; 用了 btrfs 之后似乎速度只有 80M/s 左右了，或者 Windows 和 Linux 下面 Samba 对拷速度显示有区别？110M/s 是我在 Windows 下面测出来的。&lt;/p&gt;
&lt;p&gt;蜗牛后面两个 USB3.0 只有下面的那个是真的，上面的也就 2.0 速度，下面的跑满了也就 80 到 90M/s，我的 U 盘是 CZ80，放笔记本上比这快多了，而且有时候上面那个也可以跑到 70M/s，具体原因不知道，如果是真的土豪建议直接换主板算了，非土豪完全可以插笔记本然后网络拷进蜗牛，比这奇葩接口还快。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/Arch%20Linux/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Arch Linux" label="Arch Linux" scheme="https://sh.alynx.one/tags/Arch%20Linux/" />
    
    <category term="蜗牛星际" label="蜗牛星际" scheme="https://sh.alynx.one/tags/%E8%9C%97%E7%89%9B%E6%98%9F%E9%99%85/" />
    
  </entry>
  
  
  
  <entry>
    <title>前端博客搜索引擎</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Frontend-Blog-Search/" />
    <id>https://sh.alynx.one/posts/Frontend-Blog-Search/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-09-18T07:24:00.000Z</published>
    
    
    <updated>2020-08-15T10:25:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;本来我的博客有一个前端搜索框，当输入文字时就在侧边栏展开搜索结果，虽然看起来很时髦，但也不能算是什么食用啊不实用的设计方式。而且一开始我觉得既然没有后端处理请求，也就没法单独打开一个专门搜索页面了。&lt;/p&gt;
&lt;p&gt;但是这个设计引发了 &lt;a href=&quot;https://blog.lilydjwg.me/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@依云&lt;/a&gt; 的吐槽，有一个单独的搜索页面并且对每个搜索结果有专门的 URL 看起来还是个挺合理的需求。但第一我不知道怎么实现第二我一直觉得能用就行所以开始并没有改。不过依云给我发了 Python 文档的搜索实现，让我突然想明白其实按照标准的 HTML 和 JavaScript 是可以实现无后端的搜索引擎的，然后就动手实现了一个。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;本来我的博客有一个前端搜索框，当输入文字时就在侧边栏展开搜索结果，虽然看起来很时髦，但也不能算是什么食用啊不实用的设计方式。而且一开始我觉得既然没有后端处理请求，也就没法单独打开一个专门搜索页面了。&lt;/p&gt;
&lt;p&gt;但是这个设计引发了 &lt;a href=&quot;https://blog.lilydjwg.me/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@依云&lt;/a&gt; 的吐槽，有一个单独的搜索页面并且对每个搜索结果有专门的 URL 看起来还是个挺合理的需求。但第一我不知道怎么实现第二我一直觉得能用就行所以开始并没有改。不过依云给我发了 Python 文档的搜索实现，让我突然想明白其实按照标准的 HTML 和 JavaScript 是可以实现无后端的搜索引擎的，然后就动手实现了一个。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;首先既然要搜索那还是得有个索引或者数据库，比较简单的方案就是把所有文章的标题 URL 和内容丢到一个 json 文件里面，这个功能在 Hexo 里可以使用 &lt;code&gt;hexo-generator-search&lt;/code&gt; 实现，我也给我的 Hikaru 添加了这个生成器，用来生成 JSON。&lt;/p&gt;
&lt;p&gt;首先第一件事是实现搜索跳转页面，这一步只要简单的使用 HTML 表单就能实现，首先将我的搜索框改造为如下格式：&lt;/p&gt;
&lt;figure data-raw=&quot;&lt;form action=&amp;quot;{{ getPath(&amp;quot;search.html&amp;quot;) }}&amp;quot; method=&amp;quot;get&amp;quot;&gt;
  &lt;button type=&amp;quot;submit&amp;quot; class=&amp;quot;search-submit&amp;quot; aria-label=&amp;quot;{{ __(&amp;quot;search&amp;quot;) }}&amp;quot;&gt;
    &lt;i class=&amp;quot;fas fa-search&amp;quot;&gt;&lt;/i&gt;
  &lt;/button&gt;
  &lt;input type=&amp;quot;search&amp;quot; id=&amp;quot;search-input&amp;quot; class=&amp;quot;search-input&amp;quot; name=&amp;quot;q&amp;quot; results=&amp;quot;0&amp;quot; placeholder=&amp;quot;{{ __(&amp;quot;search&amp;quot;) }}&amp;quot; aria-label=&amp;quot;{{ __(&amp;quot;search&amp;quot;) }}&amp;quot;&gt;
&lt;/form&gt;&quot; data-info=&quot;language-html&quot; data-lang=&quot;html&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-html&quot;&gt;&amp;lt;form action=&quot;{{ getPath(&quot;search.html&quot;) }}&quot; method=&quot;get&quot;&amp;gt;
  &amp;lt;button type=&quot;submit&quot; class=&quot;search-submit&quot; aria-label=&quot;{{ __(&quot;search&quot;) }}&quot;&amp;gt;
    &amp;lt;i class=&quot;fas fa-search&quot;&amp;gt;&amp;lt;/i&amp;gt;
  &amp;lt;/button&amp;gt;
  &amp;lt;input type=&quot;search&quot; id=&quot;search-input&quot; class=&quot;search-input&quot; name=&quot;q&quot; results=&quot;0&quot; placeholder=&quot;{{ __(&quot;search&quot;) }}&quot; aria-label=&quot;{{ __(&quot;search&quot;) }}&quot;&amp;gt;
&amp;lt;/form&amp;gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;使用 &lt;code&gt;button&lt;/code&gt; 而不是 &lt;code&gt;input&lt;/code&gt; 的原因是我想用我的图标做搜索按钮，反正 &lt;code&gt;&amp;lt;input type=&quot;submit&quot;&amp;gt;&lt;/code&gt; 只是个特化的 &lt;code&gt;button&lt;/code&gt;。理论上来说不放按钮靠回车提交也是 OK，但是觉得这样又会被某些用户批评不友好了……&lt;/p&gt;
&lt;p&gt;搜索框就很简单，&lt;code&gt;name=&quot;q&quot;&lt;/code&gt; 表示生成的 query string 里 keywords 的 key 是 &lt;code&gt;q&lt;/code&gt;，然后按照表单写法会被提交到 &lt;code&gt;search.html&lt;/code&gt;，理论上来说搜索应该发 GET 请求所以就是 &lt;code&gt;method=&quot;get&quot;&lt;/code&gt;，当然 POST 就实现不了复制链接查看搜索结果了。&lt;/p&gt;
&lt;p&gt;这个表单就是标准的 HTML 表单，不需要用 JavaScript 处理。生成的 GET 请求的 URL 类似于 &lt;code&gt;/search.html?q=xxx&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后接下来是处理请求了，既然是发送到 &lt;code&gt;search.html&lt;/code&gt;，对于静态后端肯定是要返回这个页面的，那就得先创建页面，然后对这个页面进行特殊处理，这里我同样利用生成器生成一个 layout 设置成 &lt;code&gt;search&lt;/code&gt; 的页面，然后就可以单独给它编写模板添加处理部分了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;search.html&lt;/code&gt; 加载之后是可以通过 &lt;code&gt;window.location.search&lt;/code&gt; 获取到 query string 的，然后我加载我修改过的 &lt;code&gt;search.js&lt;/code&gt;（&lt;a href=&quot;/js/search.js&quot;&gt;这里&lt;/a&gt;），用它处理搜索过程。同时在页面里添加了一个 container 用来放置检索结果。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;search.js&lt;/code&gt; 其实没什么黑科技，毕竟我们的难点就是在无后端情况下处理关键词和数据库，关键词已经用 &lt;code&gt;window.location.search&lt;/code&gt; 拿到了，解析一下然后只要通过 ajax/fetch 请求数据就行了，封装 ajax 的代码网上到处都是，实在不行用 jQuery 也成。&lt;/p&gt;
&lt;p&gt;然后剔除重复关键词主要是为了优化一下性能，接下来我的解决方案就是简单粗暴 &lt;code&gt;indexOf()&lt;/code&gt;，不要跟我提什么算法什么优化，短平快实现效果，我是个实用主义者，目前这一步其实还没有成为瓶颈。&lt;/p&gt;
&lt;p&gt;然后对于原版文件我的改进主要是按匹配次数排序，文章出现关键词越多则排序越靠前，相对可以提高效率。&lt;/p&gt;
&lt;p&gt;接下来使用正则表达式给关键词加上 &lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;，这样显示起来比较显眼。最后把字符串拼起来显示就好了。其实这里的算法还有点意思，比如假如两个关键词出现的位置中间大于多少个字符则插入省略号，否则合并两个的上下文，具体实现也可以参照代码。&lt;/p&gt;
&lt;p&gt;如果有性能瓶颈的话，多半也会先出现在 ajax，不过目前我文章还没有多到加载不出来的情况，也许可以靠分块加载解决？&lt;/p&gt;
&lt;p&gt;更新（2020-08-15 18:25:00）：我给代码添加了简单的分块支持。由于这里需要主题和生成器约定好路径，不太适合让生成器自动生成路径，所以采用了一个简单的方法就是让用户在设置文件里手动指定几个 JSON 文件的路径，然后生成器只是读取一下配置，假如是数组就分块写到指定好的路径里面。然后前端查找的时候分别异步查找每个文件并合并排序结果，理论来说大概会有性能提升？&lt;/p&gt;
&lt;p&gt;最后我加了个简单的 SpinKit 动画，在查询结束之前先跑一下提升用户体验。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/ARIA/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="搜索" label="搜索" scheme="https://sh.alynx.one/tags/%E6%90%9C%E7%B4%A2/" />
    
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/tags/JavaScript/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/tags/ARIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>Linux 用户的月饼食用手册</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Linux-Mooncake-Jokes/" />
    <id>https://sh.alynx.one/posts/Linux-Mooncake-Jokes/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-09-13T10:47:00.000Z</published>
    
    
    <updated>2019-09-13T10:47:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;中秋节到了，Arch Linux CN 社区里富有生活情趣（？）的用户们聚在一起，开始讨论起如何食用月饼。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;中秋节到了，Arch Linux CN 社区里富有生活情趣（？）的用户们聚在一起，开始讨论起如何食用月饼。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;Gentoo 用户需要自己编译月饼，并且可以设置不同的 USE 编译不同口味。（farseerfc，outvi 和 AlynxZhou）&lt;/li&gt;
&lt;li&gt;Debian 用户习惯将月饼拆成月饼馅、月饼皮和月饼油分别打包食用。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Arch Linux 用户喜欢购买 Debian 的月饼，然后将月饼馅、月饼皮和月饼油拆开自行组装并打包。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Manjaro 用戶買來 Arch 組裝好的 Debian 月餅然後敲了個花紋上去重新裝了起來。（farseerfc）&lt;/li&gt;
&lt;li&gt;Manjaro 用户经常吃了 Arch Linux 的月饼然后抱怨这个月饼为什么不是 Manjaro 牌的。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;CentOS 的月饼过期了。（KRyuJo）但总有人喜欢这个传统口味，不想换。甚至有人资助 RedHat 厨师学校传承老字号。（whyme）&lt;/li&gt;
&lt;li&gt;RedHat：我们将通过电话联系在线指导您服用月饼。（ArielAxionL）&lt;/li&gt;
&lt;li&gt;openSUSE 用户也喜欢将月饼拆成月饼馅、月饼皮和月饼油分别打包食用，但他们通常编写一个 &lt;code&gt;月饼.spec&lt;/code&gt; 文件，然后将买来的月饼原料和此文件一同上传到 Open Build Service 而不是自己打包月饼。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;随后 openSUSE 的月饼被冻结了，存放到 SUSE Linux Enterprise 的冰箱里。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Ubuntu 的月饼馅过期了，但是依旧没有更新。（wuliao00）&lt;/li&gt;
&lt;li&gt;Ubuntu 的月饼包装写着豆沙，用户咬了一口发现是五仁，大喊“内部错误！”。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Deepin 用户表示吃月饼时应该配点红酒（wine）。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;LFS 用戶發現需要先自己製作用於製作月餅的工具。（YHNdnzj）然后开始阅读“如何开办一家月饼工厂”。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Antergos 用户收到了一个不幸的消息“此品牌已破产”。（AlynxZhou）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随后话题变得奇怪了起来，不再仅限于常见的 Linux 发行版。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Windows 10 用户您好！感谢您选购本公司最新发行的月饼，不过要敬告您的是，您的月饼马上就要过期了。（lilydjwg）&lt;/li&gt;
&lt;li&gt;Windows 用户的冰箱被锁死了，因为“Windows 正在等待月饼”。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;iOS 用户只能购买苹果自家的月饼，买别家月饼苹果抽成 30%。（outvi）&lt;/li&gt;
&lt;li&gt;Google 表示对于月饼生产商收取 25 美元的生产费。（AlynxZhou）除非你只吃没有馅料的 YOSP。（oldherl）&lt;/li&gt;
&lt;li&gt;Python 用户用 &lt;code&gt;pip&lt;/code&gt; 安装了一个月饼，然后发现自己安装的月饼明年就过期了。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;NodeJS 用户用 &lt;code&gt;npm&lt;/code&gt; 安装了一个月饼，然后发现整个月饼流水线出现在了自己的厨房里。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Docker 用户发现自己的月饼比别家重很多，但没什么东西，而且吃月饼需要 root。（outvi）&lt;/li&gt;
&lt;li&gt;Nintendo Switch 用户购买了月饼卡带然后由于太苦无法下咽。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Java 用户发现自己需要先安装一个月饼食用环境来食用月饼。（AlynxZhou）特别是还不知道装哪个版本。（outvi）更要命的是还区分 OpenMooncake 和 OracleMooncake。（Rocket1184）&lt;/li&gt;
&lt;li&gt;Steam 用户发现自己的月饼上多了绿色的 -40% 标签。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Epic：月饼独占一年！（KRyuJo）&lt;/li&gt;
&lt;li&gt;Go 用户把所有月饼当作一种月饼（&lt;code&gt;interface {}&lt;/code&gt;）。（Sherlock_Holo）&lt;/li&gt;
&lt;li&gt;Rust 用户表示月饼的保质期很短（离开视线就被 drop 了）。（Sherlock_Holo）Rust 家的月饼可以多人一起看着，但是吃的时候不仅只能有一个人吃，而且别人不能看。有人不信邪，使用 unsafe 魔法看到了正在吃月饼的人，然后整个世界崩塌了。（lilydjwg）&lt;/li&gt;
&lt;li&gt;systemd 用户正在策划将月饼改名为 &lt;code&gt;systemd-月饼&lt;/code&gt; 的投票。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;C++ 用户表示月饼馅还不在厨房里。（wuliao00）建议食用 &lt;code&gt;boost::月饼&lt;/code&gt;。（Rocket1184）&lt;/li&gt;
&lt;li&gt;fish 用户正在重写他们的 &lt;code&gt;/etc/profile&lt;/code&gt;，没有时间吃月饼。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;TensorFlow 用户依赖他们的 NVIDIA GPU 来识别月饼皮上的文字。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;C# 用户的月饼做起来像 Java，吃起来像 Java，区别则是用户嘴里一直喊“我们的月饼比java好，而且终于开源了（一部分）！”。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;Vala 用户发现自己的月饼是 GLib 承包给 C 牌月饼的贴牌产品。（AlynxZhou）&lt;/li&gt;
&lt;li&gt;C 用戶不仅要自己制作月饼，还要在月饼制作过程中关注加工机器的操作问题，例如如何防止月饼馅料溢出。更重要的是这些操作都是纯手动完成的。（wnereiz）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    
    <category term="月饼" label="月饼" scheme="https://sh.alynx.one/tags/%E6%9C%88%E9%A5%BC/" />
    
  </entry>
  
  
  
  <entry>
    <title>可能只适合我自己的 RIME 配置</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/My-RIME/" />
    <id>https://sh.alynx.one/posts/My-RIME/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-08-19T07:16:00.000Z</published>
    
    
    <updated>2021-07-23T11:05:05.000Z</updated>
    
    
    <summary type="html">
      &lt;h1 id=&quot;为什么我要折腾这个&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E6%8A%98%E8%85%BE%E8%BF%99%E4%B8%AA&quot; title=&quot;为什么我要折腾这个&quot;&gt;&lt;/a&gt;为什么我要折腾这个&lt;/h1&gt;
&lt;p&gt;在第 n 次忍受不了 RIME 的奇怪操作逻辑之后，我终于决定彻底教育一下这个不听话的输入法，考虑到已经有 n - 1 次失败的前提，做这个决定并不容易。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;h1 id=&quot;为什么我要折腾这个&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91%E8%A6%81%E6%8A%98%E8%85%BE%E8%BF%99%E4%B8%AA&quot; title=&quot;为什么我要折腾这个&quot;&gt;&lt;/a&gt;为什么我要折腾这个&lt;/h1&gt;
&lt;p&gt;在第 n 次忍受不了 RIME 的奇怪操作逻辑之后，我终于决定彻底教育一下这个不听话的输入法，考虑到已经有 n - 1 次失败的前提，做这个决定并不容易。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;首先说明我是 Linux 用户，使用 ibus-rime 做输入引擎，所以使用什么小狼毫鼠须管或者 fcitx-rime 的如果发现不好用最好别烦我，那些我都没用过。（不好意思因为配置这玩意有点暴躁。）&lt;/p&gt;
&lt;p&gt;然后我要吐槽一下 RIME 的文档，完全没有一致的类似 API 手册的东西，而且全繁体加上佛振独特的说话风格读起来真的很累，然后这个项目习惯又是起一大堆奇奇怪怪的名字（虽然我有时候也这样）。假如你想修改一点配置，读了文档里的示例“我懂了，巴拉巴拉”，打开配置一看一堆乱七八糟的就懵了。&lt;/p&gt;
&lt;p&gt;然后就是网上“致第一次用 RIME 的你”、“也致第一次用 RIME 的你”，我都看过了，首先他们不用 ibus-rime，其次文章内容毕竟有限，每个人需求不一样，有些我需要的地方他们一笔带过了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2021-07-23）：另外我是被 felixonmars 惯坏了的 Arch Linux 用户，他已经把各种乱七八糟的 RIME 的配置打包到官方仓库了，所以我不需要和那个什么用来配置 RIME 配置的什么什么东风破打交道。如果你不是 Arch Linux 用户的话，我假设你有能力搞明白那个东风破，&lt;strong&gt;因为我搞不明白&lt;/strong&gt;，没办法告诉你怎么用。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;RIME 的拼音功能确实很好用（虽然有时候它和我对于词组的想法不太一样），我的需求其实只有几项：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一些 RIME 默认的中国人几乎都用不到的中文标点直接改成英文标点，这个在书写 Markdown 的时候简直折磨死我了，有几个人会输入全角井号？？？打个标题真的很麻烦。&lt;/li&gt;
&lt;li&gt;有些符号键在其他输入法里约定俗成的就直接输出特定的中文符号，RIME 的默认操作是弹出选择菜单，完全没这个必要，弹出菜单还需要二次选择而且打断了我的按键操作，需要英文标点时候直接切为英文就好了。&lt;/li&gt;
&lt;li&gt;关掉 RIME 的中英混输功能，在候选框输入英文字母真的很打断思路，我要输入英文要么就是打代码要么就是打单词，反正都不需要输入法，RIME 来就是给我找麻烦。&lt;/li&gt;
&lt;li&gt;还有一些奇奇怪怪的 RIME 的键位设置，偏偏要和其他输入法不一样，我已经习惯了那些操作，RIME 的键位只会降低输入速度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面介绍一下我的配置。当然如果你嫌麻烦，最后我会加上我的配置的 GitHub Repo。&lt;/p&gt;
&lt;p&gt;首先建立一个干净的 RIME 配置环境，直接移走 &lt;code&gt;~/.config/ibus/rime&lt;/code&gt; 然后执行 &lt;code&gt;ibus-daemon -rdx&lt;/code&gt; 重新生成（就是它文档里扯的部署部署部署）一套配置，由于我用的都是内置输入法所以也不需要什么乱七八糟的东风破 RIME Kit 地球拼音之类的。&lt;/p&gt;
&lt;p&gt;然后你进去 &lt;code&gt;~/.config/ibus/rime&lt;/code&gt; 新版大概有以下几个东西：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;目录 &lt;code&gt;build&lt;/code&gt;：&lt;del&gt;里面放了各种 RIME 的默认配置，我们不需要动这个。&lt;/del&gt; 很好，我搞错了，原来它是从 &lt;code&gt;/usr/share/rime-data/&lt;/code&gt; 和 &lt;code&gt;~/.config/ibus/rime/&lt;/code&gt; 下面加载不带 custom 的文件，然后再读取 custom 文件给之前的文件打 patch，最后生成到 &lt;code&gt;build&lt;/code&gt; 目录下面。&lt;/li&gt;
&lt;li&gt;目录 &lt;code&gt;luna_pinyin.userdb&lt;/code&gt;：看起来像是朙月拼音的词库，当然也不用修改。&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;installation.yaml&lt;/code&gt;：我猜不用管。&lt;/li&gt;
&lt;li&gt;文件 &lt;code&gt;user.yaml&lt;/code&gt;：我猜也不用管。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;各种乱七八糟操作逻辑的配置&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E5%90%84%E7%A7%8D%E4%B9%B1%E4%B8%83%E5%85%AB%E7%B3%9F%E6%93%8D%E4%BD%9C%E9%80%BB%E8%BE%91%E7%9A%84%E9%85%8D%E7%BD%AE&quot; title=&quot;各种乱七八糟操作逻辑的配置&quot;&gt;&lt;/a&gt;各种乱七八糟操作逻辑的配置&lt;/h1&gt;
&lt;p&gt;按照 RIME 打 patch 的配置方式我们需要在这个目录下创建一个叫 &lt;code&gt;default.custom.yaml&lt;/code&gt; 的文件，这样就可以给 &lt;code&gt;/usr/share/rime-data/default.yaml&lt;/code&gt; 这个文件 patch 辣，当然你得先会写 YAML。第一行首先写个叫 &lt;code&gt;patch:&lt;/code&gt; 的 key，RIME 要求这样，所有的自定义配置都是在 &lt;code&gt;patch&lt;/code&gt; 字段下面。&lt;/p&gt;
&lt;p&gt;怎么确定要修改的 key 名字呢？&lt;del&gt;我这里的都是在 &lt;code&gt;build/default.yaml&lt;/code&gt; 下面找到的，&lt;/del&gt; 因为 patch 的是 &lt;code&gt;/usr/share/rime-data/default.yaml&lt;/code&gt; 所以就去看这个辣，之前又写错了，那个其实是生成的文件。你也可以试试其他的 YAML 文件。&lt;/p&gt;
&lt;p&gt;RIME 的文档说什么要用 &lt;code&gt;/&lt;/code&gt; 把不同层次的 key 折叠成一个比如 &lt;code&gt;ascii_composer/switch_key&lt;/code&gt;，&lt;del&gt;亲测无所谓，我就爱展开了写完整的 YAML，这样更规范。&lt;/del&gt; 我说佛老师对不起对不起，我不懂规矩。a/b/c 是只 patch c，展开了则变成了 patch a。&lt;/p&gt;
&lt;p&gt;然后首先第一步我要修改输入法列表，我只用朙月拼音简化字模式就行了：&lt;/p&gt;
&lt;figure data-raw=&quot;patch:
  schema_list:
    - schema: &amp;quot;luna_pinyin_simp&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;patch:
  schema_list:
    - schema: &quot;luna_pinyin_simp&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后就是改掉那个自作聪明的英文输入模式：&lt;/p&gt;
&lt;figure data-raw=&quot;  # 按 CapsLock 输出大写英文字母。
  ascii_composer/good_old_caps_lock: true
  # `inline_ascii` 在输入框内插入英文。
  # `commit_text` 候选文字上屏并切换至英文。
  # `commit_code` 输入拼音上屏并切换至英文。
  # `clear` 清除拼音并切换至英文。
  # `noop` 屏蔽此按键。
  # 如果你设置 `Caps_Lock` 为 `noop`，
  # 一个奇怪的问题是退格键不能用了，除非取消大写锁定。
  # 所以我直接设置文字上屏了。
  ascii_composer/switch_key/Caps_Lock: &amp;quot;commit_text&amp;quot;
  ascii_composer/switch_key/Shift_L: &amp;quot;commit_code&amp;quot;
  ascii_composer/switch_key/Shift_R: &amp;quot;commit_code&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  # 按 CapsLock 输出大写英文字母。
  ascii_composer/good_old_caps_lock: true
  # `inline_ascii` 在输入框内插入英文。
  # `commit_text` 候选文字上屏并切换至英文。
  # `commit_code` 输入拼音上屏并切换至英文。
  # `clear` 清除拼音并切换至英文。
  # `noop` 屏蔽此按键。
  # 如果你设置 `Caps_Lock` 为 `noop`，
  # 一个奇怪的问题是退格键不能用了，除非取消大写锁定。
  # 所以我直接设置文字上屏了。
  ascii_composer/switch_key/Caps_Lock: &quot;commit_text&quot;
  ascii_composer/switch_key/Shift_L: &quot;commit_code&quot;
  ascii_composer/switch_key/Shift_R: &quot;commit_code&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;大部分坑我都写在注释里了可以自己看。&lt;/p&gt;
&lt;p&gt;然后我看那个设置选单也不是很爽，我习惯简体字，这个也可以自己改：&lt;/p&gt;
&lt;figure data-raw=&quot;  # 改掉原来的繁体字标题。
  switcher/caption: &amp;quot;【设置菜单】&amp;quot;
  # 用半角斜线而不是奇丑无比的全角斜线做分隔符。
  switcher/option_list_separator: &amp;quot;/&amp;quot;
  # 屏蔽 Ctrl-s 开启菜单，只允许 Ctrl-` 和 F4。
  switcher/hotkeys:
    # - &amp;quot;Control+s&amp;quot;
    - &amp;quot;Control+grave&amp;quot;
    - &amp;quot;F4&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  # 改掉原来的繁体字标题。
  switcher/caption: &quot;【设置菜单】&quot;
  # 用半角斜线而不是奇丑无比的全角斜线做分隔符。
  switcher/option_list_separator: &quot;/&quot;
  # 屏蔽 Ctrl-s 开启菜单，只允许 Ctrl-` 和 F4。
  switcher/hotkeys:
    # - &quot;Control+s&quot;
    - &quot;Control+grave&quot;
    - &quot;F4&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后就是改掉它奇怪的键位，Emacs 键位挺好的，但是有几个不知道为什么用不了，再者就是为什么按向左是跳一个字拼音向右是跳一个字母？&lt;/p&gt;
&lt;figure data-raw=&quot;# 这里修改的是整个输入法全局的键位，某些输入方案有自己的键位可以单独覆盖。
# 但我暂时不需要。
# Emacs 键位，我喜欢。
# 可是谁给我解释一下为什么 Left 是按字拼音跳而 Right 是按字母跳？
key_binder/bindings:
  - accept: &amp;quot;Control+p&amp;quot;
    send: &amp;quot;Up&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+n&amp;quot;
    send: &amp;quot;Down&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+b&amp;quot;
    send: &amp;quot;Left&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+f&amp;quot;
    send: &amp;quot;Right&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Alt+b&amp;quot;
    send: &amp;quot;Shift+Left&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Alt+f&amp;quot;
    send: &amp;quot;Shift+Right&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+a&amp;quot;
    send: &amp;quot;Home&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+e&amp;quot;
    send: &amp;quot;End&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+d&amp;quot;
    send: &amp;quot;Delete&amp;quot;
    when: &amp;quot;composing&amp;quot;
  # 这个用不了，不过估计也用不到。
  # - accept: &amp;quot;Control+k&amp;quot;
  #   send: &amp;quot;Shift+Delete&amp;quot;
  #   when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+h&amp;quot;
    send: &amp;quot;BackSpace&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Alt+h&amp;quot;
    send: &amp;quot;Shift+BackSpace&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+g&amp;quot;
    send: &amp;quot;Escape&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+bracketleft&amp;quot;
    send: &amp;quot;Escape&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Alt+v&amp;quot;
    send: &amp;quot;Page_Up&amp;quot;
    when: &amp;quot;composing&amp;quot;
  - accept: &amp;quot;Control+v&amp;quot;
    send: &amp;quot;Page_Down&amp;quot;
    when: &amp;quot;composing&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 这里修改的是整个输入法全局的键位，某些输入方案有自己的键位可以单独覆盖。
# 但我暂时不需要。
# Emacs 键位，我喜欢。
# 可是谁给我解释一下为什么 Left 是按字拼音跳而 Right 是按字母跳？
key_binder/bindings:
  - accept: &quot;Control+p&quot;
    send: &quot;Up&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+n&quot;
    send: &quot;Down&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+b&quot;
    send: &quot;Left&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+f&quot;
    send: &quot;Right&quot;
    when: &quot;composing&quot;
  - accept: &quot;Alt+b&quot;
    send: &quot;Shift+Left&quot;
    when: &quot;composing&quot;
  - accept: &quot;Alt+f&quot;
    send: &quot;Shift+Right&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+a&quot;
    send: &quot;Home&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+e&quot;
    send: &quot;End&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+d&quot;
    send: &quot;Delete&quot;
    when: &quot;composing&quot;
  # 这个用不了，不过估计也用不到。
  # - accept: &quot;Control+k&quot;
  #   send: &quot;Shift+Delete&quot;
  #   when: &quot;composing&quot;
  - accept: &quot;Control+h&quot;
    send: &quot;BackSpace&quot;
    when: &quot;composing&quot;
  - accept: &quot;Alt+h&quot;
    send: &quot;Shift+BackSpace&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+g&quot;
    send: &quot;Escape&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+bracketleft&quot;
    send: &quot;Escape&quot;
    when: &quot;composing&quot;
  - accept: &quot;Alt+v&quot;
    send: &quot;Page_Up&quot;
    when: &quot;composing&quot;
  - accept: &quot;Control+v&quot;
    send: &quot;Page_Down&quot;
    when: &quot;composing&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;还没完，我觉得正常人不会用 Tab 在拼音之间切换，除非你一次输入一句话（那你不觉得候选框太小了看着累吗？？？），设置 Tab 为跳候选词更自然一点，但我也不知道为什么 Shift-Tab 用不了：&lt;/p&gt;
&lt;figure data-raw=&quot;      # 正常人不会用 Tab 切换拼音光标的，相信我。用它切换选项更快。
      # - accept: &amp;quot;ISO_Left_Tab&amp;quot;
      #   send: &amp;quot;Shift+Left&amp;quot;
      #   when: &amp;quot;composing&amp;quot;
      # - accept: &amp;quot;Shift+Tab&amp;quot;
      #   send: &amp;quot;Shift+Left&amp;quot;
      #   when: &amp;quot;composing&amp;quot;
      # - accept: &amp;quot;Tab&amp;quot;
      #   send: &amp;quot;Shift+Right&amp;quot;
      #   when: &amp;quot;composing&amp;quot;
      - accept: &amp;quot;Tab&amp;quot;
        send: &amp;quot;Down&amp;quot;
        when: &amp;quot;has_menu&amp;quot;
      - accept: &amp;quot;ISO_Left_Tab&amp;quot;
        send: &amp;quot;Up&amp;quot;
        when: &amp;quot;has_menu&amp;quot;
      # 鬼知道为什么这个也用不了！
      - accept: &amp;quot;Shift+Tab&amp;quot;
        send: &amp;quot;Up&amp;quot;
        when: &amp;quot;has_menu&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;      # 正常人不会用 Tab 切换拼音光标的，相信我。用它切换选项更快。
      # - accept: &quot;ISO_Left_Tab&quot;
      #   send: &quot;Shift+Left&quot;
      #   when: &quot;composing&quot;
      # - accept: &quot;Shift+Tab&quot;
      #   send: &quot;Shift+Left&quot;
      #   when: &quot;composing&quot;
      # - accept: &quot;Tab&quot;
      #   send: &quot;Shift+Right&quot;
      #   when: &quot;composing&quot;
      - accept: &quot;Tab&quot;
        send: &quot;Down&quot;
        when: &quot;has_menu&quot;
      - accept: &quot;ISO_Left_Tab&quot;
        send: &quot;Up&quot;
        when: &quot;has_menu&quot;
      # 鬼知道为什么这个也用不了！
      - accept: &quot;Shift+Tab&quot;
        send: &quot;Up&quot;
        when: &quot;has_menu&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;以及我觉得正常人不用逗号和句号翻页，毕竟下面的默认设置是逗号句号直接上屏，你设置了翻页也没啥卵用，反正我用减号等号或者上下，不过方括号也不错就是了：&lt;/p&gt;
&lt;figure data-raw=&quot;  # 这里修改的是整个输入法全局的键位，某些输入方案有自己的键位可以单独覆盖。
  # 但我暂时不需要。
  # Emacs 键位，我喜欢。
  # 可是谁给我解释一下为什么 Left 是按字拼音跳而 Right 是按字母跳？
  key_binder/bindings:
    - accept: &amp;quot;Control+p&amp;quot;
      send: &amp;quot;Up&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+n&amp;quot;
      send: &amp;quot;Down&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+b&amp;quot;
      send: &amp;quot;Left&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+f&amp;quot;
      send: &amp;quot;Right&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Alt+b&amp;quot;
      send: &amp;quot;Shift+Left&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Alt+f&amp;quot;
      send: &amp;quot;Shift+Right&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+a&amp;quot;
      send: &amp;quot;Home&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+e&amp;quot;
      send: &amp;quot;End&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+d&amp;quot;
      send: &amp;quot;Delete&amp;quot;
      when: &amp;quot;composing&amp;quot;
    # 这个用不了，不过估计也用不到。
    # - accept: &amp;quot;Control+k&amp;quot;
    #   send: &amp;quot;Shift+Delete&amp;quot;
    #   when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+h&amp;quot;
      send: &amp;quot;BackSpace&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Alt+h&amp;quot;
      send: &amp;quot;Shift+BackSpace&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+g&amp;quot;
      send: &amp;quot;Escape&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+bracketleft&amp;quot;
      send: &amp;quot;Escape&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Alt+v&amp;quot;
      send: &amp;quot;Page_Up&amp;quot;
      when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Control+v&amp;quot;
      send: &amp;quot;Page_Down&amp;quot;
      when: &amp;quot;composing&amp;quot;
    # 正常人不会用 Tab 切换拼音光标的，相信我。用它切换选项更快。
    # - accept: &amp;quot;ISO_Left_Tab&amp;quot;
    #   send: &amp;quot;Shift+Left&amp;quot;
    #   when: &amp;quot;composing&amp;quot;
    # - accept: &amp;quot;Shift+Tab&amp;quot;
    #   send: &amp;quot;Shift+Left&amp;quot;
    #   when: &amp;quot;composing&amp;quot;
    # - accept: &amp;quot;Tab&amp;quot;
    #   send: &amp;quot;Shift+Right&amp;quot;
    #   when: &amp;quot;composing&amp;quot;
    - accept: &amp;quot;Tab&amp;quot;
      send: &amp;quot;Down&amp;quot;
      when: &amp;quot;has_menu&amp;quot;
    - accept: &amp;quot;ISO_Left_Tab&amp;quot;
      send: &amp;quot;Up&amp;quot;
      when: &amp;quot;has_menu&amp;quot;
    # 鬼知道为什么这个也用不了！
    - accept: &amp;quot;Shift+Tab&amp;quot;
      send: &amp;quot;Up&amp;quot;
      when: &amp;quot;has_menu&amp;quot;
    - accept: &amp;quot;minus&amp;quot;
      send: &amp;quot;Page_Up&amp;quot;
      when: &amp;quot;has_menu&amp;quot;
    - accept: &amp;quot;equal&amp;quot;
      send: &amp;quot;Page_Down&amp;quot;
      when: &amp;quot;has_menu&amp;quot;
    - accept: &amp;quot;bracketleft&amp;quot;
      send: &amp;quot;Page_Up&amp;quot;
      when: &amp;quot;has_menu&amp;quot;
    - accept: &amp;quot;bracketright&amp;quot;
      send: &amp;quot;Page_Down&amp;quot;
      when: &amp;quot;has_menu&amp;quot;
    # 我觉得正常人不应该用逗号和句号翻页。
    # - accept: &amp;quot;comma&amp;quot;
    #   send: &amp;quot;Page_Up&amp;quot;
    #   when: &amp;quot;paging&amp;quot;
    # - accept: &amp;quot;period&amp;quot;
    #   send: &amp;quot;Page_Down&amp;quot;
    #   when: &amp;quot;has_menu&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  # 这里修改的是整个输入法全局的键位，某些输入方案有自己的键位可以单独覆盖。
  # 但我暂时不需要。
  # Emacs 键位，我喜欢。
  # 可是谁给我解释一下为什么 Left 是按字拼音跳而 Right 是按字母跳？
  key_binder/bindings:
    - accept: &quot;Control+p&quot;
      send: &quot;Up&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+n&quot;
      send: &quot;Down&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+b&quot;
      send: &quot;Left&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+f&quot;
      send: &quot;Right&quot;
      when: &quot;composing&quot;
    - accept: &quot;Alt+b&quot;
      send: &quot;Shift+Left&quot;
      when: &quot;composing&quot;
    - accept: &quot;Alt+f&quot;
      send: &quot;Shift+Right&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+a&quot;
      send: &quot;Home&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+e&quot;
      send: &quot;End&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+d&quot;
      send: &quot;Delete&quot;
      when: &quot;composing&quot;
    # 这个用不了，不过估计也用不到。
    # - accept: &quot;Control+k&quot;
    #   send: &quot;Shift+Delete&quot;
    #   when: &quot;composing&quot;
    - accept: &quot;Control+h&quot;
      send: &quot;BackSpace&quot;
      when: &quot;composing&quot;
    - accept: &quot;Alt+h&quot;
      send: &quot;Shift+BackSpace&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+g&quot;
      send: &quot;Escape&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+bracketleft&quot;
      send: &quot;Escape&quot;
      when: &quot;composing&quot;
    - accept: &quot;Alt+v&quot;
      send: &quot;Page_Up&quot;
      when: &quot;composing&quot;
    - accept: &quot;Control+v&quot;
      send: &quot;Page_Down&quot;
      when: &quot;composing&quot;
    # 正常人不会用 Tab 切换拼音光标的，相信我。用它切换选项更快。
    # - accept: &quot;ISO_Left_Tab&quot;
    #   send: &quot;Shift+Left&quot;
    #   when: &quot;composing&quot;
    # - accept: &quot;Shift+Tab&quot;
    #   send: &quot;Shift+Left&quot;
    #   when: &quot;composing&quot;
    # - accept: &quot;Tab&quot;
    #   send: &quot;Shift+Right&quot;
    #   when: &quot;composing&quot;
    - accept: &quot;Tab&quot;
      send: &quot;Down&quot;
      when: &quot;has_menu&quot;
    - accept: &quot;ISO_Left_Tab&quot;
      send: &quot;Up&quot;
      when: &quot;has_menu&quot;
    # 鬼知道为什么这个也用不了！
    - accept: &quot;Shift+Tab&quot;
      send: &quot;Up&quot;
      when: &quot;has_menu&quot;
    - accept: &quot;minus&quot;
      send: &quot;Page_Up&quot;
      when: &quot;has_menu&quot;
    - accept: &quot;equal&quot;
      send: &quot;Page_Down&quot;
      when: &quot;has_menu&quot;
    - accept: &quot;bracketleft&quot;
      send: &quot;Page_Up&quot;
      when: &quot;has_menu&quot;
    - accept: &quot;bracketright&quot;
      send: &quot;Page_Down&quot;
      when: &quot;has_menu&quot;
    # 我觉得正常人不应该用逗号和句号翻页。
    # - accept: &quot;comma&quot;
    #   send: &quot;Page_Up&quot;
    #   when: &quot;paging&quot;
    # - accept: &quot;period&quot;
    #   send: &quot;Page_Down&quot;
    #   when: &quot;has_menu&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;最后就是那一堆乱七八糟的快捷键了，鬼才记得住，有那时间直接翻菜单就行了，那个 Shift+Space 就是我动不动就变成全角的罪魁祸首，全部不要：&lt;/p&gt;
&lt;figure data-raw=&quot;    # 鬼才记得住这么多乱七八糟的快捷键，我翻菜单比背这玩意快多了。
    # - accept: &amp;quot;Control+Shift+1&amp;quot;
    #   select: &amp;quot;.next&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+2&amp;quot;
    #   toggle: &amp;quot;ascii_mode&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+3&amp;quot;
    #   toggle: &amp;quot;full_shape&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+4&amp;quot;
    #   toggle: simplification
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+5&amp;quot;
    #   toggle: &amp;quot;extended_charset&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+exclam&amp;quot;
    #   select: &amp;quot;&amp;quot;.next&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+at&amp;quot;
    #   toggle: &amp;quot;ascii_mode&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+numbersign&amp;quot;
    #   toggle: &amp;quot;full_shape&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+dollar&amp;quot;
    #   toggle: &amp;quot;simplification&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+Shift+percent&amp;quot;
    #   toggle: &amp;quot;extended_charset&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # 你就是那个经常害我变成全角的罪魁祸首！
    # - accept: &amp;quot;Shift+space&amp;quot;
    #   toggle: &amp;quot;full_shape&amp;quot;
    #   when: &amp;quot;always&amp;quot;
    # - accept: &amp;quot;Control+period&amp;quot;
    #   toggle: &amp;quot;ascii_punct&amp;quot;
    #   when: &amp;quot;always&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;    # 鬼才记得住这么多乱七八糟的快捷键，我翻菜单比背这玩意快多了。
    # - accept: &quot;Control+Shift+1&quot;
    #   select: &quot;.next&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+2&quot;
    #   toggle: &quot;ascii_mode&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+3&quot;
    #   toggle: &quot;full_shape&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+4&quot;
    #   toggle: simplification
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+5&quot;
    #   toggle: &quot;extended_charset&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+exclam&quot;
    #   select: &quot;&quot;.next&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+at&quot;
    #   toggle: &quot;ascii_mode&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+numbersign&quot;
    #   toggle: &quot;full_shape&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+dollar&quot;
    #   toggle: &quot;simplification&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+Shift+percent&quot;
    #   toggle: &quot;extended_charset&quot;
    #   when: &quot;always&quot;
    # 你就是那个经常害我变成全角的罪魁祸首！
    # - accept: &quot;Shift+space&quot;
    #   toggle: &quot;full_shape&quot;
    #   when: &quot;always&quot;
    # - accept: &quot;Control+period&quot;
    #   toggle: &quot;ascii_punct&quot;
    #   when: &quot;always&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我自己是不习惯写 inline 的字典和列表，都写的展开的。&lt;/p&gt;
&lt;p&gt;然后是符号设置了，一开始我以为改 default 里面的符号表就行了，但是最近（2021-03-01）发现不行了，翻了一下代码，发现朙月拼音现在不读 default 了，而是加载 symbols 里面的。然后文档建议的是在输入法方案里面添加自定义的符号表，所以需要建立 &lt;code&gt;luna_pinyin_simp.custom.yaml&lt;/code&gt; 并修改。&lt;/p&gt;
&lt;p&gt;因为我们上面取消了逗号句号翻页，所以这里也就不用显式写 commit 直接上屏了。然后我去掉了一大堆菜单，我输入井号星号波浪线百分号就是想要英文标点，你给我弹个菜单我还得多确认好麻烦的。以及我觉得真的没人用那个巨长的全角斜杠，输入斜杠就是为了斜杠，什么通过朙月拼音命令输入假名有意义吗？我为什么不直接切日语输入法呢？另一些标点在中文语境下直接输出中文标点就好了，需要英文标点时候我敲一下 Shift 比看菜单选容易多了！比如书名号，竖线输出人名中间的点，反斜杠输出顿号之类的。&lt;/p&gt;
&lt;p&gt;由于我不是金融行业的，我就把一些英文标点常见但对应中文标点也可能会用到的都丢到了 &lt;code&gt;$&lt;/code&gt; 的菜单里面：&lt;/p&gt;
&lt;figure data-raw=&quot;patch:
  # 现在朙月拼音加载标点候选是加载 symbols 里面的，根本不加载 default。
  # 然后文档建议的是自己修改的标点符号表放在输入法方案配置里面。
  # 为了方便编写 Markdown，把一些奇怪的写中文根本用不到的符号弹出菜单改成直接输出英文符号。
  # 另一些直接默认输出中文符号，需要英文符号可以切换英文输入。
  # 有关 `&amp;quot;!&amp;quot;: {commit: &amp;quot;！&amp;quot;}` 的写法含义是你设置这个键为翻页按键了，
  # 但是你又想在输入拼音出现选单之后输入这个按键直接上屏（常见的逗号句号问号叹号），
  # 我觉得这是多此一举，为什么你非要拿这几个符号翻页？反正我不用。
  # 乱七八糟的符号都塞给 `$` 就好了反正我不是会计不用天天输入 `￥`。
  # 我不会使用全角英文的，我觉得其他程序员也不会。
  # 但是中文的标点又是全角的，所以我就只改半角。
  punctuator/half_shape:
    &amp;quot;!&amp;quot;: &amp;quot;！&amp;quot;
    &amp;quot;\&amp;quot;&amp;quot;:
      pair:
        - &amp;quot;“&amp;quot;
        - &amp;quot;”&amp;quot;
    &amp;quot;#&amp;quot;: &amp;quot;#&amp;quot;
    &amp;quot;$&amp;quot;:
      - &amp;quot;￥&amp;quot;
      - &amp;quot;$&amp;quot;
      - &amp;quot;€&amp;quot;
      - &amp;quot;～&amp;quot;
      - &amp;quot;×&amp;quot;
      - &amp;quot;÷&amp;quot;
      - &amp;quot;°&amp;quot;
      - &amp;quot;℃&amp;quot;
      - &amp;quot;‰&amp;quot;
      - &amp;quot;‱&amp;quot;
      - &amp;quot;℉&amp;quot;
      - &amp;quot;©&amp;quot;
      - &amp;quot;®&amp;quot;
    &amp;quot;%&amp;quot;: &amp;quot;%&amp;quot;
    &amp;quot;&amp;amp;&amp;quot;: &amp;quot;&amp;amp;&amp;quot;
    &amp;quot;&#039;&amp;quot;:
      pair:
        - &amp;quot;‘&amp;quot;
        - &amp;quot;’&amp;quot;
    &amp;quot;*&amp;quot;: &amp;quot;*&amp;quot;
    &amp;quot;+&amp;quot;: &amp;quot;+&amp;quot;
    &amp;quot;,&amp;quot;: &amp;quot;，&amp;quot;
    &amp;quot;-&amp;quot;: &amp;quot;-&amp;quot;
    &amp;quot;.&amp;quot;: &amp;quot;。&amp;quot;
    &amp;quot;/&amp;quot;: &amp;quot;/&amp;quot;
    &amp;quot;\\&amp;quot;: &amp;quot;、&amp;quot;
    &amp;quot;:&amp;quot;: &amp;quot;：&amp;quot;
    &amp;quot;;&amp;quot;: &amp;quot;；&amp;quot;
    &amp;quot;=&amp;quot;: &amp;quot;=&amp;quot;
    &amp;quot;?&amp;quot;: &amp;quot;？&amp;quot;
    &amp;quot;@&amp;quot;: &amp;quot;@&amp;quot;
    &amp;quot;(&amp;quot;: &amp;quot;（&amp;quot;
    &amp;quot;)&amp;quot;: &amp;quot;）&amp;quot;
    &amp;quot;[&amp;quot;: &amp;quot;【&amp;quot;
    &amp;quot;]&amp;quot;: &amp;quot;】&amp;quot;
    &amp;quot;{&amp;quot;: &amp;quot;「&amp;quot;
    &amp;quot;}&amp;quot;: &amp;quot;」&amp;quot;
    &amp;quot;&lt;&amp;quot;: &amp;quot;《&amp;quot;
    &amp;quot;&gt;&amp;quot;: &amp;quot;》&amp;quot;
    &amp;quot;^&amp;quot;: &amp;quot;……&amp;quot;
    &amp;quot;_&amp;quot;: &amp;quot;——&amp;quot;
    &amp;quot;`&amp;quot;: &amp;quot;`&amp;quot;
    &amp;quot;|&amp;quot;: &amp;quot;·&amp;quot;
    &amp;quot;~&amp;quot;: &amp;quot;~&amp;quot;&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;patch:
  # 现在朙月拼音加载标点候选是加载 symbols 里面的，根本不加载 default。
  # 然后文档建议的是自己修改的标点符号表放在输入法方案配置里面。
  # 为了方便编写 Markdown，把一些奇怪的写中文根本用不到的符号弹出菜单改成直接输出英文符号。
  # 另一些直接默认输出中文符号，需要英文符号可以切换英文输入。
  # 有关 `&quot;!&quot;: {commit: &quot;！&quot;}` 的写法含义是你设置这个键为翻页按键了，
  # 但是你又想在输入拼音出现选单之后输入这个按键直接上屏（常见的逗号句号问号叹号），
  # 我觉得这是多此一举，为什么你非要拿这几个符号翻页？反正我不用。
  # 乱七八糟的符号都塞给 `$` 就好了反正我不是会计不用天天输入 `￥`。
  # 我不会使用全角英文的，我觉得其他程序员也不会。
  # 但是中文的标点又是全角的，所以我就只改半角。
  punctuator/half_shape:
    &quot;!&quot;: &quot;！&quot;
    &quot;\&quot;&quot;:
      pair:
        - &quot;“&quot;
        - &quot;”&quot;
    &quot;#&quot;: &quot;#&quot;
    &quot;$&quot;:
      - &quot;￥&quot;
      - &quot;$&quot;
      - &quot;€&quot;
      - &quot;～&quot;
      - &quot;×&quot;
      - &quot;÷&quot;
      - &quot;°&quot;
      - &quot;℃&quot;
      - &quot;‰&quot;
      - &quot;‱&quot;
      - &quot;℉&quot;
      - &quot;©&quot;
      - &quot;®&quot;
    &quot;%&quot;: &quot;%&quot;
    &quot;&amp;amp;&quot;: &quot;&amp;amp;&quot;
    &quot;&#039;&quot;:
      pair:
        - &quot;‘&quot;
        - &quot;’&quot;
    &quot;*&quot;: &quot;*&quot;
    &quot;+&quot;: &quot;+&quot;
    &quot;,&quot;: &quot;，&quot;
    &quot;-&quot;: &quot;-&quot;
    &quot;.&quot;: &quot;。&quot;
    &quot;/&quot;: &quot;/&quot;
    &quot;\\&quot;: &quot;、&quot;
    &quot;:&quot;: &quot;：&quot;
    &quot;;&quot;: &quot;；&quot;
    &quot;=&quot;: &quot;=&quot;
    &quot;?&quot;: &quot;？&quot;
    &quot;@&quot;: &quot;@&quot;
    &quot;(&quot;: &quot;（&quot;
    &quot;)&quot;: &quot;）&quot;
    &quot;[&quot;: &quot;【&quot;
    &quot;]&quot;: &quot;】&quot;
    &quot;{&quot;: &quot;「&quot;
    &quot;}&quot;: &quot;」&quot;
    &quot;&amp;lt;&quot;: &quot;《&quot;
    &quot;&amp;gt;&quot;: &quot;》&quot;
    &quot;^&quot;: &quot;……&quot;
    &quot;_&quot;: &quot;——&quot;
    &quot;`&quot;: &quot;`&quot;
    &quot;|&quot;: &quot;·&quot;
    &quot;~&quot;: &quot;~&quot;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;最近的朙月拼音添加了反查笔画的功能，按下反引号并输入候选字来启动，但是反引号对于写 Markdown 的人很常用，所以我要关掉这个恼人的功能：&lt;/p&gt;
&lt;figure data-raw=&quot;  # 反查占据了宝贵的反引号，导致 Markdown 用户非常痛苦，所以关掉。
  recognizer/patterns/reverse_lookup:&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  # 反查占据了宝贵的反引号，导致 Markdown 用户非常痛苦，所以关掉。
  recognizer/patterns/reverse_lookup:&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;总之写完这些配置 &lt;strong&gt;之后要手动移除 &lt;code&gt;~/.config/ibus/rime/build/&lt;/code&gt; 这个生成目录&lt;/strong&gt; 再执行 &lt;code&gt;ibus-daemon -rdx&lt;/code&gt; 就可以应用了，现在 RIME 用起来就更让我愉快了，接下来就是慢慢养词库就行了。&lt;/p&gt;
&lt;h1 id=&quot;有关为什么ibus-rime总是竖着的&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E6%9C%89%E5%85%B3%E4%B8%BA%E4%BB%80%E4%B9%88ibus-rime%E6%80%BB%E6%98%AF%E7%AB%96%E7%9D%80%E7%9A%84&quot; title=&quot;有关为什么ibus-rime总是竖着的&quot;&gt;&lt;/a&gt;有关为什么 ibus-rime 总是竖着的&lt;/h1&gt;
&lt;p&gt;ibus-rime 是读取 rime 配置而不是 ibus 配置来设置横竖这一点本身就很离谱了，然后由于 bug 啦其他奇奇怪怪的原因啦好像很难搞清楚，我最近终于搞清楚啦！其实也不是很麻烦。&lt;/p&gt;
&lt;p&gt;ibus-rime 会读一个叫做 &lt;code&gt;ibus_rime.yaml&lt;/code&gt; 的配置文件，有这么一个配置可以让他变成横着的：&lt;/p&gt;
&lt;figure data-raw=&quot;style:
  horizontal: true&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;style:
  horizontal: true&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;可能看了之前的你会和我一样想那就打个 patch 到 &lt;code&gt;ibus_rime.custom.yaml&lt;/code&gt; 不就行了嘛！但是不行，为什么呢？因为不管是 rime 还是 librime 还是 ibus-rime 都没有提供 &lt;code&gt;/usr/share/rime-data/ibus_rime.yaml&lt;/code&gt; 的文件，所以你的 patch 找不到被打的文件，那就不会被生成到 &lt;code&gt;build&lt;/code&gt; 目录里。&lt;/p&gt;
&lt;p&gt;不要忘了之前说 rime 会读取 &lt;code&gt;~/.config/ibus/rime/&lt;/code&gt; 下面的 yaml，所以其实只要自己建立 &lt;code&gt;~/.config/ibus/rime/ibus_rime.yaml&lt;/code&gt; 写入那段配置就可以啦，因为本来也没有所以就不用打 patch 了，或者你在那两个位置建立一个空的 &lt;code&gt;ibus_rime.yaml&lt;/code&gt; 然后再打 patch 也行……&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2021 年 1 月 26 日）：Arch 的 librime 现在打包了一个 &lt;code&gt;/usr/share/rime/ibus_rime.yaml&lt;/code&gt; 文件，所以上面手动创建一个 &lt;code&gt;ibus_rime.yaml&lt;/code&gt; 的办法会被覆盖，所以现在建议创建 &lt;code&gt;~/.config/ibus/rime/ibus_rime.custom.yaml&lt;/code&gt; 然后对照着打patch，比如我写的是：&lt;/p&gt;
&lt;figure data-raw=&quot;patch:
  # 舒服不如倒着。
  style/horizontal: true
  # 有些软件的行内预测支持有 bug，所以我一般不开。
  style/inline_preedit: false&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;patch:
  # 舒服不如倒着。
  style/horizontal: true
  # 有些软件的行内预测支持有 bug，所以我一般不开。
  style/inline_preedit: false&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;hr&gt;
&lt;p&gt;不要忘了删掉 &lt;code&gt;build&lt;/code&gt; 目录再 &lt;code&gt;ibus-daemon -rdx&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2021-07-23）：最近研究了一下如何扩展 RIME 的词库，发现还是稍微复杂的，我尝试导入了肥猫打包的 &lt;code&gt;rime-pinyin-zhwiki&lt;/code&gt;。如果你要给某个输入法导入词库，首先你得自己创建一个扩展词库文件让他继承这个输入法本来的词库和你想要的词库，因为输入法配置里面只能指定一个词库配置文件。&lt;/p&gt;
&lt;p&gt;所以对于朙月拼音简化字版本，先创建一个叫 &lt;code&gt;luna_pinyin_simp.extended.dict.yaml&lt;/code&gt;，&lt;code&gt;.dict.yaml&lt;/code&gt; 之前的名字其实是随便取的，内容如下：&lt;/p&gt;
&lt;figure data-raw=&quot;# 原来要结合默认词库和第三方词库，
# 需要自己编写一个词库让它 fallback 到朙月拼音和第三方词库。
# 我说佛老师对不起对不起，我不懂规矩。
---
name: luna_pinyin_simp.extended
version: &amp;quot;0.1&amp;quot;
# `by_weight`（按词频高低排序）或 `original`（保持原码表中的顺序）。
sort: by_weight
# 因为导入的朙月拼音词库是繁转简，所以这里不能导入简化字八股文。
# 导入简化字八股文。
# vocabulary: essay-zh-hans
# 选择是否导入预设词汇表【八股文】。
use_preset_vocabulary: true

import_tables:
  - luna_pinyin
  - zhwiki&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;# 原来要结合默认词库和第三方词库，
# 需要自己编写一个词库让它 fallback 到朙月拼音和第三方词库。
# 我说佛老师对不起对不起，我不懂规矩。
---
name: luna_pinyin_simp.extended
version: &quot;0.1&quot;
# `by_weight`（按词频高低排序）或 `original`（保持原码表中的顺序）。
sort: by_weight
# 因为导入的朙月拼音词库是繁转简，所以这里不能导入简化字八股文。
# 导入简化字八股文。
# vocabulary: essay-zh-hans
# 选择是否导入预设词汇表【八股文】。
use_preset_vocabulary: true

import_tables:
  - luna_pinyin
  - zhwiki&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;应该很容易懂，我就不多唠叨了，记得里面名字和外面文件名要一致。&lt;/p&gt;
&lt;p&gt;然后在 &lt;code&gt;luna_pinyin_simp.custom.yaml&lt;/code&gt; 的 patch 里面加一行：&lt;/p&gt;
&lt;figure data-raw=&quot;  translator/dictionary: luna_pinyin_simp.extended&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  translator/dictionary: luna_pinyin_simp.extended&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我还研究了一下如何添加 emoji 功能，也是靠肥猫打的 &lt;code&gt;rime-emoji&lt;/code&gt; 包，只要在 &lt;code&gt;luna_pinyin_simp.custom.yaml&lt;/code&gt; 的 patch 里面加一行：&lt;/p&gt;
&lt;figure data-raw=&quot;  __include: emoji_suggestion:/patch&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;  __include: emoji_suggestion:/patch&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你用的不是 Arch，可能需要自己复制 patch 文件内容而不是简单地使用 include，参见&lt;a href=&quot;https://github.com/rime/rime-emoji/blob/master/README.md#%E8%87%AA%E5%8A%A9%E5%AE%89%E8%A3%9D&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;官方说明&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;当然不要忘了安装这两个依赖的包，我这个配置在 Arch Linux 下面一共需要下面几个包：&lt;/p&gt;
&lt;figure data-raw=&quot;# pacman -S librime ibus-rime rime-luna-pinyin rime-emoji rime-pinyin-zhwiki&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;# pacman -S librime ibus-rime rime-luna-pinyin rime-emoji rime-pinyin-zhwiki&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当然你要有配置好能显示的 emoji 字体。这也是个坑，等我有时间写一下我的 &lt;code&gt;/etc/fonts/local.conf&lt;/code&gt; 吧。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;下载&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/My-RIME/#%E4%B8%8B%E8%BD%BD&quot; title=&quot;下载&quot;&gt;&lt;/a&gt;下载&lt;/h1&gt;
&lt;p&gt;更新（2021-07-23）：因为加了词库和 emoji 之后文件变多了，请直接去 &lt;a href=&quot;https://github.com/AlynxZhou/alynx-rime-config/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;GitHub Repo&lt;/a&gt; 获取配置。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="输入法" label="输入法" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BE%93%E5%85%A5%E6%B3%95/" />
    
    <category term="RIME" label="RIME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E8%BE%93%E5%85%A5%E6%B3%95/RIME/" />
    
    
    <category term="输入法" label="输入法" scheme="https://sh.alynx.one/tags/%E8%BE%93%E5%85%A5%E6%B3%95/" />
    
    <category term="RIME" label="RIME" scheme="https://sh.alynx.one/tags/RIME/" />
    
  </entry>
  
  
  
  <entry>
    <title>翻译：我很幸运，但你不是。</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/I-Am-Lucky-You-Are-Not/" />
    <id>https://sh.alynx.one/posts/I-Am-Lucky-You-Are-Not/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-07-31T07:24:00.000Z</published>
    
    
    <updated>2019-07-31T07:24:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;这是一篇 &lt;a href=&quot;https://dev.to/jeromegamez&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Jérôme Gamez&lt;/a&gt; 的文章 &lt;a href=&quot;https://dev.to/jeromegamez/i-am-lucky-you-are-not-2eco&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;I am lucky, you are not.&lt;/a&gt; 的简体中文翻译。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;这是一篇 &lt;a href=&quot;https://dev.to/jeromegamez&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Jérôme Gamez&lt;/a&gt; 的文章 &lt;a href=&quot;https://dev.to/jeromegamez/i-am-lucky-you-are-not-2eco&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;I am lucky, you are not.&lt;/a&gt; 的简体中文翻译。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;你好，我的名字是杰罗姆（Jérôme）！对于分享名字我感觉很自在，因为我住在德国，并且我也不总是对我们国家的政府感到高兴。&lt;/p&gt;
&lt;p&gt;对于我能公开谈论此类事情，而不需要感到对我的言论产生的反响感到恐惧，我感觉很幸运。并且我拥有 &lt;em&gt;甚至都不需要考虑&lt;/em&gt; 需要考虑我有多么幸运的奢侈的权利（这里的重复是有意为之）。&lt;/p&gt;
&lt;p&gt;通过最近在 &lt;a href=&quot;https://discord.gg/nbgVfty&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Discord 社区&lt;/a&gt; 有关 &lt;a href=&quot;https://github.com/kreait/firebase-php&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;PHP 的 Firebase Admin SDK&lt;/a&gt; 的讨论，我才意识到以上这些事情。&lt;/p&gt;
&lt;p&gt;某位成员试图通过这个 SDK 去访问 Firebase API，但是却触发了一个既没有详细信息也没有说明错误来源的异常。事实上原因是因为他们在中国而且忘记了给代码运行的环境设置代理。是个可以修复的问题。&lt;/p&gt;
&lt;p&gt;当我在忙于在 SDK 里实现连接错误处理的时候（这是一件我以往甚至没有考虑过去做的事情，因为我在一个很幸运的位置，处于一个拥有普及且无限制的互联网连接的国家里），另一位社区成员补充说到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@jeromegamez：看看我处在一个多么令人愉悦的情形：由于美国贸易管制法律限制，您的 GitHub 账户已被限制。对于个人账户，您可能仅仅拥有用于个人交流的对于免费的 GitHub 公开仓库服务的受限访问权限。请阅读有关 GitHub 和贸易管制的文章以获取更多信息。如果您确信您的账户是被错误地标为受限，请发起申诉。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他们曾经有某次在自己祖国不通过 VPN 或代理直接访问 GitHub，然后立刻被标为受限，现在无法访问自己的私有仓库。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这太差劲了……你们会为这个申请判决吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我是这样幼稚地回复的，没意识到他们的申诉当然无法成功。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;@jeromegamez：非常不幸，你没法选择在哪出生！在大概 200 来个国家里面我就处在一个疯狂的国家里。在内部的审查制度和制裁开始之后我通常使用 VPN，拿 whatsapp 举例，有些时候我没法上传图片于是我需要使用代理或 VPN。正常来说你可以通过使用 VPN 来使用像 Nvidia.com 或者 Android.developers.com 等等国际服务，但是这次不太一样，如果你曾经用某些地方的 IP 地址访问过他们的服务，他们直接阻拦你自己。至少我仍然可以使用公开仓库，并且希望我能备份我的私有仓库！
至于申请判决，作为这些国家的公民我没法做这件事情。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我们在私有频道继续了我们的对话，他们和我聊了他们出身的国家（这是个通常让他们感到不适的话题），他们为此努力并且在公开频道展示了这些以便引起注意。&lt;/p&gt;
&lt;p&gt;人们像我一样（特别来说像我：白人、男性、欧洲人、有一份薪水不错的工作并且可以访问任何我需要和大部分想要的事物）看待这个世界并且对在一些令人不那么舒适的地方正在发生的事情感到不满和恐惧。&lt;/p&gt;
&lt;p&gt;但是还有可能成为更令人不适、敌对或者危险的地方，并且像你或我一样的人正在那生活。&lt;/p&gt;
&lt;p&gt;当我在为了躲避酷暑而努力时，有些人在努力谋生。&lt;/p&gt;
&lt;p&gt;当我因为不能在互联网平台上使用我中意的用户名而感到气愤时，有些人在确保他们的用户名不会透露太多他们的个人信息。&lt;/p&gt;
&lt;p&gt;当政府 A 在制裁国家 B，在制裁导致的后果中挣扎的是那些国家的平民百姓，而不是领导者。&lt;/p&gt;
&lt;p&gt;当我在尽力唤起人们注意的时候，有些人在尽力活下去。&lt;/p&gt;
&lt;p&gt;这不代表我们的个人问题是不相干的，但我认为，认识到我们中的大多数是幸运地出生在一个好地方，并且也有好多人不像我们这么幸运，是十分重要的。&lt;/p&gt;
&lt;p&gt;最起码我们可以做的是以尊敬、礼貌和同情对待他人，而不在乎他们的出身和背景。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="无题" label="无题" scheme="https://sh.alynx.one/categories/%E6%97%A0%E9%A2%98/" />
    
    
    <category term="无题" label="无题" scheme="https://sh.alynx.one/tags/%E6%97%A0%E9%A2%98/" />
    
  </entry>
  
  
  
  <entry>
    <title>在 Pixel C 上安装 Lineage OS</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Pixel-C-Lineage/" />
    <id>https://sh.alynx.one/posts/Pixel-C-Lineage/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-07-24T09:24:00.000Z</published>
    
    
    <updated>2019-07-24T09:24:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;Pixel C 刚出来的时候我就很喜欢，但无奈价格太贵，同时 Android M 不能说是很好的利用平板电脑硬件。由于咕鸽战略失误，现在 Pixel C 已经变成热门洋垃圾了，所以在咸鱼捡了一台玩玩。&lt;/p&gt;
&lt;p&gt;官方系统升级只支持到 8.1（真的好意思起名叫 Pixel），Lineage OS 支持也是到 8.1（LOS 版本号就是 15.1，没有 Bug），所有的 9.0 都是 Unofficial 的，不过反正我就拿来看看文档，所以直接刷 LOS 15.1 Official 了（为什么不刷官方？因为我手机不想刷第三方，就拿平板过过瘾）。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;Pixel C 刚出来的时候我就很喜欢，但无奈价格太贵，同时 Android M 不能说是很好的利用平板电脑硬件。由于咕鸽战略失误，现在 Pixel C 已经变成热门洋垃圾了，所以在咸鱼捡了一台玩玩。&lt;/p&gt;
&lt;p&gt;官方系统升级只支持到 8.1（真的好意思起名叫 Pixel），Lineage OS 支持也是到 8.1（LOS 版本号就是 15.1，没有 Bug），所有的 9.0 都是 Unofficial 的，不过反正我就拿来看看文档，所以直接刷 LOS 15.1 Official 了（为什么不刷官方？因为我手机不想刷第三方，就拿平板过过瘾）。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;由于刷机时候没拍照片我就不上图了，到手时候已经解锁了，不过既然是亲儿子想必也不会像一些国内厂商一样恶心你。按照 Lineage OS 的说法就是打开开发者选项里 &lt;code&gt;允许 OEM 解锁&lt;/code&gt; 和 &lt;code&gt;允许 USB 调试&lt;/code&gt;，按住 &lt;code&gt;音量下&lt;/code&gt; + &lt;code&gt;电源&lt;/code&gt; 直到重启进入 bootloader，然后连接电脑，&lt;code&gt;fastboot devices&lt;/code&gt;，如果检测到了就 &lt;code&gt;fastboot oem unlock&lt;/code&gt;，然后结束之后重启。（会清除所有数据，并且解锁之后每次开机会在 bootloader 停止 30 秒）。&lt;/p&gt;
&lt;p&gt;首先是去 &lt;a href=&quot;https://download.lineageos.org/dragon&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Lineage OS 官网&lt;/a&gt; 下载给 Pixel C（代号 dragon）的 nightly build ZIP。&lt;/p&gt;
&lt;p&gt;然后去 &lt;a href=&quot;https://drive.google.com/drive/folders/0By6p5AdQfavBUTZmNWJoaU1iazg&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这个 Google Drive&lt;/a&gt; 下载开发者提供的 &lt;code&gt;vendor.img&lt;/code&gt;。（&lt;strong&gt;务必要下载这个，如果有不止一个就选择最新的，因为 ROM 里不包含 vendor，其他下载的版本又和 ROM 包不匹配。&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;然后去 &lt;a href=&quot;https://dl.twrp.me/dragon/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;TWRP 官网&lt;/a&gt; 下载给 Pixel C 用的 Recovery。&lt;/p&gt;
&lt;p&gt;需要 Google Apps 就去 &lt;a href=&quot;https://opengapps.org&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Open GApps&lt;/a&gt; 下一个 ZIP，我用的是 &lt;code&gt;ARM64&lt;/code&gt; -&amp;gt; &lt;code&gt;8.1&lt;/code&gt; -&amp;gt; &lt;code&gt;stock&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;如果你需要 Magisk 就自己去下载一个。&lt;/p&gt;
&lt;p&gt;把这些都放好，在自己电脑上安装 &lt;code&gt;adb&lt;/code&gt; 和 &lt;code&gt;fastboot&lt;/code&gt;，然后打开 &lt;code&gt;允许 USB 调试&lt;/code&gt;。按住 &lt;code&gt;音量下&lt;/code&gt; + &lt;code&gt;电源&lt;/code&gt; 直到重启进入 bootloader，然后 &lt;code&gt;fastboot flash recovery TWRP-IMG-FILE&lt;/code&gt; 刷入 TWRP，然后再按住 &lt;code&gt;音量下&lt;/code&gt; + &lt;code&gt;电源&lt;/code&gt; 直到重启进入 bootloader，选择 Recovery Mode 确认 TWRP 已经刷进去了。&lt;/p&gt;
&lt;p&gt;接下来在 TWRP 里面全部 wipe（syste, data, cache, sdcard），然后接上电脑用 &lt;code&gt;adb push FILE /sdcard/&lt;/code&gt; 把下好的 ROM ZIP、&lt;code&gt;verdor.img&lt;/code&gt; 和 OpenGApps ZIP 都 push 到 sdcard 里面。&lt;/p&gt;
&lt;p&gt;然后选择 Install 刷入 Lineage 的 ZIP。**接下来选择右侧 Install IMG，刷入下好的 &lt;code&gt;vendor.img&lt;/code&gt;**，然后刷入 OpenGApps 和 Magisk，重启。如果刷入 Magisk 的话会自动重启两次再进入向导。&lt;/p&gt;
&lt;p&gt;如果你日后某次更新提示 vendor 不匹配，那就去上面的咕鸽硬盘看看有没有新的刷进去就行了。&lt;/p&gt;
&lt;p&gt;接下来就是熟悉的开机向导了。&lt;/p&gt;
&lt;p&gt;大致来说作为洋垃圾这个平板还很划算，除了屏幕下端因为接键盘的磁铁的缘故会发黄（通病）、太多磕碰容易花屏（设计缺陷，购买要买少磕碰的），屏幕素质很好尺寸也很大，看文档看 PPT 看五线谱都是绝配（我期末就是用这个看 PPT 复习的超级爽）。但是毕竟是 3 年前的产品，3 GB RAM 不是很够多任务，同时 CPU 性能也不是特别高，甚至窗口特效都会卡（老黄的芯片优化好烂），但是这台机器是 NVIDIA 的芯片，GPU 性能强劲，打开开发者选项里 &lt;code&gt;禁用 HW 叠加层&lt;/code&gt;，使用 GPU 进行窗口混成特效就不卡了。&lt;/p&gt;
&lt;p&gt;游戏性能很弱，大部分游戏都没有对这台机器 GPU 优化，CPU 和内存以及 IO 性能也不高（毕竟三年前），但是玩 FGO 意外的不卡，而且还让我用 &lt;strong&gt;维护送的石头&lt;/strong&gt; &lt;strong&gt;单抽&lt;/strong&gt; &lt;strong&gt;连续&lt;/strong&gt; 出了 &lt;strong&gt;老福&lt;/strong&gt; 和 &lt;strong&gt;心心念念的蓝呆&lt;/strong&gt;！！！要知道就算把买平板的钱都氪进去也才不到两单，要靠这些石头来双黄蛋简直是白日做梦啊！&lt;/p&gt;
&lt;p&gt;除了垃圾 B 站 APP 不支持横屏以外，大部分对我影响都不是很大，所谓生态烂其实对我这种资深 Android 用户也没什么大影响，毕竟我对它分工很明确。日常用起来 Lineage OS 也没什么问题，升级只要傻瓜化点击就 OK 了。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;Alynx Zhou&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;A Coder &amp;amp; Dreamer&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    
    <category term="Android" label="Android" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/Android/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Android" label="Android" scheme="https://sh.alynx.one/tags/Android/" />
    
  </entry>
  
  
</feed>
