<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>喵's StackHarbor</title>
  <subtitle>Whisper to the World</subtitle>
  <icon>https://sh.alynx.one/images/Mikoto_Karon_White.webp</icon>
  <link rel="self" type="application/atom+xml" href="https://sh.alynx.one/atom.xml" />
  
  <link rel="alternate" type="text/html" href="https://sh.alynx.one/" />
  
  <updated>2022-02-20T12:53:00.000Z</updated>
  
  <id>https://sh.alynx.one/</id>
  
  <author>
    <name>Alynx Zhou</name>
    <email>alynx.zhou@gmail.com</email>
  </author>
  
  <generator uri="https://github.com/AlynxZhou/hikaru-generator-feed/" version="v2.3.5">Hikaru Generator Feed</generator>
  
  
  
  
  
  <entry>
    <title>Emacs 和 Monaco 字体和 Box-drawing Character</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Emacs-Monaco-Box-drawing-Character/" />
    <id>https://sh.alynx.one/posts/Emacs-Monaco-Box-drawing-Character/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2022-02-20T12:53:00.000Z</published>
    
    
    <updated>2022-02-26T01:51:25.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;2016 年的我开始用 Atom 这种“modern”的编辑器，2022 年的我却又开始用回岁数比我都大的 GNU Emacs。切换的理由其实很简单，我曾经以为一直能追上最新版 Electron 的 VSCode 会成为第一个纯 Wayland 的代码编辑器——只要 Chromium 那边支持纯 Wayland 就好了嘛，然而直到 Emacs 那边的 pgtk 分支合并进主线（以防有读者不太清楚来龙去脉我解释一下，Emacs 虽然有图形界面，但实际上只是用 X 实现了一个 Terminal 层，而传统的 GTK3 界面只是使用 GTK3 创建一个 X 窗口，然后其它操作都是通过 X 进行，这实际上非常不适合 GTK3，导致了很多 bug，同时也使 Emacs 没法利用 GTK 的 Wayland 后端。而 pgtk 分支则是在 X 部分之外另起炉灶，利用 GTK 实现了一个和 X 部分平行的 Terminal 层，全部的绘制操作都是以 GTK/Cairo 的现代程序方式进行，自然也就摆脱了对 X 的依赖。总之在 Emacs 这样又老又庞大的代码库上做如此大范围的工程我觉得可以称得上是一项壮举了。），Chromium 的 ozone backend 还是问题多多。虽然 Emacs/Vim 这种软件看起来确实有点老派作风，但没想到也有走在这些“现代”编辑器前面的地方。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;2016 年的我开始用 Atom 这种“modern”的编辑器，2022 年的我却又开始用回岁数比我都大的 GNU Emacs。切换的理由其实很简单，我曾经以为一直能追上最新版 Electron 的 VSCode 会成为第一个纯 Wayland 的代码编辑器——只要 Chromium 那边支持纯 Wayland 就好了嘛，然而直到 Emacs 那边的 pgtk 分支合并进主线（以防有读者不太清楚来龙去脉我解释一下，Emacs 虽然有图形界面，但实际上只是用 X 实现了一个 Terminal 层，而传统的 GTK3 界面只是使用 GTK3 创建一个 X 窗口，然后其它操作都是通过 X 进行，这实际上非常不适合 GTK3，导致了很多 bug，同时也使 Emacs 没法利用 GTK 的 Wayland 后端。而 pgtk 分支则是在 X 部分之外另起炉灶，利用 GTK 实现了一个和 X 部分平行的 Terminal 层，全部的绘制操作都是以 GTK/Cairo 的现代程序方式进行，自然也就摆脱了对 X 的依赖。总之在 Emacs 这样又老又庞大的代码库上做如此大范围的工程我觉得可以称得上是一项壮举了。），Chromium 的 ozone backend 还是问题多多。虽然 Emacs/Vim 这种软件看起来确实有点老派作风，但没想到也有走在这些“现代”编辑器前面的地方。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;至于这和我换掉 Atom 有什么联系呢？主要是我发现在家里的台式机上，所有 XWayland 程序在 nvidia 驱动下面都会有闪回的情况，也就是说你打字的时候突然会闪回前几帧的画面，过一会再闪回来，你经常看不到自己输入的字符。Electron 程序尤其严重，也就导致我没有办法使用 Atom 写代码，于是不得不捡起以前东拼西凑的 Emacs 配置重新研究。（奇怪的是我自己的台式机也是 nvidia 驱动，没遇到过这种问题。）&lt;/p&gt;
&lt;p&gt;扯远了，这篇文章主要想记录的问题是什么呢？其实还要和 Emacs 绘制界面的方式有关系，对于 Atom/VSCode 这种基于浏览器的程序来说绘制点什么图形元素很简单，但是对于 Emacs/Vim 这种来自于终端里的程序，开发者们习惯的是处理字符而不是处理图形，于是你会发现比如 80 column ruler 或者 indent guide 这种东西，在 Emacs 里面其实是通过在对应的位置插入竖线字符实现的……我个人不太喜欢这样，一个原因是我以为竖线字符并不是占满整行而是上下有空白。我一直以为这是 Emacs 的问题——你干嘛用竖线字符画 UI 啊。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Emacs-Monaco-Box-drawing-Character/1.png&quot; alt=&quot;有问题的样子&quot;&gt;&lt;/p&gt;
&lt;p&gt;直到有一天我输错了 alias 在 GNOME Terminal 里面打开了 Emacs，我惊讶的发现竖线竟然接上了头！&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Emacs-Monaco-Box-drawing-Character/2.png&quot; alt=&quot;终端里的样子&quot;&gt;&lt;/p&gt;
&lt;p&gt;我当时就震惊了，我的终端和 Emacs 用的是同样的 Monaco 字体，怎么会不一样呢？难道是 Monaco 字体有问题？于是我上网搜了一下，我以前一直以为是 Emacs 的哪个设置比如 line-spacing 我没搞好，怎么搜也搜不出来，这次换成搜字体一下子就找到原因了：一个 Alacritty 的 issue 里面和我有同样的问题，不过他是 tmux 的分割线接不上头，都是 Monaco 字体。&lt;/p&gt;
&lt;p&gt;为什么只有 Monaco 接不上头呢？原来在字符界面下画这些竖线的字符和平时用 &lt;code&gt;Shift+\&lt;/code&gt; 输入的字符并不是一个，这类字符叫做 &lt;a href=&quot;https://en.wikipedia.org/wiki/Box-drawing_character&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Box-drawing Character&lt;/a&gt;，主要的范围是 &lt;code&gt;U+2500&lt;/code&gt; 到 &lt;code&gt;U+257F&lt;/code&gt;，这些字符用于在终端里绘制方框或者其它形状，所以应该是没有 padding 的，才能接上头，而 Monaco 这里有问题，它给这些字符加上了 padding，导致接不上。我尝试着给 Emacs 的字体换成 Source Code Pro，竖线立刻就连上了。&lt;/p&gt;
&lt;p&gt;怎么解决？换字体？不可能的，我是 Monaco 的狂粉，看惯了 Monaco 再看别的字体都觉得傻了吧唧的。如果不是因为它好看我才不会忍受它这么多缺点（没有内置粗体，虽然是等宽字体内部的连字表却和非等宽字体一样，有版权不能二次分发）。解决方法其实比较简单，把 &lt;code&gt;U+2500&lt;/code&gt; 到 &lt;code&gt;U+257F&lt;/code&gt; 的字符换成正常字体里的就可以了。简单的解决办法是用 FontForge 的同个实例打开 Monaco 和另一款字体（我选择了 Menlo，Menlo 是苹果用来替代 Monaco 做内置默认等宽字体的，应该会比较接近），然后选择 Monaco 的这个范围清空，然后选择 Menlo 的复制粘贴过来。不过我没在 FontForge 里面找到连续区间选择的办法，上网搜了一下说可以用它的脚本 API 选，办法是打开 File 菜单里面的 Execute Script，执行 &lt;code&gt;fontforge.activeFont().selection.select((&quot;ranges&quot;, None), 0x2500, 0x257F)&lt;/code&gt;。如果你不知道怎么把 Menlo 里面的一段字形复制粘贴到 Monaco 里面，你也可以在 Menlo 里执行这段脚本，然后反选，全部清空，然后把这部分生成一个字体，再去 Monaco 里面选 Elements 菜单里面的 Merge Fonts。&lt;/p&gt;
&lt;p&gt;或者你也可以看看这个 &lt;a href=&quot;https://github.com/Alhadis/Menloco&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;叫 Menloco 的项目&lt;/a&gt;，是我偶然间搜索到的有同样问题的用户的解决方案，这个项目包含更多的细微 tweak 脚本，帮你利用 Monaco 和 Menlo 合并出一个 Box-drawing Character 能完美接头的字体。不过有几个地方需要注意，一个是这个项目的作者应该是 macOS 的用户，如果你不是 macOS，需要自己想办法搞到 Menlo.ttf 和 Monaco.ttf，简单的办法是找个用 Mac 的朋友让他发给你，不过有可能你得到的是 Menlo.ttc，需要用 FontForge 打开选择 Regular 字重，然后导出成单个的 ttf。你还需要修改 &lt;code&gt;utils/find-font.sh&lt;/code&gt;，这个脚本的 &lt;code&gt;font_paths&lt;/code&gt; 只包含 macOS 放置字体的目录，你得加上你自己放这两个字体的目录。以及这个项目默认生成的字体名（不是文件名）叫 Menloco，如果你不想修改已有的写着 Monaco 的配置文件的话，就把 merge 这一项下面的 &lt;code&gt;--font-name=$(RESULT)&lt;/code&gt; 改成 &lt;code&gt;--font-name=$(INTO)&lt;/code&gt; 就好了。&lt;/p&gt;
&lt;p&gt;生成一个没问题的字体之后你还可以像我一样用 FontForge 做一些修改，比如说我发现 Menlo 有很多 Monaco 没有的字符，于是我直接把 Menlo merge 进了生成的字体里。并且我之前提到过 Monaco 作为一个等宽字体，内置的连字表竟然是非等宽的，不是像 Fira Code 那种把不同的编程符号连字起来同时保持等宽的连字，而是像普通无衬线一样把 &lt;code&gt;fi&lt;/code&gt; 一类的字符连起来变成单个字符宽度。我被坑得最狠的一次就是 review 同事的 patch，我问他这里是不是少了个空格，他说在他那看没问题，最后我发现是 Monaco 连字了！虽然你可以通过配置 fontconfig 关闭连字，但是 Firefox 是不吃这个配置的，而你也不可能给每个网页的代码块都加上关闭连字的 CSS。所以我直接在 FontForge 里面干掉了连字表，具体方法就是打开 Element 菜单下面的 Font Info，点击左侧的 Lookup，选中带 liga 的项 delete 之后导出字体即可。&lt;/p&gt;
&lt;p&gt;还有一个比较古怪的 Emacs 问题，Emacs 设置字体和其它程序不太一样，可以先设置一个默认字体然后针对不同的字符集设置不同的字体，一般要为中文单独设置字体才能得到合适的效果，就像下面这样：&lt;/p&gt;
&lt;figure data-raw=&quot;(set-face-attribute &#039;default nil
                    :family &amp;quot;Monaco&amp;quot;
                    ;; :slant &#039;normal
                    :width &#039;normal
                    :weight &#039;normal
                    ;; 1 height is 1/10 pt.
                    :height 140)

(dolist (charset &#039;(kana han symbol cjk-misc bopomofo))
  (set-fontset-font t charset (font-spec :family &amp;quot;Noto Sans Mono CJK SC&amp;quot;
                                         ;; :slant &#039;normal
                                         :width &#039;normal
                                         :weight &#039;normal)))
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(set-face-attribute &#039;default nil
                    :family &quot;Monaco&quot;
                    ;; :slant &#039;normal
                    :width &#039;normal
                    :weight &#039;normal
                    ;; 1 height is 1/10 pt.
                    :height 140)

(dolist (charset &#039;(kana han symbol cjk-misc bopomofo))
  (set-fontset-font t charset (font-spec :family &quot;Noto Sans Mono CJK SC&quot;
                                         ;; :slant &#039;normal
                                         :width &#039;normal
                                         :weight &#039;normal)))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;首先要注意 height 的单位是 1/10，所以你想要的字号需要乘 10 才行。&lt;/p&gt;
&lt;p&gt;然后你会发现明明你只设置了一个字号，可是中文和英文字体却不是等高的！也就是说如果你在本来都是英文的一行里面输入一个中文字，那这行的高度就会突然跳一下变高，非常烦人，也许是这两个字体在同样的字号的时候尺寸并不完全一致，但是明明其它程序都能正常处理，为什么这里这么怪！&lt;/p&gt;
&lt;p&gt;你可能会想要对中文那段单独设置 size 缩小一点，但是这样不行，你用 &lt;code&gt;C-x C-=&lt;/code&gt; 放大字体的时候中文字体就会固定大小不跟着你变了。正确的解决方法是加入下面一句：&lt;/p&gt;
&lt;figure data-raw=&quot;(setq face-font-rescale-alist &#039;((&amp;quot;Noto Sans Mono CJK SC&amp;quot; . 0.85)))
&quot; data-info=&quot;language-elisp&quot; data-lang=&quot;elisp&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-elisp&quot;&gt;(setq face-font-rescale-alist &#039;((&quot;Noto Sans Mono CJK SC&quot; . 0.85)))
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这里你可以对任意的字体指定缩放参数，不会影响按键放大缩小。我尝试了一下 &lt;code&gt;0.85&lt;/code&gt; 比较合适，虽然可能这样汉字看起来会稍微小一点，但是 &lt;code&gt;0.9&lt;/code&gt; 就太高了仍然会跳。或许你会问那这样中文字宽不是英文字宽两倍了？那没有办法，Monaco 本身就属于一个比较宽的字体，那些满足英文宽度是高度一半的字体都比较瘦长，我个人是不喜欢这样的风格的，所以对于我来说等高就行了，宽度我不太在乎。&lt;/p&gt;
&lt;p&gt;更新（2022-02-25T19:01:31）：我最近研究了一下，发现原来字号并不等于行高。虽然字体有一个 em size 作为基础的方块大小，但是设计师经常指定一些奇怪的 ascender 和 descender 值让字体的高度超出 em size……我不太清楚 Atom 或者说 Chromium 是怎么进行中英文混排的，不过 Emacs 排版时候是对齐 baseline，然后 ascender 和 descender 完全一致才能保证行高不会在切换字体时候变化。但是这实在是太难了，大部分中文字体和英文字体都对不上，特别是 Noto Sans CJK 系列，不知道为什么比其它的高特别多。一个简单的解决办法是使用等距更纱黑体，里面混合的英文等宽字体 Iosevka 和中文的思源黑体拥有一致的 ascender 和 descender，但我实在是不喜欢 Iosevka。并且不知道为什么，Noto Sans CJK 和等距更纱黑体里面的内置的思源黑体应该是同一种字体，Noto Sans CJK 就要比他高很多。我还尝试了修改 Monaco 的 ascender 和 descender，不过这部分非常复杂，涉及到好几个不同的值，而且不同字体比例尺也不一样。最关键的是修改之后相当于把字体拉高了，于是 box-drawing character 又接不上了……上面那个修改缩放参数其实也不是无级缩放，实际上是乘字号之后取整然后再去找对应大小的字符，所以其实就是找小几号的 Noto Sans CJK。具体的可以在 Emacs 里面 &lt;code&gt;M-x describe-font&lt;/code&gt; 查看详情。&lt;/p&gt;
&lt;p&gt;更新（2022-02-26T09:51:25）：补充一下，浏览器的混排应该和 Emacs 是一样的，我刚才尝试了一下，我的博客行高固定是因为我给 &lt;code&gt;&amp;lt;pre&amp;gt;&lt;/code&gt; 设置了 &lt;code&gt;line-height: 1.5&lt;/code&gt;，这个大小超过了 Noto Sans CJK 的行高，如果删掉这一行，你就会发现含有 Noto Sans CJK 的行比只有 Monaco 的行要高很多。不过 Emacs 没办法像浏览器一样指定一个最小行高，只能是它自己根据这一行的字符计算行高，所以没什么比较好的解决办法。&lt;/p&gt;
&lt;p&gt;搞定这些之后，至少 Emacs 里面看起来比较顺眼了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Emacs-Monaco-Box-drawing-Character/3.png&quot; alt=&quot;正常的样子&quot;&gt;&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="字体" label="字体" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%AD%97%E4%BD%93/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="字体" label="字体" scheme="https://sh.alynx.one/tags/%E5%AD%97%E4%BD%93/" />
    
    <category term="Emacs" label="Emacs" scheme="https://sh.alynx.one/tags/Emacs/" />
    
  </entry>
  
  
  
  <entry>
    <title>不写文章的博客生成速度最快</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fastest-Blog-Has-No-Post/" />
    <id>https://sh.alynx.one/posts/Fastest-Blog-Has-No-Post/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2022-02-15T10:33:33.000Z</published>
    
    
    <updated>2022-02-15T10:33:33.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;春节假期虽然是假期，但是在家的时间里我基本没闲着，毕竟按照传统（指 Ken Thompson 在假期里写出了 UNIX 的第一个雏形的传统，不过维基百科上并没有详述是不是这样，我也懒得考证），假期是造轮子的好机会。所以我就胡乱捣鼓一通看看能不能让我的博客生成器更圆一点。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;春节假期虽然是假期，但是在家的时间里我基本没闲着，毕竟按照传统（指 Ken Thompson 在假期里写出了 UNIX 的第一个雏形的传统，不过维基百科上并没有详述是不是这样，我也懒得考证），假期是造轮子的好机会。所以我就胡乱捣鼓一通看看能不能让我的博客生成器更圆一点。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3await&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Fastest-Blog-Has-No-Post/#%E9%87%8D%E6%96%B0%E7%90%86%E8%A7%A3await&quot;&gt;&lt;/a&gt;重新理解 await&lt;/h1&gt;
&lt;p&gt;第一个简单的修改就是把启动时加载文件的部分并行化，其实我也没有非要尽可能并行，性能也不是我第一位的追求。&lt;/p&gt;
&lt;p&gt;我一开始写代码的时候知道有 await 之后就开始在各种地方给 Promise 用 await，随便你怎么说都行，后来我也才意识到，给所有的 Promise 都加上 await 不就是相当于每一个 Promise 都写在上一个的 then 里面，那不还是顺序执行吗？写多了以后对异步有理解了我才想起来这里完全可以用 &lt;code&gt;Promise.all()&lt;/code&gt;，反正加载插件/脚本/模板/语言是不太有先后依赖顺序的（非要说的话，插件和脚本里可能包含模板引擎，所以可能下一步是给前两个和后两个分开顺序加载）。&lt;/p&gt;
&lt;h1 id=&quot;%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86%E7%9A%84%E4%BA%8B%E6%83%85%E5%B0%B1%E8%AE%A9%E4%BA%BA%E6%9D%A5%E5%81%9A&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Fastest-Blog-Has-No-Post/#%E7%A8%8B%E5%BA%8F%E8%A7%A3%E5%86%B3%E4%B8%8D%E4%BA%86%E7%9A%84%E4%BA%8B%E6%83%85%E5%B0%B1%E8%AE%A9%E4%BA%BA%E6%9D%A5%E5%81%9A&quot;&gt;&lt;/a&gt;程序解决不了的事情就让人来做&lt;/h1&gt;
&lt;p&gt;随便你怎么说，我一直觉得有些程序很难理解的事情而人类很好理解的就该让人类来做，而不是费很大力气得到不好的效果。一个多少接近这一条的问题就是主题文件的依赖问题——很多生成器比如 Hexo 在以 server 模式运行的时候都有 watch 功能，可以监测文件变化然后实时重新生成，用户只要一刷新就可以看到最新的更改。直接看上去不难，写 Node 的谁还不知道 chokidar 了。但是问题就在于，普通用户写文章不太需要一边看渲染一边写（你不会连 Markdown 这么简单的格式都不能脑补吧？我鄙视 Typora），反而是主题作者经常需要看到自己刚编写的样式是什么样子，而这是一个很复杂的地方，CSS 预处理器和 HTML 模板引擎通常都有 import/include 一类的语法，让你不用写很多重复的片段，而博客生成器并不能理解每一种预处理器和模板引擎的语法。假如你在 A 模板里 include 了 B，然后修改了 B，此时你刷新一个用了 A 模板的页面，你是看不到页面更新的，那在最需要这个功能的时候这个功能变成了废物。&lt;/p&gt;
&lt;p&gt;有一个简单的解决方案是不要预编译你的模板，而是每次需要渲染页面的时候重新读取模板文件编译出一个函数来。不过这对于生成器而言不太优雅，有些模板引擎比如 nunjucks 可能有内建的 cache 支持，但另一些可能是没有的。再说你来来回回读这么多次磁盘，那干嘛不直接把渲染页面的工作也挪到用户浏览器（指前端）里呢？还要博客生成器做什么。&lt;/p&gt;
&lt;p&gt;我一开始的打算是既然生成器自己不好理解依赖语法，那就像处理博客文章一样，让主题作者给文件加上 front matter 记录这个文件的依赖。不过问题又来了，对于直接使用的模板（指博客生成器读取并编译它们）可以在读取时去掉 front matter，但是假如这个模板 include 的模板也带有 front matter，此时实际上是模板引擎（比如 nunjucks）自己去磁盘上读那个文件，它不会去掉 front matter。而给每一种模板引擎都重写文件加载器显然是不现实的，所以最后的方案就是要求主题作者提供一个 &lt;code&gt;file-dependencies.yaml&lt;/code&gt; 的文件，里面记录每个文件的依赖关系，大概像是这样：&lt;/p&gt;
&lt;figure data-raw=&quot;layouts:
  includes/layout.njk:
    - includes/footer.njk
    - includes/header.njk
    - includes/sidebar.njk
&quot; data-info=&quot;language-yaml&quot; data-lang=&quot;yaml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-yaml&quot;&gt;layouts:
  includes/layout.njk:
    - includes/footer.njk
    - includes/header.njk
    - includes/sidebar.njk
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;第一层是需要 watch 的目录名，因为不是所有的目录都需要实时刷新，显然这种耗时的操作越少越好，第二层是依赖其他文件的文件，第三层则是一个被它依赖的文件的列表。程序里面我写了一个 Watcher 类，启动时会读取这个文件，然后将它翻转过来：以被其它文件依赖的文件作为 key，而依赖这个文件的文件成为 value 列表。因为我们总是检测到被依赖的文件变化之后才开始统计受到它影响的文件。然后就是一个递归收集受到影响的文件的函数，因为文件依赖并不是只有一层的。收集之后分别给这些文件也加入到需要更新的列表里面。&lt;/p&gt;
&lt;p&gt;写完这个功能之后我最大的感叹就是：要是我写主题的时候能有这种功能，我应该能节省不少检查的时间吧……&lt;/p&gt;
&lt;p&gt;后面闲着又给这个做了点修改，一个是支持用 glob pattern 作为被依赖的文件，虽然我个人觉得还是把需要的文件都列出来算了，但是想必对于处在开发调试期的主题来说很有用，作者可能不一定想得起来及时更新这个文件。另一个是考虑到使用 glob 之后很容易在无意间搞出循环依赖，又写了在递归里打破循环依赖的功能，我通常不擅长处理递归的逻辑，但我脑子灵光一闪想起来可以给函数最后一个参数设置成一个记录已经处理过哪些文件的 Set，然后递归的时候作为参数传进去，然后就这么成了。&lt;/p&gt;
&lt;p&gt;现在如果开启 server 模式，各种文件以及语言文件模板文件，甚至包括这个依赖描述文件自己都是实时更新的了，只有主题和站点的两个关键配置文件需要重启之后才能重新加载。&lt;/p&gt;
&lt;h1 id=&quot;%E5%89%8A%E5%87%8F%E4%BE%9D%E8%B5%96%E7%9A%84%E8%B7%AF%E4%B8%8A%E6%B2%A1%E6%9C%89%E6%9C%80%E5%B0%91%E5%8F%AA%E6%9C%89%E6%9B%B4%E5%B0%91&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Fastest-Blog-Has-No-Post/#%E5%89%8A%E5%87%8F%E4%BE%9D%E8%B5%96%E7%9A%84%E8%B7%AF%E4%B8%8A%E6%B2%A1%E6%9C%89%E6%9C%80%E5%B0%91%E5%8F%AA%E6%9C%89%E6%9B%B4%E5%B0%91&quot;&gt;&lt;/a&gt;削减依赖的路上没有最少只有更少&lt;/h1&gt;
&lt;p&gt;事实上我在添加依赖的时候已经非常克制了，我尽量只使用那些我不得不用的 npm 包，有些功能能自己实现的我都自己实现了。但是总有还能去掉的依赖。我首先干掉了 Stylus，理由很哭笑不得，它好像不是那么流行了，我都找不到合适的支持它的 Emacs 插件。我本来想换成 Less 或者 SCSS，但是前者语法和 Stylus 差得有点多，后者有好几种语言的实现，本来我看 GNOME 都在用 C 写的 libsass，我觉得挺好，也打算用这个，结果发现它教程里挂着说“不推荐使用 &lt;code&gt;@import&lt;/code&gt; 而推荐 &lt;code&gt;@use&lt;/code&gt; 但目前只有 dart 版本的实现支持了后者”，让我感到说不出来的难受，我不太喜欢这种奇怪的新语言，而且搞这么多实现，还整出参差不齐的语法，实在是麻烦，虽然 dart 可以编译到 JavaScript，我还是放弃了。其实我自己写 Stylus 的时候不是放飞自我型的，而是尽可能贴近 CSS 型的，所以干脆把我的样式都改成了原生 CSS 了，顺手就干掉了一个依赖，如果有需要的人还是装插件吧。&lt;/p&gt;
&lt;p&gt;再之后就是我一直使用 glob 来匹配文件，但是它还依赖一些别的包，我在想能不能用依赖更少的包替换它。glob 使用 minimatch 分析 glob pattern，但是比如 chokidar 使用的是另一个替代品叫 picomatch。我找到一个叫 fdir 的库，虽然接口用起来怪怪的，但是如果你用它做 glob，只需要它和 picomatch，没有引入别的依赖，于是我就试了一下。但是不得不感叹作者能不能写点阳间的代码，这个库默认忽略软链接文件，这显然是不能用的，但是假如你设置解析链接文件，它倒好，就算我要的是相对路径，它还是直接解析并拼接了绝对路径——我只是想让你把链接文件当普通文件返回一下！就在我打算放弃并用回阳间的 glob 包的时候，我发现 chokidar 自己依赖的 readdirp 库也可以配合 picomatch 使用。但是如果你直接把 glob pattern 丢给它让它自己调用 picomatch 编译的话，又有一些阴间的限制，索性可以给它传自定义的过滤器函数，正好我还需要支持一些别的功能，就自己编译 glob 传给它了。&lt;/p&gt;
&lt;p&gt;实际上我现在只有 10 个左右的直接依赖，全部的运行依赖大概是 36 个，在 Node.js 编写的程序里面应该算是相当克制的了，考虑到这里面大部分都是 nunjucks 的间接依赖，我觉得我做得相当不错。&lt;/p&gt;
&lt;p&gt;对于其它我编写的简单的 npm 包我还是比较追求 0 依赖，只有 0 依赖的包才是比较可控的，如果一个 npm 包在 npm 上显示有 1 个依赖，那你就不能确定这一个依赖有多少间接依赖，而不更新的间接依赖会引入多少安全问题你也无法得知。我在给 Hikaru 选依赖的时候一般也会倾向于 0 依赖的包（这就是为什么选择 commander.js 而不是 yargs 的原因）或者是一些虽然有依赖，但是递归翻几次就是 0 依赖的包（chokidar 属于这类，而且我还给 nunjucks 提过一个 PR 使用 commander.js 代替了 yargs），而不会选那些依赖摞依赖无穷无尽的包。&lt;/p&gt;
&lt;p&gt;这里不得不吐槽一下 jsdoc、mocha 这些大型的开发用的工具库，依赖实在是太混乱了，甚至 jsdoc 似乎同时依赖 marked 和 markdown-it……开发者写新功能的时候能不能长点心啊。还有我之前用 react-scripts 的时候，用旧版提示依赖里面有的版本有安全问题，升级到新版依赖算了一大堆，甚至出现了不同版本的间接依赖，而且仍然是有问题的版本，还是希望开发者对自己的依赖都关心关心，及时更新依赖版本，不要锁死一个版本懒得改就觉得万事大吉了。&lt;/p&gt;
&lt;p&gt;如果你对削减 npm 包的依赖感兴趣，强烈建议你读一下 &lt;a href=&quot;https://paulmillr.com/posts/chokidar-3-save-32tb-of-traffic/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;chokidar 开发者写的这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;worker_threads%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BD%86%E5%92%8C%E6%88%91%E6%83%B3%E7%9A%84%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E2%80%A6%E2%80%A6&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Fastest-Blog-Has-No-Post/#worker_threads%E6%98%AF%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%8C%E4%BD%86%E5%92%8C%E6%88%91%E6%83%B3%E7%9A%84%E4%B8%8D%E5%A4%AA%E4%B8%80%E6%A0%B7%E2%80%A6%E2%80%A6&quot;&gt;&lt;/a&gt;worker_threads 是多线程，但和我想的不太一样……&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;我：你懂 Node 吗？为什么我多线程比单线程慢？
铁道迷：Node 就是单线程拖拉机啊。
我：你不懂，88。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;凡是跟你说“Node.js 只有单线程”的人，都可以直接和他说“你不懂 Node.js”了。Node 要解决的就是非阻塞 IO 的问题，而非阻塞 IO 肯定不是多线程能解决的。至少对于内部的 fs 来说，调用异步函数的时候是 libuv 从线程池里面拉出一个线程去解决任务，而 JavaScript 本身的线程不会被阻塞。如果你还想了解“有哪些代码会阻塞主线程而哪些代码不会”，可以看 &lt;a href=&quot;https://nodejs.org/en/docs/guides/dont-block-the-event-loop/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Node.js 官网的这篇文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;说实话，对于用户自己写的 JavaScript 代码段，似乎是没什么好办法把它丢到主线程之外的线程上去执行的……请务必注意“回调”，“异步”和“非阻塞”的区别——不是所有回调都是异步的，比如我传了一个回调函数它也可能是同步的，而就算你把一段耗时的同步代码套上 &lt;code&gt;setImmediate&lt;/code&gt; 和 Promise，也不意味着它就不会阻塞主线程了……它执行的时候还是在主线程执行，只是你把它延迟了，推到了 event loop 空闲的时候去运行——但轮到它运行起来还是阻塞住了主线程。（说出来不怕笑话，我也是写得多了最近才认识到这些区别（乐），如果我写的不对还希望大家指正。）&lt;/p&gt;
&lt;p&gt;起因是我读了 &lt;a href=&quot;https://blog.skk.moe/post/say-hello-to-nodejs-worker-thread/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Sukka 的这篇文章&lt;/a&gt;，介绍了 Node 新加的 worker_threads 模块，是允许你开启子线程运行代码的。正好我想到我的博客生成器里有一段分析每篇文章内容并修饰里面的图片和链接的代码，要是能起一个线程池，把每个文章分配给不同的线程去处理，那多是一件美事啊！&lt;/p&gt;
&lt;p&gt;我发现这个 worker_threads 并不是很好用，它并不像 pthread，直接运行一个函数，而是要求你必须传一个 JavaScript 脚本的路径进去，这就给代码编写搞出了很大的麻烦。我做的修改在另一个 worker 分支里面，可以访问 &lt;a href=&quot;https://github.com/AlynxZhou/hikaru/commits/worker&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/hikaru/commits/worker&lt;/a&gt; 看到。不过一个尴尬的事情是写好以后我跑了几次，发现多线程还没有我之前单线程运行快……而且很反直觉的是线程越多越慢，在我 12 核心的处理器上四个线程是跑在主线程之外最快的，比什么 2、6、8、12 都快。&lt;/p&gt;
&lt;p&gt;说实话，我也没有搞清楚到底是怎么回事，可以确定任务确实是分发给了不同的线程，但是为什么会这么慢呢？一个可能的原因是在不同的线程之间并不是像 C 一样直接共享内存空间，传递参数的时候 Node 是复制之后传递的，虽然我觉得我传递的数据量不至于让复制造成瓶颈吧，但这是我能想到唯一的原因了。而且阅读例子的时候也发现，好像推荐的用法是比如做 http server，每一个线程都是启动之后一直监听，而不像我这样是不断的分配大量的小任务。总之我很需要一个像 pthread 那样简单的给我执行一段代码的线程，而 worker_threads 好像倾向长时间运行一个单独文件……强扭的瓜不甜，我还是放弃吧。&lt;/p&gt;
&lt;p&gt;然后说回到性能这件事上，我倒不是觉得生成器现在的性能难以忍受，否则我就该用 Hugo，相反我实在是觉得现在的生成速度出乎意料的棒了，而且又不像 Hugo 只支持 go template，Node 有很多种模板引擎可以选（我就是不喜欢 go 你来打我呀）。完整生成一遍我的博客大概耗时 800 毫秒，而且我也没有把渲染啦解析啦之类的功能用多线程解决，并且我的生成器没有缓存，每次都是从头生成的。没有缓存这点其实和之前 watch 文件的功能很类似，不够可靠还不如不要算了。在我以前用 Hexo 的时候它是有缓存的，但是这个缓存经常导致奇怪的结果，比如该更新的页面没有伴随文章一起更新之类的，我也不是很理解到底怎么回事（特别是考虑到 Hexo 里面还有一个奇怪的 JSON 数据库 warehouse），所以每次我都是 clean 之后再从头生成，那我自己实现的时候自然就砍掉这种不靠谱的功能了。&lt;/p&gt;
&lt;p&gt;当然我问了琪神 Hugo 生成他的博客耗时多少，似乎只需要 200 毫秒的样子，不过除了 go 是编译型语言而且 Hugo 肯定用了协程渲染以外，他只有 6 篇文章而我有 83 篇文章也是一个很重要的因素！他甚至连分页都不需要生成！&lt;/p&gt;
&lt;p&gt;所以如果你真的只追求速度不追求别的，什么语言都是浮云，总结出来就一句话：&lt;strong&gt;不写文章的博客生成速度最快！&lt;/strong&gt;&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="Hikaru" label="Hikaru" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/Hikaru/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="Hikaru" label="Hikaru" scheme="https://sh.alynx.one/tags/Hikaru/" />
    
  </entry>
  
  
  
  <entry>
    <title>StackHarbor 的 2021 尾记</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/2021-Tail/" />
    <id>https://sh.alynx.one/posts/2021-Tail/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2022-02-09T02:22:55.000Z</published>
    
    
    <updated>2022-02-11T01:18:12.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;今年一直拖着没写总结，不是因为懒，主要是因为我总觉得好像距离去年写总结也没太久，我还能回忆起来去年写总结时候是什么样……也说不上是因为我记忆力不太好还是因为这一年实在没什么能让我记住的事情。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;今年一直拖着没写总结，不是因为懒，主要是因为我总觉得好像距离去年写总结也没太久，我还能回忆起来去年写总结时候是什么样……也说不上是因为我记忆力不太好还是因为这一年实在没什么能让我记住的事情。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;2021 年工作没什么变化，不过我换了个好一点的住处，虽然仍然是旧楼但是里面是新装修过的，至少让人待着的时候感到舒适，而且还可以吸室友的猫，虽然小猫也经常搞破坏，不过猫做什么都可以原谅。&lt;/p&gt;
&lt;p&gt;看了去年的总结，才发现我是 2021 年把 FlipClock 改成 Meson 管理编译的，于是想起来我这一年学了 Meson 怎么用，因为 CMake 实在是让我烧脑筋。我今年还终于让 scrcpy 能够模拟 USB 键盘，这样使用 scrcpy 的时候也能用数字键选词了，多少算是在一个大项目里面做了一个大贡献。&lt;/p&gt;
&lt;p&gt;然后其他能记得住的就是最近折腾的一些东西了，春节假期没写博客也是因为忙着写代码。写了一个简单的网页小游戏，基本是平面版神庙逃亡，感觉还是挺有成就感的。然后给之前的弹钢琴页面改成了原生 JS 实现，放弃 React 的原因是依赖太多了，而且不是每个软件包都能及时更新自己的依赖。比如你用一个老版本的 create-react-app 会带来许多有漏洞的依赖，然后你更新到最新版因为依赖变了，有些库又依赖了另一个有漏洞的版本。我觉得为了简单的 UI 和数据绑定这个代价是不值得的，所以我就重写了一个。然后给我的博客生成器添加了文件依赖的支持，很久很久以前当我刚开始用静态博客生成器的时候就在头疼这个，博客生成器理解不了你的模板引擎或者预处理器的导入和扩展语句，于是没办法在一个文件更新的时候更新所有包含它的依赖，导致主题开发要不停的关掉生成器再开。一开始我是想给这些文件都加上 front matter，但是我发现虽然我自己加载的时候可以去掉 front matter，模板引擎处理导入语句的时候是他自己读文件所以没办法去掉 front matter，我不想给每个模板引擎都写自定义的 loader，所以最后改成用一个单独的文件记录依赖了。最后的结果就是单独抽出了一个 Watcher 类，可以查表查出所有需要更新的文件然后调回调，效果还挺不错的。以及本来我想清理一下博客的样式然后顺便换个 CSS 预处理器，因为感觉 Stylus 不是特别火了，但是考察了一下，less 的语法和 Stylus 差得有点多，而 scss 虽然使用广泛，而且有纯 C 语言写的实现，但是它有好多个实现，并且官网上说只有 Dart 语言写的版本才不过时，其它的都只实现了过时的 &lt;code&gt;@import&lt;/code&gt; 而用户应该用最新的 &lt;code&gt;@use&lt;/code&gt;，总之搞得这么麻烦看起来就不想用。虽然 Dart 能编译成纯 JS，我还是觉得没兴趣。于是最后我把我的样式都改成了原生 CSS，然后去掉了生成器内置的 Stylus 支持。&lt;/p&gt;
&lt;p&gt;显示器从去年的一个换成了两个，因为我是一个经常最大化窗口的人，切工作区虽然快，但是比如在浏览器和代码编辑器之间切换的时候还是会打断思路，有了双屏就没这个烦恼。一开始我想的是双屏更方便一边全屏游戏一边干别的事情，不过好像也就那样，因为从全屏切出来到另一个屏幕也不是很顺畅。不过买双屏的时候很头疼的就是因为不是一个批次，两个显示器的色温差得不是一点，最终是换了一台然后用校色仪调了好久，虽然不是 100% 一致，但是至少差不多了。&lt;/p&gt;
&lt;p&gt;说到这个我想说，感觉幸运和倒霉是伴随而来的，不太可能一直幸运，经常是发生一些开心的事之后又发生一些不开心的事，比如去年买了新相机，经常没事拍点照片什么的，结果昨天晚上我突然发现不开镜头盖的时候 CMOS 有个红点……我觉得我基本可以排除激光损伤，应该就是坏点，但是我用机内的像素映射却解决不掉。感觉最后还得跑一趟维修站，而我在老家，一时半会不会回北京，这边也没有维修站，总之麻烦的事情就会让我心累。买了一张升降桌，不过这个最便宜的款式不太靠谱，现在升降功能不太正常，于是只是变成了一台大桌子。不过椅子坏了之后换了个比较便宜的工学椅倒确实令我满意。&lt;/p&gt;
&lt;p&gt;今年没有换手机，主要是把这个钱投资到镜头或者灯上让我更高兴一点，手机厂商出的手机真是越来越烂了。不过把备用的 iPhone 8 换成了 iPhone XR，在二手频道看到一个成色很好，而且是红色款的，我早就觉得 iPhone 8 屏幕太小了。&lt;/p&gt;
&lt;p&gt;动漫也想不起来看过什么，今年也许只看了 EVA 最后一部剧场版和 love live superstar，反正看 EVA 就是大家都想看看他怎么收尾而已，总体来说还是不错，特别是看了纪录片之后。然后 love live 我以前没看过，我的评价就是挺好听的。然后我感觉在电影院看到 Fate/Stay Night HF 第三季的可能性应该是没了，特别是考虑到今年院线上的国外电影的比例……还能说什么呢懂得都懂哈哈。&lt;/p&gt;
&lt;p&gt;想不起来看过多少书，总之前段时间有天晚上睡不着，一口气把挪威的森林看完了，我早就买了这本书，但是以前都是打开看几页就看不下去了，这次一口气看完感觉还挺好的。&lt;/p&gt;
&lt;p&gt;今年的另一个好消息是 NVIDIA 驱动终于补全了 Wayland 支持，感谢所有在这个过程中努力的人，比如 NVIDIA 那个一直在处理相关事情的用蜗牛做头像的老哥，事情总要是靠人推进的嘛。不过回家之后莫名发现我的 Atom 在 XWayland 下面会疯狂地闪回，明明我自己住处的电脑也是一样的配置就没问题。然后这时候我发现 Emacs 的纯 GTK 分支已经合并进了主线，也就是说 Emacs 现在终于是纯 Wayland 程序了，我立刻搞了一个最新版本，然后捡起来以前的配置文件，又仔细研究仔细鼓捣，目前多少是堪用了，虽然还有不少地方不像 Atom 那么习惯，主要还是我懒得仔细研究，反正凑合用，我是真的怀念 Atom 上的一些功能，比如注释反注释代码块、移动代码块、方便的查找替换还有现代化的界面……Emacs 的界面元素感觉还是基于文本的，然后包括粗体字渲染感觉也不太光滑，比如 indent guide 或者 80 column ruler 这种东西就应该直接在界面上划线嘛，不要用字符做。不过我在用 Atom 的时候也怀念 Emacs 的一些功能比如纯键盘分屏和 C-SPC Mark Region。&lt;/p&gt;
&lt;p&gt;今年的游戏时间基本都拿来打 Dota 了，虽然看 TI 看得很难受，但是和朋友一起玩游戏还是挺快乐的，这也属于幸运和倒霉的周期了吧。塞尔达什么的，等我想起来慢慢玩……&lt;/p&gt;
&lt;p&gt;跨年的时候还是和去年一样朋友聚餐了，我还在 B 站上传了 vlog，和蓝猫铁道迷一起吃寿喜锅很开心。今年写代码没少让琪神当小黄鸭，谢谢琪神。&lt;/p&gt;
&lt;p&gt;总之先写这些，如果我又想起什么，我后面再慢慢加上吧，最近冻着了嗓子疼，希望倒霉的周期赶紧过去，过段时间还得找找机会去修相机呢……&lt;/p&gt;

    </content>
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    
    
    <category term="时光飞逝" label="时光飞逝" scheme="https://sh.alynx.one/tags/%E6%97%B6%E5%85%89%E9%A3%9E%E9%80%9D/" />
    
  </entry>
  
  
  
  <entry>
    <title>把我的时间戳还给我！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Please-Bring-back-My-Timestamp/" />
    <id>https://sh.alynx.one/posts/Please-Bring-back-My-Timestamp/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-11-09T01:19:55.000Z</published>
    
    
    <updated>2021-11-09T01:19:55.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;当然，我在标题里说的时间戳并不是狭义的 UNIX 时间戳，我只是想表达一下精确的时间记录而已。&lt;/p&gt;
&lt;p&gt;不知道从什么时候开始，许多网站都不再显示 &lt;code&gt;2021-11-09 09:00:00&lt;/code&gt; 这样精确的时间，而是开始显示“刚刚”、“5 分钟前”、“3 个月前”、“1 年前”，我能猜出来这又是哪些自以为聪明的产品经理以“对用户友好”的理由想出来的或者抄来的，但不幸的是大部分这种行为都很愚蠢。据我所知 Twitter 是这样，Twitter 做什么就抄什么的微博也是这样，令人难以忍受的是 GitHub 也是这样显示时间，以及今天彻底惹恼了我的 YouTube 在视频页面也是这样显示。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;当然，我在标题里说的时间戳并不是狭义的 UNIX 时间戳，我只是想表达一下精确的时间记录而已。&lt;/p&gt;
&lt;p&gt;不知道从什么时候开始，许多网站都不再显示 &lt;code&gt;2021-11-09 09:00:00&lt;/code&gt; 这样精确的时间，而是开始显示“刚刚”、“5 分钟前”、“3 个月前”、“1 年前”，我能猜出来这又是哪些自以为聪明的产品经理以“对用户友好”的理由想出来的或者抄来的，但不幸的是大部分这种行为都很愚蠢。据我所知 Twitter 是这样，Twitter 做什么就抄什么的微博也是这样，令人难以忍受的是 GitHub 也是这样显示时间，以及今天彻底惹恼了我的 YouTube 在视频页面也是这样显示。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;如果你还没搞清楚我的愤怒来源，我实际上是想做这样的事情：我知道索尼 A7S3 是在 2020 年 7 月发布，我想快速找到相关的视频，请问我怎么在这一大片的“1 年前”里猜到去年 7 月的大致位置？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Please-Bring-back-My-Timestamp/1.png&quot; alt=&quot;全都是 1 年前&quot;&gt;&lt;/p&gt;
&lt;p&gt;“1 年前”这个描述可以包含从“1 年零 1 天”到“1 年零 364 天”这样不精确的时间范围，我觉得和直接不显示时间范围也没什么区别了。或者像 GitHub 那样鼠标悬浮在上方显示时间戳的方案也不好，比如这个页面这么多视频，我的目的是一眼快速找到我需要的时间段，一个一个悬浮多慢？所谓的用户友好？不见得，用户要被气死了。人类的脑子还没弱到连算个大致的时间差都算不出来。从工程上来说，这还引入了额外的复杂度，比如有一个 JS 脚本是专门用来更新这些时间的，你需要引入额外的代码，才能保证从“刚刚”变成“7 秒前”、“10 秒前”、“不到一分钟”、“5 分钟前”（说的就是你 GitHub），哈哈，这简直太好笑了。更别提弱智的微博 API 竟然直接在 JSON 里面返回“X 分钟前”，不过反正这种互不联网说不定什么时候就把 API 给砍了。&lt;/p&gt;
&lt;p&gt;我觉得 Twitter 和微博这种本身就是短平快讲究时效性的网站使用大致的时间差而不是时间戳还算可以理解，至于 YouTube、 GitHub 这种经常需要查看精确时间的显示大致的时间差纯粹是给用户填堵，这一点 B 站经常脑残的前端反而做得不错，在视频页面显示的是精确的日期。&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    
    <category term="吐槽" label="吐槽" scheme="https://sh.alynx.one/tags/%E5%90%90%E6%A7%BD/" />
    
    <category term="愤怒" label="愤怒" scheme="https://sh.alynx.one/tags/%E6%84%A4%E6%80%92/" />
    
  </entry>
  
  
  
  <entry>
    <title>通过 USB HID over AOAv2 在 scrcpy 里模拟真实键盘</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/" />
    <id>https://sh.alynx.one/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-09-18T15:08:08.000Z</published>
    
    
    <updated>2021-09-19T04:01:45.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;这篇文章同时有 &lt;a href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;中文版本&lt;/a&gt; 和 &lt;a href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#EnglishVersion&quot;&gt;英文版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;This post is both available in &lt;a href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;Chinese version&lt;/a&gt; and &lt;a href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#EnglishVersion&quot;&gt;English version&lt;/a&gt;.&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;这篇文章同时有 &lt;a href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;中文版本&lt;/a&gt; 和 &lt;a href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#EnglishVersion&quot;&gt;英文版本&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;This post is both available in &lt;a href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;Chinese version&lt;/a&gt; and &lt;a href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#EnglishVersion&quot;&gt;English version&lt;/a&gt;.&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#%E4%B8%AD%E6%96%87%E7%89%88%E6%9C%AC&quot;&gt;&lt;/a&gt;中文版本&lt;/h1&gt;
&lt;p&gt;三年前（2018 年）我在 scrcpy 的 GitHub 仓库里提了 &lt;a href=&quot;https://github.com/Genymobile/scrcpy/issues/279&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这个 issue&lt;/a&gt;，因为我当时发现这个项目能把手机投屏到电脑上，也就是说我就可以在 Linux 下面通过 Android 手机聊 QQ 了（我当时大概也许还有高强度聊 QQ 的需求），不过试了之后发现很难用，因为它和直接在手机上插键盘不一样，显示的还是软键盘，虽然能通过电脑键盘触发输入法，但是却不能用数字键选词。我当时也不太懂，于是就发 issue 问开发者，&lt;a href=&quot;https://github.com/rom1v&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@rom1v&lt;/a&gt; 回复说 Android 有个叫 HID over AOA 的协议可以实现，但是对有些设备来说有 bug，同时也需要有人花时间读 USB 规范然后做把 SDL event 转换成 HID event 的工作。我又想那能不能直接用电脑的输入法生成字符然后传给手机，&lt;a href=&quot;https://github.com/rom1v&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@rom1v&lt;/a&gt; 表示现在就是这么做的，但是 Android 相关的 API 限制只能发送 ASCII 的字符，所以也行不通。&lt;/p&gt;
&lt;p&gt;我当时稍微了解了一下这些相关的东西，不过显然超出了我的能力范围，于是这件事我就搁置了。一直到最近或者准确的说就是上周和 Hackghost 跟我提起说苹果似乎打算做手机投屏到电脑的功能，然后又说华为好像有个现成的。不过我对这些一向是漠不关心的，这些厂商就是又懒又坏的典型，不会做一个 Linux 版的客户端的。如果他们自己做不了或者不打算做，那就应该公开一点，让能做的人来做而不是藏着掖着。然后就是我们讨论了一气关于成本到底谁付了谁亏了的问题，我坚持认为厂商赚得已经够多了，成本和利润 Linux 用户在买手机的时候也是照样付的，只是这些人贪得无厌能少付出成本就少付出一点而已。最后我说已经有能做的人做了 scrcpy 这个项目出来，投屏完全没问题，支持各种平台，美中不足就是输入体验不太好。这时候我又想已经过去很久了，不如我再试试去看看能不能解决输入体验的问题，于是就回去翻了这个 issue。&lt;/p&gt;
&lt;p&gt;运气不错，翻过去看到在 2019 年年初的时候 &lt;a href=&quot;https://github.com/amosbird&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@amosbird&lt;/a&gt; 已经写了一份代码，他自称是能用的，然而不知道为什么当初没有合并进主线，现在多半也是跑不起来。我一开始想我把他这个在当前的 HEAD 上重构一下就好了，于是开始读他的代码。一开始还是没什么头绪，看起来他似乎写了不止一个功能，但是都在一个 commit 里面，又没什么关于思路的注释。随后我加上了他的 Telegram，不过他本人表示时间有点久了他也不记得自己写的代码都是什么意思（笑）。于是我只能硬着头皮啃了，好在我现在的经验比以前涨了很多，然后再同时啃 USB 和 Android 的协议，配合一些搜到的其他资料，最终了解了大概是怎么回事。最开始本来以为简单地合并一下代码就可以了，没想到还发现了他代码里的错误，基本是变成重写了。花了头两天事件让程序跑起来，然后用了几天调整成和现有代码一致的风格以便合并进去。 &lt;em&gt;总之很是有一点新手村出来遇到 BOSS 暂时撤退，升级打怪三年之后杀回来的感觉。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;做好之后的效果基本就是下面两张截图，Gboard 开始工作在外接硬件键盘的模式了：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/1.png&quot; alt=&quot;1.png&quot;&gt;
&lt;img src=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;既然是 USB HID over AOAv2，那很显然需要知道 USB HID 是怎么回事，USB 官方有一个 &lt;a href=&quot;https://www.usb.org/document-library/device-class-definition-hid-111&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;很长的 PDF&lt;/a&gt; 规定怎么成为一个合法的 HID 设备，说实话，看不太下去。如果你想要查一些有帮助的例子，直接查 AOAv2 多半是没戏的，只有 &lt;a href=&quot;https://source.android.com/devices/accessories/aoa2&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Android 自己一个惜字如金的文档页&lt;/a&gt;，我的经验就是你找那些主题是用单片机模拟键盘鼠标的文章，他们的目标和这个基本是一致的。不过我说好不碰硬件的话看来是算作废了。&lt;/p&gt;
&lt;p&gt;基本上成为一个 USB HID 设备需要你发送一大堆的描述符到主机，不过我们这里有点不一样，因为 Android 设备连接电脑的时候，Android 是 USB 从设备，电脑是主设备，而 AOAv2 是从主机反向发数据到从设备，它不要求我们发送一大堆 USB 的描述符，只要向 Android 注册一个设备，发送 HID 的报告描述符，再发送 HID event，再注销就好了。这部分可以通过 libusb 这个库来实现 USB 的数据包传输，然后把 Android 的几个命令封装成函数就可以了，基本是在 &lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/aoa_hid.c#L155-L246&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/aoa_hid.c#L155-L246&lt;/a&gt; 这部分。&lt;/p&gt;
&lt;p&gt;基础的 API 有了之后则是具体的发什么数据包了，HID 的数据实际上就是由 byte 组成的 buffer，首先就是报告描述符，这个描述符是让主设备知道每个发过来的 event 里面的每个 byte 都是什么含义，键盘的描述符其实相对是比较固定的，在 &lt;a href=&quot;https://www.usb.org/document-library/device-class-definition-hid-111&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Device Class Definition for Human Interface Devices&lt;/a&gt; 这个 PDF 里面其实给了一个最简单的 USB 键盘的例子，这个也是保证在 BIOS 里面能正常使用 USB 键盘的最小集合，是在 Appendix B: Boot Interface Descriptors 下面的 B.1 Protocol 1 (Keyboard) 和 Appendix E: Example USB Descriptors for HID Class Devices 下面的 E.6 Report Descriptor (Keyboard)。不过有时候光知道这些还不够，比如报告描述符里面大部分都是两个 byte 一句话，第一个 byte 表示的是类别而第二个表示的是具体的值，后面的大概很好理解，但是第一个 byte 是怎么算出来的可能需要了解，这需要看那个 PDF 里 8. Report Protocol 这一节了，或者中文的话可以看 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/41960639&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这篇知乎文章&lt;/a&gt;，然后你就会明白为什么有时候看起来数字不一样结果含义却一样了，因为其实第一个 byte 的每个 bit 都是有分别的含义的。然后就是对于 Usage Tag 这个有很多，被放在 &lt;a href=&quot;https://usb.org/sites/default/files/hut1_22.pdf&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;另一个单独的 PDF&lt;/a&gt; 里面了。&lt;/p&gt;
&lt;p&gt;我还是把 &lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L28-L144&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L28-L144&lt;/a&gt; 这段代码贴过来好了，详细的说明我加在了注释里面：&lt;/p&gt;
&lt;figure data-raw=&quot;unsigned char kb_report_desc_buffer[]  = {
    // Usage Page (Generic Desktop)
    // 键盘这个字段应该是 Generic Desktop，为啥是这个我也不知道。
    0x05, 0x01,
    // Usage (Keyboard)
    // 也不用我解释了吧，自己查表去。
    0x09, 0x06,

    // Collection (Application)
    // 然后基本上 USB HID 描述符要有不同的 Collection，
    // 代表你发到主机的一组数据，
    // 一个设备最少有一个 Collection 吧，不然也没意义了。
    // 为啥是 Application 好像是因为 Keyboard 的 Usage Page tag 在这个里面。
    0xA1, 0x01,
    // Report ID (1)
    // 你会发现最基础的那个键盘示例里面没有这个字段，
    // 实际上当你只发一种数据的时候这个字段可以省略。
    // 但是现在是个机械键盘都带媒体控制按键吧，那个要算另一个 Collection 的，
    // 所以就通过 Report ID 区分，同时你发数据的时候第一个 byte 就得说明自己发的是哪个
    // Report ID。所以不要问为什么网上说 USB HID 键盘一个事件 8 个 byte 我们却发了 9 个。
    0x85, 0x01,

    // Usage Page (Keyboard)
    // 这里注意 Usage Page 和 Usage 不一样咯。好像这个文档里也叫 Key Codes 来着。
    0x05, 0x07,
    // Usage Minimum (224)
    // 一般来说一组报告数据包含很多用途，你不可能把所有的用途都列出来，给个用途范围就可以了。
    // 这里表示最小的用途 tag 是 0xE0，应该是 Left Control 的意思。
    0x19, 0xE0,
    // Usage Maximum (231)
    // 最大的用途 tag，是 Right GUI 键。这个 byte 的含义就是键盘上的八个修饰键。
    // Left Control，Right Control，Left Alt，Right Alt，Left Shift，Right Shift，
    // Left GUI，Right GUI。
    // 不过一定要记住 16 进制数转成 2 进制时候最右边是第 0 位，也就是说上边的顺序要倒过来。
    0x29, 0xE7,
    // Logical Minimum (0)
    // 每个 bit 的逻辑最小值当然是 0 啦。
    0x15, 0x00,
    // Logical Maximum (1)
    // 按下去就变成最大值 1。
    0x25, 0x01,
    // Report Size (1)
    // 每个数据只占 1 bit。
    0x75, 0x01,
    // Report Count (8)
    // 一共 8 个数据。
    0x95, 0x08,
    // Input (Data, Variable, Absolute): Modifier byte
    // 关于 Input tag 是什么意思太长了，自己查去吧，总之和上面那些要符合。
    0x81, 0x02,

    // 下面这段是厂商保留位，一般只要写一个为 0 的 byte 就可以了。
    // Report Size (8)
    0x75, 0x08,
    // Report Count (1)
    0x95, 0x01,
    // Input (Constant): Reserved byte
    0x81, 0x01,

    // 这部分表示主设备返回的关于 LED 灯亮的信号，
    // HID 键盘自己是不保存什么大写锁定的状态的。
    // 不过我们毕竟不是真的键盘，这部分抄一下就完事了，程序直接忽略。
    // 总之键盘上有 5 个灯，和上面的修饰键差不多，一个 bit 代表一个灯。
    // Usage Page (LEDs)
    0x05, 0x08,
    // Usage Minimum (1)
    0x19, 0x01,
    // Usage Maximum (5)
    0x29, 0x05,
    // Report Size (1)
    0x75, 0x01,
    // Report Count (5)
    0x95, 0x05,
    // Output (Data, Variable, Absolute): LED report
    0x91, 0x02,

    // 5 个 bit 对不齐，这 3 个 bit 是为了凑整的。
    // Report Size (3)
    0x75, 0x03,
    // Report Count (1)
    0x95, 0x01,
    // Output (Constant): LED report padding
    0x91, 0x01,

    // 下面就有意思了，键盘上有 101 个普通键，你肯定是不会同时按下 101 个键的，
    // 所以也不需要像修饰键那样每个 bit 代表一个键
    //（当然理论上你写个描述符说我这个键盘就是这样的也未尝不可啦），
    // 所以实际上这里返回的是一个数组，每个 byte 代表一个被按下去的键的键码。
    // Usage Page (Key Codes)
    0x05, 0x07,
    // Usage Minimum (0)
    // 用途最小值从不代表任何键的空值 0 开始。
    0x19, 0x00,
    // Usage Maximum (101)
    // 这里就是 101 啦，标准键盘上的按键数量，如果要支持非标准键盘自己查表去。
    0x29, HID_KEYBOARD_KEYS - 1,
    // Logical Minimum (0)
    // 因为每个 byte 放的都是键码，键码最小值是 0。
    0x15, 0x00,
    // Logical Maximum(101)
    // 最大值就是第 101 个键。
    0x25, HID_KEYBOARD_KEYS - 1,
    // Report Size (8)
    // 每个值都是 1 byte。
    0x75, 0x08,
    // Report Count (6)
    // 最基础的 USB 键盘一次最多能返回 6 个被同时按下的按键，
    // 你的 USB 键盘实际上很可能会告诉电脑它能报告更多，
    // 不过我们毕竟不是真的键盘，6 个键应该能满足大部分情况了。
    0x95, HID_KEYBOARD_MAX_KEYS,
    // Input (Data, Array): Keys
    // 这里也查表去吧，总之变成了 Array 而不是 Variable。
    // 一个 Collection 应该是只能有一个 Array，必须在末尾来着。
    0x81, 0x00,

    // End Collection
    // 这样我们代表正常键盘的 Collection 就结束了。
    0xC0,

    // Usage Page (Consumer)
    // 下面则是代表媒体控制的按键，他们属于另一个用途页了。
    0x05, 0x0C,
    // Usage (Consumer Control)
    // 这些键在另一个用途下面。
    0x09, 0x01,

    // Collection (Application)
    // 一个新的 Collection，数据和之前不一样了。
    0xA1, 0x01,
    // Report ID (2)
    // 一个新的 Report ID，
    // 所以这种 event 是 1 byte Report ID 和 1 byte 键码一共 2 byte。
    0x85, 0x02,

    // Usage Page (Consumer)
    // 下面的用途都算这里。
    0x05, 0x0C,
    // 这些和修饰键基本是一个意思，每个 bit 代表一个按键，不过这些用途不连贯了。
    // Usage (Scan Next Track)
    0x09, 0xB5,
    // Usage (Scan Previous Track)
    0x09, 0xB6,
    // Usage (Stop)
    0x09, 0xB7,
    // Usage (Eject)
    0x09, 0xB8,
    // Usage (Play/Pause)
    0x09, 0xCD,
    // Usage (Mute)
    0x09, 0xE2,
    // Usage (Volume Increment)
    0x09, 0xE9,
    // Usage (Volume Decrement)
    0x09, 0xEA,
    // 和修饰键差不多啦下面。
    // Logical Minimum (0)
    0x15, 0x00,
    // Logical Maximum (1)
    0x25, 0x01,
    // Report Size (1)
    0x75, 0x01,
    // Report Count (8)
    0x95, 0x08,
    // Input (Data, Array)
    0x81, 0x02,

    // End Collection
    0xC0
};
&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;unsigned char kb_report_desc_buffer[]  = {
    // Usage Page (Generic Desktop)
    // 键盘这个字段应该是 Generic Desktop，为啥是这个我也不知道。
    0x05, 0x01,
    // Usage (Keyboard)
    // 也不用我解释了吧，自己查表去。
    0x09, 0x06,

    // Collection (Application)
    // 然后基本上 USB HID 描述符要有不同的 Collection，
    // 代表你发到主机的一组数据，
    // 一个设备最少有一个 Collection 吧，不然也没意义了。
    // 为啥是 Application 好像是因为 Keyboard 的 Usage Page tag 在这个里面。
    0xA1, 0x01,
    // Report ID (1)
    // 你会发现最基础的那个键盘示例里面没有这个字段，
    // 实际上当你只发一种数据的时候这个字段可以省略。
    // 但是现在是个机械键盘都带媒体控制按键吧，那个要算另一个 Collection 的，
    // 所以就通过 Report ID 区分，同时你发数据的时候第一个 byte 就得说明自己发的是哪个
    // Report ID。所以不要问为什么网上说 USB HID 键盘一个事件 8 个 byte 我们却发了 9 个。
    0x85, 0x01,

    // Usage Page (Keyboard)
    // 这里注意 Usage Page 和 Usage 不一样咯。好像这个文档里也叫 Key Codes 来着。
    0x05, 0x07,
    // Usage Minimum (224)
    // 一般来说一组报告数据包含很多用途，你不可能把所有的用途都列出来，给个用途范围就可以了。
    // 这里表示最小的用途 tag 是 0xE0，应该是 Left Control 的意思。
    0x19, 0xE0,
    // Usage Maximum (231)
    // 最大的用途 tag，是 Right GUI 键。这个 byte 的含义就是键盘上的八个修饰键。
    // Left Control，Right Control，Left Alt，Right Alt，Left Shift，Right Shift，
    // Left GUI，Right GUI。
    // 不过一定要记住 16 进制数转成 2 进制时候最右边是第 0 位，也就是说上边的顺序要倒过来。
    0x29, 0xE7,
    // Logical Minimum (0)
    // 每个 bit 的逻辑最小值当然是 0 啦。
    0x15, 0x00,
    // Logical Maximum (1)
    // 按下去就变成最大值 1。
    0x25, 0x01,
    // Report Size (1)
    // 每个数据只占 1 bit。
    0x75, 0x01,
    // Report Count (8)
    // 一共 8 个数据。
    0x95, 0x08,
    // Input (Data, Variable, Absolute): Modifier byte
    // 关于 Input tag 是什么意思太长了，自己查去吧，总之和上面那些要符合。
    0x81, 0x02,

    // 下面这段是厂商保留位，一般只要写一个为 0 的 byte 就可以了。
    // Report Size (8)
    0x75, 0x08,
    // Report Count (1)
    0x95, 0x01,
    // Input (Constant): Reserved byte
    0x81, 0x01,

    // 这部分表示主设备返回的关于 LED 灯亮的信号，
    // HID 键盘自己是不保存什么大写锁定的状态的。
    // 不过我们毕竟不是真的键盘，这部分抄一下就完事了，程序直接忽略。
    // 总之键盘上有 5 个灯，和上面的修饰键差不多，一个 bit 代表一个灯。
    // Usage Page (LEDs)
    0x05, 0x08,
    // Usage Minimum (1)
    0x19, 0x01,
    // Usage Maximum (5)
    0x29, 0x05,
    // Report Size (1)
    0x75, 0x01,
    // Report Count (5)
    0x95, 0x05,
    // Output (Data, Variable, Absolute): LED report
    0x91, 0x02,

    // 5 个 bit 对不齐，这 3 个 bit 是为了凑整的。
    // Report Size (3)
    0x75, 0x03,
    // Report Count (1)
    0x95, 0x01,
    // Output (Constant): LED report padding
    0x91, 0x01,

    // 下面就有意思了，键盘上有 101 个普通键，你肯定是不会同时按下 101 个键的，
    // 所以也不需要像修饰键那样每个 bit 代表一个键
    //（当然理论上你写个描述符说我这个键盘就是这样的也未尝不可啦），
    // 所以实际上这里返回的是一个数组，每个 byte 代表一个被按下去的键的键码。
    // Usage Page (Key Codes)
    0x05, 0x07,
    // Usage Minimum (0)
    // 用途最小值从不代表任何键的空值 0 开始。
    0x19, 0x00,
    // Usage Maximum (101)
    // 这里就是 101 啦，标准键盘上的按键数量，如果要支持非标准键盘自己查表去。
    0x29, HID_KEYBOARD_KEYS - 1,
    // Logical Minimum (0)
    // 因为每个 byte 放的都是键码，键码最小值是 0。
    0x15, 0x00,
    // Logical Maximum(101)
    // 最大值就是第 101 个键。
    0x25, HID_KEYBOARD_KEYS - 1,
    // Report Size (8)
    // 每个值都是 1 byte。
    0x75, 0x08,
    // Report Count (6)
    // 最基础的 USB 键盘一次最多能返回 6 个被同时按下的按键，
    // 你的 USB 键盘实际上很可能会告诉电脑它能报告更多，
    // 不过我们毕竟不是真的键盘，6 个键应该能满足大部分情况了。
    0x95, HID_KEYBOARD_MAX_KEYS,
    // Input (Data, Array): Keys
    // 这里也查表去吧，总之变成了 Array 而不是 Variable。
    // 一个 Collection 应该是只能有一个 Array，必须在末尾来着。
    0x81, 0x00,

    // End Collection
    // 这样我们代表正常键盘的 Collection 就结束了。
    0xC0,

    // Usage Page (Consumer)
    // 下面则是代表媒体控制的按键，他们属于另一个用途页了。
    0x05, 0x0C,
    // Usage (Consumer Control)
    // 这些键在另一个用途下面。
    0x09, 0x01,

    // Collection (Application)
    // 一个新的 Collection，数据和之前不一样了。
    0xA1, 0x01,
    // Report ID (2)
    // 一个新的 Report ID，
    // 所以这种 event 是 1 byte Report ID 和 1 byte 键码一共 2 byte。
    0x85, 0x02,

    // Usage Page (Consumer)
    // 下面的用途都算这里。
    0x05, 0x0C,
    // 这些和修饰键基本是一个意思，每个 bit 代表一个按键，不过这些用途不连贯了。
    // Usage (Scan Next Track)
    0x09, 0xB5,
    // Usage (Scan Previous Track)
    0x09, 0xB6,
    // Usage (Stop)
    0x09, 0xB7,
    // Usage (Eject)
    0x09, 0xB8,
    // Usage (Play/Pause)
    0x09, 0xCD,
    // Usage (Mute)
    0x09, 0xE2,
    // Usage (Volume Increment)
    0x09, 0xE9,
    // Usage (Volume Decrement)
    0x09, 0xEA,
    // 和修饰键差不多啦下面。
    // Logical Minimum (0)
    0x15, 0x00,
    // Logical Maximum (1)
    0x25, 0x01,
    // Report Size (1)
    0x75, 0x01,
    // Report Count (8)
    0x95, 0x08,
    // Input (Data, Array)
    0x81, 0x02,

    // End Collection
    0xC0
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;所以基本上我们构建的虚拟键盘就告诉主设备它是这么报告数据的。里面除了要注意具体的数据之外第一个 byte 要放 Report ID 之外也没什么。然后就是怎么把 SDL 的事件转换成 HID 事件了，一开始看 &lt;a href=&quot;https://github.com/amosbird&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@amosbird&lt;/a&gt; 的代码，发现他把 HID event 理解成了和 SDL event 一样的东西了——有一个类似修饰键的数据和一个按下抬起的数据和一个具体哪个键的数据，用户按一个键就生成一个针对这个键单独的 event——但是其实不是，HID 键盘并不会直接告诉你哪个键按下还是抬起了，从上面的报告描述符也能看出来，实际上它是一个基于顺序的协议，比方说我按下了 C，给主机的事件可能是 &lt;code&gt;C键 00 00 00 00 00&lt;/code&gt;，又按下了 B，再发一个 &lt;code&gt;C键 B键 00 00 00 00&lt;/code&gt;，抬起来 C，再发一个 &lt;code&gt;B键 00 00 00 00 00&lt;/code&gt;，然后主机对比之前和之后的事件，得到“C 抬起了”或者“B 按下了”的信息，这才是我们司空见惯的“键盘事件”。所以在程序里面我们需要做个反向操作，把单独针对某个按键的按下抬起的数据变成一个“有哪些键按下”的数据。这里其实很简单，我们内部用一个数组保存当前的按键状态，每次有 SDL 的按键事件发来就更新状态（&lt;strong&gt;不是所有按键事件都是那 101 个键哦&lt;/strong&gt;），然后遍历这个数组，就可以利用哪些索引对应的值是 &lt;code&gt;true&lt;/code&gt; 生成 HID 事件的内容了，同时 HID 也不要求发送的按键在数组里的顺序和按下的顺序一致，而且 SDL 的 scancode 和 HID 的值是一致的。对于修饰键更简单，SDL 每个事件里面的修饰键和 HID 一样，都是包含当前所有修饰键的状态，只是具体的哪个 bit 表示哪个键不一样，转换一下就可以了（&lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L195-L223&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L195-L223&lt;/a&gt;）。&lt;strong&gt;但是千万不要因为发来的按键不是那 101 个键就直接忽略掉整个事件，因为可能用户只是单独按了一下修饰键，所以如果要跳过只要跳过更新按键状态就好了&lt;/strong&gt;（&lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L225-L269&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L225-L269&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;可能有聪明的小朋友要问了，你这最多只能发六个键，我按下七个怎么办？自己好好读一下 HID 协议就行了，这种情况下需要回一个 phantom state，具体就是修饰键一切照常，六个 key 全返回 &lt;code&gt;0x01&lt;/code&gt;（&lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L250-L259&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L250-L259&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;基本上看到这里已经可以成功的给 Android 手机发 HID 键盘事件了，另外就是如果你用桌面环境的话，媒体按键应该会被桌面环境拦截，所以其实我没有发媒体事件，scrcpy 是用组合键单独处理了一部分功能。然后就是一些收尾，比如 &lt;a href=&quot;https://github.com/amosbird&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@amosbird&lt;/a&gt; 忘记在程序结束之前取消注销 HID 设备了，这会导致如果你不拔掉 USB 线，触摸用的软键盘就一直出不来。&lt;/p&gt;
&lt;p&gt;最后 &lt;a href=&quot;https://github.com/rom1v&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@rom1v&lt;/a&gt; 表示 scrcpy 是在单独的线程里处理输入的，所以我也给 AOA 单独起了一个线程，这个只要照着 scrcpy 原本 controller 的线程抄一个就可以了。&lt;/p&gt;
&lt;p&gt;你要是问为什么不把鼠标也用 HID 的方式模拟进去的话，我可以告诉你我也试过了，效果并不算好，AOA 是可以注册不止一个 HID 设备的，只要你分配不同的 ID 并作为参数发过去就可以了，这一部分代码我都留好了。但是一个主要的问题是 HID 鼠标只汇报 X 和 Y 的变化量，导致比方说我把鼠标从 SDL 的窗口挪走，MotionEvent 停止，HID 鼠标就会停在边框上，这时候我再从另一个方向挪进窗口，HID 鼠标的指针和你本机的指针就不再同步了，体验不如 scrcpy 自己注入事件的方式，所以我放弃了。&lt;/p&gt;
&lt;p&gt;Windows 下面 libusb 似乎不能很好的连接 Android 手机发送数据，这个我没什么办法，看起来是个 &lt;a href=&quot;https://libusb-devel.narkive.com/vENuKzdR/getting-the-serial-number-of-the-camera-fails&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;陈年老 bug&lt;/a&gt;，考虑到我一开始的目的只是我自己能在 Linux 下面方便地聊 QQ，做成这样我觉得就可以了，我的代码逻辑正确，即使要修复，也不至于动 scrcpy 这部分而是动 libusb，&lt;a href=&quot;https://github.com/rom1v&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@rom1v&lt;/a&gt; 也表示现在就很不错了。&lt;/p&gt;
&lt;p&gt;当然因为依赖 USB，所以你利用 ADB over WiFi 的话就没办法用这个功能了，不过我用电脑时候一般会给手机充电，也无所谓。&lt;/p&gt;
&lt;p&gt;提交的 PR 链接是 &lt;a href=&quot;https://github.com/Genymobile/scrcpy/pull/2632/files&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/Genymobile/scrcpy/pull/2632/files&lt;/a&gt;，感觉是个大工程，最后实际上也就修改了一千行？不过确实挺难的。&lt;/p&gt;
&lt;hr&gt;
&lt;h1 id=&quot;EnglishVersion&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/#EnglishVersion&quot;&gt;&lt;/a&gt;English Version&lt;/h1&gt;
&lt;p&gt;(Title is Simulate Physical Keyboards in Scrcpy via USB HID over AOAv2.)&lt;/p&gt;
&lt;p&gt;Three years (2018) ago I opened an &lt;a href=&quot;https://github.com/Genymobile/scrcpy/issues/279&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;issue&lt;/a&gt; on scrcpy&#039;s GitHub repo, because I just found using scrcpy I can mirror my Android phone to computer and control it, so I could use QQ on Linux via my Android phone (I still had to use QQ frequently at that time), but after I tried it, I found it&#039;s inconvenient, because it shows soft keyboard on Android phone instead of simulating physical keyboard, I can trigger input method via typing but using numbers to choose words is not available. I know little about the code at that time and ask the maintainer for some reason, &lt;a href=&quot;https://github.com/rom1v&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@rom1v&lt;/a&gt; replied that there is a protocol called HID over AOA supported by Android can implement a physical keyboard, but there is a bug on some devices and needs some one take their time to read specifications and write some code to convert SDL event into HID event. Then I asked that how about using computer&#039;s IME and pass Chinese into Android, &lt;a href=&quot;https://github.com/rom1v&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@rom1v&lt;/a&gt; said that&#039;s what scrcpy did but Android has a limitation that you can only pass ASCII chars.&lt;/p&gt;
&lt;p&gt;I just tried reading some related things but it beyonds my ability, I just put it here. Until last week when I am talking with my friend Hackghost, he said Apple is making their own screen mirror implementation, and seems Huawei has one on their phone. I never care about Hardware manufacturer, neither Apple nor Huawei, because I think they are both lazy and evil, and they won&#039;t make a Linux client for their screen mirror implementation. If they are unable to make it, they should be open and allow users to do it by themselves. Then we talked about cost and profit, I insist that they have enough profit and Linux users also paid for their phone, so the feature should be available on Linux, but they are greedy and want more profit. Finally I said that there is already a hero who made scrcpy, and scrcpy runs on Windows, Linux and macOS, except for the bad IME experience. And I remebered it takes a long time after I opened the issue, maybe I should try again so I did it.&lt;/p&gt;
&lt;p&gt;I am lucky that &lt;a href=&quot;https://github.com/amosbird&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@amosbird&lt;/a&gt; already wrote some code in 2019 and he said it is able to work but he didn&#039;t send a PR, I guess it won&#039;t work now but I could refactor it to current HEAD so I start to read his code. At first I am wired that he implemented not only one feature in a single commit without any hinting about what he did. Then I managed to contact to him via Telegram, but he forget his code because 2 years past (lol). So I need to do it myself, I am more experienced that 3 years ago and I read USB and Android documents, with some other articles, I know what I should do. At first I think I just merge code, but finally I am re-writing because some mistakes in his code. It takes 2 days to make it work and some other days to tweak it. &lt;em&gt;Sounds like that you met a BOSS when you are a newbie and you escaped, fight to level up and come back after 3 years&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Those are screenshots of this feature:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/1.png&quot; alt=&quot;1.png&quot;&gt;
&lt;img src=&quot;/posts/Simulate-Physical-Keyboard-in-Scrcpy-via-USB-HID-over-AOAv2/2.png&quot; alt=&quot;2.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;So it&#039;s USB HID over AOAv2, you need to know what&#039;s USB HID, there is a &lt;a href=&quot;https://www.usb.org/document-library/device-class-definition-hid-111&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;long PDF&lt;/a&gt; from USB IF telling you how to be a HID device, it&#039;s hard to read. And if you want examples, typing AOAv2 in Google is useless, you can only &lt;a href=&quot;https://source.android.com/devices/accessories/aoa2&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;get a little page from Android&#039;s documents&lt;/a&gt;, I found that articles about simulating keyboard with single chip microcomputer (not sure whether this is the correct translation, some thing like Arduino or STM32) are helpful, however I&#039;ve said that I won&#039;t touch hardware, my words are fake now.&lt;/p&gt;
&lt;p&gt;Basically you need to send a lot of descriptors to host if you want to be a USB HID device, but things are different here. When you connect your Android phone to computer, your computer is the host and your Android is sub-device, AOAv2 is about sending data from host to sub-device, so we don&#039;t need most USB descriptors, just register a device to Android and send HID report descriptor, then send HID event, then unregister it. We can use libusb for data transfering and make some Android&#039;s command into functions, see &lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/aoa_hid.c#L155-L246&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/aoa_hid.c#L155-L246&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;After API we need to decide what to send, HID just sends buffer made of bytes, first is the report descriptor, telling host that what&#039;s the meaning of every bytes in event, keyboard has a basic example in &lt;a href=&quot;https://www.usb.org/document-library/device-class-definition-hid-111&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Device Class Definition for Human Interface Devices&lt;/a&gt; which could be used in BIOS, you need to read Appendix B: Boot Interface Descriptors, B.1 Protocol 1 (Keyboard) 和 Appendix E: Example USB Descriptors for HID Class Devices and Appendix E: Example USB Descriptors for HID Class Devices, E.6 Report Descriptor (Keyboard). But those are not enough, mostly two bytes in descriptor made one meaning, the first byte is about type and the second is value, if you want to know how to calculate the first bye, you need to read 8. Report Protocol, and then you&#039;ll know why sometimes different numbers have the same meaning because each bits of the byte have different meaning. And their are a lot of Usage tags, they are in &lt;a href=&quot;https://usb.org/sites/default/files/hut1_22.pdf&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;another PDF&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;I copy &lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L28-L144&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L28-L144&lt;/a&gt; here and add detailed meaning in comments:&lt;/p&gt;
&lt;figure data-raw=&quot;unsigned char kb_report_desc_buffer[]  = {
    // Usage Page (Generic Desktop)
    // I don&#039;t know why keyboard should be Generic Desktop.
    0x05, 0x01,
    // Usage (Keyboard)
    // Go to look up in the table.
    0x09, 0x06,

    // Collection (Application)
    // There are collections in descriptor,
    // they represent for data you send to computer.
    // A device should have at least 1 collection.
    // Keyboard&#039;s usage page tag is under Application.
    0xA1, 0x01,
    // Report ID (1)
    // You&#039;ll find there are no Report ID in the keyboard example,
    // because you can ignore it if you have only 1 collection.
    // But if your keyboard has media keys, they are in different collection.
    // So you need a Report ID and you send it as the first byte of event.
    // You know why we send 9 bytes in event while people say 8 for keyboards?
    0x85, 0x01,

    // Usage Page (Keyboard)
    // Usage Page is different from Usage.
    0x05, 0x07,
    // Usage Minimum (224)
    // You have many Usages in a collection, but you cannot list them all,
    // so you have a range from 224, which is Left Control.
    0x19, 0xE0,
    // Usage Maximum (231)
    // And end to 231, the Right GUI, those are 8 modifier keys.
    // Left Control，Right Control，Left Alt，Right Alt，Left Shift，Right Shift，
    // Left GUI，Right GUI。
    // But when you convert hex to binary, the right is bit 0,
    // so reverse the sequence.
    0x29, 0xE7,
    // Logical Minimum (0)
    // 0 is the minimum of a bit.
    0x15, 0x00,
    // Logical Maximum (1)
    // Press is the maximum 1.
    0x25, 0x01,
    // Report Size (1)
    // One key for one bit.
    0x75, 0x01,
    // Report Count (8)
    // 8 keys.
    0x95, 0x08,
    // Input (Data, Variable, Absolute): Modifier byte
    // Too long to describe what input means, please read the table,
    // should match the above.
    0x81, 0x02,

    // Reserved, just send a byte of 0.
    // Report Size (8)
    0x75, 0x08,
    // Report Count (1)
    0x95, 0x01,
    // Input (Constant): Reserved byte
    0x81, 0x01,

    // LEDs on keyboard, HID keyboard does not handle LED states itself.
    // This is not a real keyboard so just grab it from Internet.
    // 5 LEDs works like modifiers but output.
    // Usage Page (LEDs)
    0x05, 0x08,
    // Usage Minimum (1)
    0x19, 0x01,
    // Usage Maximum (5)
    0x29, 0x05,
    // Report Size (1)
    0x75, 0x01,
    // Report Count (5)
    0x95, 0x05,
    // Output (Data, Variable, Absolute): LED report
    0x91, 0x02,

    // 5 bits of LEDs are not aligned so add 3 bits as padding.
    // Report Size (3)
    0x75, 0x03,
    // Report Count (1)
    0x95, 0x01,
    // Output (Constant): LED report padding
    0x91, 0x01,

    // We have 101 normal keys on keyboards so you don&#039;t want to use 101 bits
    // for them (it might be OK but hard to write), so we return an array and
    // a byte is for a keycode.
    // Usage Page (Key Codes)
    0x05, 0x07,
    // Usage Minimum (0)
    // Minimum is 0 for no key pressed.
    0x19, 0x00,
    // Usage Maximum (101)
    // 101 is the max keycode on standard keyboard.
    0x29, HID_KEYBOARD_KEYS - 1,
    // Logical Minimum (0)
    // Bytes are keyboards and the minimum is 0.
    0x15, 0x00,
    // Logical Maximum(101)
    // Maximum is 101.
    0x25, HID_KEYBOARD_KEYS - 1,
    // Report Size (8)
    // Each key takes 1 byte.
    0x75, 0x08,
    // Report Count (6)
    // USB keyboards need to report 6 keys at lease,
    // your keyboard might tell your computer it can report more,
    // but 6 is mostly OK.
    0x95, HID_KEYBOARD_MAX_KEYS,
    // Input (Data, Array): Keys
    // Input is an array here, not a variable, array can only be the last
    // of a collecton.
    0x81, 0x00,

    // End Collection
    // Collection for keyboard is end.
    0xC0,

    // Usage Page (Consumer)
    // FOr media keys.
    0x05, 0x0C,
    // Usage (Consumer Control)
    0x09, 0x01,

    // Collection (Application)
    // A new collection because data format changes.
    0xA1, 0x01,
    // Report ID (2)
    // A new Report ID, so event has two bytes, first Report ID then keycode.
    0x85, 0x02,

    // Usage Page (Consumer)
    0x05, 0x0C,
    // Like the modifiers, but those usages are not consistent,
    // we have to list them here.
    // Usage (Scan Next Track)
    0x09, 0xB5,
    // Usage (Scan Previous Track)
    0x09, 0xB6,
    // Usage (Stop)
    0x09, 0xB7,
    // Usage (Eject)
    0x09, 0xB8,
    // Usage (Play/Pause)
    0x09, 0xCD,
    // Usage (Mute)
    0x09, 0xE2,
    // Usage (Volume Increment)
    0x09, 0xE9,
    // Usage (Volume Decrement)
    0x09, 0xEA,
    // Like modifiers.
    // Logical Minimum (0)
    0x15, 0x00,
    // Logical Maximum (1)
    0x25, 0x01,
    // Report Size (1)
    0x75, 0x01,
    // Report Count (8)
    0x95, 0x08,
    // Input (Data, Array)
    0x81, 0x02,

    // End Collection
    0xC0
};
&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;unsigned char kb_report_desc_buffer[]  = {
    // Usage Page (Generic Desktop)
    // I don&#039;t know why keyboard should be Generic Desktop.
    0x05, 0x01,
    // Usage (Keyboard)
    // Go to look up in the table.
    0x09, 0x06,

    // Collection (Application)
    // There are collections in descriptor,
    // they represent for data you send to computer.
    // A device should have at least 1 collection.
    // Keyboard&#039;s usage page tag is under Application.
    0xA1, 0x01,
    // Report ID (1)
    // You&#039;ll find there are no Report ID in the keyboard example,
    // because you can ignore it if you have only 1 collection.
    // But if your keyboard has media keys, they are in different collection.
    // So you need a Report ID and you send it as the first byte of event.
    // You know why we send 9 bytes in event while people say 8 for keyboards?
    0x85, 0x01,

    // Usage Page (Keyboard)
    // Usage Page is different from Usage.
    0x05, 0x07,
    // Usage Minimum (224)
    // You have many Usages in a collection, but you cannot list them all,
    // so you have a range from 224, which is Left Control.
    0x19, 0xE0,
    // Usage Maximum (231)
    // And end to 231, the Right GUI, those are 8 modifier keys.
    // Left Control，Right Control，Left Alt，Right Alt，Left Shift，Right Shift，
    // Left GUI，Right GUI。
    // But when you convert hex to binary, the right is bit 0,
    // so reverse the sequence.
    0x29, 0xE7,
    // Logical Minimum (0)
    // 0 is the minimum of a bit.
    0x15, 0x00,
    // Logical Maximum (1)
    // Press is the maximum 1.
    0x25, 0x01,
    // Report Size (1)
    // One key for one bit.
    0x75, 0x01,
    // Report Count (8)
    // 8 keys.
    0x95, 0x08,
    // Input (Data, Variable, Absolute): Modifier byte
    // Too long to describe what input means, please read the table,
    // should match the above.
    0x81, 0x02,

    // Reserved, just send a byte of 0.
    // Report Size (8)
    0x75, 0x08,
    // Report Count (1)
    0x95, 0x01,
    // Input (Constant): Reserved byte
    0x81, 0x01,

    // LEDs on keyboard, HID keyboard does not handle LED states itself.
    // This is not a real keyboard so just grab it from Internet.
    // 5 LEDs works like modifiers but output.
    // Usage Page (LEDs)
    0x05, 0x08,
    // Usage Minimum (1)
    0x19, 0x01,
    // Usage Maximum (5)
    0x29, 0x05,
    // Report Size (1)
    0x75, 0x01,
    // Report Count (5)
    0x95, 0x05,
    // Output (Data, Variable, Absolute): LED report
    0x91, 0x02,

    // 5 bits of LEDs are not aligned so add 3 bits as padding.
    // Report Size (3)
    0x75, 0x03,
    // Report Count (1)
    0x95, 0x01,
    // Output (Constant): LED report padding
    0x91, 0x01,

    // We have 101 normal keys on keyboards so you don&#039;t want to use 101 bits
    // for them (it might be OK but hard to write), so we return an array and
    // a byte is for a keycode.
    // Usage Page (Key Codes)
    0x05, 0x07,
    // Usage Minimum (0)
    // Minimum is 0 for no key pressed.
    0x19, 0x00,
    // Usage Maximum (101)
    // 101 is the max keycode on standard keyboard.
    0x29, HID_KEYBOARD_KEYS - 1,
    // Logical Minimum (0)
    // Bytes are keyboards and the minimum is 0.
    0x15, 0x00,
    // Logical Maximum(101)
    // Maximum is 101.
    0x25, HID_KEYBOARD_KEYS - 1,
    // Report Size (8)
    // Each key takes 1 byte.
    0x75, 0x08,
    // Report Count (6)
    // USB keyboards need to report 6 keys at lease,
    // your keyboard might tell your computer it can report more,
    // but 6 is mostly OK.
    0x95, HID_KEYBOARD_MAX_KEYS,
    // Input (Data, Array): Keys
    // Input is an array here, not a variable, array can only be the last
    // of a collecton.
    0x81, 0x00,

    // End Collection
    // Collection for keyboard is end.
    0xC0,

    // Usage Page (Consumer)
    // FOr media keys.
    0x05, 0x0C,
    // Usage (Consumer Control)
    0x09, 0x01,

    // Collection (Application)
    // A new collection because data format changes.
    0xA1, 0x01,
    // Report ID (2)
    // A new Report ID, so event has two bytes, first Report ID then keycode.
    0x85, 0x02,

    // Usage Page (Consumer)
    0x05, 0x0C,
    // Like the modifiers, but those usages are not consistent,
    // we have to list them here.
    // Usage (Scan Next Track)
    0x09, 0xB5,
    // Usage (Scan Previous Track)
    0x09, 0xB6,
    // Usage (Stop)
    0x09, 0xB7,
    // Usage (Eject)
    0x09, 0xB8,
    // Usage (Play/Pause)
    0x09, 0xCD,
    // Usage (Mute)
    0x09, 0xE2,
    // Usage (Volume Increment)
    0x09, 0xE9,
    // Usage (Volume Decrement)
    0x09, 0xEA,
    // Like modifiers.
    // Logical Minimum (0)
    0x15, 0x00,
    // Logical Maximum (1)
    0x25, 0x01,
    // Report Size (1)
    0x75, 0x01,
    // Report Count (8)
    0x95, 0x08,
    // Input (Data, Array)
    0x81, 0x02,

    // End Collection
    0xC0
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;So our keyboard sends this to host. The only thing you need to remember is send Report ID as the first byte of event. Then how to convert SDL event into HID event? Firstly I read &lt;a href=&quot;https://github.com/amosbird&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@amosbird&lt;/a&gt;&#039;s code and he thinks HID event is like SDL event——one field for modifiers and another field for press/release and one field for which key, an event represents for one single key——but it&#039;s not, HID keyboards won&#039;t tell you which key is pressed or release, it&#039;s based on sequence, for example I press C first, it sends &lt;code&gt;C 00 00 00 00 00&lt;/code&gt;, then I press B, sends &lt;code&gt;C B 00 00 00 00&lt;/code&gt;, release C, sends &lt;code&gt;B 00 00 00 00 00&lt;/code&gt;, the host is responsible for comparing the events and getting info like &quot;B pressed&quot; or &quot;C released&quot;. So we need to convert it back to &quot;what are pressed keys&quot;, it&#039;s simple, just use an array for state of current keys, update it when a SDL event is fired (&lt;strong&gt;not all key events are the 101 keys&lt;/strong&gt;), then iterate the array to generate a event contains the indices of &lt;code&gt;true&lt;/code&gt;, the sequence of keys does not matter in HID and SDL&#039;s scancode is the same as HID values. For modifiers are easier, every SDL events contains all modifiers just like HID events, they are just different in bits, so we do a convert (&lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L195-L223&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L195-L223&lt;/a&gt;). &lt;strong&gt;But don&#039;t ignore events just because it&#039;s not inside the 101 keys! User may just press a modifer, and we only skip updating keys state here&lt;/strong&gt; (&lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L225-L269&gt;&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L225-L269&amp;gt;&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;You may ask that what will happen if I press 7 keys at the same time? HID requires to report a phantom state, which fills &lt;code&gt;0x01&lt;/code&gt; as all 6 keys (&lt;a href=&quot;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L250-L259&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/AlynxZhou/scrcpy/blob/dev/app/src/hid_keyboard.c#L250-L259&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;We almost done it, and if you have a DE, media keys should be caught by it before SDL, so I never send it in code. Scrcpy uses some combination keys for it. And some cleaning, for example &lt;a href=&quot;https://github.com/amosbird&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@amosbird&lt;/a&gt; forget to unregister HID device before program exitting, and you cannot use soft keybaords until you disconnect the USB cable.&lt;/p&gt;
&lt;p&gt;At last &lt;a href=&quot;https://github.com/rom1v&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@rom1v&lt;/a&gt; says scrcpy uses another thread for input, so I make a thread for AOA, too. Just grab the code from controller.&lt;/p&gt;
&lt;p&gt;You may ask about HID mouse, I&#039;ve tried it, not good, AOA can register different HID devices, just pass different ID as argument, I have those code. But the biggest problem is that HID mouse only report the delta of X and Y, if I move the mouse outside the window from left edge, MotionEvent stops, the HID cursor will stop on the edge, and then I move my mouse inside the window from right edge, the HID cursor then loses sync with my mouse. The typicall scrcpy injection events work better so I give up.&lt;/p&gt;
&lt;p&gt;libusb has &lt;a href=&quot;https://libusb-devel.narkive.com/vENuKzdR/getting-the-serial-number-of-the-camera-fails&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;an old bug&lt;/a&gt; on Windows so this cannot work on windows, I have no idea and because at first I just want to use QQ on Linux, I think it&#039;s OK, so does &lt;a href=&quot;https://github.com/rom1v&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;@rom1v&lt;/a&gt;. My code is correct and once libusb fixed it, my code should not be updated I think.&lt;/p&gt;
&lt;p&gt;However you need USB and this won&#039;t work with ADB over WiFi, I typically charge my phone while using computer so it&#039;s not a problem for me.&lt;/p&gt;
&lt;p&gt;PR is &lt;a href=&quot;https://github.com/Genymobile/scrcpy/pull/2632/files&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/Genymobile/scrcpy/pull/2632/files&lt;/a&gt;, only 1 thousand lines? I spend a lot of time on it.&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    
    <category term="Android" label="Android" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/Android/" />
    
    
    <category term="Android" label="Android" scheme="https://sh.alynx.one/tags/Android/" />
    
  </entry>
  
  
  
  <entry>
    <title>Fontconfig 和 Noto Color Emoji 和抗锯齿</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fontconfig-NotoColorEmoji-Antialias/" />
    <id>https://sh.alynx.one/posts/Fontconfig-NotoColorEmoji-Antialias/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-09-08T01:33:33.000Z</published>
    
    
    <updated>2021-09-08T01:33:33.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我一直用的是以前积攒的一份 fontconfig 配置，主要功能就是设置对于无衬线字体优先用 Roboto 显示英文字体，然后回退到 Noto Sans CJK SC 显示中文字体，因为 Roboto 比 Noto 的英文字好看，以及对等宽字体优先用 Monaco。虽然大部分都是网上抄来的，我自己并不太懂，但是这个配置一直工作的还可以。直到我开启了 RIME 内置的 emoji 输入法，发现 emoji 显示成了空白。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我一直用的是以前积攒的一份 fontconfig 配置，主要功能就是设置对于无衬线字体优先用 Roboto 显示英文字体，然后回退到 Noto Sans CJK SC 显示中文字体，因为 Roboto 比 Noto 的英文字好看，以及对等宽字体优先用 Monaco。虽然大部分都是网上抄来的，我自己并不太懂，但是这个配置一直工作的还可以。直到我开启了 RIME 内置的 emoji 输入法，发现 emoji 显示成了空白。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;一开始没觉得是什么很难解决的问题，在字体列表末尾加上 Noto Color Emoji 不就行了？不过事情要是真的这么简单，也就没必要写个博客记下来了。忘记当时怎么查的了，总之是搜到 &lt;a href=&quot;https://bugzilla.mozilla.org/show_bug.cgi?id=1454152&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;一个 firefox 的 bug&lt;/a&gt;，提 bug 的人表示自己一直是开着 hintfull 和 antialias 的，关掉这个 Noto Color Emoji 才能显示。于是我看了一眼我的配置，也有这么一段：&lt;/p&gt;
&lt;figure data-raw=&quot;&lt;!-- 针对所有字体的默认设置，力求显示效果最好。 --&gt;
&lt;match target=&amp;quot;font&amp;quot;&gt;
  &lt;!-- 禁用内嵌点阵。 --&gt;
  &lt;edit name=&amp;quot;embeddedbitmap&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;false&lt;/bool&gt;
  &lt;/edit&gt;
  &lt;!-- 禁用合成粗体。 --&gt;
  &lt;edit name=&amp;quot;embolden&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;false&lt;/bool&gt;
  &lt;/edit&gt;
  &lt;!-- 设置显示器为 RGB 排列。 --&gt;
  &lt;edit name=&amp;quot;rgba&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;const&gt;rgb&lt;/const&gt;
  &lt;/edit&gt;
  &lt;!-- 开启轻度微调。 --&gt;
  &lt;edit name=&amp;quot;hinting&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;true&lt;/bool&gt;
  &lt;/edit&gt;
  &lt;edit name=&amp;quot;autohint&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;true&lt;/bool&gt;
  &lt;/edit&gt;
  &lt;edit name=&amp;quot;hintstyle&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;const&gt;hintslight&lt;/const&gt;
  &lt;/edit&gt;
  &lt;!-- 开启抗锯齿。 --&gt;
  &lt;edit name=&amp;quot;antialias&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;true&lt;/bool&gt;
  &lt;/edit&gt;
&lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- 针对所有字体的默认设置，力求显示效果最好。 --&amp;gt;
&amp;lt;match target=&quot;font&quot;&amp;gt;
  &amp;lt;!-- 禁用内嵌点阵。 --&amp;gt;
  &amp;lt;edit name=&quot;embeddedbitmap&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;!-- 禁用合成粗体。 --&amp;gt;
  &amp;lt;edit name=&quot;embolden&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;!-- 设置显示器为 RGB 排列。 --&amp;gt;
  &amp;lt;edit name=&quot;rgba&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;const&amp;gt;rgb&amp;lt;/const&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;!-- 开启轻度微调。 --&amp;gt;
  &amp;lt;edit name=&quot;hinting&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;edit name=&quot;autohint&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;edit name=&quot;hintstyle&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;const&amp;gt;hintslight&amp;lt;/const&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;!-- 开启抗锯齿。 --&amp;gt;
  &amp;lt;edit name=&quot;antialias&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;那我觉得针对 Noto Color Emoji 关掉这几个选项就行了，正好这个 bug 下面就有人提供了配置：&lt;/p&gt;
&lt;figure data-raw=&quot;&lt;!-- Noto Color Emoji 不支持开启抗锯齿和微调，所以在全局开启之后还得给它关掉。 --&gt;
&lt;match target=&amp;quot;font&amp;quot;&gt;
  &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
    &lt;string&gt;Noto Color Emoji&lt;/string&gt;
  &lt;/test&gt;
  &lt;edit name=&amp;quot;scalable&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;true&lt;/bool&gt;
  &lt;/edit&gt;
  &lt;edit name=&amp;quot;embeddedbitmap&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;true&lt;/bool&gt;
  &lt;/edit&gt;
  &lt;edit name=&amp;quot;hinting&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;false&lt;/bool&gt;
  &lt;/edit&gt;
  &lt;edit name=&amp;quot;antialias&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
    &lt;bool&gt;false&lt;/bool&gt;
  &lt;/edit&gt;
&lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;!-- Noto Color Emoji 不支持开启抗锯齿和微调，所以在全局开启之后还得给它关掉。 --&amp;gt;
&amp;lt;match target=&quot;font&quot;&amp;gt;
  &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
    &amp;lt;string&amp;gt;Noto Color Emoji&amp;lt;/string&amp;gt;
  &amp;lt;/test&amp;gt;
  &amp;lt;edit name=&quot;scalable&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;edit name=&quot;embeddedbitmap&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;edit name=&quot;hinting&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
  &amp;lt;edit name=&quot;antialias&quot; mode=&quot;assign&quot;&amp;gt;
    &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
  &amp;lt;/edit&amp;gt;
&amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;重新登录，输入法里面的 emoji 都显示出来了，我以为事情到这里就结束了，没想到噩梦才刚刚开始……&lt;/p&gt;
&lt;p&gt;某一天用 firefox 打开 twitter，发现里面字体都是毛毛糙糙的，我觉得很离奇，明明我只是对 Noto Color Emoji 关了抗锯齿，为什么 twitter 的字体也受到影响了？而且其他页面的字体都是正常的，后来我又打开过一个微软的文档页面，也出现了类似的毛病。我研究了一下发现这两个页面都用了自定义的 webfont。可是 webfont 和 Noto Color Emoji 有什么关系？人类摸不着头发。&lt;/p&gt;
&lt;p&gt;我查了很多博客文章，不过它们都关注在正常的字体顺序上，还没有人研究 webfont 有什么问题。于是我只能自己研究，不过我不能保证我对 fontconfig 的理解完全正确，这东西看起来非常复杂，不过我还是大致搞清楚了一些事情。引用我看到的 &lt;a href=&quot;https://eev.ee/blog/2015/05/20/i-stared-into-the-fontconfig-and-the-fontconfig-stared-back-at-me/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;一篇英文博客&lt;/a&gt; 的标题：&lt;/p&gt;
&lt;div class=&quot;centerquote&quot;&gt;
当我凝视着 fontconfig 时，fontconfig 也在凝视着我。
&lt;/div&gt;

&lt;p&gt;首先我找到了这个叫 &lt;a href=&quot;http://marguerite.su/posts/fontconfig_%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;fontconfig 几个常见的坑&lt;/a&gt; 的文章，里面信息量挺大的，不过说实话没有解决掉我的问题——我明明只对匹配到 Noto Color Emoji 时候关掉了抗锯齿，为什么 webfont 也受到影响了呢？这篇文章主要介绍怎么调整字体列表顺序，不过说实话我没有遇到那么多障碍，简单的写法就工作了。同一个作者还写了 &lt;a href=&quot;http://marguerite.su/posts/color_emoji_in_opensuse/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Color Emoji in openSUSE&lt;/a&gt; 的文章，不过总感觉是交待到一半，翻了文章列表没有后续了。而且这篇文章关心的也是字体 fallback 时候某些字符选到错误的字体的问题，和我这个不太相关。&lt;/p&gt;
&lt;p&gt;然后还有 &lt;a href=&quot;https://catcat.cc/post/2020-10-31/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Linux fontconfig 的字体匹配&lt;/a&gt; 这篇文章，它介绍了浏览器是怎么和 fontconfig 合作匹配字体的，但是对于 webfont 也是没有提到。包括它的后续文章 &lt;a href=&quot;https://catcat.cc/post/2021-03-07/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;用 fontconfig 治理 Linux 中的字体&lt;/a&gt; 也没提到和 Noto Color Emoji 相关的调整（可能和它用的 Twemoji 有关系）。&lt;/p&gt;
&lt;p&gt;然后我尝试按照文章里的办法对 firefox 进行一个 fontconfig 的调试，&lt;code&gt;FC_DEBUG=4 firefox --new-instance --private-window https://twitter.com/&lt;/code&gt; 直接吐了 12 万行输出，我实在是不知道从哪里看了。翻了一下午胡乱修改了好几次配置也没找出来哪里有问题。就在我眼花的时候偶然看到一条有用的，fontconfig 吐出来一个匹配结果，family 是 &lt;code&gt;Roboto, Noto Sans CJK SC, Noto Color Emoji, sans-serif…&lt;/code&gt; 等等一长串，style 是 &lt;code&gt;¶&lt;/code&gt;。这个就很有趣了，因为我看 firefox 里面，twitter 用的 webfont 叫 TwitterChirp，它的 style 也是这么个 &lt;code&gt;¶&lt;/code&gt;（我怀疑是个 bug），那这条可能就是相关的了。然后我发现这个匹配结果下面 antialias 是 false，但理论上来说这条又不是最先匹配到 Noto Color Emoji，怎么会应用 Noto Color Emoji 的设置呢？我猜测是因为默认 test 语句是 &lt;code&gt;qual=&quot;any&quot;&lt;/code&gt; 含义似乎是只要匹配到的有一个满足就应用，正常匹配一个字体应该是不会返回这么一长串 family 的（我用 &lt;code&gt;fc-match&lt;/code&gt; 一般只返回一个符合条件的 &lt;code&gt;family&lt;/code&gt;），虽然我不知道为什么 webfont 会返回这么一长串结果，总之我改成 &lt;code&gt;qual=&quot;all&quot;&lt;/code&gt; 也就是必须所有结果都是 Noto Color Emoji 时候才应用就好了对吧！然后重新登录，emoji 能显示，我以为已经胜利了！结果事情证明是半场开香槟……&lt;/p&gt;
&lt;p&gt;当我以为完全没问题，正打算用 atom 整理一下这份配置的时候，突然发现不对劲了……Atom里面的中文字体失去了抗锯齿……你可以想像我当时心情有多绝望。具体为什么还是同样的我不知道，不过我猜测恰好是和 &lt;a href=&quot;https://catcat.cc/post/2020-10-31/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Linux fontconfig 的字体匹配&lt;/a&gt; 里面提到的 chromium 查询字体的奇葩逻辑有关系……可能只是它某次查询刚好漏掉了 Noto Sans CJK SC 匹配到了 Noto Color Emoji 然后就给了个 antialias false，然后再通过什么奇怪的 UI 字体查询找出了中文字体……反正总之我的心好累，我实在不知道该怎么解决了，我只想用个 emoji，我甚至还给 Noto Color Emoji 提了请求支持抗锯齿的 issue……然后我决定要不换成 Twemoji 算了。&lt;/p&gt;
&lt;p&gt;Twemoji 倒也不是开箱即用，它不能禁用内嵌点阵字体，不过好歹这个不像抗锯齿那么要命，就算影响了其他字体大概也许能够忽略吧……于是我改成了这个。不过这时候我突然灵光一闪有了新主意。&lt;/p&gt;
&lt;p&gt;按照前面那几篇博客和 &lt;a href=&quot;http://www.jinbuguo.com/gui/fonts.conf.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;这一篇手册翻译&lt;/a&gt; 的讲解，fontconfig match 的 target 分为三个阶段，第一是 scan，扫描字体文件，构建一个集合。然后是 pattern，按照规则构建一个字体列表。最后是 font，意味着已经挑出了需要的字体列表。所以调整字体回退顺序一般都放在 pattern 阶段。而网上大部分都把对于 freetype2 微调的选项放在了 font 阶段，不过我想放在 scan 阶段是不是也可以？这样扫描到 Noto Color Emoji 的时候就对它设置选项，也就不存在 family 列表可能有很多项的问题了。测试了一下发现基本一切正常，于是就把所有 freetype2 微调选项移到了 scan 阶段。（我不是 fontconfig 的专家，这一段要是有错误还希望指正。）&lt;/p&gt;
&lt;p&gt;下面是我现在的配置，首先我配置文件放的位置是 &lt;code&gt;/etc/fonts/local.conf&lt;/code&gt;，因为 &lt;code&gt;/etc/fonts/fonts.conf&lt;/code&gt; 是发行版默认的设置，用来加载其他配置文件所以不能改，然后我想对所有用户都生效，所以没有放在我的家目录，Arch Linux 包含一个 &lt;code&gt;/etc/fonts/conf.d/51-local.conf&lt;/code&gt; 文件，&lt;code&gt;/etc/fonts/fonts.conf&lt;/code&gt; 会加载它，然后它再加载 &lt;code&gt;/etc/fonts/local.conf&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;首先是 XML 开头必须要有的那些东西：&lt;/p&gt;
&lt;figure data-raw=&quot;&lt;?xml version=&amp;quot;1.0&amp;quot;?&gt;
&lt;!DOCTYPE fontconfig SYSTEM &amp;quot;fonts.dtd&amp;quot;&gt;
&lt;fontconfig&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;?xml version=&quot;1.0&quot;?&amp;gt;
&amp;lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&amp;gt;
&amp;lt;fontconfig&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后接下来就是针对所有字体的 freetype2 微调选项，按照上面介绍的放在 scan 阶段：&lt;/p&gt;
&lt;figure data-raw=&quot;  &lt;!-- 针对所有字体的默认设置，力求显示效果最好。 --&gt;
  &lt;match target=&amp;quot;scan&amp;quot;&gt;
    &lt;!-- 禁用内嵌点阵。 --&gt;
    &lt;edit name=&amp;quot;embeddedbitmap&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;false&lt;/bool&gt;
    &lt;/edit&gt;
    &lt;!-- 禁用合成粗体。 --&gt;
    &lt;edit name=&amp;quot;embolden&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;false&lt;/bool&gt;
    &lt;/edit&gt;
    &lt;!-- 设置显示器为 RGB 排列。 --&gt;
    &lt;edit name=&amp;quot;rgba&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;const&gt;rgb&lt;/const&gt;
    &lt;/edit&gt;
    &lt;!-- 开启轻度微调。 --&gt;
    &lt;edit name=&amp;quot;hinting&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;true&lt;/bool&gt;
    &lt;/edit&gt;
    &lt;edit name=&amp;quot;autohint&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;true&lt;/bool&gt;
    &lt;/edit&gt;
    &lt;edit name=&amp;quot;hintstyle&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;const&gt;hintslight&lt;/const&gt;
    &lt;/edit&gt;
    &lt;!-- 开启抗锯齿。 --&gt;
    &lt;edit name=&amp;quot;antialias&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;true&lt;/bool&gt;
    &lt;/edit&gt;
  &lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!-- 针对所有字体的默认设置，力求显示效果最好。 --&amp;gt;
  &amp;lt;match target=&quot;scan&quot;&amp;gt;
    &amp;lt;!-- 禁用内嵌点阵。 --&amp;gt;
    &amp;lt;edit name=&quot;embeddedbitmap&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;!-- 禁用合成粗体。 --&amp;gt;
    &amp;lt;edit name=&quot;embolden&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;!-- 设置显示器为 RGB 排列。 --&amp;gt;
    &amp;lt;edit name=&quot;rgba&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;const&amp;gt;rgb&amp;lt;/const&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;!-- 开启轻度微调。 --&amp;gt;
    &amp;lt;edit name=&quot;hinting&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;edit name=&quot;autohint&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;edit name=&quot;hintstyle&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;const&amp;gt;hintslight&amp;lt;/const&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;!-- 开启抗锯齿。 --&amp;gt;
    &amp;lt;edit name=&quot;antialias&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;内嵌点阵的效果通常没有矢量绘制的效果好，合成粗体也只是个临时方案，微调什么的见仁见智了就。&lt;/p&gt;
&lt;p&gt;然后对于 Twemoji 要打开内嵌点阵：&lt;/p&gt;
&lt;figure data-raw=&quot;  &lt;!-- 当然另一个简单方案是换成 Twemoji，不过它不能关这个。 --&gt;
  &lt;match target=&amp;quot;scan&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;Twemoji&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;embeddedbitmap&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;true&lt;/bool&gt;
    &lt;/edit&gt;
  &lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!-- 当然另一个简单方案是换成 Twemoji，不过它不能关这个。 --&amp;gt;
  &amp;lt;match target=&quot;scan&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;Twemoji&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;embeddedbitmap&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;对于 Noto Color Emoji 也是打开内嵌点阵关闭微调和抗锯齿：&lt;/p&gt;
&lt;figure data-raw=&quot;  &lt;!-- Noto Color Emoji 不支持开启抗锯齿和微调，所以在全局开启之后还得给它关掉。 --&gt;
  &lt;match target=&amp;quot;scan&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;Noto Color Emoji&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;scalable&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;true&lt;/bool&gt;
    &lt;/edit&gt;
    &lt;edit name=&amp;quot;embeddedbitmap&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;true&lt;/bool&gt;
    &lt;/edit&gt;
    &lt;edit name=&amp;quot;hinting&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;false&lt;/bool&gt;
    &lt;/edit&gt;
    &lt;edit name=&amp;quot;antialias&amp;quot; mode=&amp;quot;assign&amp;quot;&gt;
      &lt;bool&gt;false&lt;/bool&gt;
    &lt;/edit&gt;
  &lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!-- Noto Color Emoji 不支持开启抗锯齿和微调，所以在全局开启之后还得给它关掉。 --&amp;gt;
  &amp;lt;match target=&quot;scan&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;Noto Color Emoji&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;scalable&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;edit name=&quot;embeddedbitmap&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;true&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;edit name=&quot;hinting&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
    &amp;lt;edit name=&quot;antialias&quot; mode=&quot;assign&quot;&amp;gt;
      &amp;lt;bool&amp;gt;false&amp;lt;/bool&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我个人还有一个需求，Monaco 作为一个等宽字体竟然支持连字，导致某次我看别人的代码时候 &lt;code&gt;fi&lt;/code&gt; 连在一起让我以为他没有对齐缩进，结果人家说是我的问题，十分尴尬，于是我在这里关掉了它。不过有些程序比如 firefox 是不支持这个的，解决方法是用 FontForge 编辑字体文件删掉连字相关的数据再导出……&lt;/p&gt;
&lt;figure data-raw=&quot;  &lt;!-- 我真不理解一个等宽字体要连字功能干嘛？故意变得不等宽？ --&gt;
  &lt;match target=&amp;quot;scan&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;Monaco&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;fontfeatures&amp;quot; mode=&amp;quot;append&amp;quot;&gt;
      &lt;string&gt;liga off&lt;/string&gt;
      &lt;string&gt;dlig off&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!-- 我真不理解一个等宽字体要连字功能干嘛？故意变得不等宽？ --&amp;gt;
  &amp;lt;match target=&quot;scan&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;Monaco&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;fontfeatures&quot; mode=&quot;append&quot;&amp;gt;
      &amp;lt;string&amp;gt;liga off&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;dlig off&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后就是常见的默认字体代称（sans-serif，serif，monospace，emoji）回退列表了，我是按照 &lt;code&gt;Roboto/Roboto Slab/Monaco -&amp;gt; Noto Sans/Serif (Mono) CJK SC -&amp;gt; Noto Color Emoji&lt;/code&gt; 的顺序回退的：&lt;/p&gt;
&lt;figure data-raw=&quot;  &lt;!-- 下面这一系列等同于 alias。 --&gt;
  &lt;!-- 默认无衬线字体。 --&gt;
  &lt;match target=&amp;quot;pattern&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;sans&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;family&amp;quot; mode=&amp;quot;prepend&amp;quot; binding=&amp;quot;same&amp;quot;&gt;
      &lt;string&gt;Roboto&lt;/string&gt;
      &lt;string&gt;Noto Sans CJK SC&lt;/string&gt;
      &lt;string&gt;Noto Color Emoji&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;

  &lt;match target=&amp;quot;pattern&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;sans-serif&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;family&amp;quot; mode=&amp;quot;prepend&amp;quot; binding=&amp;quot;same&amp;quot;&gt;
      &lt;string&gt;Roboto&lt;/string&gt;
      &lt;string&gt;Noto Sans CJK SC&lt;/string&gt;
      &lt;string&gt;Noto Color Emoji&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;

  &lt;!-- 默认有衬线字体。 --&gt;
  &lt;match target=&amp;quot;pattern&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;serif&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;family&amp;quot; mode=&amp;quot;prepend&amp;quot; binding=&amp;quot;same&amp;quot;&gt;
      &lt;string&gt;Roboto Slab&lt;/string&gt;
      &lt;string&gt;Noto Serif CJK SC&lt;/string&gt;
      &lt;string&gt;Noto Color Emoji&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;

  &lt;!-- 默认等宽字体。 --&gt;
  &lt;match target=&amp;quot;pattern&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;monospace&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;family&amp;quot; mode=&amp;quot;prepend&amp;quot; binding=&amp;quot;same&amp;quot;&gt;
      &lt;string&gt;Monaco&lt;/string&gt;
      &lt;string&gt;Noto Sans Mono CJK SC&lt;/string&gt;
      &lt;string&gt;Noto Color Emoji&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;

  &lt;!-- 默认 emoji 字体。 --&gt;
  &lt;match target=&amp;quot;pattern&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;emoji&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;family&amp;quot; mode=&amp;quot;prepend&amp;quot; binding=&amp;quot;same&amp;quot;&gt;
      &lt;string&gt;Noto Color Emoji&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!-- 下面这一系列等同于 alias。 --&amp;gt;
  &amp;lt;!-- 默认无衬线字体。 --&amp;gt;
  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;sans&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;same&quot;&amp;gt;
      &amp;lt;string&amp;gt;Roboto&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Sans CJK SC&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Color Emoji&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;

  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;sans-serif&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;same&quot;&amp;gt;
      &amp;lt;string&amp;gt;Roboto&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Sans CJK SC&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Color Emoji&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;

  &amp;lt;!-- 默认有衬线字体。 --&amp;gt;
  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;serif&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;same&quot;&amp;gt;
      &amp;lt;string&amp;gt;Roboto Slab&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Serif CJK SC&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Color Emoji&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;

  &amp;lt;!-- 默认等宽字体。 --&amp;gt;
  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;monospace&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;same&quot;&amp;gt;
      &amp;lt;string&amp;gt;Monaco&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Sans Mono CJK SC&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Color Emoji&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;

  &amp;lt;!-- 默认 emoji 字体。 --&amp;gt;
  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;emoji&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;family&quot; mode=&quot;prepend&quot; binding=&quot;same&quot;&amp;gt;
      &amp;lt;string&amp;gt;Noto Color Emoji&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;这里的写法和 &lt;code&gt;&amp;lt;alias&amp;gt;&lt;/code&gt; 是等价的。设置完这个记得把所有软件的自定义字体设置里面无衬线设置为 &lt;code&gt;sans-serif&lt;/code&gt;，有衬线设置为 &lt;code&gt;serif&lt;/code&gt;，等宽设置为 &lt;code&gt;monospace&lt;/code&gt;，这样才会遵守这里的回退顺序。&lt;/p&gt;
&lt;p&gt;然后很多网站写的都是 Apple Color Emoji，我们这里自然是没有的，要换掉：&lt;/p&gt;
&lt;figure data-raw=&quot;  &lt;!-- 替换 Apple Color Emoji 字体。 --&gt;
  &lt;match target=&amp;quot;pattern&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;Apple Color Emoji&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;family&amp;quot; mode=&amp;quot;assign&amp;quot; binding=&amp;quot;same&amp;quot;&gt;
      &lt;string&gt;Noto Color Emoji&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!-- 替换 Apple Color Emoji 字体。 --&amp;gt;
  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;Apple Color Emoji&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;family&quot; mode=&quot;assign&quot; binding=&quot;same&quot;&amp;gt;
      &amp;lt;string&amp;gt;Noto Color Emoji&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后是个非常弱智的部分，B 站直播首页的 CSS 写死字体回退顺序为 &lt;code&gt;Arial,Microsoft YaHei, &quot;Microsoft Sans Serif&quot;,Microsoft SanSerf,微软雅黑&lt;/code&gt;，你没看错，这个不合格的前端连最后要加 sans-serif 保证兼容性都不知道，而且还把 Microsoft Sans Serif 拼错了，如果我是他的老板，我真想一拳打在他头上告诉他这个世界不是只有微软字体，然后再把他开除掉。但现在我需要加条规则让他匹配到我想要的字体，虽然这样在一些需要微软雅黑的 office 软件里面可能有问题，不过反正我的工作不需要用垃圾 office 哈哈哈哈哈哈哈哈哈哈：&lt;/p&gt;
&lt;figure data-raw=&quot;  &lt;!--
    B 站直播首页的前端认为这个世界上只有微软字体（Arial,Microsoft YaHei,
    &amp;quot;Microsoft Sans Serif&amp;quot;,Microsoft SanSerf,微软雅黑），
    所以我不得不开着这几个规则。如果我是他的老板，我就会开除掉这个不合格的前端。
    这里不能换成 sans-serif，因为它们只是插入用的锚点而不是子列表，
    除非我们把这条抬到最前面。
  --&gt;
  &lt;match target=&amp;quot;pattern&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;Microsoft YaHei&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;family&amp;quot; mode=&amp;quot;append&amp;quot; binding=&amp;quot;same&amp;quot;&gt;
      &lt;string&gt;Roboto&lt;/string&gt;
      &lt;string&gt;Noto Sans CJK SC&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;

  &lt;match target=&amp;quot;pattern&amp;quot;&gt;
    &lt;test name=&amp;quot;family&amp;quot; qual=&amp;quot;any&amp;quot;&gt;
      &lt;string&gt;Microsoft Sans Serif&lt;/string&gt;
    &lt;/test&gt;
    &lt;edit name=&amp;quot;family&amp;quot; mode=&amp;quot;append&amp;quot; binding=&amp;quot;same&amp;quot;&gt;
      &lt;string&gt;Roboto&lt;/string&gt;
      &lt;string&gt;Noto Sans CJK SC&lt;/string&gt;
    &lt;/edit&gt;
  &lt;/match&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;  &amp;lt;!--
    B 站直播首页的前端认为这个世界上只有微软字体（Arial,Microsoft YaHei,
    &quot;Microsoft Sans Serif&quot;,Microsoft SanSerf,微软雅黑），
    所以我不得不开着这几个规则。如果我是他的老板，我就会开除掉这个不合格的前端。
    这里不能换成 sans-serif，因为它们只是插入用的锚点而不是子列表，
    除非我们把这条抬到最前面。
  --&amp;gt;
  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;Microsoft YaHei&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;family&quot; mode=&quot;append&quot; binding=&quot;same&quot;&amp;gt;
      &amp;lt;string&amp;gt;Roboto&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Sans CJK SC&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;

  &amp;lt;match target=&quot;pattern&quot;&amp;gt;
    &amp;lt;test name=&quot;family&quot; qual=&quot;any&quot;&amp;gt;
      &amp;lt;string&amp;gt;Microsoft Sans Serif&amp;lt;/string&amp;gt;
    &amp;lt;/test&amp;gt;
    &amp;lt;edit name=&quot;family&quot; mode=&quot;append&quot; binding=&quot;same&quot;&amp;gt;
      &amp;lt;string&amp;gt;Roboto&amp;lt;/string&amp;gt;
      &amp;lt;string&amp;gt;Noto Sans CJK SC&amp;lt;/string&amp;gt;
    &amp;lt;/edit&amp;gt;
  &amp;lt;/match&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;剩下还有一些冗长的用来在不同语言下选择不同的 Noto Sans CJK 变体的设置，因为 Noto Sans CJK 是一个多语种集合字体，然后中日韩对一些汉字有不同的变体，所以需要这一段，不过我就不贴在这里了，完整的文件可以在文章末尾下载。&lt;/p&gt;
&lt;p&gt;最后收个尾：&lt;/p&gt;
&lt;figure data-raw=&quot;&lt;/fontconfig&gt;
&quot; data-info=&quot;language-xml&quot; data-lang=&quot;xml&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-xml&quot;&gt;&amp;lt;/fontconfig&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;完整的文件在这里：&lt;a href=&quot;/posts/Fontconfig-NotoColorEmoji-Antialias/local.conf&quot;&gt;local.conf&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;😼&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="字体" label="字体" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E5%AD%97%E4%BD%93/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/tags/Linux/" />
    
    <category term="字体" label="字体" scheme="https://sh.alynx.one/tags/%E5%AD%97%E4%BD%93/" />
    
  </entry>
  
  
  
  <entry>
    <title>NVIDIA 驱动和 GNOME 和 Wayland</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/NVIDIA-GNOME-Wayland/" />
    <id>https://sh.alynx.one/posts/NVIDIA-GNOME-Wayland/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-07-29T23:50:39.000Z</published>
    
    
    <updated>2021-11-09T01:10:21.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;更新（2021-11-09）：最新的 NVIDIA 495 驱动终于支持了大家都在用的 GBM，同时最新的 XWayland 21.1.3 也添加了这方面的支持，也就意味着 NVIDIA 用户不再需要单独的轮子而是使用现有的稳定的代码。我已经切换到 GNOME Wayland 不止一周，目前各种功能都很正常。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由于各种各样的历史原因和近期的变化，我在最近的聊天里发现很多朋友对 NVIDIA 驱动对 Wayland 的支持情况不甚了解，正好我最近在折腾相关的东西，所以打算简单介绍一下我了解的。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;更新（2021-11-09）：最新的 NVIDIA 495 驱动终于支持了大家都在用的 GBM，同时最新的 XWayland 21.1.3 也添加了这方面的支持，也就意味着 NVIDIA 用户不再需要单独的轮子而是使用现有的稳定的代码。我已经切换到 GNOME Wayland 不止一周，目前各种功能都很正常。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;由于各种各样的历史原因和近期的变化，我在最近的聊天里发现很多朋友对 NVIDIA 驱动对 Wayland 的支持情况不甚了解，正好我最近在折腾相关的东西，所以打算简单介绍一下我了解的。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98&quot;&gt;&lt;/a&gt;常见问题&lt;/h1&gt;
&lt;h2 id=&quot;%E4%B8%BA%E4%BB%80%E4%B9%88NVIDIA%E7%9A%84Wayland%E6%94%AF%E6%8C%81%E8%BF%99%E4%B9%88%E5%B7%AE%EF%BC%9F&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E4%B8%BA%E4%BB%80%E4%B9%88NVIDIA%E7%9A%84Wayland%E6%94%AF%E6%8C%81%E8%BF%99%E4%B9%88%E5%B7%AE%EF%BC%9F&quot;&gt;&lt;/a&gt;为什么 NVIDIA 的 Wayland 支持这么差？&lt;/h2&gt;
&lt;p&gt;长话短说，大部分驱动（AMD 的开源和闭源驱动，NVIDIA 的开源驱动 nouveau，Intel 的开源驱动）都同意采用 GBM 作为缓存 API，但是 NVIDIA 像个赌气的小孩一样表示“你们这个不好，我要做个更好的 EGLStreams”所以不支持 GBM，于是所有要兼容 NVIDIA 闭源驱动的混成器都要为它做单独的实现代码。诸如 GNOME 或者 KDE 这种大型项目有足够的人手，同时 NVIDIA 似乎也提供了一定的帮助所以已经有了混成器内部的 EGLStreams 实现，但也有些小型项目并不支持这个玩意。而且 NVIDIA 吹牛皮吹得很大，EGLStreams 哪里“更好”从他们的龟速进展上根本体现不出来。可能是因为挖矿赚得盆满钵满，忘记了显卡的本职工作是显示，NVIDIA 的闭源 Linux 驱动质量一直停留在能用的程度，同时又做各种各样限制导致开源的 nouveau 在较新的显卡上几乎不能用。&lt;/p&gt;
&lt;p&gt;NVIDIA 闭源驱动之前一直是稀泥巴糊不上墙的垃圾，因为它在 Wayland 下对使用 XWayland 的程序没有硬件加速支持——也就是说如果你使用 Xorg 会话，程序是有硬件加速的，你使用 Wayland 会话，Wayland 程序也是有硬件加速的，但是在 Wayland 会话下面那些旧的 Xorg 程序就没有硬件加速（听起来就像捡了芝麻丢了西瓜一样）——而仍然有相当一部分旧程序在 Wayland 下依赖 XWayland 运行，所以 NVIDIA 闭源驱动的 Wayland 会话基本可以认为是不能日常使用的。&lt;/p&gt;
&lt;p&gt;从版本 470 之后 NVIDIA 闭源驱动有所改善，首先是他们的员工提交的&lt;a href=&quot;https://gitlab.freedesktop.org/xorg/xserver/-/merge_requests/587/diffs&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;补丁&lt;/a&gt;在 XWayland 21.1.1 版本释出了，这个补丁添加了对 XWayland 硬件加速的支持（需要新版本驱动），然后新版本驱动在上周变为稳定版，用户可以安装，所以在拖了至少三年之后最后一块空缺终于被补上了。使用 KDE 和 GNOME 的 NVIDIA 显卡用户理论上就可以获得完整的 Wayland 体验了。&lt;/p&gt;
&lt;h2 id=&quot;%E7%8E%B0%E5%9C%A8NVIDIA%E7%94%A8%E6%88%B7%E7%9A%84Wayland%E4%BC%9A%E8%AF%9D%E5%8F%AF%E4%BB%A5%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BA%86%E5%90%97%EF%BC%9F&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E7%8E%B0%E5%9C%A8NVIDIA%E7%94%A8%E6%88%B7%E7%9A%84Wayland%E4%BC%9A%E8%AF%9D%E5%8F%AF%E4%BB%A5%E6%97%A5%E5%B8%B8%E4%BD%BF%E7%94%A8%E4%BA%86%E5%90%97%EF%BC%9F&quot;&gt;&lt;/a&gt;现在 NVIDIA 用户的 Wayland 会话可以日常使用了吗？&lt;/h2&gt;
&lt;p&gt;更新到 470 驱动之后我第一时间体验了一下，&lt;del&gt;结果就是很抱歉，还是不行，不过&lt;/del&gt; 我遇到的都是一些小问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;del&gt;Firefox 稳定版没法正常工作，但是 Nightly 版本是可以的，原因是 NVIDIA 和 Mesa 的 EGL 实现存在一点小区别，&lt;a href=&quot;https://hg.mozilla.org/mozilla-central/rev/c2191ee9cb65&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;修复补丁&lt;/a&gt;已经在 Nightly 里面了，我们只要等稳定版版本升上去就可以了。&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;GTK3 程序都能工作，但是 GTK4 的程序（比如 GNOME Extensions）却全都挂了，原因应该和 Firefox 一致，&lt;a href=&quot;https://gitlab.gnome.org/GNOME/gtk/-/merge_requests/3726&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;修复补丁&lt;/a&gt;也已经合并了，只是还没有释出稳定版。&lt;/del&gt;&lt;/li&gt;
&lt;li&gt;&lt;del&gt;Google Chrome 不能工作，但是比较新的 Chromium 似乎可以，原因推测也是一样的，我懒得查了，同时&lt;/del&gt; 所有一直抱着旧版 Electron 不更新的程序应该都有同样的问题。&lt;/li&gt;
&lt;li&gt;GNOME Shell 的缩略图会显示错误，看起来是个&lt;a href=&quot;https://gitlab.gnome.org/GNOME/mutter/-/issues/528&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;两年的老 bug&lt;/a&gt;，最近开发者似乎找到了原因，还没修复。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不过总而言之这些都是能很快修复（废话，大家动作都比 NVIDIA 快，建议老黄把自己的皮衣换成乌龟壳）的问题，不至于被卡很久，至于你的发行版是那种追求“稳定”选择了一个不支持的大版本然后不更新的？哈哈，关我 X 事。&lt;/p&gt;
&lt;p&gt;更新（2021-09-17）：Arch 这边 Firefox 更新到了 92.0，所以已经修好了。Google Chrome 现在是 93.0.4577.63，我也能正常打开。GTK4 的 MR 已经释出了稳定版，所以没问题。Atom 在我这用的是 electron9，能用，反而是用 electron12 的 Code - OSS 不能用了……最后那些不知道打包了几百年前的闭源拖拉机（要不把拖去掉变成垃圾？）也就是我指的很明确的 Slack 不能用，加上 &lt;code&gt;--disable-gpu&lt;/code&gt; 是能用的，但是是他的问题，为什么要我关掉硬件加速消耗 CPU 资源？最后 GNOME Shell 自己的那个 bug……目前没有开发者搞这个，我简单看了一下发现是个我没涉足过的领域，不过总之我觉得是个看起来不爽但不影响你实际使用的问题，所以现在的状态就是 &lt;strong&gt;“又不是不能用”&lt;/strong&gt; ！（我可没说后半句啊！上一个说了后半句的珠海小厂现在还活着吗？）&lt;/p&gt;
&lt;p&gt;另外我在 openSUSE Tumbleweed 上测试的时候还遇到一个问题啊，它默认安装的是 nouveau，需要手动在 YaST 里面安装 NVIDIA，装完之后似乎两个驱动冲突把我显示器搞黑屏了，于是我就没法直接重启。而且在那之后我显示器神奇的再也不亮了（PS4、Switch 全都点不亮它），拔掉电源放半分钟再插上才好，很头疼啊。&lt;/p&gt;
&lt;h2 id=&quot;%E6%88%91%E6%98%AFGNOME%E7%94%A8%E6%88%B7%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A3%85%E4%BA%86470%E7%89%88%E6%9C%ACGDM%E9%80%89%E5%8D%95%E9%87%8C%E7%9A%84GNOME%E8%BF%98%E6%98%AFXorg%E4%BC%9A%E8%AF%9D%EF%BC%9F&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E6%88%91%E6%98%AFGNOME%E7%94%A8%E6%88%B7%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A3%85%E4%BA%86470%E7%89%88%E6%9C%ACGDM%E9%80%89%E5%8D%95%E9%87%8C%E7%9A%84GNOME%E8%BF%98%E6%98%AFXorg%E4%BC%9A%E8%AF%9D%EF%BC%9F&quot;&gt;&lt;/a&gt;我是 GNOME 用户，为什么装了 470 版本 GDM 选单里的 GNOME 还是 Xorg 会话？&lt;/h2&gt;
&lt;p&gt;这个有几个原因，首先就是 Wayland 需要 Kernel Mode Setting 的支持（这也是个 NVIDIA 拖了好久才补上的特性），所以你的内核参数要有 &lt;code&gt;nvidia-drm.modeset=1&lt;/code&gt;。其次要看 &lt;code&gt;/etc/gdm/custom.conf&lt;/code&gt; 里面 &lt;code&gt;WaylandEnable=false&lt;/code&gt; 是不是被注释掉的（默认应该是）。&lt;/p&gt;
&lt;p&gt;最可能的是 udev 规则，GDM 带了一个 &lt;code&gt;/usr/lib/udev/rules.d/61-gdm.rules&lt;/code&gt; 文件，里面有这么几行：&lt;/p&gt;
&lt;figure data-raw=&quot;# disable Wayland on Hi1710 chipsets
ATTR{vendor}==&amp;quot;0x19e5&amp;quot;, ATTR{device}==&amp;quot;0x1711&amp;quot;, RUN+=&amp;quot;/usr/lib/gdm-runtime-config set daemon WaylandEnable false&amp;quot;
# disable Wayland when using the proprietary nvidia driver
DRIVER==&amp;quot;nvidia&amp;quot;, RUN+=&amp;quot;/usr/lib/gdm-runtime-config set daemon WaylandEnable false&amp;quot;
# disable Wayland if modesetting is disabled
IMPORT{cmdline}=&amp;quot;nomodeset&amp;quot;, RUN+=&amp;quot;/usr/lib/gdm-runtime-config set daemon WaylandEnable false&amp;quot;
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;# disable Wayland on Hi1710 chipsets
ATTR{vendor}==&quot;0x19e5&quot;, ATTR{device}==&quot;0x1711&quot;, RUN+=&quot;/usr/lib/gdm-runtime-config set daemon WaylandEnable false&quot;
# disable Wayland when using the proprietary nvidia driver
DRIVER==&quot;nvidia&quot;, RUN+=&quot;/usr/lib/gdm-runtime-config set daemon WaylandEnable false&quot;
# disable Wayland if modesetting is disabled
IMPORT{cmdline}=&quot;nomodeset&quot;, RUN+=&quot;/usr/lib/gdm-runtime-config set daemon WaylandEnable false&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;第二行表示如果检测到 NVIDIA 闭源驱动就关闭 Wayland，第三行则是如果没开启 Kernel Mode Setting 也关掉 Wayland。&lt;/p&gt;
&lt;p&gt;我猜大部分用户都没有第一行的设备，所以我建议直接 &lt;code&gt;ln -s /dev/null /etc/udev/rules.d/61-gdm.rules&lt;/code&gt; 屏蔽掉这个文件。&lt;/p&gt;
&lt;p&gt;别问我既然 470 驱动都出来了 GNOME 开发者为什么不删掉这个文件，NVIDIA 憋出来 470 驱动总共也就一周多点，还有一堆小问题呢，删了怕不是又有一堆人来骂“怎么又把不稳定的东西搞给我了”。&lt;/p&gt;
&lt;h2 id=&quot;%E6%88%91%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%8F%8C%E6%98%BE%E5%8D%A1%E7%94%A8%E6%88%B7%EF%BC%8C%E4%B8%BB%E7%94%A8%E7%9A%84%E6%98%AF%E6%A0%B8%E8%8A%AF%E6%98%BE%E5%8D%A1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91GDM%E9%80%89%E5%8D%95%E9%87%8C%E7%9A%84GNOME%E4%B9%9F%E6%98%AFXorg%E4%BC%9A%E8%AF%9D%EF%BC%9F&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E6%88%91%E6%98%AF%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%8F%8C%E6%98%BE%E5%8D%A1%E7%94%A8%E6%88%B7%EF%BC%8C%E4%B8%BB%E7%94%A8%E7%9A%84%E6%98%AF%E6%A0%B8%E8%8A%AF%E6%98%BE%E5%8D%A1%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E6%88%91GDM%E9%80%89%E5%8D%95%E9%87%8C%E7%9A%84GNOME%E4%B9%9F%E6%98%AFXorg%E4%BC%9A%E8%AF%9D%EF%BC%9F&quot;&gt;&lt;/a&gt;我是笔记本双显卡用户，主用的是核芯显卡，为什么我 GDM 选单里的 GNOME 也是 Xorg 会话？&lt;/h2&gt;
&lt;p&gt;检查一下你是不是用了 NVIDIA 之前提供的 Xorg 下面的双显卡管理功能（有群友说叫 prime，我不知道是不是叫 prime）（顺便一提这也是 NVIDIA 憋了好几年才憋出来的本来就该有的东西）？如果你使用那个，首先它是 Xorg 下面的支持，其次它会加载 nvidia 模块，自然就会落到上一个问题里面的 udev 规则上。&lt;/p&gt;
&lt;p&gt;有群友在群里表示他删了那个规则然后进 Wayland，可以是可以，但我感到很迷惑。这个 prime 功能 NVIDIA 之前只是说了在 Xorg 下面可用，所以我不是很理解又要 prime 又要 Wayland 的可行性，我也不知道 NVIDIA 的按需渲染现在到 Wayland 里面还能不能像之前 Xorg 里面提供的功能一样正常工作。就理论上我给 NVIDIA 掏了钱，这是他的义务给我支持这个功能，但这可是垃圾 NVIDIA 啊！&lt;/p&gt;
&lt;p&gt;你问我有没有什么建议？如果你需要这玩意，就按照 GNOME 的规则用 Xorg 就好了，没错虽然我是 Wayland 支持者，但我在这里建议你还是先用着 Xorg。如果你只是想用 Wayland 然后并不是很需要用 NVIDIA 显卡，那就关掉它不让它加载驱动，没错，我在自己的笔记本上用的是 Bumblebee。&lt;/p&gt;
&lt;h2 id=&quot;%E6%88%91%E6%98%AFKDE%E7%94%A8%E6%88%B7%EF%BC%8C%E4%BD%A0%E6%89%AF%E8%BF%99%E4%B9%88%E5%A4%9AGNOME%EF%BC%8C%E8%B7%9F%E6%88%91%E8%AF%B4%E8%AF%B4KDE%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%97%EF%BC%9F&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E6%88%91%E6%98%AFKDE%E7%94%A8%E6%88%B7%EF%BC%8C%E4%BD%A0%E6%89%AF%E8%BF%99%E4%B9%88%E5%A4%9AGNOME%EF%BC%8C%E8%B7%9F%E6%88%91%E8%AF%B4%E8%AF%B4KDE%E7%8E%B0%E5%9C%A8%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E5%91%97%EF%BC%9F&quot;&gt;&lt;/a&gt;我是 KDE 用户，你扯这么多 GNOME，跟我说说 KDE 现在有什么问题呗？&lt;/h2&gt;
&lt;p&gt;大哥，我是 GNOME 用户啊，既然你是 KDE 用户，建议你自己试试然后给我讲讲……&lt;/p&gt;
&lt;h1 id=&quot;%E6%B2%A1%E7%94%A8%E7%9A%84%E8%A7%82%E7%82%B9&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E6%B2%A1%E7%94%A8%E7%9A%84%E8%A7%82%E7%82%B9&quot;&gt;&lt;/a&gt;没用的观点&lt;/h1&gt;
&lt;h2 id=&quot;%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AAGDM%E5%B0%B1%E6%98%AF%E9%80%8A%E5%95%A6%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E5%8D%A1%E6%AD%BB%E6%A0%B9%E6%9C%AC%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%8C%E5%A4%A7%E5%AE%B6%E9%83%BD%E6%8E%A8%E8%8D%90%E6%8D%A2SDDM%E5%B7%B4%E6%8B%89%E5%B7%B4%E6%8B%89%E2%80%A6%E2%80%A6&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E4%BD%A0%E7%9C%8B%E8%BF%99%E4%B8%AAGDM%E5%B0%B1%E6%98%AF%E9%80%8A%E5%95%A6%EF%BC%8C%E6%88%91%E8%BF%99%E9%87%8C%E5%8D%A1%E6%AD%BB%E6%A0%B9%E6%9C%AC%E4%B8%8D%E8%83%BD%E7%94%A8%EF%BC%8C%E5%A4%A7%E5%AE%B6%E9%83%BD%E6%8E%A8%E8%8D%90%E6%8D%A2SDDM%E5%B7%B4%E6%8B%89%E5%B7%B4%E6%8B%89%E2%80%A6%E2%80%A6&quot;&gt;&lt;/a&gt;你看这个 GDM 就是逊啦，我这里卡死根本不能用，大家都推荐换 SDDM 巴拉巴拉……&lt;/h2&gt;
&lt;p&gt;强调一下我的目的是解决问题，比如群里有人问为什么我双显卡 GDM 里没 Wayland 可选你来这么一句我觉得很不礼貌，当别人就是需要用 GDM 的时候说“大家都推荐换 SDDM”我觉得不管是 GNOME 用户还是 KDE 用户都会觉得不是个好回答。其次只说自己 GDM 卡死完全没法判断问题所在，别人都没这个问题，或许问题就不在 GDM 而在你的配置呢？同理，这个“大家都推荐换 SDDM”里的“大家”是哪里来的呢？我觉得这样的回复对解决问题没什么帮助。&lt;/p&gt;
&lt;h2 id=&quot;Xorg%E5%A5%BD%EF%BC%81Wayland%E5%9D%8F%EF%BC%81&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#Xorg%E5%A5%BD%EF%BC%81Wayland%E5%9D%8F%EF%BC%81&quot;&gt;&lt;/a&gt;Xorg 好！Wayland 坏！&lt;/h2&gt;
&lt;p&gt;请列举出充分而恰当的理由支持你的观点，而不是人云亦云。比方说你可能觉得 Wayland 缺乏你需要的某些功能，这可能是设计理念上的不同，或者发展时间不够所导致的，毕竟 X 协议的历史比 Wayland 长得多，所以请多一点耐心。而至于不讲道理或者二极管或者言论不友善的行为在哪里都是不受欢迎的。&lt;/p&gt;
&lt;h2 id=&quot;%E6%88%91%E4%B9%9F%E6%98%AFNVIDIA%E7%94%A8%E6%88%B7%EF%BC%8C%E6%88%91%E7%8E%A9XX%E6%B8%B8%E6%88%8F%E5%8D%A1%E6%88%90%E5%B9%BB%E7%81%AF%E7%89%87%E4%BA%86%EF%BC%81&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E6%88%91%E4%B9%9F%E6%98%AFNVIDIA%E7%94%A8%E6%88%B7%EF%BC%8C%E6%88%91%E7%8E%A9XX%E6%B8%B8%E6%88%8F%E5%8D%A1%E6%88%90%E5%B9%BB%E7%81%AF%E7%89%87%E4%BA%86%EF%BC%81&quot;&gt;&lt;/a&gt;我也是 NVIDIA 用户，我玩 XX 游戏卡成幻灯片了！&lt;/h2&gt;
&lt;p&gt;……信息太少，无法给出合理推断，只能告诉你我游戏玩的可欢乐了！&lt;/p&gt;
&lt;h2 id=&quot;%E4%BD%A0%E4%BB%ACNVIDIA%E7%94%A8%E6%88%B7%E7%9C%9F%E9%BA%BB%E7%83%A6%EF%BC%8C%E8%B0%81%E5%8F%AB%E4%BD%A0%E4%BB%AC%E8%87%AA%E5%B7%B1%E6%8E%8F%E9%92%B1%E4%B9%B0N%E5%8D%A1%E5%8F%97%E7%BD%AA%EF%BC%81&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/NVIDIA-GNOME-Wayland/#%E4%BD%A0%E4%BB%ACNVIDIA%E7%94%A8%E6%88%B7%E7%9C%9F%E9%BA%BB%E7%83%A6%EF%BC%8C%E8%B0%81%E5%8F%AB%E4%BD%A0%E4%BB%AC%E8%87%AA%E5%B7%B1%E6%8E%8F%E9%92%B1%E4%B9%B0N%E5%8D%A1%E5%8F%97%E7%BD%AA%EF%BC%81&quot;&gt;&lt;/a&gt;你们 NVIDIA 用户真麻烦，谁叫你们自己掏钱买 N 卡受罪！&lt;/h2&gt;
&lt;p&gt;你又不知道老子都有什么需求，买 N 卡我是暂时没法用 Wayland，但是不买 N 卡我就要达芬奇受罪 Windows 下面打游戏受罪直播编码受罪跑 hashcat 受罪（存疑）。我做的选择是我权衡之后的结果。再说一遍，解决问题和“换 XX”是完全不一样的态度。&lt;/p&gt;
&lt;p&gt;所以就是钱是掏了，骂还是照样骂，而且我都掏钱了，骂得然更有底气了！&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    
    
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    
    <category term="Wayland" label="Wayland" scheme="https://sh.alynx.one/tags/Wayland/" />
    
    <category term="NVIDIA" label="NVIDIA" scheme="https://sh.alynx.one/tags/NVIDIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>新项目和新相机和新住处</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/New-Project-New-Camera-New-Home/" />
    <id>https://sh.alynx.one/posts/New-Project-New-Camera-New-Home/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-04-25T06:50:00.000Z</published>
    
    
    <updated>2021-04-25T06:50:00.000Z</updated>
    
    
    <summary type="html">
      本来之前是想等新开的项目搞差不多了就来更新博客，结果没想到越写 TODO 越多一直搞到这个月才搞定，所以到现在才更新。 新项目 从家里回来北京之后第一件事情就是 SUSE 的 HackWeek，我之前大致想好了要做什么，我用过 screenkey 这个项目，但它使用了 X11 的…
    </summary>
    
    
    <content type="html">
      &lt;p&gt;本来之前是想等新开的项目搞差不多了就来更新博客，结果没想到越写 TODO 越多一直搞到这个月才搞定，所以到现在才更新。&lt;/p&gt;
&lt;h1 id=&quot;%E6%96%B0%E9%A1%B9%E7%9B%AE&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/New-Project-New-Camera-New-Home/#%E6%96%B0%E9%A1%B9%E7%9B%AE&quot;&gt;&lt;/a&gt;新项目&lt;/h1&gt;
&lt;p&gt;从家里回来北京之后第一件事情就是 SUSE 的 HackWeek，我之前大致想好了要做什么，我用过 screenkey 这个项目，但它使用了 X11 的 API，所以不支持 Wayland，我简单调查了一下，发现其实是可以绕过显示部分直接读取输入设备的事件的，于是就打算造一个替代品。&lt;/p&gt;
&lt;p&gt;读取键盘事件的部分其实很容易，简单试了一下就完成了。但是反而是显示部分比较难搞。一开始我打算用刚发布稳定版的 GTK4，结果发现 GTK4 在 NVIDIA 驱动的 Wayland 会话下面反而是有问题的，只能回退到没问题的 GTK3。我原本以为一周的时间做出一个能用的程序还是挺充足的，但是后来发现中间有各种各样的问题和奇怪的 work around。比如涉及到 GObject 对象在什么时候释放，有些文档说的也不是很清楚。以及因为要用单独的子进程执行需要 root 权限的后端读取输入事件和用单独的子线程查询后端输出带来的进程/线程间通信问题。篇幅有限，打算后续再开一篇博客来介绍这里面的经验。在一周的时间里勉强做出了能用的 demo 参加了 HackWeek 的成果展示环节（给有始有终的参与者的小礼物大概还放在我公司的桌子上，我都不知道是什么，因为一直没去取），然后用了几周打游戏的时间整理代码里面的问题（主要是各种资源释放），以及做一下翻译工作和打包工作，终于在上周达到基本稳定了。如果有兴趣，可以访问 &lt;a href=&quot;https://showmethekey.alynx.one/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://showmethekey.alynx.one/&lt;/a&gt; 或者观看 &lt;a href=&quot;https://www.bilibili.com/video/BV1EB4y1A7QN&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;我发在 B 站上的介绍视频&lt;/a&gt;。&lt;/p&gt;
&lt;h1 id=&quot;%E6%96%B0%E7%9B%B8%E6%9C%BA&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/New-Project-New-Camera-New-Home/#%E6%96%B0%E7%9B%B8%E6%9C%BA&quot;&gt;&lt;/a&gt;新相机&lt;/h1&gt;
&lt;p&gt;之前一直想提升视频的画质，但是还有一个想法是想玩玩摄影，因为平时周末经常是起得很晚然后在家里玩游戏，感觉也挺无聊的，所以打算买个相机，这样周末就有理由出去走走了。拍出来什么东西无所谓，主要是找点乐趣。然后朋友建议我买黑卡，虽然这个玩意确实很黑科技，但我并不是太感兴趣。很久以前我家里有一个数码相机，不是卡片机，是一个能变焦变很长的型号，但是后来智能手机出现之后就很快的不用它了，因为没有手机轻便的同时也没有足够的专业程度。所以我对相机的看法就是要么就搞高级一点的，肯定不会被手机取代，要么就用手机算了，而且说实话最高端的黑卡价格也都达到微单的价格区间了。考虑到要拿来录视频，很多录视频的 UP 主选择的都是微单而不是单反，再查找了一下发现很多人都用的索尼 A73，那选一个大家都在用的总是错不了的吧，于是初步选定了目标。然后又开始考虑是 A73 还是 A7C，虽然很多人对于 A7C 只是缩小体积然后价格却比 A73 高感到不满，但我阅读了一个对比表格之后，觉得还是 A7C 更适合我这种有录视频需求的人，于是就选择了 A7C。&lt;/p&gt;
&lt;p&gt;我个人是对 A7C 相比 A73 砍掉的部分没什么需求的，只看参数很容易会变成那种“这个也想要那个也想要”的情况，虽然作为消费者而言，当然是希望厂家提供越多的功能越好。但是在只有这几个选项的情况下还是得考虑需求做一下取舍。比如去掉 MicroUSB 接口导致只能接一些 USB-C 接口的配件，看了看配件价格，短期内我大概是不会考虑这些配件的……去掉前拨轮和摇杆对我来说也不是不能接受，毕竟触摸对焦也挺好用的。虽然少了很多自定义按键，但是方向键现在都是可以自定义的，其实差别也不大。反而轻巧的体积和翻转屏，以及没有录制时间限制于我来说很重要。有人说没有双卡槽不够专业，万一给别人录东西丢了数据没有冗余，但可以预见的未来我不会靠这玩意获得收入，录我自己的话丢了也不算什么无法挽回的后果（反正自己选的）。&lt;/p&gt;
&lt;p&gt;看点作品？虽然我就是随便拍拍，还是有几张觉得好看的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/New-Project-New-Camera-New-Home/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前去五棵松玩，想试试夜拍效果，结果套头的焦段显然不够拍月亮，不过回家看看感觉这张图还不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/New-Project-New-Camera-New-Home/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;某天吃完饭散步，坐在长椅上拍了一张，莫名觉得很好看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/New-Project-New-Camera-New-Home/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;之前经常来我窗口咕咕咕叫吵我清梦的珠颈斑鸠，我管它叫大鸽，经常我拿着相机走到窗口它跑了，这张一开始其实拍到了部分室内，导致窗外的部分有点过曝，不过好在 RAW 可以调整，拉低了一些曝光然后裁掉窗户周围的部分，就变得很生动了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/New-Project-New-Camera-New-Home/4.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;最近大鸽不怎么来了，是不是因为楼下在锯树，大鸽的家没了？（虽然我对珠颈斑鸠再造一个窝需要花的时间表示怀疑。）&lt;/p&gt;
&lt;p&gt;买完了 A7C 莫名开始种草 A7S3，4K 60 帧看起来真诱人啊……1080P 60 帧和 4K 30 帧只能二选一到底是谁想出来的牙膏啊！&lt;/p&gt;
&lt;p&gt;说起来最近拍照片之后发现存储空间的需求还是很大啊，虽然我两块 2T 的机械应该还足以满足短期内的需求。最近挖矿导致大容量硬盘也涨价了，估计更新存储设备也不太现实，还是有空精简一下吧。NAS 的问题我也考虑过，但是后来想想还是放弃了把星际蜗牛重新搞起来的想法，因为看了很多视频/数码 UP 工作室的介绍之后意识到 NAS 比起存储的用途，更大的用途还是共享，比如多个剪辑师可以同时访问 NAS 上面的一份素材，不用在每台电脑上都复制一份。但我显然没这个需求也没这个网速，只是存储一些数据的话，还是直接插台式机里面比较方便吧！&lt;/p&gt;
&lt;p&gt;顺便我朋友一直怂恿我买一个大光圈定焦镜头，我也确实心动了，比较了一下之后打算先入 FE 55 F1.8 ZA，然后再考虑 FE 24-105 G F4 代替套头，不过因为一些原因还是暂时搁置了，原因的话就是下一部分。&lt;/p&gt;
&lt;h1 id=&quot;%E6%96%B0%E4%BD%8F%E5%A4%84&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/New-Project-New-Camera-New-Home/#%E6%96%B0%E4%BD%8F%E5%A4%84&quot;&gt;&lt;/a&gt;新住处&lt;/h1&gt;
&lt;p&gt;当初因为时间比较紧所以选的这个住处，有几个不太满意的地方：房间太小了，放下柜子床电脑桌就没什么地方了。为了节约空间我是把桌子沿着床边摆的，我自己坐在桌子和衣柜之间，所以如果我要打开衣柜找东西就要把椅子推到桌子下面。然后在我 B 站录的视频里也能看出来，有朋友不止一次吐槽过我录视频环境过于混乱了。房子太旧了，实在是让人连做饭的想法都没，又破又旧，同时上班的话也比较麻烦，不是说交通不便，而是这个房子在一个院子的深处，出门坐公交或者去超市都要走很长一段距离。再加上我的卧室是直接挨着楼道，隔音又比较差，有时候午睡就会被上下楼的脚步声打扰。以及说实话我想要个稍微便宜点的房子，谁不想呢？&lt;/p&gt;
&lt;p&gt;所以今年快到期的时候我就在考虑搬家的问题。我们现在还是在家办公的状态，所以相对来说位置不太重要，虽然还是想尽可能找个上班方便的地方。但是很少有人和我一个方向上班，所以折腾了很久。本来是打算搬到更西南边的，甚至这一个月跑了好几个不同地方看房子，但是都因为各种原因没有选中，比如同学上班太远，周围没什么生活设施（虽然就在路边但是出门走好远好远才有超市到底是怎么搞的啊，为什么北京这边经常小区靠着路的一侧都是围墙，没有什么商业网点之类的，真的很没生活感），离地铁站太远，小区门禁是人脸识别（谁允许你们随便采集人脸信息的，而且约朋友来我家还要登记算几个意思啊）。而且想一起合租的同学以后可能考了教师资格证之后回老家工作，那样到时候就要再找人合租，我实在是不抱信心，所以还是决定再找别人合租。&lt;/p&gt;
&lt;p&gt;最后和有猫的孙老师在交大附近找了另一个房子。看了一上午最后直接选中的原因只有一个：实在是太新了，刚装修完，非常干净，而且卫生间和厨房都有采光。让我这个饱受破旧和阴暗厨房之苦的人非常满意。同时面积分配也非常科学，孙老师希望要有阳台的卧室，养猫比较方便，我希望卧室面积别太小，这样我录视频的时候把电脑桌当作背景，可以有一定的景深，让桌子在焦外就不会显得太乱。很多房子都是有阳台的卧室大得不得了而另一个卧室只能放个床，这个房子的次卧则不一样，有充足的地方放桌子。所以我们就敲定了这个，兜兜转转还是没离开学校周边。&lt;/p&gt;
&lt;p&gt;当然也没有完美的事情，满足了空间和干净和隔音（卧室并不是直接挨着楼道），价格和位置也就不能太强求了，交通的话看起来还好，离路边不会太远，大学周围也不至于太荒凉吧（街头生活感本来就和整齐不沾边，城市到底是让大人物拿来看的地方还是让小人物生活的地方呢？）。虽然考虑到更高的房租+中介费让我感到心疼肉疼（感觉镜头离自己远去了）……但是安慰自己多花几百块买来了刚装修完崭新的房子其实也很赚了对吧！&lt;/p&gt;
&lt;p&gt;所以希望接下来能轻松地搬家，毕竟我东西还是挺多的，有了空间就可以仔细布置一下了，让视频看起来更精致一点。&lt;/p&gt;
&lt;p&gt;总之还是要对生活有希望吧。&lt;/p&gt;

    </content>
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/tags/%E7%94%9F%E6%B4%BB/" />
    
  </entry>
  
  
  
  <entry>
    <title>运行在 JACK 上层的 PulseAudio</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Run-PulseAudio-on-Top-of-JACK/" />
    <id>https://sh.alynx.one/posts/Run-PulseAudio-on-Top-of-JACK/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-02-18T02:51:11.000Z</published>
    
    
    <updated>2021-02-18T02:51:11.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;很多朋友都知道我除了是个程序员以外还是个乐器玩家，很久之前因为想要录音上网了解了一下需要购买专门的麦克风声卡从此掉进深坑一发不可收拾。当然 Linux 用户在购买硬件之前需要做好功课，大概 16 年左右我还在上高中的时候用我还凑合的英语水平翻了几个 Linux 音乐论坛最后决定买一台 Focusrite Scarlett 2i4（不过它后来似乎更新了几个版本所以我购买的变成了 1st Gen），我不太清楚除了更换了接口之后还有什么奇怪的改动没有，所以这里就不盲目推荐大家买更新的型号了，反正声卡这玩意够用的话也不太需要追新。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;很多朋友都知道我除了是个程序员以外还是个乐器玩家，很久之前因为想要录音上网了解了一下需要购买专门的麦克风声卡从此掉进深坑一发不可收拾。当然 Linux 用户在购买硬件之前需要做好功课，大概 16 年左右我还在上高中的时候用我还凑合的英语水平翻了几个 Linux 音乐论坛最后决定买一台 Focusrite Scarlett 2i4（不过它后来似乎更新了几个版本所以我购买的变成了 1st Gen），我不太清楚除了更换了接口之后还有什么奇怪的改动没有，所以这里就不盲目推荐大家买更新的型号了，反正声卡这玩意够用的话也不太需要追新。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;做功课的时候还了解到常见的 Linux 桌面采用的都是 PulseAudio，但专业录音为了追求更低的延迟所以都使用 JACK，于是简单学习了一下，发现只要打开 Qjackctl 选择设备然后启动，Audacity 就可以选择使用 JACK 设备了。系统的其它软件仍然通过 PulseAudio 输出到板载声卡，不会冲突，基本满足我的需求也就没研究过其它的。&lt;/p&gt;
&lt;p&gt;但是最近直播的时候总有人说我的耳机麦克风不太灵敏，我想了想不如干脆把录音用的声卡和话筒利用上，整个系统直接采用 2i4 作为默认声卡？但是虽然 PulseAudio 可以直接控制 2i4，软件的兼容性却不太好，比如 Audacity 启动的时候即使没有运行 JACK 它似乎也会尝试通过 JACK 连接 2i4 于是导致缓慢的启动和几下破音。于是只能采用网上常见的方案也就是把 PulseAudio 的音频输出到 JACK，但我觉得其实这样不太准确因为音频是既有输出又有输入的，所以我的标题是把 PulseAudio 运行在 JACK 上层。当然还有一种方案是采用 PipeWire，打算自己替代 PulseAudio 和 JACK 一桶浆糊的新项目，它欺骗程序让它们以为它就是 JACK 和 PulseAudio，但虽然我是个 GNOME Dev，我对这个不太感冒。有个常见的笑话是“现在有 N 个不那么好用的系统了，我们写个新的把它们全部替代掉！然后现在有 N + 1 个不那么好用的系统了！”。JACK 对于专业用户来说很好用，而专业用户通常是不太喜欢变化的，所以我不太期待 PipeWire 替代 JACK。&lt;/p&gt;
&lt;p&gt;有人说 Linux 的音频系统比意大利面条还复杂，这倒不能说错，因为假如你看维基百科上那张巨恐怖的图的话确实是这样。但本质上来说音频不过是把信号丢给声卡，所以只要是个能写声卡的软件都可以叫音频系统嘛，也就不奇怪那张图那么复杂，实际上在现代的 Linux 桌面通常都集成 PulseAudio，我们也没必要去研究那些边边角角的奇怪方案，于是整个结构其实很清晰，一般的用户看到的都是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/typical-desktop.png&quot; alt=&quot;typical-desktop&quot;&gt;&lt;/p&gt;
&lt;p&gt;然后作为对比，我之前的方式是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/mine-old.png&quot; alt=&quot;mine-old&quot;&gt;&lt;/p&gt;
&lt;p&gt;而这篇文章要达到的目的则是下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/mine-new.png&quot; alt=&quot;mine-new&quot;&gt;&lt;/p&gt;
&lt;p&gt;当然实际上假如你理解了这个结构的话，其实也没必要只用一个声卡，完全可以用独立声卡录音用板载声卡输出，只是 JACK 是绑定独立声卡的，于是就像下图这样：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/some-interesting-things.png&quot; alt=&quot;some-interesting-things&quot;&gt;&lt;/p&gt;
&lt;p&gt;总之这样做的依据在于 JACK 被我们绑定了独立声卡，然后利用 PulseAudio 设置不同的输入输出设备控制基于 PulseAudio 的桌面程序的输入输出，同时它还可以把自己作为 JACK 的客户端。而具体到与声卡交互，则全部都是内核里面的 ALSA 组件控制的。这里没有涉及到使用 ALSA 用户态组件的客户端程序，因为 PulseAudio 会把自己伪装成 ALSA 的客户态组件，于是这些老旧的程序就被连接到了 PulseAudio 上面从而无法直接占据声卡了。&lt;/p&gt;
&lt;p&gt;了解原理之后就可以具体操作，首先需要安装 jack2，这个软件包包含的是 JACK 的组件，必须要装 jack2 因为 jack1 不支持 DBus 所以也就没办法和桌面交互了。安装 qjackctl 来控制 JACK，然后安装 pulseaudio-jack，这是让 PulseAudio 作为 JACK 客户端的兼容层。&lt;/p&gt;
&lt;p&gt;然后需要启动 Qjackctl，在 Setup 的 Settings 选项卡里面选择 Advanced，将 Input Device 和 Output Device 全都设置为 2i4（应该就是 hw:USB 那一项），然后切换到 Misc 选项卡，像下图那样设置 Others 部分（基本就是除了 Keep child windows always on top 的全都勾上），这样就可以做到毫无感觉的启动 JACK（只要打开 Qjackctl 它就在后台启动 JACK，退出 Qjackctl 也只是退到后台）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Run-PulseAudio-on-Top-of-JACK/misc-tab.png&quot; alt=&quot;misc-tab&quot;&gt;&lt;/p&gt;
&lt;p&gt;这样再次启动 Qjackctl，应该 JACK 就已经在控制 2i4 了，PulseAudio 应该会自动把 2i4 的控制权交给 JACK，省了不少事情。对于一些原生支持 JACK 的客户端程序来说这已经足够了，比如 Ardour 或者 Audacity，它们不经过 PulseAudio，直接连接到 JACK。接下来需要调整的是那些基于 PulseAudio 的客户端程序。&lt;/p&gt;
&lt;p&gt;然后打开你桌面环境的音频控制器，比如我是 GNOME 就是 GNOME Control Center 里面的 Sound 选项卡，这里基本都是集成的 PulseAudio 控制，把 Input Device 设置成 Jack Source，于是 2i4 上的麦克风的录音便通过 JACK 传到 PulseAudio 再传到 PulseAudio 的客户端程序比如 OBS Studio 和 Firefox。然后如果你想让 PulseAudio 的客户端程序把音频输出到 2i4 上的耳机里面，那就将 Output Device 设置为 Jack sink，这样其实 PulseAudio 就是运行在 JACK 上层。&lt;/p&gt;
&lt;p&gt;最后你需要设置 JACK 在登录时启动，这样 PulseAudio 才能找到 JACK，这个很简单，因为我们已经设置 Qjackctl 无感启动 JACK 了，那只要将 Qjackctl 设置为自动启动即可，比如 GNOME 用户可以在 GNOME Tweaks 里面设置。&lt;/p&gt;
&lt;p&gt;当然，一般的家庭录音用户都是单声道麦克风，某些客户端程序需要自己手动设置，比如 OBS Studio 需要在 Advanced Sound Properties 里面勾选 Mono。&lt;/p&gt;
&lt;p&gt;如果你遇到了一些奇怪的明明已经设置 PulseAudio 重定向到 JACK 却没有声音的情况，可能是因为你某些软件或者插件带了奇怪的设置，建议先重置它们试试。&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="Linux" label="Linux" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/" />
    
    <category term="音频" label="音频" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/Linux/%E9%9F%B3%E9%A2%91/" />
    
    
    <category term="录音" label="录音" scheme="https://sh.alynx.one/tags/%E5%BD%95%E9%9F%B3/" />
    
    <category term="PulseAudio" label="PulseAudio" scheme="https://sh.alynx.one/tags/PulseAudio/" />
    
    <category term="JACK" label="JACK" scheme="https://sh.alynx.one/tags/JACK/" />
    
  </entry>
  
  
  
  <entry>
    <title>StackHarbor 的 2020 尾记</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/2020-Tail/" />
    <id>https://sh.alynx.one/posts/2020-Tail/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2021-01-04T09:21:33.000Z</published>
    
    
    <updated>2021-01-04T09:21:33.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我最近思考了一下，总是记不起来去年的总结写了什么，结果翻了一下博客发现我的记忆力是对的——我去年还真的就忘了写总结。&lt;/p&gt;
&lt;p&gt;今年的总结因为各种原因写的稍微晚了一点，不过总之还算是写了，比忘记写要好得多吧！&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我最近思考了一下，总是记不起来去年的总结写了什么，结果翻了一下博客发现我的记忆力是对的——我去年还真的就忘了写总结。&lt;/p&gt;
&lt;p&gt;今年的总结因为各种原因写的稍微晚了一点，不过总之还算是写了，比忘记写要好得多吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;以前小时候总是觉得一年过得很慢，要过很久才到新一年放烟花吃饺子，但是现在觉得一年过得很快，可能要忙的事情多了就会觉得时间不够用。但我一般来说又不觉得自己做了什么值得记录的事情，看到别人的博客年终总结写的特别充实，又是自己出国求学又是自己找实习转正的，但是到了我自己总觉得这些也没什么好写的。再加上我是个相当讨厌计划的人，所以也没什么“检查自己一年的完成度”的机会。&lt;/p&gt;
&lt;p&gt;不过我在那些不错的年终总结里面还是学到了一些东西，所以打算也写点类似的。不过我虽然是程序员，写文章还是习惯从头到尾写，不擅长做那些分类加标题的事情，所以就想到哪写到哪。&lt;/p&gt;
&lt;p&gt;2020 年感觉最不错的事情大概是加入某绿色蜥蜴工作，虽然这个严格来说从 2019 年就开始了，但是我去年忘记写总结了……多亏了同学的推荐得到了一份实习，面试感觉很好，没有考什么我特别不擅长的算法题而是一些实践性的知识，这个我还是挺擅长的。然后同事也都相当好相处，一开始是测试相关的工作，也了解了很多测试方面的知识，甚至还写了点 perl（虽然只了解皮毛），总之是很有意思的经历，然后更意外的是领导居然主动问我有没有什么别的感兴趣的领域，因为我一直是 GNOME 用户所以对 GNOME 维护挺感兴趣的，结果后面就转到 GNOME 组去实习了（这也太好了吧天哪）。然后就是快毕业了需要准备正式工作，一般来说这边没有类似国内互联网企业那样招一大堆实习生然后给几个转正名额竞（yang）争（gu）的途径，并且他们也几乎不进行校招，对毕业生和社招一视同仁，虽然我个人很想在这工作，但是如果想留下来的话还挺看运气的。这时候领导又和我说正好组里有空缺职位，可以安排面试，只要能保证一直实习到正式入职就可以了，于是又十分幸运的毕业之后正式入职。总之能在自己感兴趣的领域做工作已经是十分幸运了，然后待遇相对来说也不错，特别是看多了加班猝死的新闻，心里更加满足了……同事也都很友善，而且都是技术类型的，做的又都是开源相关，平时也很聊得来。今年整体来说不是那么容易找工作的，我都要反思我为什么那么幸运了……顺便由于疫情原因，我司今年一直是在家办公状态，也节省了好多通勤的时间金钱……&lt;/p&gt;
&lt;p&gt;在找工作这方面我实在是没什么经验可谈，我太靠运气了……如果非要说的话，就是平时自己多学习多写写程序吧……&lt;/p&gt;
&lt;p&gt;因为工作的原因今年一直是自己在外面住的，房租好贵啊……至于自己住虽然挺安静的但也挺麻烦的……把东西从学校搬出来也花了不少麻烦。&lt;/p&gt;
&lt;p&gt;今年个人项目方面没做什么新东西，去年把 Hikaru 从 CoffeeScript 换成 JavaScript 之后基本就只是写文档、加测试、改功能，大改是去掉了 cheerio 改成自己实现了一部分功能，谁叫他们一年不更新……主题方面给 ARIA 做了个大改是去掉了 jQuery 加上了暗色模式，当然我自己看起来界面并没有什么变化。大一时候写的 FlipClock 努努力改成了 CMake，然后这样就可以跨平台做成 Windows 屏保了。顺便了解了一下怎么在 Android 上面运行 SDL，做了个 Android 的 FlipClock。而至于我的弹钢琴页面和 Telegram Bot，我已经忘记是今年还是去年写的了……&lt;/p&gt;
&lt;p&gt;今年折腾了一遍我的电脑，因为终于有时间和钱玩自己的台式机了，仔细想想好像把之前的能换的都换了，27 寸的显示器对没有双屏空间的人来说提升了不少工作效率，5800X 打游戏也很爽，就是钱包不太舒服……&lt;/p&gt;
&lt;p&gt;口琴方面今年年末又高产起来了，而且开始剪视频，发现达芬奇可以在 Linux 下面用（虽然有些限制）（Adobe 看看人家！），而且还挺流畅的，于是看了影视飓风的达芬奇教程学了一些基本的剪辑知识，为了用的更舒服还闲鱼买了个加密狗（假货很多，安全下车），今后可能剪视频的频率会逐渐增多，就当练习新技能了。&lt;/p&gt;
&lt;p&gt;手机打算再用一年，今年手机厂商出的都是什么垃圾？我现在也想清楚了反正手机又不能给我带来收入，有这个钱还不如投资到台式机上，希望各种换手机患者也考虑一下，我现在是能用就行了。除非哪个厂家出一个摄像头不丑还有耳机孔最好还是直屏系统不要乱删乱改的旗舰机。&lt;/p&gt;
&lt;p&gt;动漫除了看电磁炮 T 以外就是看了紫罗兰永恒花园，一开始很多人吹导致我对这个比较反感，实际看了以后觉得还是很不错的，所以吹得太过果然会招黑吗……电磁炮 T 总之中规中矩，能有第三部已经很不错了，我还想看第四部……、&lt;/p&gt;
&lt;p&gt;认识了一些新朋友，同时很多老朋友也都有各自要忙的事情，总之几乎没什么人一起打游戏了……不过经常能和蓝猫她们一起出去玩还是避免了成为死宅的命运，本来我都打算在家打游戏跨年了，最后和蓝猫狐狸一起吃了海底捞，虽然三点才回家导致第二天犯了鼻炎，不过还是非常开心。&lt;/p&gt;
&lt;p&gt;年末通关了 Titanfall 2，剧情很短，中规中矩，但是就已经是非常不错了，除了操作不适合我这个手残以外都很适合我。今年几乎没怎么玩 CSGO，但是下班之后有很多空余时间基本都投入在 Dota 2 上面了，虽然我也看很久 Dota 2 了，但是玩起来确实很难……不过我这一年一直都沉迷在中单光一直播里面，已经成了我玩 Dota 2 的动力了……现在多少也算入门了，虽然偶尔还是操作不过来，但至少明白是个怎么回事了。中单光一的直播真的很好看！正人君子，皮又好看，说话又好听，打游戏厉害，又很温柔。一开始我只是看他打 Dota，反正讲围棋我又看不懂，但我发现他读围棋棋手传记有意思多了，已经进入追小说模式了……拖到现在才写年终总结也是因为坐了 16 个小时的火车跑到上海去看 VirtuaReal 的第一次线下 Live，不过互动环节没抽到我实在是令人沮丧，我太非了，那么多人根本没我的机会呜呜呜呜呜……&lt;/p&gt;
&lt;p&gt;就写这些吧，希望 2021 年大家的生活都能变得顺利！&lt;/p&gt;

    </content>
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    
    
    <category term="时光飞逝" label="时光飞逝" scheme="https://sh.alynx.one/tags/%E6%97%B6%E5%85%89%E9%A3%9E%E9%80%9D/" />
    
  </entry>
  
  
  
  <entry>
    <title>解决 Spleeter 愚蠢的依赖问题</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fix-Silly-Spleeter-Dependencies/" />
    <id>https://sh.alynx.one/posts/Fix-Silly-Spleeter-Dependencies/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-11-26T08:43:12.000Z</published>
    
    
    <updated>2020-11-26T08:43:12.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我倒不是对机器学习有什么莫名的偏见。事实上有些只能用机器学习搞定的东西我也很支持用机器学习解决，比如 waifu2x 这种增加图片分辨率的或者 Spleeter 这种分离人声和伴奏的，用传统的分离人声的方法就是不能完美解决这类问题，而机器学习模糊分类则可以无限接近完美解决。我讨厌的有两个，一个是传统方法很好解决的东西非要用机器学习解决，另一个是混乱的机器学习项目，后者更严重。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我倒不是对机器学习有什么莫名的偏见。事实上有些只能用机器学习搞定的东西我也很支持用机器学习解决，比如 waifu2x 这种增加图片分辨率的或者 Spleeter 这种分离人声和伴奏的，用传统的分离人声的方法就是不能完美解决这类问题，而机器学习模糊分类则可以无限接近完美解决。我讨厌的有两个，一个是传统方法很好解决的东西非要用机器学习解决，另一个是混乱的机器学习项目，后者更严重。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;不知道是因为什么原因，许多机器学习从业者似乎都缺乏整理代码和依赖的能力——能轻松地把一个这类开源项目打包简直是奇迹，更多时候别提打包了，你想自己安装然后跑起来都不太现实，哪怕是同样做机器学习的其他人也有这样的苦恼：实现者似乎把论文写好然后在自己电脑上能跑起来就心满意足了，丢出来一份没什么文档的代码，不折腾几天根本不知道这坨代码需要装些什么才能跑起来。对我这种洁癖用户就更严重了，我可不希望 pip 在我的系统里塞一堆乱七八糟的东西，这个需要其他项目才能避免全局安装的程序比起 npm 真是差远了，解决依赖的能力也远不如 pacman 和 npm。&lt;/p&gt;
&lt;p&gt;然后有人发明了 conda 和 docker 这样的 &lt;del&gt;辣鸡&lt;/del&gt; 项目来拯救其他的辣鸡，但事实上不过是变得更糟而已——它们给了一些懒人名正言顺不维护项目的借口——反正我丢一个 conda 配置或者 docker 文件上去，你们拉上一大堆和我一样的过期依赖就能跑了，至于占了你多少硬盘，干不干净，关我什么事？如果不是物理限制，恐怕这些懒人会把整个宇宙都塞进去。而且他们再也不会管版本更新，什么 tensorflow 2 与我何干？用了我的 docker 你的系统里就会有几百个不同的过期的 tensorflow 1，买硬盘就完了呗？这和买显卡就完了呗还真是一路货色，这样依赖商业公司的产品，总有一天感觉会被割韭菜。&lt;/p&gt;
&lt;p&gt;今天我用到的这个 Spleeter 某种意义上也是这样的一坨辣鸡，它的仓库里面的 README 是完全过时的，但这起码是件好事：代码还在更新。只是你按照文档是没办法顺利的搞定它的，我总结了一下我的解决方案，可能不适合其他人，但我大概知道怎么解决了。&lt;/p&gt;
&lt;p&gt;这个文档有多离谱呢？它说你如果使用 GPU 加速的版本，必须从 conda-forge 安装，pip 和 GitHub 的版本都只有 CPU——那你这也是按揭开源？然后整个文档没有一个地方告诉我我需要单独下载训练好的模型才能跑起来，直接运行程序则丢一个段错误——可能他们搞机器学习的人觉得下模型是常识不需要说吧。&lt;/p&gt;
&lt;p&gt;如果直接按它的方法运行 &lt;code&gt;conda install -c conda-forge spleeter-gpu&lt;/code&gt;，你会得到一个不能用 GPU 的 GPU 版，这实在是太搞笑了。我捏着鼻子用 conda 就是为了能让你一步把这一坨东西给我弄好，现在你说你弄不好？&lt;/p&gt;
&lt;p&gt;但是有一点好处就是实际上他们的代码已经更新到支持 tensorflow 2 了，所以其实完全不需要用那个过期的 conda-forge 的版本，你完全可以直接在 Python 3.8 里面 &lt;code&gt;pip install spleeter-gpu&lt;/code&gt; 安装最新的版本——然后我又遇到了依赖问题，我的一些系统软件包依赖 numpy，然后 Arch 官方源里的 numpy 版本还是比 spleeter-gpu 依赖的 tensorflow 依赖的 numpy 版本新——你们写 Python 的人真麻烦，版本号兼容性是可以随便 break 的吗？&lt;/p&gt;
&lt;p&gt;所以这时候我还是用 conda 解决，总之就是搞一个和系统独立的虚拟环境（npm：这不应该是内置功能吗？还需要用商业软件？）。总之&lt;a href=&quot;https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;去 TUNA 搞一个 Miniconda 3 最新的安装包来&lt;/a&gt;，然后直接安装，看着它往你的 shell 配置里塞一坨辣鸡（我把实际用到的命令拿出来做了个 alias，这样就可以只在我需要的时候打开 conda 了）。&lt;/p&gt;
&lt;p&gt;为什么使用 miniconda 而不是 anaconda？因为 anaconda 带的那个图形界面根本用不了，miniconda 够用了。&lt;/p&gt;
&lt;p&gt;然后创建一个 Python 3.8 的环境，高了低了都不行，真是难伺候，同时别忘了带上 cuda 和 cudnn，不然它一声不吭的就会只能用 CPU：&lt;/p&gt;
&lt;figure data-raw=&quot;$ conda create -n spleeter python=3.8 cudatoolkit cudnn
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ conda create -n spleeter python=3.8 cudatoolkit cudnn
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;cuda 不叫 cuda，叫 cudatoolkit 就离谱。&lt;/p&gt;
&lt;p&gt;然后切进去：&lt;/p&gt;
&lt;figure data-raw=&quot;$ conda activate spleeter
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ conda activate spleeter
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后装 &lt;code&gt;spleeter-gpu&lt;/code&gt; 到 conda 新创建的这个 Python 环境：&lt;/p&gt;
&lt;figure data-raw=&quot;$ pip install spleeter-gpu
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ pip install spleeter-gpu
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;所有的依赖应该 pip 都会解决，但这个弱智有时候还会说我本机已经装了 numpy 1.19.4，比 tensorflow 需要的版本高，但我都创建虚拟环境了你还读取我系统的干嘛？不过其实好像也不影响使用，或者此时可以 &lt;code&gt;pip install numpy==1.18.5&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后到 &lt;a href=&quot;https://github.com/deezer/spleeter/releases&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://github.com/deezer/spleeter/releases&lt;/a&gt; 去下载训练好的模型，这也是个弱智的地方：哪有 tar 打包不把目录本身打进去的？然后还得给这个程序创建一个工作目录，因为它是写死的到当前目录下面的 &lt;code&gt;pretrained_models&lt;/code&gt; 下面去找模型。&lt;/p&gt;
&lt;figure data-raw=&quot;$ mkdir -p spleeter/pretrained_models
$ cd spleeter/pretrained_models
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ mkdir -p spleeter/pretrained_models
$ cd spleeter/pretrained_models
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;我这里用 2stems 的模型示范，因为我只需要分离人声和伴奏：&lt;/p&gt;
&lt;figure data-raw=&quot;$ wget -c &#039;https://github.com/deezer/spleeter/releases/download/v1.4.0/2stems.tar.gz&#039;
$ mkdir 2stems
$ cd 2stems
$ tar -xpvzf ../2stems.tar.gz
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ wget -c &#039;https://github.com/deezer/spleeter/releases/download/v1.4.0/2stems.tar.gz&#039;
$ mkdir 2stems
$ cd 2stems
$ tar -xpvzf ../2stems.tar.gz
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为他们打 tar 包时候没把目录打进去，所以别忘了自己创建目录！&lt;/p&gt;
&lt;p&gt;然后回到你的工作目录就可以用了，我这里结构是 &lt;code&gt;spleeter/pretrained_models/2stems&lt;/code&gt; 所以工作目录就是 &lt;code&gt;spleeter&lt;/code&gt;：&lt;/p&gt;
&lt;figure data-raw=&quot;$ cd ../../
$ spleeter separate -i 你要处理的歌曲 -p spleeter:2stems -o 输出目录 -B tensorflow
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;$ cd ../../
$ spleeter separate -i 你要处理的歌曲 -p spleeter:2stems -o 输出目录 -B tensorflow
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;如果你想使用其他的几个模型，那就把 2stems 改成其他模型的名字，但是这里还有个开发者脑子抽了的地方：带有 &lt;code&gt;-finetune&lt;/code&gt; 的是高品质模型，它们的模型目录名字应该是比如 &lt;code&gt;2stems-finetune&lt;/code&gt;，但是参数名字却不是这个而是 &lt;code&gt;-p spleeter:2stems-16kHz&lt;/code&gt;，文档里当然是没找到的，我觉得应该揍开发者一顿让他老实写文档（不过我又看了一下，这个 finetune 对于分离音轨没什么用好像）。&lt;/p&gt;
&lt;p&gt;我这里必须使用 &lt;code&gt;-B tensorflow&lt;/code&gt; 才会走显卡加速。&lt;/p&gt;
&lt;p&gt;用完了就可以 &lt;code&gt;conda deactivate&lt;/code&gt; 退出虚拟环境，要用的时候别忘了 &lt;code&gt;conda activate spleeter&lt;/code&gt; 切换进来，&lt;/p&gt;
&lt;p&gt;遇到类似问题的同学可以参考我的文章，但是因为这个处理过程影响因素太多了，如果你的不能用我也没什么办法。&lt;/p&gt;
&lt;p&gt;回头一看，这个项目犯了一大堆禁忌：难以解决的依赖，写死的模型路径还有匮乏的文档，导致配环境就要配一大堆。当然，好在他们还是在努力更新跟上依赖而不是撒手不管让它慢慢死去，并且功能非常好。真正对开发者友好应该是不需要配环境的，比如在 Linux 下面开发软件，包管理已经帮你考虑好各种依赖了。只有像 Windows 或者 Android 这种不以开发者为中心或者是许多机器学习项目这种“数据好看就行”的地方才会有这么多麻烦。真的很希望这些人能补一点务实的基础，不要让他们的软件这么难用。&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    
    <category term="Python" label="Python" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/Python/" />
    
    
    <category term="Python" label="Python" scheme="https://sh.alynx.one/tags/Python/" />
    
    <category term="Spleeter" label="Spleeter" scheme="https://sh.alynx.one/tags/Spleeter/" />
    
  </entry>
  
  
  
  <entry>
    <title>奇怪的书名和我和吐槽</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Strange-Book-Names/" />
    <id>https://sh.alynx.one/posts/Strange-Book-Names/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-10-06T09:48:00.000Z</published>
    
    
    <updated>2020-10-06T09:48:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;好久没更新非技术类博文了。可能很多人不但丢掉了阅读的习惯，连书店都不去了，书店都沦为练习册店，学生们更加对书店敬而远之，这种恶性循环实在是可悲又无趣的事情。&lt;/p&gt;
&lt;p&gt;今天和同学一起去了书店，在常规意义的书店而非练习册店的部分发现了一些有趣或奇怪的书名，很有槽点，让人想要吐槽。于是拍了点照片发到这里。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;好久没更新非技术类博文了。可能很多人不但丢掉了阅读的习惯，连书店都不去了，书店都沦为练习册店，学生们更加对书店敬而远之，这种恶性循环实在是可悲又无趣的事情。&lt;/p&gt;
&lt;p&gt;今天和同学一起去了书店，在常规意义的书店而非练习册店的部分发现了一些有趣或奇怪的书名，很有槽点，让人想要吐槽。于是拍了点照片发到这里。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E5%A5%97%E5%A8%83%E5%9E%8B&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E5%A5%97%E5%A8%83%E5%9E%8B&quot;&gt;&lt;/a&gt;套娃型&lt;/h1&gt;
&lt;p&gt;此类书名非常适合套娃，比如这本《如何阅读一本书》，且不说阅读方法因人而异且随经验变化，单就这个名字还可以有《如何阅读如何阅读一本书》、《如何阅读如何阅读如何阅读一本书》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/1.jpg&quot; alt=&quot;如何阅读一本书&quot;&gt;&lt;/p&gt;
&lt;p&gt;我以为只有当代为搏销量疯狂吸引眼球的作者会起这种名字，然而接下来我看到了一本《木心谈木心》。虽然我不太清楚木心是谁，但似乎是个有名的作者。这书名总是让我想后续会不会有《木心谈木心谈木心》、《木心谈木心谈木心谈木心》。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/2.jpg&quot; alt=&quot;木心谈木心&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;%E6%80%A7%E8%BD%AC%E5%9E%8B&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E6%80%A7%E8%BD%AC%E5%9E%8B&quot;&gt;&lt;/a&gt;性转型&lt;/h1&gt;
&lt;p&gt;这本书的名字非常奇特，她叫做《少女福尔摩斯》，作为半资深福尔摩斯迷和半资深月球氪金母X，我只能说型月都没敢做的这作者做了。由于原作实在是珠玉在前，写老福的故事已经很难了，性转老福怕是难上加难，建议寄一本给蘑菇看看。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/3.jpg&quot; alt=&quot;少女福尔摩斯&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;%E8%B9%AD%E7%83%AD%E5%BA%A6%E5%9E%8B&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E8%B9%AD%E7%83%AD%E5%BA%A6%E5%9E%8B&quot;&gt;&lt;/a&gt;蹭热度型&lt;/h1&gt;
&lt;p&gt;这位叫蒋勋的作者在书架上占据了一片，又是说唐诗又是说宋词，一会谈莫奈一会谈高达哦不是梵高和达芬奇，想必上知天文下知地理。&lt;strong&gt;不过这书脊把这些名人加粗放在下面，让我总是有一种这是个达芬奇/梵高/莫奈的著作、作品标题叫做蒋勋的感觉。&lt;/strong&gt; 不知道这个叫蒋勋的作品是不是样样通样样松呢？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/4.jpg&quot; alt=&quot;蒋勋&quot;&gt;&lt;/p&gt;
&lt;p&gt;还有这本《逝水年华》，连我的输入法都怀疑我是不是想输入《追忆似水年华》，敢问作者是不是有点大舌头，让出版社的编辑听错了标题？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/5.jpg&quot; alt=&quot;逝水年华&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;%E8%BF%9E%E9%94%81%E5%8F%8D%E5%BA%94%E5%9E%8B&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Strange-Book-Names/#%E8%BF%9E%E9%94%81%E5%8F%8D%E5%BA%94%E5%9E%8B&quot;&gt;&lt;/a&gt;连锁反应型&lt;/h1&gt;
&lt;p&gt;《知更鸟》吗？大家都说有本书想杀你，不知道与你是什么关系？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/6.jpg&quot; alt=&quot;知更鸟&quot;&gt;&lt;/p&gt;
&lt;p&gt;虽然《重返美丽新世界》和《美丽新世界》是一个作者，但总让我想起狗尾续貂，不知道是不是我错了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/7.jpg&quot; alt=&quot;美丽新世界&quot;&gt;&lt;/p&gt;
&lt;p&gt;好家伙，你把《24个比利》放在这，那他们肯定会打架的，不过叫《比利打群架》比《比利战争》更好吧，无谓夸大不可取，要实事求是。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/8.jpg&quot; alt=&quot;比利&quot;&gt;&lt;/p&gt;
&lt;p&gt;《面包树上的女人》怎么啦？她没怎么，《面包树出走了》，那可真是个离奇的故事，但是你这内容就不知道是不是好故事了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/9.jpg&quot; alt=&quot;面包树&quot;&gt;&lt;/p&gt;
&lt;p&gt;我以为文学大家不屑于做这种在标题上吸引人的无聊事情，毕竟内容才是王道。我也不是有意冒犯杨绛先生，但是《洗澡》做书名已经是太随意了，再整一本《洗澡之后》是不是过分了？还是说这是出书的不负责任的编辑洗澡前洗澡后决定的两本文集的名字？那这就说得通了。但是说实话《洗澡》、《洗澡之后》接下来摆一本《暗示》是不是店员的恶趣味？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Strange-Book-Names/10.jpg&quot; alt=&quot;洗澡&quot;&gt;&lt;/p&gt;
&lt;p&gt;希望看了我文章的朋友不要给我评论“一看到白胳膊……”，我老实承认我不是一个完全脱离了低级趣味的人，写这文章也是让大家开心一下，毕竟实事求是更重要。我也希望写书的作者们都实事求是一点，内容不行，靠标题党吸引人肯定是经不起考验的。&lt;/p&gt;

    </content>
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/categories/%E7%94%9F%E6%B4%BB/" />
    
    
    <category term="生活" label="生活" scheme="https://sh.alynx.one/tags/%E7%94%9F%E6%B4%BB/" />
    
  </entry>
  
  
  
  <entry>
    <title>固定 GNOME Shell 的输入法列表</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fixed-IME-List-for-GNOME-Shell/" />
    <id>https://sh.alynx.one/posts/Fixed-IME-List-for-GNOME-Shell/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-09-26T02:40:00.000Z</published>
    
    
    <updated>2020-09-26T02:40:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;GNOME Shell 有个令人很不爽的“特性”，它的输入法列表使用的是最近使用优先排列。也就是说当你有三个或以上输入法的时候，比如我，我有英文简体中文和日语输入法，我经常在中英之间切换，这没什么，前两个总是中英所以按一次就可以在这两个之间切换，但假如我偶尔用了一次日语输入法，我的列表就被打乱了，我不清楚按几下才能切回中文，并且再切到英文也得看一眼才能知道。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;GNOME Shell 有个令人很不爽的“特性”，它的输入法列表使用的是最近使用优先排列。也就是说当你有三个或以上输入法的时候，比如我，我有英文简体中文和日语输入法，我经常在中英之间切换，这没什么，前两个总是中英所以按一次就可以在这两个之间切换，但假如我偶尔用了一次日语输入法，我的列表就被打乱了，我不清楚按几下才能切回中文，并且再切到英文也得看一眼才能知道。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我不是很理解这个特性存在的意义，设置里面是可以手动调节输入法的顺序的，我明明调成了我想要的顺序，你就给我这个顺序好了，这样我闭着眼睛不用动脑子都能猜出来要按几下，比如从英文到日语按两下，中文到日语按一下等等。可能有些人的脑子长得比较擅长模拟最近使用优先排列？反正我不行。&lt;/p&gt;
&lt;p&gt;既然感觉不爽那就动手处理一下好了，最近看了一些有关写 GNOME Shell 扩展的文档，所以写个扩展解决一下就可以了。为什么不直接提交给上游？因为上游一开始是固定顺序的，但是很久以前某个人加了这个“特性”，现在如果提个请求说删掉这个特性，势必会陷入一场“用户到底是喜欢最近使用优先排列还是固定排列”的争论，这肯定很难得出结论（毕竟大部分的人实际上是不需要使用输入法的英语用户以及只有两种输入法的用户！），并且按照 GNOME 上游的习惯他们也是不愿意为了这个多添加一个开关的。所以比起在拉锯战上浪费时间，先搞一个能用的才是我的风格。至于升级之后扩展挂掉……不就是在上游里和其他代码一起被重构和我自己单独重构的区别吗？只要我还在用应该就会持续更新了。&lt;/p&gt;
&lt;p&gt;具体的解决方法比较 dirty，是我从别的扩展里学来的：把 GNOME Shell 里面的类的原型上的方法替换成自己的，就可以修改实例调用时的函数了（也算 JS 特性之一），不过不要用箭头函数，因为显然我们希望 &lt;code&gt;this&lt;/code&gt; 是调用时的上下文也就是实例，而不是绑定到当前上下文。&lt;/p&gt;
&lt;p&gt;因为这算是我第一个扩展所以也多少记录一下踩的坑。&lt;/p&gt;
&lt;p&gt;首先 Gjs 的导入和 Node.js 的导入是不一样的，它通过一个 &lt;code&gt;imports&lt;/code&gt; 对象引入其他库，比如通过 GI 导入的就在 &lt;code&gt;gi&lt;/code&gt; 下面，因为是 GNOME Shell 扩展所以可以访问 GNOME Shell 的 JS 库，就是简单地把 JS 路径换成对象的 key 然后 JS 文件里所有的 &lt;code&gt;var&lt;/code&gt; 和 &lt;code&gt;function&lt;/code&gt; 都会被导出。比如导入 &lt;code&gt;Main&lt;/code&gt; 就是 &lt;code&gt;imports.ui.main.Main&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然后就是怎么知道要修改什么以及如何获取到相关对象，不过因为 GNOME Shell JS 部分经常重构，也没什么完整的文档，反正只能多花时间看代码吧，而且它的结构其实比看起来的要复杂，所以经常需要仔细翻来翻去的。比如 GNOME Shell 的输入法部分很多人认为是需要修改 iBus，实际上 GNOME Shell 只是调用 iBus 作为后端，自己处理状态和界面，这部分的代码都在 &lt;code&gt;js/ui/status/keyboard.js&lt;/code&gt; 里面。&lt;/p&gt;
&lt;p&gt;扩展主要有 &lt;code&gt;init()&lt;/code&gt;，&lt;code&gt;enable()&lt;/code&gt; 和 &lt;code&gt;disable()&lt;/code&gt; 三个函数，&lt;code&gt;init()&lt;/code&gt; 在 GNOME Shell 加载扩展时候调用，我这个显然不需要。&lt;code&gt;enable()&lt;/code&gt; 是你在 Extensions app 里面打开开关时候调用的，&lt;code&gt;disable()&lt;/code&gt; 是关掉开关时候调用的。&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;enable()&lt;/code&gt; 里面有几个需要我修改的地方，一个是阻止 &lt;code&gt;InputSourceManager&lt;/code&gt; 在输入法切换之后的最近使用优先排列，解决方法很简单，需要自己替换掉 &lt;code&gt;_currentInputSourceChanged&lt;/code&gt; 函数，注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L447-453&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L447-453&lt;/a&gt; 这一段更新代码。&lt;/p&gt;
&lt;p&gt;当然光有这个还是不行的，这样假如你是先切换过再打开扩展，实际上列表是你开启扩展之前的状态而不是用户设置的顺序，所以我们还需要在打开扩展之后更新它的列表，让它直接读取用户设置。更新列表的函数是 &lt;code&gt;_updateMruSources&lt;/code&gt;，假如检测到当前列表为空，会先从一个缓存的 gsettings 里读取之前存储的最近使用优先排列列表，这显然是很恶心的所以要注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L504-522&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L504-522&lt;/a&gt; 这一段。之后它会先加载当前列表里的，然后再把用户列表里增加的当前列表里没有的加到后面，因为我们已经决定要清空当前列表并且不加载 gsettings 里面的缓存，所以这个当前列表肯定是空，那直接加用户列表就行了，所以注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L525-533&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L525-533&lt;/a&gt;。这样我们后续只要清空 &lt;code&gt;_mruSources&lt;/code&gt; 设置 &lt;code&gt;_mruSourcesBackup&lt;/code&gt; 为 &lt;code&gt;null&lt;/code&gt; 然后调用 &lt;code&gt;_updateMruSources&lt;/code&gt; 就可以了。&lt;/p&gt;
&lt;p&gt;然后我们需要获取运行时的这个 &lt;code&gt;InputSourceManager&lt;/code&gt; 实例，这个实例没有被绑定到 &lt;code&gt;Main&lt;/code&gt; 对象上，不过我阅读代码发现它是个单例模式，就是说在 &lt;code&gt;js/ui/status/keyboard.js&lt;/code&gt; 有一个 &lt;code&gt;_inputSourceManager&lt;/code&gt; 变量，然后有个 &lt;code&gt;getInputSourceManager()&lt;/code&gt; 的函数，被调用时候如果有就返回 &lt;code&gt;_inputSourceManager&lt;/code&gt; 否则创建一个赋值返回，其他代码都用的这个，所以我们也导入这个就行了。&lt;/p&gt;
&lt;p&gt;然后你会发现另一个弱智的地方，怎么每次按下切换键，切换框都是从第一个切换到第二个？不是应该从我当前的切换到下一个吗？这个对于当前输入法总在第一个的最近使用优先排列是可以的，但在我们这个场景选中的并不总是第一个，所以需要修改。这部分函数是 &lt;code&gt;_switchInputSource&lt;/code&gt;，可以看到它只是展示了一个 &lt;code&gt;InputSourcePopup&lt;/code&gt;，而 &lt;code&gt;InputSourcePopup&lt;/code&gt; 继承的是 &lt;code&gt;imports.ui.switcherPopup.SwitcherPopup&lt;/code&gt;，这个类有一个叫做 &lt;code&gt;_selectedIndex&lt;/code&gt; 的变量用于选择下一个上一个时候的计算，而且它默认是 0！不能通过参数初始化！真是头秃，不过我们可以在创建完切换框但展示之前单独设置这个值就行了，所以我在 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L412&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L412&lt;/a&gt; 的下一行插入如下代码：&lt;/p&gt;
&lt;figure data-raw=&quot;if (this._currentSource != null) {
  popup._selectedIndex = this._mruSources.indexOf(this._currentSource);
}
&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;if (this._currentSource != null) {
  popup._selectedIndex = this._mruSources.indexOf(this._currentSource);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为我们不一定总有 &lt;code&gt;_currentSource&lt;/code&gt; 所以还是要检查一下，如果没有的话让它从 0 开始也无所谓。&lt;/p&gt;
&lt;p&gt;然后还有一个比较头痛的是快捷键是绑定的回调函数，回调函数又绑定了 &lt;code&gt;this&lt;/code&gt;，所以我们光修改原型是改不了被回调的函数的，这个也简单，我们需要读一下 &lt;code&gt;InputSourceManager&lt;/code&gt; 的 &lt;code&gt;constructor&lt;/code&gt; 的代码，然后删掉它在 &lt;code&gt;Main.wm&lt;/code&gt; 里面绑定的组合键重新绑定成我们的，就是这样：&lt;/p&gt;
&lt;figure data-raw=&quot;Main.wm.removeKeybinding(&amp;quot;switch-input-source&amp;quot;);
_inputSourceManager._keybindingAction =
  Main.wm.addKeybinding(
    &amp;quot;switch-input-source&amp;quot;,
    new Gio.Settings({&amp;quot;schema_id&amp;quot;: &amp;quot;org.gnome.desktop.wm.keybindings&amp;quot;}),
    Meta.KeyBindingFlags.NONE,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );
Main.wm.removeKeybinding(&amp;quot;switch-input-source-backward&amp;quot;);
_inputSourceManager._keybindingActionBackward =
  Main.wm.addKeybinding(
    &amp;quot;switch-input-source-backward&amp;quot;,
    new Gio.Settings({&amp;quot;schema_id&amp;quot;: &amp;quot;org.gnome.desktop.wm.keybindings&amp;quot;}),
    Meta.KeyBindingFlags.IS_REVERSED,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );
&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;Main.wm.removeKeybinding(&quot;switch-input-source&quot;);
_inputSourceManager._keybindingAction =
  Main.wm.addKeybinding(
    &quot;switch-input-source&quot;,
    new Gio.Settings({&quot;schema_id&quot;: &quot;org.gnome.desktop.wm.keybindings&quot;}),
    Meta.KeyBindingFlags.NONE,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );
Main.wm.removeKeybinding(&quot;switch-input-source-backward&quot;);
_inputSourceManager._keybindingActionBackward =
  Main.wm.addKeybinding(
    &quot;switch-input-source-backward&quot;,
    new Gio.Settings({&quot;schema_id&quot;: &quot;org.gnome.desktop.wm.keybindings&quot;}),
    Meta.KeyBindingFlags.IS_REVERSED,
    Shell.ActionMode.ALL,
    InputSourceManager.prototype._switchInputSource.bind(_inputSourceManager)
  );
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;同样我们也不要忘记绑定 &lt;code&gt;this&lt;/code&gt;，实际上我们希望调用的时候绑定的 &lt;code&gt;this&lt;/code&gt; 是那个单例，那直接 &lt;code&gt;bind&lt;/code&gt; 它就好了。&lt;/p&gt;
&lt;p&gt;但是你会发现这个弱智的家伙没有按我们想象的工作！这是什么意思！仔细阅读代码之后我发现有如下逻辑：你按下的第一次组合键其实并不是算在那个弹框的按键回调里面，而是我们通过构造函数传递进去的，然后它分析这个传进去的按键是哪一种，调用 &lt;code&gt;_initialSelection&lt;/code&gt; 执行第一次切换，而这个家伙更弱智了！明明有 &lt;code&gt;_selectedIndex&lt;/code&gt; 它不用，竟然用硬编码的倒数第一个和第一个！真有你的啊！我不太敢修改 &lt;code&gt;SwitcherPopup&lt;/code&gt; 因为还有别的东西使用它，那就修改 &lt;code&gt;InputSourcePopup&lt;/code&gt; 这个子类吧，其实就是把 &lt;code&gt;InputSourcePopup.prototype._initialSelection&lt;/code&gt; 这个函数原来的的 &lt;code&gt;this._select(this._items.length - 1);&lt;/code&gt; 换成 &lt;code&gt;this._select(this._previous());&lt;/code&gt;，&lt;code&gt;this._select(1)&lt;/code&gt; 换成 &lt;code&gt;this._select(this._next())&lt;/code&gt;（1 其实是 0 + 1 的意思），不但功能增加了，可读性也提升了！&lt;/p&gt;
&lt;p&gt;现在搭配起来应该和我们的需求一致了！但假如我关掉扩展之后希望列表是打开之前的状态怎么办！还记得之前说的那个 &lt;code&gt;_updateMruSources&lt;/code&gt; 会读取 gsettings 吗？这个 gsettings 实际上在每次切换输入法的时候都会写入当前状态，那我们只要让它开启扩展时候不要写入，关掉扩展恢复的时候再更新不就读取了之前的状态吗。所以需要修改 &lt;code&gt;InputSourceManager.prototype._updateMruSettings&lt;/code&gt;，注释掉 &lt;a href=&quot;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L432-438&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://gitlab.gnome.org/GNOME/gnome-shell/-/blob/gnome-3-36/js/ui/status/keyboard.js#L432-438&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;总结一下其实就是在 &lt;code&gt;enable&lt;/code&gt; 的时候修改这些函数，然后获取单例，重新绑定快捷键，然后清空当前的列表重新更新列表，然后为了避免 bug，我们总是激活列表里的第一个输入法：&lt;/p&gt;
&lt;figure data-raw=&quot;if (_inputSourceManager._mruSources.length &gt; 0) {
  _inputSourceManager._mruSources[0].activate(true);
}
&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;if (_inputSourceManager._mruSources.length &amp;gt; 0) {
  _inputSourceManager._mruSources[0].activate(true);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;disable&lt;/code&gt; 的时候同样是把函数修改回去，然后获取单例，重新绑定快捷键这样它又绑成了原来的函数，然后清空当前的列表重新更新列表这样它就恢复到开启之前的顺序了，接下来同样地，因为最近使用优先列表的第一个元素肯定是正在用的，所以我们也还是激活第一个输入法就可以了。&lt;/p&gt;
&lt;p&gt;完整的项目参见 &lt;a href=&quot;https://github.com/AlynxZhou/gnome-shell-extension-fixed-ime-list/&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;GitHub&lt;/a&gt;，Arch Linux 用户也可以从 AUR 或者 Arch Linux CN 源安装 &lt;code&gt;gnome-shell-extension-fixed-ime-list&lt;/code&gt;。&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/GNOME/" />
    
    
    <category term="GNOME" label="GNOME" scheme="https://sh.alynx.one/tags/GNOME/" />
    
  </entry>
  
  
  
  <entry>
    <title>GObject 备忘录</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/GObject-Reminder/" />
    <id>https://sh.alynx.one/posts/GObject-Reminder/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-09-05T01:23:00.000Z</published>
    
    
    <updated>2020-09-05T01:23:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;说来惭愧，我一直记不太清 GObject 到底是怎么用的，毕竟作为一个写过 C++ 和 Python 然后常用 JS 的人来说，面向对象的实现是非常自然的，不需要考虑为什么。所以我总是看着一大堆类型转换和分散的定义以及各种 chain up 感到眩晕。而 GObject 的文档写的也相当分散，有种管中窥豹之感。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;说来惭愧，我一直记不太清 GObject 到底是怎么用的，毕竟作为一个写过 C++ 和 Python 然后常用 JS 的人来说，面向对象的实现是非常自然的，不需要考虑为什么。所以我总是看着一大堆类型转换和分散的定义以及各种 chain up 感到眩晕。而 GObject 的文档写的也相当分散，有种管中窥豹之感。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;有同学觉得其实把函数变成指针放在结构体里看起来就面向对象了，以前我也这么觉得，但是显然这样不能实现继承封装等等特性，GObject 独特之处在于它实现了这些，并且是和语言独立的。当然，要想在一个没有这些概念的语言里面做到这些，就有很多需要自己手动处理和函数库处理的地方，就是因为有些隐藏了起来有些又要自己做，才让它看起来像古老的黑魔法。&lt;/p&gt;
&lt;p&gt;最近我尝试做了一个小项目，以便搞清楚如何按照 GObject 的模式编写一些继承封装的代码。&lt;/p&gt;
&lt;p&gt;首先得给项目起名字，因为 GObject 要求你的命名符合一定的约定，其中一个前缀是项目名，不过这个 简单，就叫 &lt;code&gt;test&lt;/code&gt; 好了，然后做一个基类叫 &lt;code&gt;animal&lt;/code&gt;，于是就有了 &lt;code&gt;test-animal.h&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#ifndef __TEST_ANIMAL_H__
#define __TEST_ANIMAL_H__

#include &lt;glib-object.h&gt;

G_BEGIN_DECLS

// 这个玩意必须要手动定义。
#define TEST_TYPE_ANIMAL test_animal_get_type()
// 这个玩意会展开成一大堆函数声明、typedef 什么的，
// 所以我们只要按约定定义结构体实现函数。
G_DECLARE_DERIVABLE_TYPE(TestAnimal, test_animal, TEST, ANIMAL, GObject)

// 但是上面那个玩意其实不会给你搞一个类结构体出来，
// 而且这个因为是给其他文件用的所以必须写在头文件里，
// 不然人家怎么知道你有什么虚函数！
struct _TestAnimalClass {
    GObjectClass parent_class;
    // 定义一个可以继承的函数。
    void (*print)(TestAnimal *animal);
    gpointer padding[12];
};

// 因为上面的 class 里面定义了，这个只是调用那个。
void test_animal_print(TestAnimal *animal);
// 这个玩意得手动定义，是个不可继承的公开函数。
TestAnimal *test_animal_new(gchar *animal_name);

G_END_DECLS

#endif
&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#ifndef __TEST_ANIMAL_H__
#define __TEST_ANIMAL_H__

#include &amp;lt;glib-object.h&amp;gt;

G_BEGIN_DECLS

// 这个玩意必须要手动定义。
#define TEST_TYPE_ANIMAL test_animal_get_type()
// 这个玩意会展开成一大堆函数声明、typedef 什么的，
// 所以我们只要按约定定义结构体实现函数。
G_DECLARE_DERIVABLE_TYPE(TestAnimal, test_animal, TEST, ANIMAL, GObject)

// 但是上面那个玩意其实不会给你搞一个类结构体出来，
// 而且这个因为是给其他文件用的所以必须写在头文件里，
// 不然人家怎么知道你有什么虚函数！
struct _TestAnimalClass {
    GObjectClass parent_class;
    // 定义一个可以继承的函数。
    void (*print)(TestAnimal *animal);
    gpointer padding[12];
};

// 因为上面的 class 里面定义了，这个只是调用那个。
void test_animal_print(TestAnimal *animal);
// 这个玩意得手动定义，是个不可继承的公开函数。
TestAnimal *test_animal_new(gchar *animal_name);

G_END_DECLS

#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;因为代码里写了很多注释所以我这里就不再啰嗦一遍了，说点里面没写的。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 表示你声明了一个可以继承的类，也就是说你需要自己弄一个虚函数表出来。有时候你会在某个 GObject 的项目里定义了一大堆宏（比如 GTK 就不爱用这个而是手动定义），其实它们和 &lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 做了一样的工作，因为总要做，就写了个宏实现。这个并不会给你定义具体的类结构体（其实就是虚函数表，用来存放所有可以继承重载的函数），所以我们要按照约定自己写一个 &lt;code&gt;_TestAnimalClass&lt;/code&gt; 的结构体，在类型名字前面加下划线作为结构体名也是约定俗成的，&lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 会展开出一句 &lt;code&gt;typedef struct _TestAnimalClass TestAnimalClass&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个类结构体约定第一个元素是它的父类型的类结构体——这其实意味着我们复制了一份父类型的虚函数表出来，于是我们就可以覆盖父类型的方法而不修改原本的父类型。这一句可能比较难懂，不过后面还有关联。&lt;/p&gt;
&lt;p&gt;这个类结构体存放的并不是实例的变量，它有点类似于 JS 里面的原型，这样我们就不需要给每一个生成的实例复制一份虚函数了，它们共用一个虚函数表。&lt;/p&gt;
&lt;p&gt;然后会有一个 &lt;code&gt;test-animal.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-animal.h&amp;quot;

// Derivable 类型会自动帮你定义实例结构体，
// 所以你想夹带点私货就得自己搞个 Private 类型。
typedef struct {
    gchar *animal_name;
} TestAnimalPrivate;

// 这个也会展开一大堆声明什么的。
G_DEFINE_TYPE_WITH_PRIVATE(TestAnimal, test_animal, G_TYPE_OBJECT)

// 要想通过 new 函数直接初始化一些值就需要搞点属性。
enum {
    PROP_0,
    PROP_ANIMAL_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        if (priv-&gt;animal_name)
            g_free(priv-&gt;animal_name);
        // 所以其实我们是在设置属性的时候更新私有成员。
        priv-&gt;animal_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        // 所以你看属性这个名称和我们想的属性不一样，
        // 其他语言里面属性就是成员，能存点东西，
        // 但这里好像属性只是成员的一个代理，
        // 具体的东西存在成员里面，通过属性设置。
        g_value_set_string(value, priv-&gt;animal_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 给子类提供一个默认的实现，这样它就不是一个纯虚函数了。
static void print_impl(TestAnimal *animal)
{
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);
    g_message(&amp;quot;I am an Animal called %s.&amp;quot;, priv-&gt;animal_name);
}

static void test_animal_class_init(TestAnimalClass *animal_class)
{
    // 首先我们覆盖这个类里面的 GObject 类的方法，
    // 你调用 GObject 的函数，他会先获取参数的 GObject 类，
    // 那就获取到我们这个了，然后具体的实现就是我们覆盖的这个。
    GObjectClass *object_class = G_OBJECT_CLASS(animal_class);
    object_class-&gt;get_property = get_property_impl;
    object_class-&gt;set_property = set_property_impl;

    // 给虚方法设置默认实现。
    animal_class-&gt;print = print_impl;

    obj_properties[PROP_ANIMAL_NAME] = g_param_spec_string(
        &amp;quot;animal-name&amp;quot;,
        &amp;quot;Animal Name&amp;quot;,
        &amp;quot;Name of Animal&amp;quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_animal_init(TestAnimal *animal)
{
}

void test_animal_print(TestAnimal *animal)
{
    // 你看其实这里和 GObject 类设置属性的原理是一样的。
    // 子类调用这个函数，实际上获取到的是子类自己那个 Animal 类，
    // 于是他只要覆盖自己的那个 Animal 类，调用的就是他自己的。
    TestAnimalClass *animal_class;
    animal_class = TEST_ANIMAL_GET_CLASS(animal);
    g_return_if_fail(animal_class-&gt;print != NULL);
    animal_class-&gt;print(animal);
}

TestAnimal *test_animal_new(gchar *animal_name)
{
    g_return_val_if_fail(animal_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_ANIMAL,
        &amp;quot;animal-name&amp;quot;, animal_name,
        NULL
    );
}
&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-animal.h&quot;

// Derivable 类型会自动帮你定义实例结构体，
// 所以你想夹带点私货就得自己搞个 Private 类型。
typedef struct {
    gchar *animal_name;
} TestAnimalPrivate;

// 这个也会展开一大堆声明什么的。
G_DEFINE_TYPE_WITH_PRIVATE(TestAnimal, test_animal, G_TYPE_OBJECT)

// 要想通过 new 函数直接初始化一些值就需要搞点属性。
enum {
    PROP_0,
    PROP_ANIMAL_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        if (priv-&amp;gt;animal_name)
            g_free(priv-&amp;gt;animal_name);
        // 所以其实我们是在设置属性的时候更新私有成员。
        priv-&amp;gt;animal_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestAnimal *animal = TEST_ANIMAL(object);
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);

    switch (property_id) {
    case PROP_ANIMAL_NAME:
        // 所以你看属性这个名称和我们想的属性不一样，
        // 其他语言里面属性就是成员，能存点东西，
        // 但这里好像属性只是成员的一个代理，
        // 具体的东西存在成员里面，通过属性设置。
        g_value_set_string(value, priv-&amp;gt;animal_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 给子类提供一个默认的实现，这样它就不是一个纯虚函数了。
static void print_impl(TestAnimal *animal)
{
    TestAnimalPrivate *priv = test_animal_get_instance_private(animal);
    g_message(&quot;I am an Animal called %s.&quot;, priv-&amp;gt;animal_name);
}

static void test_animal_class_init(TestAnimalClass *animal_class)
{
    // 首先我们覆盖这个类里面的 GObject 类的方法，
    // 你调用 GObject 的函数，他会先获取参数的 GObject 类，
    // 那就获取到我们这个了，然后具体的实现就是我们覆盖的这个。
    GObjectClass *object_class = G_OBJECT_CLASS(animal_class);
    object_class-&amp;gt;get_property = get_property_impl;
    object_class-&amp;gt;set_property = set_property_impl;

    // 给虚方法设置默认实现。
    animal_class-&amp;gt;print = print_impl;

    obj_properties[PROP_ANIMAL_NAME] = g_param_spec_string(
        &quot;animal-name&quot;,
        &quot;Animal Name&quot;,
        &quot;Name of Animal&quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_animal_init(TestAnimal *animal)
{
}

void test_animal_print(TestAnimal *animal)
{
    // 你看其实这里和 GObject 类设置属性的原理是一样的。
    // 子类调用这个函数，实际上获取到的是子类自己那个 Animal 类，
    // 于是他只要覆盖自己的那个 Animal 类，调用的就是他自己的。
    TestAnimalClass *animal_class;
    animal_class = TEST_ANIMAL_GET_CLASS(animal);
    g_return_if_fail(animal_class-&amp;gt;print != NULL);
    animal_class-&amp;gt;print(animal);
}

TestAnimal *test_animal_new(gchar *animal_name)
{
    g_return_val_if_fail(animal_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_ANIMAL,
        &quot;animal-name&quot;, animal_name,
        NULL
    );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;理论上来说我们直接往实例结构体里添加成员作为私有成员就可以，但是在头文件里定义实例结构体，其它文件是可以看到实例结构体的成员的，所以 &lt;code&gt;G_DECLARE_DERIVABLE_TYPE&lt;/code&gt; 不允许我们这么做。&lt;/p&gt;
&lt;p&gt;但有一个省事的宏 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt;，它要求我们做一个 Private 类型，里面存放我们想要的任何私有元素，它不会被继承，并且因为定义在 &lt;code&gt;.c&lt;/code&gt; 文件里所以也不会被其它文件看到。它还会提供一些 GObject 内置类型系统的实现函数（不然 GObject 系统怎么知道你建了哪些类型！），还有一些只在实现里面用到的定义。当然 Private 类型的名字也是约定好的。&lt;/p&gt;
&lt;p&gt;多说一句，按照 GTK 的代码实现，其实 Private 最后就是在实例结构体里面定义了一个叫 &lt;code&gt;priv&lt;/code&gt; 的指针，类型是自己定义的 Private 类型，因为 GTK 是手写的头文件定义然后用的 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt; 同时又没产生冲突，其实你也可以完全不理会这两个宏，全都自己写，只要保证类结构体和实例结构体的第一个成员是父类结构体和父实例结构体就可以了。但是 &lt;code&gt;G_DEFINE_TYPE_WITH_PRIVATE&lt;/code&gt; 提供了一个 &lt;code&gt;项目名_类型名_get_instance_private&lt;/code&gt; 的函数，我们就不用直接访问 &lt;code&gt;priv&lt;/code&gt; 成员了。&lt;/p&gt;
&lt;p&gt;在使用 &lt;code&gt;g_object_new&lt;/code&gt; 新建一个对象的时候可以通过 key-value 的方式设置一些初始值，这个其实是通过 GObject 提供的 property 功能实现的，因为 C 并没有哈希表这种东西。这个过程很繁琐但也很固定，其实就是实现其它语言里面传一个对象作为构造函数参数然后以此设置私有成员初始值的功能。property 就是参数，具体的内容还是存在初始值里面的，不过其实你也可以通过 property 访问具体的值。这里很容易理解成 property 有自己单独的存储空间，其实不是。property 是可以继承的，所以子类可以同时设置父类和自己的 property。&lt;/p&gt;
&lt;p&gt;然后我们要接触到第一个重载的部分了，因为 &lt;code&gt;TestAnimal&lt;/code&gt; 继承了 GObject，所以我们要重载掉它类结构体里面的父类结构体的 &lt;code&gt;set_property&lt;/code&gt; 和 &lt;code&gt;get_property&lt;/code&gt; 函数。过程也很简单，GObject 要求我们实现两个函数 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt; 和 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt;，其中前者就是让我们初始化类结构体用的。首先进行一个类型转换把 &lt;code&gt;TestAnimalClass&lt;/code&gt; 转换成 &lt;code&gt;GObjectClass&lt;/code&gt;（为什么可以强转？那你先思考一下为什么定义类结构体时候第一个元素是父类结构体？就是因为要这样才能进行类型转换，本质上是个套娃），然后直接赋值。这样假如有人对我们这个类型执行 &lt;code&gt;g_object_set_property&lt;/code&gt;，实际上是调用的我们重载过的函数（为什么？怎么做到的？往下看）。&lt;/p&gt;
&lt;p&gt;那其实我们知道如何覆盖父类的方法，但运行的时候是如何动态重载到我们自己的函数的也不清楚，我们先搞定我们自己的那个虚函数，其实很简单，我们定义具体的方法的时候（指 &lt;code&gt;test_animal_print&lt;/code&gt;），不要让它实现具体的逻辑，而是让它通过参数的实例执行虚函数表里的函数就可以了。这需要一个自动生成的 &lt;code&gt;项目名_类型名_GET_CLASS&lt;/code&gt; 的宏，它的作用是通过一个实例查找到 &lt;strong&gt;这个实例本身&lt;/strong&gt; 对应的类结构体，然后就可以运行虚函数了。比如我给 &lt;code&gt;g_object_set_property&lt;/code&gt; 传一个 &lt;code&gt;TestAnimal&lt;/code&gt;，那我们调用的其实是 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的第一个成员那个 &lt;code&gt;GObjectClass&lt;/code&gt; 的 &lt;code&gt;set_property&lt;/code&gt;，这个已经被我们改成自己的了，于是就实现了一个 &lt;del&gt;不那么直观的&lt;/del&gt; 重载。&lt;/p&gt;
&lt;p&gt;当然假如我们不想写一个纯虚函数，可以在 &lt;code&gt;项目名_类型名_class_init&lt;/code&gt; 里面设置一个初值，这样假如子类没有重载，调用的就是这个。&lt;/p&gt;
&lt;p&gt;那你可能要问假如我有一个不想被重载的函数呢，那你就不要跳虚函数表了，直接写逻辑就可以了。&lt;/p&gt;
&lt;p&gt;接下来我们终于可以写子类的，首先就是 &lt;code&gt;test-cat.h&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#ifndef __TEST_CAT_H__
#define __TEST_CAT_H__

#include &lt;glib-object.h&gt;
#include &amp;quot;test-animal.h&amp;quot;

G_BEGIN_DECLS

#define TEST_TYPE_CAT test_cat_get_type()
// Final 类型就不用写类结构体啦，反正那个最大的用处是用来写可以继承的虚函数。
G_DECLARE_FINAL_TYPE(TestCat, test_cat, TEST, CAT, TestAnimal);

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name);

G_END_DECLS

#endif
&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#ifndef __TEST_CAT_H__
#define __TEST_CAT_H__

#include &amp;lt;glib-object.h&amp;gt;
#include &quot;test-animal.h&quot;

G_BEGIN_DECLS

#define TEST_TYPE_CAT test_cat_get_type()
// Final 类型就不用写类结构体啦，反正那个最大的用处是用来写可以继承的虚函数。
G_DECLARE_FINAL_TYPE(TestCat, test_cat, TEST, CAT, TestAnimal);

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name);

G_END_DECLS

#endif
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;TestCat&lt;/code&gt; 是继承 &lt;code&gt;TestAnimal&lt;/code&gt; 的，并且我们不想让它被继承，所以它就不需要写类结构体了（因为虚函数表是用来重载的，没有继承当然也没有重载）。&lt;/p&gt;
&lt;p&gt;所以接下来就直接到实现部分了，在 &lt;code&gt;test-cat.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-cat.h&amp;quot;

// Final 类型也没有 Private，但是它自己本身就是容器嘛！
// 所以实例结构体就给你自己写了。
// 当然别的文件不需要知道你有什么私货所以不要写在头文件里。
struct _TestCat {
    TestAnimal parent_instance;
    gchar *cat_name;
};

G_DEFINE_TYPE(TestCat, test_cat, TEST_TYPE_ANIMAL)

enum {
    PROP_0,
    PROP_CAT_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        if (cat-&gt;cat_name)
            g_free(cat-&gt;cat_name);
        cat-&gt;cat_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        g_value_set_string(value, cat-&gt;cat_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 那我们不想要默认的实现就可以覆盖掉自己的。
static void print_impl(TestAnimal *animal)
{
    TestCat *cat = TEST_CAT(animal);
    g_message(&amp;quot;I am a Cat called %s.&amp;quot;, cat-&gt;cat_name);
    // 这个自动生成的 parent 变量指向的是真正的父类！
    // 因为我们自己带的父类结构体被我们覆盖了，所以这里给你一个访问正主的机会。
    // 它是个 gpointer 所以你得手动设置类型。
    // 其实你的子类如果是完全覆盖父类的功能其实我觉得不用写这一句了。
    // 但是有时候你的子类是在父类上面增加功能就得写。
    // 这不就是 super 指针嘛！
    TEST_ANIMAL_CLASS(test_cat_parent_class)-&gt;print(animal);
}

static void test_cat_class_init(TestCatClass *cat_class)
{
    GObjectClass *object_class = G_OBJECT_CLASS(cat_class);
    object_class-&gt;get_property = get_property_impl;
    object_class-&gt;set_property = set_property_impl;

    // 干掉我们自己的这个父类结构体里面带的内置实现，
    // 这样父类的函数调用的其实是我们自己的这个实现。
    // 那你看你一会让父类调用自己一会又让自己调用父类可真是麻烦。
    TestAnimalClass *animal_class = TEST_ANIMAL_CLASS(cat_class);
    animal_class-&gt;print = print_impl;

    obj_properties[PROP_CAT_NAME] = g_param_spec_string(
        &amp;quot;cat-name&amp;quot;,
        &amp;quot;Cat Name&amp;quot;,
        &amp;quot;Name of Cat&amp;quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_cat_init(TestCat *cat)
{
}

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name)
{
    g_return_val_if_fail(animal_name != NULL &amp;amp;&amp;amp; cat_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_CAT,
        &amp;quot;animal-name&amp;quot;, animal_name,
        &amp;quot;cat-name&amp;quot;, cat_name,
        NULL
    );
}
&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-cat.h&quot;

// Final 类型也没有 Private，但是它自己本身就是容器嘛！
// 所以实例结构体就给你自己写了。
// 当然别的文件不需要知道你有什么私货所以不要写在头文件里。
struct _TestCat {
    TestAnimal parent_instance;
    gchar *cat_name;
};

G_DEFINE_TYPE(TestCat, test_cat, TEST_TYPE_ANIMAL)

enum {
    PROP_0,
    PROP_CAT_NAME,
    N_PROPERTIES
};

static GParamSpec *obj_properties[N_PROPERTIES] = {NULL};

static void set_property_impl(
    GObject *object,
    guint property_id,
    const GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        if (cat-&amp;gt;cat_name)
            g_free(cat-&amp;gt;cat_name);
        cat-&amp;gt;cat_name = g_value_dup_string(value);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

static void get_property_impl(
    GObject *object,
    guint property_id,
    GValue *value,
    GParamSpec *pspec
)
{
    TestCat *cat = TEST_CAT(object);

    switch (property_id) {
    case PROP_CAT_NAME:
        g_value_set_string(value, cat-&amp;gt;cat_name);
        break;
    default:
        /* We don&#039;t have any other property... */
        G_OBJECT_WARN_INVALID_PROPERTY_ID(object, property_id, pspec);
        break;
    }
}

// 那我们不想要默认的实现就可以覆盖掉自己的。
static void print_impl(TestAnimal *animal)
{
    TestCat *cat = TEST_CAT(animal);
    g_message(&quot;I am a Cat called %s.&quot;, cat-&amp;gt;cat_name);
    // 这个自动生成的 parent 变量指向的是真正的父类！
    // 因为我们自己带的父类结构体被我们覆盖了，所以这里给你一个访问正主的机会。
    // 它是个 gpointer 所以你得手动设置类型。
    // 其实你的子类如果是完全覆盖父类的功能其实我觉得不用写这一句了。
    // 但是有时候你的子类是在父类上面增加功能就得写。
    // 这不就是 super 指针嘛！
    TEST_ANIMAL_CLASS(test_cat_parent_class)-&amp;gt;print(animal);
}

static void test_cat_class_init(TestCatClass *cat_class)
{
    GObjectClass *object_class = G_OBJECT_CLASS(cat_class);
    object_class-&amp;gt;get_property = get_property_impl;
    object_class-&amp;gt;set_property = set_property_impl;

    // 干掉我们自己的这个父类结构体里面带的内置实现，
    // 这样父类的函数调用的其实是我们自己的这个实现。
    // 那你看你一会让父类调用自己一会又让自己调用父类可真是麻烦。
    TestAnimalClass *animal_class = TEST_ANIMAL_CLASS(cat_class);
    animal_class-&amp;gt;print = print_impl;

    obj_properties[PROP_CAT_NAME] = g_param_spec_string(
        &quot;cat-name&quot;,
        &quot;Cat Name&quot;,
        &quot;Name of Cat&quot;,
        NULL,
        G_PARAM_CONSTRUCT_ONLY | G_PARAM_READWRITE
    );

    g_object_class_install_properties(
        object_class,
        N_PROPERTIES,
        obj_properties
    );
}

static void test_cat_init(TestCat *cat)
{
}

TestCat *test_cat_new(gchar *animal_name, gchar *cat_name)
{
    g_return_val_if_fail(animal_name != NULL &amp;amp;&amp;amp; cat_name != NULL, NULL);
    return g_object_new(
        TEST_TYPE_CAT,
        &quot;animal-name&quot;, animal_name,
        &quot;cat-name&quot;, cat_name,
        NULL
    );
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;Final 类型没有 Private，因为它自己就是 Private，所以这个定义实例结构体的权力交给了你，直接在里面写私有成员即可，但是不要忘了套娃（指第一个成员一定要是父实例结构体）。&lt;/p&gt;
&lt;p&gt;然后就是设置我们自己的 property 并重载 GObject 的虚函数，当然你可能会说这样父类型的 property 不就丢了吗？其实 property 是放在 GObject 系统单独的一个表里，需要的时候它去查询，并且会考虑父类型的继承链，所以我们不需要考虑重载时候覆盖掉父类型的问题。&lt;/p&gt;
&lt;p&gt;接下来就是重载父类型提供给我们的虚函数也就是 &lt;code&gt;TestCatClass.print&lt;/code&gt; 了！当然首先是把我们自己的类结构体里面的父类结构体的虚函数换掉。&lt;/p&gt;
&lt;p&gt;在写我们自己重载的函数的时候，一个比较重要的事情是 chain up，也就是最后一行那个 &lt;code&gt;TEST_ANIMAL_CLASS(test_cat_parent_class)-&amp;gt;print(animal);&lt;/code&gt;，有时候你重载只是做了一些子类自己的处理，然后还是需要父类提供的处理函数的，这该怎么办？你可能会说类结构体里面不是有个父类结构体了吗？但那个已经被我们覆盖了！你这样不就是咬自己尾巴的猫吗？&lt;/p&gt;
&lt;p&gt;当我们自己解决不了的时候就得 GObject 解决了，&lt;code&gt;G_DEFINE_TYPE&lt;/code&gt; 会提供一个 &lt;code&gt;项目名_类型名_parent_class&lt;/code&gt; 的指针定义，这个指向的是那个真正的唯一的 &lt;strong&gt;不是我们自己包含的&lt;/strong&gt; 那个父类结构体！也就是说对于子类和父类继承而言，有两个父类结构体，一个是父类自己作为一个类的那个，另一个是子类为了实现重载包含的那个，这个访问的就是前者。&lt;/p&gt;
&lt;p&gt;当然这个类型其实是个 &lt;code&gt;gpointer&lt;/code&gt; 所以我们还得自己转换一下类型，然后只要调用方法就可以了（这不就是 super 指针嘛）。&lt;/p&gt;
&lt;p&gt;最后我们写一个测试的程序 &lt;code&gt;main.c&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;#include &amp;quot;test-animal.h&amp;quot;
#include &amp;quot;test-cat.h&amp;quot;

int main(int argc, char *argv[])
{
    TestAnimal *animal = test_animal_new(&amp;quot;animal1&amp;quot;);
    TestCat *cat = test_cat_new(&amp;quot;animal2&amp;quot;, &amp;quot;cat1&amp;quot;);
    test_animal_print(animal);
    test_animal_print(TEST_ANIMAL(cat));
    return 0;
}
&quot; data-info=&quot;language-c&quot; data-lang=&quot;c&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-c&quot;&gt;#include &quot;test-animal.h&quot;
#include &quot;test-cat.h&quot;

int main(int argc, char *argv[])
{
    TestAnimal *animal = test_animal_new(&quot;animal1&quot;);
    TestCat *cat = test_cat_new(&quot;animal2&quot;, &quot;cat1&quot;);
    test_animal_print(animal);
    test_animal_print(TEST_ANIMAL(cat));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;然后用这个 &lt;code&gt;Makefile&lt;/code&gt;:&lt;/p&gt;
&lt;figure data-raw=&quot;CC := cc
OBJECTS := main.o test-animal.o test-cat.o
CFLAGS := `pkg-config --cflags gobject-2.0`
LIBS := `pkg-config --libs gobject-2.0`

all: ${OBJECTS}
    ${CC} -o test ${OBJECTS} ${LIBS}

main.o: test-animal.h test-cat.h
    ${CC} -c main.c ${CFLAGS}

test-animal.o:
    ${CC} -c test-animal.c ${CFLAGS}

test-cat.o: test-animal.h
    ${CC} -c test-cat.c ${CFLAGS}

.PHONY: clean
clean:
    -rm test ${OBJECTS}
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;CC := cc
OBJECTS := main.o test-animal.o test-cat.o
CFLAGS := `pkg-config --cflags gobject-2.0`
LIBS := `pkg-config --libs gobject-2.0`

all: ${OBJECTS}
    ${CC} -o test ${OBJECTS} ${LIBS}

main.o: test-animal.h test-cat.h
    ${CC} -c main.c ${CFLAGS}

test-animal.o:
    ${CC} -c test-animal.c ${CFLAGS}

test-cat.o: test-animal.h
    ${CC} -c test-cat.c ${CFLAGS}

.PHONY: clean
clean:
    -rm test ${OBJECTS}
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;运行的结果是这样的：&lt;/p&gt;
&lt;figure data-raw=&quot;** Message: 11:23:25.727: I am an Animal called animal1.
** Message: 11:23:25.729: I am a Cat called cat1.
** Message: 11:23:25.729: I am an Animal called animal2.
&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code&gt;** Message: 11:23:25.727: I am an Animal called animal1.
** Message: 11:23:25.729: I am a Cat called cat1.
** Message: 11:23:25.729: I am an Animal called animal2.
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;你可以看到第一行是父类也就是 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的函数的输出。第二行是 &lt;code&gt;TestCatClass&lt;/code&gt; 重载的函数的输出，第三行则是 &lt;code&gt;TestCatClass&lt;/code&gt; 重载的函数 chain up 到 &lt;code&gt;TestAnimalClass&lt;/code&gt; 的输出，但是输出的是子类继承的父类的属性！&lt;/p&gt;
&lt;p&gt;最后有关我到底该声明成子类还是父类以及传参时候要不要类型转换：其实在这个 GObject 的样例里面看起来是无所谓的，类型转换可行不可行其实取决于具体 new 的是什么，而不是声明的指针是什么，所以其实声明成父类和子类都没有关系，类型转换也主要是为了满足 C 语言对指针类型和函数声明的要求罢了。&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="编程" label="编程" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BC%96%E7%A8%8B/" />
    
    
    <category term="GObject" label="GObject" scheme="https://sh.alynx.one/tags/GObject/" />
    
  </entry>
  
  
  
  <entry>
    <title>基于 GitHub Issue 的前端评论框</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Frontend-GitHub-Issue-Based-Comment/" />
    <id>https://sh.alynx.one/posts/Frontend-GitHub-Issue-Based-Comment/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-08-15T10:25:00.000Z</published>
    
    
    <updated>2020-08-18T04:25:00.000Z</updated>
    
    
    <summary type="html">
      &lt;h1 id=&quot;%E9%80%A0%E8%BD%AE%E5%AD%90%E6%98%AF%E7%97%85%EF%BC%8C%E5%BE%97%E6%B2%BB%E3%80%82&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E9%80%A0%E8%BD%AE%E5%AD%90%E6%98%AF%E7%97%85%EF%BC%8C%E5%BE%97%E6%B2%BB%E3%80%82&quot;&gt;&lt;/a&gt;造轮子是病，得治。&lt;/h1&gt;
&lt;p&gt;自从造了 &lt;a href=&quot;/posts/Frontend-Blog-Search/&quot;&gt;前端博客搜索引擎&lt;/a&gt; 的轮子之后，我对自己的能力有了极大的信心，同时也掌握了一些有趣的用法，于是把枪口瞄准了下一个我看着不顺眼的地方——评论框。&lt;/p&gt;
&lt;p&gt;（这标题怎么写的和毕业论文似的！）&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;h1 id=&quot;%E9%80%A0%E8%BD%AE%E5%AD%90%E6%98%AF%E7%97%85%EF%BC%8C%E5%BE%97%E6%B2%BB%E3%80%82&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E9%80%A0%E8%BD%AE%E5%AD%90%E6%98%AF%E7%97%85%EF%BC%8C%E5%BE%97%E6%B2%BB%E3%80%82&quot;&gt;&lt;/a&gt;造轮子是病，得治。&lt;/h1&gt;
&lt;p&gt;自从造了 &lt;a href=&quot;/posts/Frontend-Blog-Search/&quot;&gt;前端博客搜索引擎&lt;/a&gt; 的轮子之后，我对自己的能力有了极大的信心，同时也掌握了一些有趣的用法，于是把枪口瞄准了下一个我看着不顺眼的地方——评论框。&lt;/p&gt;
&lt;p&gt;（这标题怎么写的和毕业论文似的！）&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;%E8%BD%AE%E5%AD%90%E4%B9%9F%E4%B8%8D%E6%98%AF%E7%99%BD%E9%80%A0%E7%9A%84%E3%80%82&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E8%BD%AE%E5%AD%90%E4%B9%9F%E4%B8%8D%E6%98%AF%E7%99%BD%E9%80%A0%E7%9A%84%E3%80%82&quot;&gt;&lt;/a&gt;轮子也不是白造的。&lt;/h1&gt;
&lt;p&gt;从我建站以来我的评论框就命途多舛，Disqus 虽然是最著名的评论系统，但是在国内访问不太顺畅。多说火了一段时间之后便关门大吉，HyperComments 则在我用了一段时间后发邮件提示要收费了，于是我之前的评论便华丽流失。而对于 Valine 这种基于 LeanCloud 的评论系统，我对 LeanCloud 不甚了解所以也不想尝试（而且 Valine 现在似乎转向闭源了，当初也许是个正确的决定）。然后赶上 Gitment 和 Gitalk 火了起来，大家意识到 GitHub Issue 正是个放评论的好地方。但是由于 &lt;a href=&quot;https://github.com/iissnan/hexo-theme-next/pull/1634#issuecomment-313596649&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Gitment 和 Gitalk 采用他们自己的服务器实现博客评论框提交——转发到 GitHub API 的实现&lt;/a&gt;，以及 &lt;a href=&quot;https://www.v2ex.com/t/535608&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;采用的 OAuth App 权限过高&lt;/a&gt;，有人怀疑这不太安全，于是我也没太敢参与。后来遇到 &lt;a href=&quot;https://github.com/wzpan/comment.js&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;comment.js&lt;/a&gt; 这个项目，它绕过了提交评论的问题——直接给一个到 GitHub Issue 的评论框的链接就可以了。于是我就开始用这个，至于什么 utterances 这种用 GitHub App 降低权限的评论系统，我也懒得尝试了。&lt;/p&gt;
&lt;p&gt;但我为什么决定替换掉 comment.js 我已经记不清楚了，可能是为了对主题的显示有更好的掌握吧，毕竟它带有自己的 CSS 样式而且经常和我的冲突，也可能是因为它迟迟没提供像 Disqus 一样查找每篇文章评论数目的功能，不过它现在已经不再维护了，所以我也算是未雨绸缪。&lt;/p&gt;
&lt;h1 id=&quot;%E4%BA%8B%E6%83%85%E6%9C%AC%E8%AF%A5%E5%BE%88%E7%AE%80%E5%8D%95%E3%80%82&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E4%BA%8B%E6%83%85%E6%9C%AC%E8%AF%A5%E5%BE%88%E7%AE%80%E5%8D%95%E3%80%82&quot;&gt;&lt;/a&gt;事情本该很简单。&lt;/h1&gt;
&lt;p&gt;研究了一下原理其实并不是很难，首先就是从 GitHub 的 API 上 ajax 获取数据，然后操作 DOM 添进去就可以了，所以我就先阅读了 &lt;a href=&quot;https://docs.github.com/en/rest/reference/issues&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;GitHub API 的文档&lt;/a&gt;，总之还算容易，只要先获取一个仓库的 issue 列表，然后按照某种方法在里面查找相关的 issue，如果没有就渲染一个到新建 issue 的链接，否则获取该 issue 的全部评论并显示就可以了。&lt;/p&gt;
&lt;p&gt;查找 issue 的 key 也算容易，我给它做成了函数参数，然后在主题模板里填一个每个页面唯一的字符串就行了，比如文章标题，然后新生成 issue 页面时候就把这个作为 issue 的标题，这样查找 GitHub Issue 页面时候也比较容易看。然后 GitHub 把 PR 也视为 issue，这个不要紧，收到数组之后过滤一下就好了。而显示数目我琢磨了一下其实也没什么难的嘛！我都获取到所有 issue 的信息了。做一个新的函数，主题作者在页面上放置一系列空的元素并设置好 class 属性，然后同样地把每个页面唯一的字符串设置成这些元素的属性（Disqus 也是这样的），加载函数时候把 class 作为参数传进去，分别从 issue 列表里查找对应的标题就可以了。还有一个奇葩问题是 GitHub issue 的 comments 指的是除了顶楼以外的评论，但很显然看起来不是这样的，这个也简单，直接把顶楼加到数组里就成了嘛。剩下就是艰苦的在浏览器里刀耕火种写 JS 拼 HTML 字符串发 ajax 请求写嵌套回调（没有 async/await 也太痛苦了吧！。&lt;/p&gt;
&lt;p&gt;一切正常工作了一段时间一后我发现不太对劲，怎么评论太多的时候显示不全呢？仔细查了一下发现 GitHub API 是强制分页的，也就是说不管你怎么设置，最多一次只能获取 100 条评论，默认则是 30 条，本来我不太想给博客加评论分页功能的，现在看来是 GitHub 被迫让我加啊。当然这个并不是最痛苦的，最痛苦的是它查找仓库的 issue 列表的时候也是强制分页的！这就麻烦了，还记得我们之前说要获取到列表之后查找标题吗？获取不到完整列表还怎么查找啊！&lt;/p&gt;
&lt;p&gt;当然你可以说按顺序多查几页不就行了嘛，这就是它分页难受的地方了！ajax 是异步的啊亲！你不会想让我一个 for 循环几个 ajax 还指望优雅的等他们结束了再跑查找吧！我知道能用 &lt;code&gt;Promise.all()&lt;/code&gt; 解决，但是由于我大发慈悲的支持使用 IE11 的用户（微软我&amp;amp;A%￥S&amp;amp;……省略一千字儒雅随和），所以我的函数是基于回调的，那也没什么办法。而且这样首先你得读一下仓库信息才能知道有多少个 open 的 issue（没错只能算 open 的不能算 close 的！所以在后面查 issue 的时候我也不得不筛选掉 close 的，不过这大概也许是个 feature？），然后自己计算有多少页。最后我只能造了一个不那么优雅的尾递归回调（反正就那个意思），不过它工作的不错，这样我就可以获取到全部的 issue 列表了。&lt;/p&gt;
&lt;p&gt;然后后面其实还是差不多，至于评论分页又不一样了，既然 GitHub 只有分页 API，我也就半推半就啊不是将计就计吧。我才不要继续获取全部评论了，我也每次直接获取 GitHub 那边的一页就行了，每页个数则由主题作者传参进来。至于如何确定我要哪一页呢？和搜索功能一样，继续前端解析 query string 呗。根据 issue 评论总数计算一下有几页，然后生成几个链接放在页尾，每次加载时候解析一下参数确定当前页是哪个即可。当然，不要忘了 issue 顶楼不算评论，计算分页的时候也不要给它加进去！而且既然是这么分页，我也懒得把顶楼算在里面了（不然真的麻烦的要死啊后面分页和每页个数全乱了），所以假如你设置每页 10 个评论，那第一页其实有 11 个，别烦我，代码在那，不满意自己改……然后继续刀耕火种……&lt;/p&gt;
&lt;p&gt;为了减轻负担，我没有实现太多的功能，比如时间戳我没有搞成什么几分钟几小时前，这种东西又不清晰又浪费带宽，我只搞了&lt;del&gt;基于 marked 的 Markdown 渲染（必须的）和&lt;/del&gt;语法高亮，Markdown 渲染不是必须的，因为你可以 &lt;a href=&quot;https://docs.github.com/en/rest/overview/media-types#comment-body-properties&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;设置 header 让 GitHub 直接返回 HTML&lt;/a&gt;。为了保证效果统一，这个 JS 只是建立了 HTML 布局，给每个元素添加了 class，具体的样式则完全是主题自己编写的，所以配合起来也比较好看。&lt;/p&gt;
&lt;p&gt;最后的效果其实还可以，完整的脚本就是 &lt;a href=&quot;/js/comment.js&quot;&gt;这个网站在用的 JS&lt;/a&gt;，具体和主题的整合方法就慢慢翻 ARIA 的模板吧。唯一的缺点是 GitHub API 的频率限制太低，按照这个弱智的 issue 列表分页的话又不得不多一次读取仓库有多少 issue 的请求，假如你的 issue 太多估计也是问题？不过应该不会有那么多博文吧！我只有调试脚本的时候遇到过被 GitHub 提示等会的问题，所以对于访问者应该没什么影响。有影响以后再想解决办法（或者没办法）。&lt;/p&gt;
&lt;p&gt;也许最好的办法是解决掉需求——要什么评论框？不就是破事水？如果有问题想联系作者电子邮件又不是不能用！（逃&lt;/p&gt;
&lt;h1 id=&quot;%E5%85%B6%E5%AE%9E%E4%BD%A0%E7%9F%A5%E9%81%93%EF%BC%8C%E7%83%A6%E6%81%BC%EF%BC%88bug%EF%BC%89%E4%BC%9A%E8%A7%A3%E5%86%B3%E7%83%A6%E6%81%BC%EF%BC%88bug%EF%BC%89%E3%80%82&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E5%85%B6%E5%AE%9E%E4%BD%A0%E7%9F%A5%E9%81%93%EF%BC%8C%E7%83%A6%E6%81%BC%EF%BC%88bug%EF%BC%89%E4%BC%9A%E8%A7%A3%E5%86%B3%E7%83%A6%E6%81%BC%EF%BC%88bug%EF%BC%89%E3%80%82&quot;&gt;&lt;/a&gt;其实你知道，烦恼（bug）会解决烦恼（bug）。&lt;/h1&gt;
&lt;div class=&quot;alert-green&quot;&gt;这一部分更新于 2020-08-17 10:34:00。&lt;/div&gt;

&lt;p&gt;GitHub API 推荐用户 &lt;a href=&quot;https://docs.github.com/en/rest/overview/resources-in-the-rest-api#conditional-requests&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;缓存之前的请求响应，然后根据缓存的响应的 Header 里面的 ETag 发送请求查询是否过期，若未过期则返回一个不消耗频率限制次数的 304 状态码&lt;/a&gt;。我心想这也简单，那就在前端搞一个缓存就可以了。&lt;/p&gt;
&lt;p&gt;然后我搜索了一番找到了 CacheStorage，看起来它是唯一一个跨标签页的基于 Session 的正宗的前端缓存。但是很显然 IE 又不支持，而且这个 API 基于 Promise 并且只能缓存 Response 对象，也就是说没办法简单的通过在 XHR 的时候判断一下跳过不支持的情况，要 Polyfill 则需要引入完整的 Promise 和 fetch/Response，所以我们做了一个&lt;del&gt;艰难&lt;/del&gt;容易的决定——是时候去掉 IE 支持了！&lt;/p&gt;
&lt;p&gt;于是我把请求 API 的函数改成了如下操作：&lt;/p&gt;
&lt;figure data-raw=&quot;let cachePromise = window.caches.open(&amp;quot;cacheName&amp;quot;);

// Fetching JSON with cache for GitHub API.
const cachedFetchJSON = (path, opts = {}) =&gt; {
  let cachedResponse = null;
  return cachePromise.then((cache) =&gt; {
    return cache.match(path);
  }).then((response) =&gt; {
    // No cache or no ETag, just re-fetch;
    if (response == null || !response.headers.has(&amp;quot;ETag&amp;quot;)) {
      return window.fetch(path, opts);
    }
    // Ask GitHub API whether cache is outdated.
    cachedResponse = response;
    opts[&amp;quot;headers&amp;quot;] = opts[&amp;quot;headers&amp;quot;] || {};
    opts[&amp;quot;headers&amp;quot;][&amp;quot;If-None-Match&amp;quot;] = cachedResponse.headers.get(&amp;quot;ETag&amp;quot;);
    return window.fetch(path, opts);
  }).then((response) =&gt; {
    if (response.status === 200) {
      // No cache or cache outdated and succeed.
      // Update cache.
      cachePromise.then((cache) =&gt; {
        return cache.put(path, response);
      });
      // Cache needs an unconsumed response,
      // so we clone respone before consume it.
      return response.clone().json();
    } else if (response.status === 304 &amp;amp;&amp;amp; cachedResponse != null) {
      // Not modified so use cache.
      return cachedResponse.clone().json();
    } else {
      // fetch does not reject on HTTP error, so we do this manually.
      throw new Error(&amp;quot;Unexpected HTTP status code &amp;quot; + response.status);
    }
  });
};
&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;let cachePromise = window.caches.open(&quot;cacheName&quot;);

// Fetching JSON with cache for GitHub API.
const cachedFetchJSON = (path, opts = {}) =&amp;gt; {
  let cachedResponse = null;
  return cachePromise.then((cache) =&amp;gt; {
    return cache.match(path);
  }).then((response) =&amp;gt; {
    // No cache or no ETag, just re-fetch;
    if (response == null || !response.headers.has(&quot;ETag&quot;)) {
      return window.fetch(path, opts);
    }
    // Ask GitHub API whether cache is outdated.
    cachedResponse = response;
    opts[&quot;headers&quot;] = opts[&quot;headers&quot;] || {};
    opts[&quot;headers&quot;][&quot;If-None-Match&quot;] = cachedResponse.headers.get(&quot;ETag&quot;);
    return window.fetch(path, opts);
  }).then((response) =&amp;gt; {
    if (response.status === 200) {
      // No cache or cache outdated and succeed.
      // Update cache.
      cachePromise.then((cache) =&amp;gt; {
        return cache.put(path, response);
      });
      // Cache needs an unconsumed response,
      // so we clone respone before consume it.
      return response.clone().json();
    } else if (response.status === 304 &amp;amp;&amp;amp; cachedResponse != null) {
      // Not modified so use cache.
      return cachedResponse.clone().json();
    } else {
      // fetch does not reject on HTTP error, so we do this manually.
      throw new Error(&quot;Unexpected HTTP status code &quot; + response.status);
    }
  });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;当然理想很丰满现实很骨感，在不支持 CacheStorage 的浏览器里要 fallback 到不带缓存的版本，本来我以为很简单，但是……（下面开启吐槽时间。）&lt;/p&gt;
&lt;blockquote class=&quot;center-quote&quot;&gt;支持 IE 的前端的痛苦都是相似的，不支持 IE 的前端则各有各的痛苦。&lt;/blockquote&gt;

&lt;p&gt;为什么非 HTTPS + localhost 不能用 CacheStorage 啊，难道他们没考虑过在电脑上开发然后手机访问测试移动版吗？还是说他们打算在手机上起一个开发服务器？为什么 Firefox 在非 HTTPS 时限制 CacheStorage 的方法是在 Promise 里 reject 一个 Error 从而导致这个过程变成了异步的？为什么 CacheStorage 只能缓存 Response 而不是任意数据结构？Safari 不能完整支持 Response 对象也就算了，为什么移动版 Chrome 和 Firefox 也不支持？合着你们 fetch 返回的 Response 还不是 Response？这世界到底怎么了……&lt;/p&gt;
&lt;p&gt;所以最后需要一个长长的基于 Promise 的判断加载函数：&lt;/p&gt;
&lt;figure data-raw=&quot;// 加载评论的时候才加载缓存。
let cachePromise = null;

let fetchJSON = uncachedFetchJSON;

const loadCache = (name) =&gt; {
  // Unlike in .then(),
  // we must explicit resolve and reject in a Promise&#039;s execuator.
  return new Promise((resolve, reject) =&gt; {
    if (cachePromise != null &amp;amp;&amp;amp; fetchJSON !== uncachedFetchJSON) {
      return reject(new Error(&amp;quot;Cache is already loaded!&amp;quot;));
    }
    // Old version browsers does not support Response.
    if (window.Response == null) {
      return reject(
        new Error(&amp;quot;Old version browsers does not support Response.&amp;quot;)
      );
    }
    const testResponse = new window.Response();
    // Safari and most mobile browsers do not support `Response.clone()`.
    if (testResponse.headers == null || testResponse.clone == null) {
      return reject(new Error(
        &amp;quot;Safari and most mobile browsers do not support `Response.clone()`.&amp;quot;
      ));
    }
    // Chromium and Safari set `window.caches` to `undefined` if not HTTPS.
    if (window.caches == null) {
      return reject(new Error(
        &amp;quot;Chromium and Safari set `window.caches` to `undefined` if not HTTPS.&amp;quot;
      ));
    }
    window.caches.open(&amp;quot;CacheStorageTest&amp;quot;).then((cache) =&gt; {
      fetchJSON = cachedFetchJSON;
      cachePromise = window.caches.open(name);
      return window.caches.delete(&amp;quot;CacheStorageTest&amp;quot;);
    }).then(() =&gt; {
      return resolve();
    }).catch((error) =&gt; {
      // Firefox throws `SecurityError` if not HTTPS.
      console.error(error);
      return reject(new Error(&amp;quot;Firefox throws `SecurityError` if not HTTPS.&amp;quot;));
    });
  }).catch((error) =&gt; {
    console.error(error);
  });
};
&quot; data-info=&quot;language-JavaScript&quot; data-lang=&quot;JavaScript&quot; class=&quot;code-block&quot;&gt;&lt;pre class=&quot;code&quot;&gt;&lt;code class=&quot;language-JavaScript&quot;&gt;// 加载评论的时候才加载缓存。
let cachePromise = null;

let fetchJSON = uncachedFetchJSON;

const loadCache = (name) =&amp;gt; {
  // Unlike in .then(),
  // we must explicit resolve and reject in a Promise&#039;s execuator.
  return new Promise((resolve, reject) =&amp;gt; {
    if (cachePromise != null &amp;amp;&amp;amp; fetchJSON !== uncachedFetchJSON) {
      return reject(new Error(&quot;Cache is already loaded!&quot;));
    }
    // Old version browsers does not support Response.
    if (window.Response == null) {
      return reject(
        new Error(&quot;Old version browsers does not support Response.&quot;)
      );
    }
    const testResponse = new window.Response();
    // Safari and most mobile browsers do not support `Response.clone()`.
    if (testResponse.headers == null || testResponse.clone == null) {
      return reject(new Error(
        &quot;Safari and most mobile browsers do not support `Response.clone()`.&quot;
      ));
    }
    // Chromium and Safari set `window.caches` to `undefined` if not HTTPS.
    if (window.caches == null) {
      return reject(new Error(
        &quot;Chromium and Safari set `window.caches` to `undefined` if not HTTPS.&quot;
      ));
    }
    window.caches.open(&quot;CacheStorageTest&quot;).then((cache) =&amp;gt; {
      fetchJSON = cachedFetchJSON;
      cachePromise = window.caches.open(name);
      return window.caches.delete(&quot;CacheStorageTest&quot;);
    }).then(() =&amp;gt; {
      return resolve();
    }).catch((error) =&amp;gt; {
      // Firefox throws `SecurityError` if not HTTPS.
      console.error(error);
      return reject(new Error(&quot;Firefox throws `SecurityError` if not HTTPS.&quot;));
    });
  }).catch((error) =&amp;gt; {
    console.error(error);
  });
};
&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;
&lt;p&gt;不管怎么样现在这个网站在支持 CacheStorage 和 Response 的浏览器上（似乎也就桌面版 Chrome/Firefox……）是缓存 GitHub API 的结果了，打开 DevTools 切到 Network 面板可以看到 GitHub API 返回的是 304 而不是 200，其他浏览器则 fallback 到无缓存的 fetch。当然其他浏览器不包含 IE 咯。&lt;/p&gt;
&lt;h1 id=&quot;%E7%94%B1%E4%BF%AD%E5%85%A5%E5%A5%A2%E6%98%93%EF%BC%8C%E7%94%B1%E5%A5%A2%E5%85%A5%E4%BF%AD%E9%9A%BE%E3%80%82&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Frontend-GitHub-Issue-Based-Comment/#%E7%94%B1%E4%BF%AD%E5%85%A5%E5%A5%A2%E6%98%93%EF%BC%8C%E7%94%B1%E5%A5%A2%E5%85%A5%E4%BF%AD%E9%9A%BE%E3%80%82&quot;&gt;&lt;/a&gt;由俭入奢易，由奢入俭难。&lt;/h1&gt;
&lt;div class=&quot;alert-green&quot;&gt;这一部分更新于 2020-08-18 12:25:00。&lt;/div&gt;

&lt;p&gt;我后来又仔细想了想，其实要兼容 IE 还是有办法的，首先 &lt;code&gt;fetch&lt;/code&gt; 和 &lt;code&gt;Promise&lt;/code&gt; 都有成熟的 polyfill，甚至 &lt;code&gt;URLSearchParams&lt;/code&gt; 也有，只要写一段脚本在不支持的时候加载他们就可以了。然后去掉所有 IE 不支持的 ES6 特性，比如箭头函数、模板字符串、&lt;code&gt;for…of…&lt;/code&gt; 循环以及 MapReduce（IE 竟然支持 &lt;code&gt;const&lt;/code&gt; 和 &lt;code&gt;let&lt;/code&gt; 真是惊到我了）。但是能做到并不意味着一定要做，人总是还要向前看的，现在是 2020 年，连罪魁祸首始作俑者微软都放弃了 IE，就算是照顾用户量，IE 用户也是可以忽略的那一部分了。既然我已经用 ES6 重写了，就不要想再让我为这种历史垃圾放弃我得到的好处了，从我开始写主题到现在丢掉 IE 支持也算是仁至义尽了，所以为什么不让这些用户支持一下 Firefox 呢？&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/ARIA/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="评论" label="评论" scheme="https://sh.alynx.one/tags/%E8%AF%84%E8%AE%BA/" />
    
    <category term="JavaScript" label="JavaScript" scheme="https://sh.alynx.one/tags/JavaScript/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/tags/ARIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>和 cheerio 说再见！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Drop-Cheerio/" />
    <id>https://sh.alynx.one/posts/Drop-Cheerio/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-08-04T13:06:00.000Z</published>
    
    
    <updated>2020-08-04T13:06:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我早就想把 cheerio 从 Hikaru 的依赖里移出去了，倒不是我对他的功能有什么不满，但是一年不更新 NPM 上的包也太恶心了吧！&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我早就想把 cheerio 从 Hikaru 的依赖里移出去了，倒不是我对他的功能有什么不满，但是一年不更新 NPM 上的包也太恶心了吧！&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;我的生成器使用 cheerio 的地方主要有两个，一是给标题生成喵点并依次生成 TOC，二是检查文章里相对路径的图片和链接引用并改成绝对路径，否则如果截取之后放在首页的摘要包含图片的话，会因为当前页面的地址变化而不工作。后者也是我自己编写生成器的原因之一，就是因为像 Hexo 或者 Hugo 这种已有的生成器内部并没有考虑，只能通过插件解决，我在写 Hexo 主题时嵌入了一个使用正则表达式的脚本，但相比之下我觉得还是一个能理解 HTML 的库更加可靠。所以后来我选了 cheerio 来做解析和修改以实现这些功能。&lt;/p&gt;
&lt;p&gt;但是 cheerio 有一个 &lt;a href=&quot;https://github.com/cheeriojs/cheerio/issues/1198&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;很古怪的 bug&lt;/a&gt;，存在于它目前在 NPM 上最新的版本 &lt;code&gt;1.0.0-rc3&lt;/code&gt; 上。假如你使用 cheerio 解析并编辑包含中文的 HTML 的话，导出字符串时所有的中文都被编码成了 HTML 实体，导致进行下一步处理比如用 &lt;code&gt;substring&lt;/code&gt; 截断的话，字符串长度变化了，而且可能会在文字中间截断。假如你使用 &lt;code&gt;decodeEntities: false&lt;/code&gt; 的话，原本文档里的 &lt;code&gt;&amp;amp;lt;&lt;/code&gt; 一类的字符反而会被 cheerio 导出成 &lt;code&gt;&amp;lt;&lt;/code&gt;，变成一团乱麻。&lt;/p&gt;
&lt;p&gt;这个 bug 非常古怪并且我花了一段时间来研究它，上一个版本 &lt;code&gt;0.22.0&lt;/code&gt; 使用 &lt;code&gt;decodeEntities: false&lt;/code&gt; 是没有这个问题的。最后发现原因是 cheerio 在 &lt;code&gt;1.0.0-rc1&lt;/code&gt; 开始引入 parse5 代替原本的 htmlparser2 作为默认的 HTML 解析器，而 parse5 在解析时并不会使用 &lt;code&gt;decodeEntities&lt;/code&gt; 这个参数，比如你输入 &lt;code&gt;&amp;amp;lt;&lt;/code&gt;，parse5 解析时会在节点里存储原本的值 &lt;code&gt;&amp;lt;&lt;/code&gt;，但 cheerio 在序列化的时候还是会依赖这个参数进行编码，所以假如传递 &lt;code&gt;false&lt;/code&gt; 进去，cheerio 就不会主动进行 encode，导致最后出来的是 &lt;code&gt;&amp;lt;&lt;/code&gt;。而 htmlparser2 会按照这个参数选择解不解码，所以也不会发生这种错误。&lt;/p&gt;
&lt;p&gt;那这么看起来是 parse5 的问题？并不！parse5 有自己的序列化函数，和自己的解析函数是配套的，所以只要使用 parse5 的序列化函数就不会存在这个问题了。&lt;/p&gt;
&lt;p&gt;最后总结起来修复的办法也有很多：首先其实序列化的时候并不需要将所有元素都编码成 HTML 实体，只要对几个字符进行转义即可，我提交了这样的 PR，但因为 cheerio 和它自己的序列化库 dom-serializer 是两个仓库，不是很好处理，而且其实也没有从根源上解决 htmlparser2 和 parse5 表现不一致的问题。cheerio 后来的提交中采用的是简单办法，假如使用 parse5 解析就继续使用 parse5 序列化就好了。&lt;/p&gt;
&lt;p&gt;但是这个提交之后并没有发布到 NPM 上，NPM 挂的一直是有问题的 &lt;code&gt;1.0.0-rc3&lt;/code&gt; 版本，至于原因呢很简单，他们打算释出第一个稳定版本 &lt;code&gt;1.0.0&lt;/code&gt;，所以要等到所有 TODO 都解决了再发新版本！&lt;/p&gt;
&lt;p&gt;搞毛啊老哥，你这样放着有 bug 的版本是把用户做宝搞吗？而且你是个函数库，下面好多人依赖你处理 DOM 呢，NodeJS 上提供 jQuery 模式的函数库大概也没什么别的替代品了，一堆项目在 issue 里问你就给个这破理由？&lt;/p&gt;
&lt;p&gt;我选择的是锁死 &lt;code&gt;0.22.0&lt;/code&gt; 版本，其他下游的项目也都各自做了 workaround，要么安装 GitHub 上的 &lt;code&gt;1.0.0&lt;/code&gt; 分支要么回退版本。但总之都让强迫症很不爽啊！&lt;/p&gt;
&lt;p&gt;大家等他发稳定版就这么等了一年，在这一年间有些项目比如 &lt;a href=&quot;https://github.com/hexojs/hexo/issues/3677&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Hexo 直接抛弃了 cheerio 用正则处理 HTML&lt;/a&gt;，虽然他们主要是为了性能。我倒不是那么在乎生成器的性能（真的在乎的话我就该去用 Hugo，而且我也不敢说我自己的代码写的很好）。&lt;/p&gt;
&lt;p&gt;晚上睡觉前我突然想到假如只是过滤链接和图片并检查他们的属性的话其实不需要 jQuery 一样的 API，只需要能理解 HTML，那找个简单的解析器就可以了。而且第二天正好读了 &lt;a href=&quot;https://blog.phoenixlzx.com/2017/02/18/dont-ask-me-why-invent-another-planet-river-of-news/#%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E5%86%85%E5%AE%B9%E5%AE%89%E5%85%A8&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;卷老师的这篇博文&lt;/a&gt;，发现和我想的也差不多。于是就开始动手。&lt;/p&gt;
&lt;p&gt;卷老师用的 sanitize-html 对我来说不太合适，因为我的静态生成器并不需要过滤内容——都是 Markdown 生成的，而且不安全也是使用者自己故意写的，不是我的责任，生成器也没有不安全的 HTML 的运行环境。sanitize-html 和 cheerio 用的都是 htmlparser2 作为解析器，虽然它号称自己是跑得最快的 HTML 解析器，但经过之前那个问题我还是心有余悸。而且 htmlparser2 是非常简单的基于事件回调的解析器（就像 Python 自带的那个，我太久不写 Python 不记得叫什么了），不会给你构建树状结构也不包含序列化，自己写序列化就容易像之前那个 cheerio bug 一样出问题。所以我考察了一下 parse5 发现还不错，会构建树状结构，数据结构都写在文档里，同时就是简单的可以直接操作的 Object，至于速度虽然慢一点但我并不太在乎那 10 毫秒。&lt;/p&gt;
&lt;p&gt;于是我就先手动造了一些 wrapper 函数比如递归前置遍历一颗树来代替 cheerio 的 &lt;code&gt;$.each()&lt;/code&gt;，前置遍历正好是 HTML 文档自上往下的顺序，生成 TOC 的时候也是按照这个顺序来的，然后就是比如获取结点内文本的函数、获取属性和设置属性的函数之类的。至于插入结点我想了个巧妙的办法，因为 parse5 把最终解析到的文本作为单独的结点，我就直接在插入文本的函数里让 parse5 解析输入的 HTML，然后用得到的子结点替换被插入结点的子结点即可。&lt;/p&gt;
&lt;p&gt;随后我重写了生成 TOC，生成标题 ID 和检查文章里相对路径的图片和链接引用并改成绝对路径的函数。然后写了点简单的测试样例跑了一下发现没问题，就用它们替换掉 Hikaru 的 &lt;code&gt;utils.js&lt;/code&gt; 里面用 cheerio 的版本，然后修改了 process 代码。我造的这几个简单的 wrapper 完全符合我的要求，于是提交打版本号发布一气呵成，一年不更新的 cheerio 就从我的生成器里拜拜了。&lt;/p&gt;
&lt;p&gt;虽然嘴上说着不追求速度，但是凭我肉体的感觉还是多少快了一点儿，不过我也并不是很在乎生成的时间，感知真的不强，无所谓了。但我真的不能理解这种为了憋个大的不发版本把用户做宝搞的行为，就算是发个 &lt;code&gt;1.0.0-rc4&lt;/code&gt; 也比一年不发强吧！就算只是 make user happy 也好，何况面对的不是 user 而是其它项目的 dev 呢，都是同行，这行为算不算托大？反正我是习惯做了点改动就打个新版本，即使我自己安装的都是开发版本，我也希望能把我最新的修改送到用户手上，又不是 breaking change 或者什么不能随便更新的软件，打个小版本号至于那么难吗？？？&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="Hikaru" label="Hikaru" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/Hikaru/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="Hikaru" label="Hikaru" scheme="https://sh.alynx.one/tags/Hikaru/" />
    
  </entry>
  
  
  
  <entry>
    <title>给你的主题来点暗色！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Dark-Mode-in-Theme/" />
    <id>https://sh.alynx.one/posts/Dark-Mode-in-Theme/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-08-04T09:15:00.000Z</published>
    
    
    <updated>2020-08-07T02:50:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我自己对暗色模式其实是没什么兴趣的，因为设计一种配色就已经让我绞尽脑汁了，还要我设计另一种。但是我也确实意识到暗色模式在晚上玩手机实在是很方便，而且做这个也很流行，于是我也做了一个，只是因为我能做到。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我自己对暗色模式其实是没什么兴趣的，因为设计一种配色就已经让我绞尽脑汁了，还要我设计另一种。但是我也确实意识到暗色模式在晚上玩手机实在是很方便，而且做这个也很流行，于是我也做了一个，只是因为我能做到。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;%E8%B7%9F%E7%9D%80%E7%B3%BB%E7%BB%9F%E5%8F%98%E8%89%B2%E5%B0%B1%E8%A1%8C%E4%BA%86%E5%90%97%EF%BC%9F&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E8%B7%9F%E7%9D%80%E7%B3%BB%E7%BB%9F%E5%8F%98%E8%89%B2%E5%B0%B1%E8%A1%8C%E4%BA%86%E5%90%97%EF%BC%9F&quot;&gt;&lt;/a&gt;跟着系统变色就行了吗？&lt;/h1&gt;
&lt;p&gt;现在的系统大概都支持暗色模式（Linux 的桌面环境早就有这种设置了，Firefox 可以直接读取我的系统设置，Android/iOS 也都有暗色模式开关），浏览器也紧跟潮流提供了 &lt;code&gt;@media&lt;/code&gt; 的 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/@media/prefers-color-scheme&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;查询属性&lt;/a&gt;（IE：那……是……什……么……）。理论上来说只要简单地在 CSS 里面查询然后编写修改颜色的代码就可以了，问题只是如何修改颜色比较轻松。&lt;/p&gt;
&lt;h1 id=&quot;CSS%E5%8F%98%E9%87%8F%E6%98%AF%E5%A5%BD%E4%B8%9C%E8%A5%BF%EF%BC%81&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#CSS%E5%8F%98%E9%87%8F%E6%98%AF%E5%A5%BD%E4%B8%9C%E8%A5%BF%EF%BC%81&quot;&gt;&lt;/a&gt;CSS 变量是好东西！&lt;/h1&gt;
&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/CSS/Using_CSS_custom_properties&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;使用 CSS 变量&lt;/a&gt; 当然是最简单的解决方案了，就像我们平时编程一样使用变量作为 &lt;code&gt;color&lt;/code&gt; 和 &lt;code&gt;background&lt;/code&gt; 的值，然后在查询到暗色模式的代码块里给这些变量重新赋值，一切都十分简单有条理，而且最重要的是你不需要一个一个选择器查找有哪些需要变色的属性，所有的颜色变量都是放在一起的。&lt;/p&gt;
&lt;h1 id=&quot;%E7%9C%9F%E6%98%AF%E6%81%A8%E6%AD%BBIE%E8%BF%99%E5%BA%9F%E7%89%A9%E4%BA%86%EF%BC%81&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E7%9C%9F%E6%98%AF%E6%81%A8%E6%AD%BBIE%E8%BF%99%E5%BA%9F%E7%89%A9%E4%BA%86%EF%BC%81&quot;&gt;&lt;/a&gt;真是恨死 IE 这废物了！&lt;/h1&gt;
&lt;p&gt;虽然 IE 有很多不支持的选项，但是不支持 CSS 变量真是让我工作量剧增的一件事情。虽然我从不测试我的网站在 IE 上能否运行，但是在最新版 IE 上一般都是没问题的，因此我也会放弃一些最新版 IE 不支持的新特性，CSS 变量就是其中之一。&lt;/p&gt;
&lt;p&gt;既然没有办法用 CSS 变量，那就只能自己一个一个找选择器下面和颜色相关的属性，然后给它们重新设置属性了，真是找的人头晕眼花啊。&lt;/p&gt;
&lt;p&gt;可能有人会说你不是用 CSS 预处理器吗，预处理器不是也有变量吗？但是预处理器是在生成阶段把变量编译掉了啊！不方便到运行时（浏览器）里去替换变量。&lt;/p&gt;
&lt;h1 id=&quot;%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E5%9C%A8%E6%9A%97%E8%89%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%94%A8%E4%BA%AE%E8%89%B2%E5%95%8A%EF%BC%81&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%88%91%E5%B0%B1%E6%98%AF%E6%83%B3%E5%9C%A8%E6%9A%97%E8%89%B2%E6%B5%8F%E8%A7%88%E5%99%A8%E9%87%8C%E7%94%A8%E4%BA%AE%E8%89%B2%E5%95%8A%EF%BC%81&quot;&gt;&lt;/a&gt;我就是想在暗色浏览器里用亮色啊！&lt;/h1&gt;
&lt;p&gt;在全部重新调整过颜色并能看之后（其实就是把浅色的色块换成深色，颜色层次基本不变，背景图搞个反色，至于那些彩色的按钮标签我实在没精力重新配色了，把透明度调低一点就好了），我自己还是比较喜欢自己一开始设计的样子，但我又是个习惯电脑全局暗色的人，这怎么能忍！&lt;/p&gt;
&lt;p&gt;CSS 的媒体属性不像一般的属性，只能是浏览器设置我们读取，没有办法用 JS 控制，于是也就没法简单地利用这个添加切换按钮。上网搜了半天也只有曲线救国的方案。&lt;/p&gt;
&lt;h1 id=&quot;%E6%9B%B2%E7%BA%BF%E6%95%91%E5%9B%BD&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%9B%B2%E7%BA%BF%E6%95%91%E5%9B%BD&quot;&gt;&lt;/a&gt;曲线救国&lt;/h1&gt;
&lt;p&gt;如果并不是想那么和系统的设置同步而只是给自己的网站添加切换的话，并不需要媒体查询。只要设计一个按钮给 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 或 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 添加删除 class/attribute 就行了。然后如果要和系统同步，在 JavaScript 里也有 &lt;a href=&quot;https://developer.mozilla.org/en-US/docs/Web/API/Window/matchMedia&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;相关的 API&lt;/a&gt; 可以做到查询和监听，在检测到变化的时候也修改 class/attribute 即可。&lt;/p&gt;
&lt;p&gt;我选择的是给 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 加 &lt;code&gt;data-theme=&quot;dark&quot;&lt;/code&gt; 或 &lt;code&gt;data-theme=&quot;light&quot;&lt;/code&gt; 属性，不选 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 是因为 WebKit 那些该死的不遵循标准的 scrollbar 伪类，文档没有说他们到底依附哪个元素，我尝试得到的是 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;。接下来只要把之前的 CSS 里面的媒体查询选择器改成 &lt;code&gt;html[data-theme=&quot;dark&quot;]&lt;/code&gt; 就行了。&lt;/p&gt;
&lt;p&gt;不过还要注意继承关系，这样写的话有些属性并不是继承外面的，而是在这个选择器里面就近继承。比如假如修改了 &lt;code&gt;html[data-theme=&quot;dark&quot;] a&lt;/code&gt; 的边框，那 &lt;code&gt;html[data-theme=&quot;dark&quot;] a.cls&lt;/code&gt; 的边框会优先继承这个，而不是 &lt;code&gt;a.cls&lt;/code&gt;。我知道有些人可能会笑我半懂不懂了，但是我确实遇到了这个问题，并且思考了一下找到了原因。&lt;/p&gt;
&lt;p&gt;还有一个比较尴尬的事情，我给一些元素设置了 &lt;code&gt;transition&lt;/code&gt; 用于 &lt;code&gt;:hover&lt;/code&gt; 之后加一个渐变颜色的效果，现在暗色模式也是修改颜色，导致这些元素会比其他元素慢变一下，没什么好办法因为你分不开两种 &lt;code&gt;color&lt;/code&gt; 变化。我的解决方案是一个一个找切换暗色模式时候会变属性的选择器，给它们也添加 &lt;code&gt;transition&lt;/code&gt;。效果还不错，不过 Chrome 在处理这种 CSS 动画时候竟然会掉帧？？？&lt;/p&gt;
&lt;p&gt;不管了，反正我用 Firefox，Firefox 效果好得很，完全不掉帧。&lt;/p&gt;
&lt;p&gt;更新（2020-08-07 10:50:00）：我怀疑 Chrome 想做新时代的 IE，其实并不是性能问题导致掉帧，WebKit 对于继承来的属性的 transition 存在问题，会导致不是同时变换而是有延迟的变换，效果糟透了，&lt;a href=&quot;https://stackoverflow.com/a/36779404&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;StackOverflow 上也有人遇到这个问题&lt;/a&gt;，看起来是 bug 并且不打算解决，而 Firefox 就没有这个问题。使用 CSS 变量在 WebKit 下效果会好一点，不过也不能给所有变色的元素加 transition，还是会卡，只能给 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 加一个，因为我的链接有 &lt;code&gt;:hover&lt;/code&gt; 时变色的 transition，都是 color 就没办法在那时 transition 而暗色模式时候不 transition。总之由于 WebKit 的存在导致没法让全部元素同步 transition，只能近似。两权相害取其轻，还是让 IE 用户只能用亮色吧，我最后还是选择了 CSS 变量。&lt;/p&gt;
&lt;h1 id=&quot;%E6%80%8E%E4%B9%88%E4%BD%A0%E8%BF%99%E7%A0%B4%E7%BD%91%E7%AB%99%E6%8D%A2%E4%B8%AA%E9%A1%B5%E9%9D%A2%E8%BF%98%E8%A6%81%E9%87%8D%E6%96%B0%E7%82%B9%E4%B8%80%E6%AC%A1%EF%BC%9F&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E6%80%8E%E4%B9%88%E4%BD%A0%E8%BF%99%E7%A0%B4%E7%BD%91%E7%AB%99%E6%8D%A2%E4%B8%AA%E9%A1%B5%E9%9D%A2%E8%BF%98%E8%A6%81%E9%87%8D%E6%96%B0%E7%82%B9%E4%B8%80%E6%AC%A1%EF%BC%9F&quot;&gt;&lt;/a&gt;怎么你这破网站换个页面还要重新点一次？&lt;/h1&gt;
&lt;p&gt;一切看起来都十分美好，直到我把一个暗色页面切成亮色然后点了个链接，下一个页面并不会理会我们上一个页面设置了什么主题，又变成了暗色。每个页面点一下切换按钮也太烦人了，我们得来点持久化。&lt;/p&gt;
&lt;p&gt;某个域名想在用户的浏览器里存点是完全可行的，使用 &lt;code&gt;localStorage&lt;/code&gt; 就行了，就是简单的键值对。但是这样我们就有了多种可能切换亮暗的动作：&lt;code&gt;localStorage&lt;/code&gt; 里面存的选项，网页加载时浏览器媒体查询的结果，用户点了网页上的切换按钮，用户点了系统切换亮暗的设置。这些的判断顺序要好好处理一下，不然某些就会被忽视掉变成“我点了怎么不动啊！！！”。&lt;/p&gt;
&lt;p&gt;经过我考虑一下之后，这个玩意的逻辑应该是这样的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;假如 &lt;code&gt;localStorage&lt;/code&gt; 里面没有值，用户是首次打开网站，此时读取媒体查询按照系统的主题设置。&lt;/li&gt;
&lt;li&gt;否则说明用户之前打开过网站，已经有他自己的喜好了，按照 &lt;code&gt;localStorage&lt;/code&gt; 里面的值设置。&lt;/li&gt;
&lt;li&gt;上两个步骤结束之后注册一个媒体查询监听器，用于响应用户修改系统设置。&lt;/li&gt;
&lt;li&gt;注册一个按钮监听器，用于响应用户点击网页切换按钮设置。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上 1 和 2 的顺序不能反了，并且每一个设置动作里都要把这次设置的值写入 &lt;code&gt;localStorage&lt;/code&gt; 用于后续加载用户的选择。&lt;/p&gt;
&lt;p&gt;现在看起来一切都很满意，是时候发布了！&lt;/p&gt;
&lt;h1 id=&quot;%E7%94%A8%E6%88%B7%EF%BC%9A%E5%95%8A%EF%BC%81%E6%88%91%E7%9A%84%E7%9C%BC%E7%9D%9B%EF%BC%81&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E7%94%A8%E6%88%B7%EF%BC%9A%E5%95%8A%EF%BC%81%E6%88%91%E7%9A%84%E7%9C%BC%E7%9D%9B%EF%BC%81&quot;&gt;&lt;/a&gt;用户：啊！我的眼睛！&lt;/h1&gt;
&lt;p&gt;我躺在床上用手机测试的时候又发现了一个问题。因为网页在生成的时候总有一个初始状态（JS 要等到 document 加载完成才开始处理 DOM，不像那些单页应用），假如我设置成暗色然后切换到别的页面，网页就会以亮色加载然后变成暗色，用户在晚上看起来就像是个闪光弹（伏拉什棒！）。&lt;/p&gt;
&lt;p&gt;其实没什么好的解决办法，因为这是传统 HTML 页面的限制之一，我也不想找有没有什么新的东西能解决这些问题，最后的方案其实相当简单，既然亮色到暗色会让人受不了，我搞成暗色到亮色不就行了。&lt;/p&gt;
&lt;p&gt;于是就是把模板里按钮的初始状态修改一下，渲染的时候出来的是 &lt;code&gt;data-theme=&quot;dark&quot;&lt;/code&gt;，假如用户选择亮色，加载页面时会有一个暗色到亮色的变化。反正我自己都不在意。&lt;/p&gt;
&lt;p&gt;更新（2020-08-06 18:23:00）：我后来阅读了一些其它主题的代码，看它们是怎么在不使用单页应用的前提下解决这个问题的，结果方法相当简单，我自己也想得到：不用等到 &lt;code&gt;DOMContentLoaded&lt;/code&gt; 事件之后，反正只是修改 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 标签，直接在 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 标签里面编辑 &lt;code&gt;document.documentElement&lt;/code&gt; 是可以的，因为反正加载到 &lt;code&gt;&amp;lt;script&amp;gt;&lt;/code&gt; 的时候肯定也已经加载到 &lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt; 了。所以就把修改这个属性和修改按钮的 DOM 分开了两部分，并且添加了一个 &lt;code&gt;storage&lt;/code&gt; 的监听器，这样假如打开了多个页面，一个页面切换其它页面也会跟随切换。&lt;/p&gt;
&lt;h1 id=&quot;%E4%B8%8D%E8%A6%81%E8%BF%87%E5%BA%A6%E8%AE%BE%E8%AE%A1%EF%BC%81&quot;&gt;&lt;a class=&quot;header-link&quot; href=&quot;/posts/Dark-Mode-in-Theme/#%E4%B8%8D%E8%A6%81%E8%BF%87%E5%BA%A6%E8%AE%BE%E8%AE%A1%EF%BC%81&quot;&gt;&lt;/a&gt;不要过度设计！&lt;/h1&gt;
&lt;p&gt;经过这么一大堆折腾（代码行数++++++++），我甚至在想要不要支持每个页面单独设置亮暗初值，反正只要添加一个 front matter 然后在模板里判断一下嘛。不过后来想了想，就算有这么个功能又有什么用？实际意义几乎为零，徒增复杂度，所以还是不要过度设计了。&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/ARIA/" />
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%AB%99/" />
    
    <category term="ARIA" label="ARIA" scheme="https://sh.alynx.one/tags/ARIA/" />
    
  </entry>
  
  
  
  <entry>
    <title>修复更换 PCI-E 插槽后 Windows 下无线网卡的名称问题</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Fix-Windows-Wireless-Adapter-Name/" />
    <id>https://sh.alynx.one/posts/Fix-Windows-Wireless-Adapter-Name/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2020-06-28T11:02:00.000Z</published>
    
    
    <updated>2020-06-28T11:02:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;这是一篇其实没什么逻辑也没什么技术的文章，但踩到这个坑又很头痛，所以记录一下。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;这是一篇其实没什么逻辑也没什么技术的文章，但踩到这个坑又很头痛，所以记录一下。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;我用的是一张 PCI-E 的网卡，占据一个 PCI-Ex1 的插槽，对于一个主流的 ATX 主板来说有三个选择，第二条 x16 长度的插槽上面的一个和下面的两个，由于显卡一般会插在第一条 x16 上，所以如果插在第二条 x16 长度上面的那个，会挡住一部分显卡风扇，所以我一开始插在了第二条 x16 长度插槽下面的第一个插槽。这样也是有点问题的，因为这里 x16 和 x1 之间并没有留出一个槽的空位，一般主流显卡又都是双槽的，虽然我不太可能在机箱里塞第二张显卡，但是这么装直接就干掉了这种可能性，所以我一直想把无线网卡换到最底下的插槽。（这一部分比较乱，但是装过机的直接上网搜一下主流 ATX 主板的图就能理解了。）&lt;/p&gt;
&lt;p&gt;之前由于最后一个插槽挡板的螺丝拧的太紧我一直没换，今天买了一个柄比较粗比较省力的螺丝刀，终于拧下来螺丝把网卡换了个插槽。开机之后 Linux 下其实没什么问题，检测设备和持久化命名都正常工作了。不过 Network Manager 似乎认为更换了设备，所以建议删掉之前的连接配置重新连接网络，之后一切都正常。&lt;/p&gt;
&lt;p&gt;切到 Windows 发现不太对劲，首先就是我的 WiFi 适配器名字变成了 &lt;code&gt;WLAN 2&lt;/code&gt;，想要重命名成 &lt;code&gt;WLAN&lt;/code&gt; 又提示已经存在，但是我又看不到，点进去发现它选择的无线网卡名字后面多了个 &lt;code&gt;#2&lt;/code&gt; 的后缀，总之我也不知道怎么回事，但是强迫症觉得很难受，明明我只有一张网卡啊。&lt;/p&gt;
&lt;p&gt;上网搜索了一下，首先是在设备管理器的查看菜单里选择显示隐藏的设备，这样就会发现一个灰色的没有后缀的网卡，我也不知道 Windows 为什么要存一个隐藏的之前存在现在不存在的 PCI-E 设备，首先按照网上的说法卸载掉这个设备然后重启，再开机就没有这个隐藏设备了。&lt;/p&gt;
&lt;p&gt;接下来需要去掉 &lt;code&gt;#2&lt;/code&gt; 的后缀，让 Windows 把这个插槽里的卡认成唯一的一张，这里就十分晦涩，Windows 试图隐藏起这个逻辑，但导致了一个令强迫症十分不爽的问题。我搜索了一下，发现了一个 &lt;a href=&quot;https://wenku.baidu.com/view/275565c68bd63186bcebbc96.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;百度文库文档&lt;/a&gt; 提供的方案。&lt;/p&gt;
&lt;p&gt;首先打开注册表编辑器定位到 &lt;code&gt;HKEY_LOCAL_MACHINE\SYSTEM\_ControlSet001\Control\Network\{4D36E972-E325-11CE-BFC1-08002BE10318}\Descriptions&lt;/code&gt; 这一项，然后在右侧找到你无线网卡的名称，里面的值应该是 &lt;code&gt;2&lt;/code&gt;，改成 &lt;code&gt;1&lt;/code&gt;，然后卸载网卡设备，然后重启，应该就解决了，而且因为设备名字恢复了，&lt;code&gt;WLAN 2&lt;/code&gt; 也应该变回 &lt;code&gt;WLAN&lt;/code&gt; 了。&lt;/p&gt;
&lt;p&gt;所以其实这篇文章并没有什么逻辑和技术，但是 Windows 自作主张非要保存一个隐藏的不存在的设备，实在是令人头痛，又没什么明显的解决方式，所以也只好记下来以防再次被恶心到。&lt;/p&gt;
&lt;p&gt;更新：Arch Linux CN offtopic Telegram 群组里面叫 Give Way 的网友表示并不需要这么复杂，只要把两个无线网卡的设备都卸载掉重启就可以了。理论上确实是如此，但我没机会再试了，遇到相同问题的朋友可以试试。&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    <category term="网络" label="网络" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E7%BD%91%E7%BB%9C/" />
    
    
    <category term="网络" label="网络" scheme="https://sh.alynx.one/tags/%E7%BD%91%E7%BB%9C/" />
    
    <category term="Windows" label="Windows" scheme="https://sh.alynx.one/tags/Windows/" />
    
  </entry>
  
  
  
  <entry>
    <title>让你们的主题商店离我远点！</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/Taking-Your-Theme-Store-Away/" />
    <id>https://sh.alynx.one/posts/Taking-Your-Theme-Store-Away/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-12-18T08:17:00.000Z</published>
    
    
    <updated>2019-12-18T08:17:00.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;我不觉得我是个刻薄的人，但对于一些实在令我讨厌的人，不把他们的名字挂出来就是我最后的怜悯。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;我不觉得我是个刻薄的人，但对于一些实在令我讨厌的人，不把他们的名字挂出来就是我最后的怜悯。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;已经有不止一个人询问过我有关把博客主题移植到其他生成器上的问题了，这实际上是超出我范围的工作，因为我并不熟悉他们的生成器。但如果有人这样询问我（当然最好的方式是发 issue），我一般会先了解一下他说的生成器，然后解释是因为我没有时间或者我不熟悉目标技术栈。&lt;/p&gt;
&lt;p&gt;我还记得的最远范围是某个 Gridea 的用户发邮件问我怎么把我的主题用到他这个生成器上。某种程度上我觉得他要么是真的无知要么就是装成无知然后提一些在技术上很显而易见的问题来气人（我今天新学的词叫 troll），于是我去查了一下 Gridea，是个一条龙的基于 Vue 的图形化博客系统。对我足够熟悉的人可能知道我不喜欢把博客做成单页应用的样子，而且在我理解里博客生成器就应该是一个比较简单的命令行工具，而不是一个图形化数据库管理工具。尽管我不太喜欢这个项目和它的宣传方式，但万一对方真的是个并不了解这些的小白用户呢？我回复的语气可能并不是十分客气，但我还是解释了一下博客主题和生成器的关系，以及我不了解 Gridea 的技术栈也不是很喜欢这个项目，所以没办法写一个 收费/免费 的主题给这个项目。当然最后结果相对还不错，他也理解我给他的解释。&lt;/p&gt;
&lt;p&gt;但是我最近又收到一封标题为“诚邀合作事宜”的邮件，为了不破坏我第一句的承诺，我修改了部分名词：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很喜欢你博客的风格，可否为Cxxxxx-CMS开发一套（免费/付费）主题，然后发布到Cxxxxx商店里面？&lt;/p&gt;
&lt;p&gt;CxxxxxJS：是一款顶级NodeJS全栈业务开发框架, 基于KoaJS + EggJS + VueJS + Framework7
Cxxxxx-CMS：是基于CxxxxxJS全栈业务开发框架开发的动静结合的CMS，可以快速构建企业网站、博客、社区、商城等Web应用
Cxxxxx商店：包括品类广泛的各类模块，满足不同场景的开发需求&lt;/p&gt;
&lt;p&gt;CxxxxxJS介绍：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/introduce.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/introduce.html&lt;/a&gt;
Cxxxxx-CMS介绍：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/cms-introduce.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/cms-introduce.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cxxxxx商店运营模式：&lt;a href=&quot;https://cxxxxx.com/zh-cn/articles/store.html&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;https://cxxxxx.com/zh-cn/articles/store.html&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我也不是个专业的前端工程师，现在不是，将来大概也不是前端“全栈”工程师，但我还是能懂这封邮件的内容。俗话说“文无第一，武无第二”，程序员的圈子里这句话应该也十分受用，所以我通读全文之后，目光就落在了“顶级”两个字上面。毕竟去掉套话之后，满足这类泛泛功能的项目也不少，所以还是先看看“顶级”比较有意思。&lt;/p&gt;
&lt;p&gt;在 Google 搜索这个 Cxxxxx 之后，还是有一些相关度比较高的内容的，出于个人习惯，我直接点开了他在 GitHub 上的仓库。既然是“顶级”框架，想必受益者众多，star 数量高达……108 个（截止昨日 18:00）。&lt;/p&gt;
&lt;p&gt;这就十分可笑了，虽然我也不是什么大牛，但是这个数量级 star 的仓库也有，虽然 star 不能说明代码质量，但是说明“顶级”这种人气形容词拿来正合适，如果我有这么个仓库，我肯定不会腆着脸在宣传语里加“顶级”二字。然后在大概阅读了一下文档和官网之后，我觉得就是个普通的 CMS，而且我也不认为静态博客生成器需要和 CMS 结合起来，我更希望静态博客生成器像编译器。而说到 JS 框架的话，既然都基于 &lt;code&gt;KoaJS&lt;/code&gt;、&lt;code&gt;EggJS&lt;/code&gt;、&lt;code&gt;VueJS&lt;/code&gt; 了，我想不出还能在这些套娃外面再套什么娃（禁止套娃！）。&lt;/p&gt;
&lt;p&gt;于是我就回了一封有点嘲讽意味的邮件（我知道可能换个人不会说这种话，不过这种情况稍微嘲讽一下也没什么错吧）：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;前几天有个意思和你差不多的，但他没你这么能吹，他就是另一个博客生成器的普通用户。&lt;/p&gt;
&lt;p&gt;可能我这话有点刻薄，但假如我自己有一个 100 个 star 的项目，我不会在宣传语里用 &lt;strong&gt;顶级&lt;/strong&gt; 这种形容词。&lt;/p&gt;
&lt;p&gt;写博客是我个人爱好，换句话说就是我也没打算靠这个玩意赚钱，就是自己用着爽然后开源出来有人喜欢随便用。我也没觉得自己技术强到可以靠这个吃饭了。&lt;/p&gt;
&lt;p&gt;既然是“诚邀”，那我觉得应该先看看我博客主题吧，不然容易让人觉得你是爬个 Hexo 主题作者列表然后群发邮件的哎。如果真看了就知道我这个主题的技术栈和你这个项目完全不搭。我的定位是静态博客生成器哎，我也不是很懂这种 CMS 或者 Koa Egg Vue，对这种快速批量构建网站没兴趣，毕竟个人博客嘛，随便折腾折腾才好玩。&lt;/p&gt;
&lt;p&gt;因此我建议你另请高明，或者真有兴趣，Fork 我的主题随便改。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后我就去忙别的去了，手头正好有个奇葩 Bug。我想这下大概清净了，没想到过一会又来了一封邮件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这就是一般大学生傲慢的地方了。如果是业务爱好者，我不好说什么。如果是一位志于软件开发的同行，就会一个静态博客生成器有什么可炫耀的呢？只怕你还真没有好好看看CxxxxxJS的文档了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这话说的很讨人厌哎。我脾气还算好，实在懒得一点点找出这话里有问题的地方反驳他，就随便回了一句：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我再说一遍，我可没有给我自己的哪个项目加上“顶级”两个字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后他又来：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;你可以细细思考这个问题：我用顶级二字就把你伤到了吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Arch Linux CN 群里的群友建议我直接拉黑算了，我也这么想的，但是晚上回去闲的没事翻了翻，发现了其他的东西：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/Taking-Your-Theme-Store-Away/1.png&quot; alt=&quot;骚扰证据&quot;&gt;&lt;/p&gt;
&lt;p&gt;好啊！你还敢说你是“诚邀”！还真被我说中了，明明就是爬了 Hexo 主题列表挨个作者群发！一开始邮件是我略有刻薄，不想再逐条反驳他，但看到这个我实在是 &lt;strong&gt;口区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;首先对于这类“主题商店”，细细想想就知道不对劲，不仅仅这一个项目，还有别的没什么用户又跟你说邀请你驻入商店也是，他说他是诚邀作者设计一款主题放在他商店收费，可是主题作者真的拿到好处了吗？主题做的好，&lt;strong&gt;作者拿到的钱是用户掏的&lt;/strong&gt;，&lt;strong&gt;而用户的使用习惯和黏性是落在他的项目上的&lt;/strong&gt;！图里的有些主题我都看过，真的是非常优秀的作者，从作者角度想不得到任何好处地加入某一项目，也会希望这一项目的人气能给自己带来一些用户口碑，而这个项目很显然不满足！&lt;strong&gt;好一招空手套白狼！&lt;/strong&gt;用户的钱三七分成，豪绅的钱……豪绅现在连钱都不用掏了，全靠一张嘴吹一吹？&lt;/p&gt;
&lt;p&gt;比如 Hexo、Jekyll、Hugo、Pelican 的主题页面（你愿意叫商店也行），都是作者自己主动提交的，为什么？因为这些广受好评的项目，可以为主题作者吸引人气，所以作者才会主动“合作”！&lt;/p&gt;
&lt;p&gt;其次说句不客气的，这类 CMS 项目说到底是拼工作量的东西，我也不是没写过。如果作者就是谦虚的说“我写了个 CMS，希望大家能给点意见使用一下”，我一个一般大学生哪里来的毛病非要嘲讽你？我最起码还得心里叨咕一句作者做这种项目坚持下来不容易，先支持一下劳动量再说。可是既然您把自己放在“顶级”的位子上，而且还看不起我，我也就不说什么客套话了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;这种项目 V2EX 上一天能刷个十来个，有些就是很诚恳用来练手刷简历的，有些则是这种没有痛点制造痛点也要上的&lt;/strong&gt;。我还再仔细搜了一遍这个项目，发现了好几篇什么掘金知乎&lt;strong&gt;甚至还真有 V2EX&lt;/strong&gt; 上作者发的宣传帖，什么“动静结合”、“全栈开发利器”、“开发业务实战”，这种套话一套一套的。V2EX 帖子就 6 个回帖，有人表示不理解，本来 Hexo 是个静态博客生成器，为啥非得搞个动静结合解决痛点呢？然后作者复读机上身又复制了一下这类套话，换我我也不接着看了。类似我这种静态博客用户就是不想要“后台管理系统”才用静态博客生成器的，这个“痛点”我怎么理解呢？&lt;/p&gt;
&lt;p&gt;“一般大学生傲慢的地方”，这话说的真是让人恶心啊，一般大学生怎么了呢？一般大学生哪里傲慢了呢？一般大学生是不会在自己项目上用“顶级”二字做宣传的。“就会一个静态博客生成器有什么可炫耀的”，我倒是想问问这位同行（呕，请别叫我前端全栈工程师啊各位，我知道自己还不合格呢），您在哪里看到我炫耀啦？我也不在知乎掘金 V2EX 发宣传帖，我甚至还没来得及在我自己博客上介绍一下，我还经常说我这个有写地方写的还不够好，一边学习一边继续编写代码解决我自己的问题，请问您在哪听见我炫耀的？&lt;strong&gt;莫非是我在隔壁宿舍和同学聊天吹水时候跟他吹了一下您听见了？如果真是这样，我还得告您搞窃听呢。&lt;/strong&gt;哦对了，我也不是什么就会一个静态博客生成器，我写生成器是为了解决我自己遇到的痛点的，这只是我涉及领域的一小部分，如果您真的仔细看了我的博客我的 GitHub，就知道我不是只搞前端，反而我看您 GitHub 都是 EggJS 的插件来着，真是令人眼花缭乱啊。&lt;/p&gt;
&lt;p&gt;什么你说让我看文档？文档有什么好看的，你想写什么就写什么，我也能把文档写出花来，那就能欺骗我自己项目本来没解决别人什么痛点嘛？&lt;/p&gt;
&lt;p&gt;让我细细思考？我看是您用了“顶级”二字，被我伤到了吧。都是写点胶水代码的玩意，我生成器还没用 Koa、Egg、Vue 这种框架呢，库是别人写的，框架逻辑都是我自己的，我 &lt;strong&gt;细细思考&lt;/strong&gt; 一下真的很好奇在三大框架（甚至还有个企业级框架）上面能套出什么框架呢？如果你愿意一层一层一层的剥开我的心？本来我不想扯技术方面的，可是别的方面也没看到这个项目对主题作者有什么优势和好处啊！&lt;/p&gt;
&lt;p&gt;我要时时刻刻提醒我自己，我就是个一般大学生，不懂的东西还有很多，也不能学这种说话语气，不然会被人当成知乎上那种讨人厌的家长，就是自己本来也没什么见识还在年轻人面前的死要面子那种，年轻人说点什么就贬低他什么。&lt;/p&gt;
&lt;p&gt;我个人是不习惯在知乎掘金 V2EX 上写帖子骗眼球的，所以就写到我自己博客上了，想必“一般大学生”的博客，估计也没什么人看吧！如果您真的介意，还是那句话，“文无第一，武无第二”，评论区或者在您的博客上，放马过来，反驳我这篇文章，我不介意的。但是，我真的很厌恶往别人仓库刷这种“诚邀合作事宜”的 issue，issue 是用来说代码相关问题的也算是程序员的自我修养之一了吧。我写这个也是希望万一有主题作者看到了别上当了，这不是“诚邀”，是“白嫖”作者人气。&lt;/p&gt;

    </content>
    
    
    <category term="网站" label="网站" scheme="https://sh.alynx.one/categories/%E7%BD%91%E7%AB%99/" />
    
    
    <category term="空手套白狼" label="空手套白狼" scheme="https://sh.alynx.one/tags/%E7%A9%BA%E6%89%8B%E5%A5%97%E7%99%BD%E7%8B%BC/" />
    
    <category term="全靠一张嘴" label="全靠一张嘴" scheme="https://sh.alynx.one/tags/%E5%85%A8%E9%9D%A0%E4%B8%80%E5%BC%A0%E5%98%B4/" />
    
    <category term="你这是瞧谁不起" label="你这是瞧谁不起" scheme="https://sh.alynx.one/tags/%E4%BD%A0%E8%BF%99%E6%98%AF%E7%9E%A7%E8%B0%81%E4%B8%8D%E8%B5%B7/" />
    
  </entry>
  
  
  
  <entry>
    <title>装机小记</title>
    <link rel="alternate" type="text/html" href="https://sh.alynx.one/posts/My-Desktop-PC/" />
    <id>https://sh.alynx.one/posts/My-Desktop-PC/</id>
    
    <author>
      <name>Alynx Zhou</name>
      <email>alynx.zhou@gmail.com</email>
    </author>
    
    
    <published>2019-11-25T02:14:00.000Z</published>
    
    
    <updated>2021-01-15T11:46:45.000Z</updated>
    
    
    <summary type="html">
      &lt;p&gt;由于笔记本散热和性能实在是不适合打游戏（有一说一，Optimus 双显卡还是没有直接单卡来得爽），所以很早就想组装一台台式机。特别是最近一直和高中同桌玩 Dota2，我的笔记本如果直播 Dota2，直播推流就会十分卡顿，而我又不想像 CSGO 一样降低画质玩。&lt;/p&gt;

    </summary>
    
    
    <content type="html">
      &lt;p&gt;由于笔记本散热和性能实在是不适合打游戏（有一说一，Optimus 双显卡还是没有直接单卡来得爽），所以很早就想组装一台台式机。特别是最近一直和高中同桌玩 Dota2，我的笔记本如果直播 Dota2，直播推流就会十分卡顿，而我又不想像 CSGO 一样降低画质玩。&lt;/p&gt;
&lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;作为计算机专业的学生，当然不打算直接淘宝整机啦。经过一番挑选和参考别人意见，最后成套配置是下面这样：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU：AMD Ryzen 7 5800X 3199（之前是 AMD Ryzen 5 3600X）&lt;/li&gt;
&lt;li&gt;主板：ROG STRIX X570-E GAMING 1999（特价）（之前是 微星 X570-A PRO 套装 2349）&lt;/li&gt;
&lt;li&gt;显卡：NVIDIA GeForce RTX 2070 SUPER 4300（之前是 七彩虹 RTX 2060 战斧 6G 2199）&lt;/li&gt;
&lt;li&gt;显卡支架：酷冷至尊 显卡支撑架 70&lt;/li&gt;
&lt;li&gt;内存：铂胜 C9BJZ 颗粒 白马甲 DDR4 3000 8G x4 1000&lt;/li&gt;
&lt;li&gt;网卡：Intel AX200（主板内置，之前是单独购买的花了 150）&lt;/li&gt;
&lt;li&gt;固态硬盘：三星 970 EVO Plus 512G 769&lt;/li&gt;
&lt;li&gt;固态硬盘：英睿达 MX500 2TB 1299&lt;/li&gt;
&lt;li&gt;机械硬盘：东芝 P300 2TB 400&lt;/li&gt;
&lt;li&gt;机械硬盘：西数 紫盘 2TB 400&lt;/li&gt;
&lt;li&gt;电源：海韵 CORE GX650 650W 金牌 549（特价）&lt;/li&gt;
&lt;li&gt;CPU 散热：利民 AK120 145（之前是 超频三 东海x5 89）&lt;/li&gt;
&lt;li&gt;M.2 散热：主板自带（之前是利民 M.2 硬盘散热片 39）&lt;/li&gt;
&lt;li&gt;机箱：Corsair 4000D 白色 629 （之前是 先马 鲁班1 209）&lt;/li&gt;
&lt;li&gt;机箱风扇：利民 TL-C12R-S x2 + 利民 TL-C12S 418（TL-C12R-S 只有 299 的三联包）（之前是 Arctic F12 PWM 温控 x3 120）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总计 15177。（有些具体价格我记不清了，而且京东价格总是波动。）性价比一般，因为我在其它人觉得没必要的地方分了很多预算比如主板风扇和硬盘，选 B450M 和西数的 NVMe 以及随便买个不带温控但是带灯的风扇的大有人在。&lt;/p&gt;
&lt;p&gt;选这样一套配置其实有原因，可能很多人觉得为什么要给 R5 配 X570 这种高端主板，不如换成 B450 然后把预算加到别的上面。但按照我朋友的使用经验，4 代和以前的 AMD 芯片组存在 USB 兼容性问题，而且我装好机器后就在 Arch Linux CN 群里看到有人遇到这种问题，5 代似乎重新设计了 USB 控制器，目前一切正常。虽然这大概是最丐的 X570，连前面板 USB C 的接口都不支持，但是带 3900X 以下的 CPU 还是没什么压力的，而且我的机箱也没前面板 USB C。唯一的问题是微星不太厚道，今年 B550 出来之后又搞了个 X570 Tomahawk，大概只贵了几百块但是却有比肩旗舰的供电能力和前面板 USB C 支持，所以不再推荐购买 X570-A PRO 和 X570 Gaming Edge 这两个低端款了。有这种好东西为什么不一开始就吐出来？？？&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020 年 11 月 16 日）：AMD 发布了 Zen 3 系列的 CPU，游戏性能全面反超 Intel，对于我这种玩的都是吃 CPU 的游戏的用户来说实在是太香了，而且我一直想要 8 核心的 R7，于是买了首发的 R7-5800X，果然性能提升明显。然后正好有朋友的朋友打算装机买我换下来的 CPU 和主板，于是双十一为了 &lt;del&gt;更好的 RGB 效果&lt;/del&gt; 更好的供电支持换了 ROG 的 X570-E（东哥疯狂耍猴，本来我是想 Tomahawk 的，但是微星的几款真香主板都无货，而且我对微星土里土气的设计也审美疲劳了，1999 的打人国度带眼睛它不香吗）。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;如果仅仅是打游戏也可以把 R5-3600X + X570 换成 i5-9600KF + Z390，大概可以便宜一点然后升级一下显卡？我觉得差价是不够 2060 换 2060S 的。或者如果要求不高换成 R5-3600 也行。但 R5-3600(X) 是 12 线程而 i5-9600KF 只有 6 线程，所以我还是选择了 Ryzen，反正 AMD CPU 最近表现都很不错，没必要给 Intel 掏更多的钱。如果你在京东买，建议自己翻翻店铺，一般买主板 CPU 套装更便宜，但是它不会摆出来……&lt;/p&gt;
&lt;p&gt;显卡一开始我是打算买个 1999 的 GTX 1660Ti 的，反正我玩的游戏也不需要光线追踪（难道真相不是本来就没几个游戏支持光线追踪嘛？），然而看到七彩虹最便宜的 2060 正在特价 2199，果断少买一条内存，加钱上这个。反正 1999 的 1660Ti 也是便宜货，而且看了一下视频似乎这块卡也不是丐中丐中丐，质量还可以（同价位索泰铭瑄也不能说是什么高端货吧？），反正内存可以再插新的，而显卡二手不值钱。什么你说 A 卡？虽然 A 卡对于 Linux 的驱动支持更好一点，但是 N 卡也不是不能用，而且我要开直播的话 NVENC 编码挺香的，而且对我的 Steam 库存来说 N 卡也更友好一点（但是骂老黄还是要骂的）。另外虽然我不做机器学习，但万一室友毕设需要的话，反正我上班也不用台式机，装个 CUDA 让他 SSH 上去用岂不是你好我好大家好。&lt;/p&gt;
&lt;p&gt;内存其实没什么特别要求，不过由于 Ryzen 的设计，频率越高越好，但按照这一代的设计，最佳频率是 3600 左右，再高反而会下降，我是买不起那么奢侈的内存，甚至 3200 的都买不起，但这款 3000 的也不错，据说颗粒是镁光创下超频记录的那一批，所以就买了四条。我也不需要 RGB，这款的马甲还挺好看的。当然 3000 是 XMP 频率，需要在 BIOS 里打开 XMP，不然默认只有 2400。最近抄了个 3600 16-19-19-36 的作业，结果四条内存轻轻松松就上去了，2K 下面 PUBG 大概提升了 20 FPS，还是挺爽的。&lt;/p&gt;
&lt;p&gt;硬盘不多说了，买 MX500 还是看中一个稳，我还是不放心买同价位国产白片……而且作为一个 2016 年就在笔记本上使用 NVMe SSD 的人，表示并没感觉出 NVME 和 SATA 有什么使用差别……我也不渲染视频，写写代码打打游戏都不卡。但是后来打脸了，公司发了新年福利于是还是上了个 NVMe 硬盘。顺便还配了个无线网卡用来接蓝牙和 WiFi，似乎 Intel AX200 是对 Linux 支持比较好的，就随便买了个 PCI-E 的插上了（御三家集齐了！）（ATX 的好处终于用上了，多出来的 PCI-E 随便插）。&lt;/p&gt;
&lt;p&gt;电源有点买亏了，买完了发现长城同系列 550W 的电源当时也是 329，都怪京东迷一样的定价策略，好在我这一套功耗并不是很高，当然最后趁着福利 + 打折还是换成了海韵一元一瓦的金牌全模组，带我这套绰绰有余。开始我听说原装散热器也能压住 3600X，所以就没打算换，但后来发现刀法还是精准啊，3600X 带的散热器竟然不是铜芯的，再加上 Ryzen 三代的电压控制比较激进，待机温度有时候超过 50，打游戏时候机箱上方有点烤腿，所以还是换了个塔式散热器，风道科学了不少，温度控制也更好了。而且 AMD 原装风扇转速太高，3000rpm 的时候机箱都在震，换了之后安静了很多。顺便安原装散热器时候拆下来的螺丝卡扣不要扔，万一换塔式散热器，好多都是需要装在这个卡扣上的。&lt;/p&gt;
&lt;p&gt;说到机箱和风扇我就一肚子气！本着对京东自营品质和速度的信赖，我全套都是在京东买的，结果拿到手全部安装上之后发现机箱开机跳线是短路的，插上电源就开机，开一会因为短路主板以为你在长按电源又关了！开始我还以为是主板坏了，结果发现螺丝刀手动碰一下开机跳线开关是可以正常开机的！于是又费了九牛二虎之力拆下来退货，主板散热器显卡都在盒子里椅子上放了两天，还好新机箱没问题，但是我买风扇的时候又给我发了个断轴的！东哥呀东哥，我拿你当兄弟，你拿我当代价？你是盯上我了？虽然我平时说你两句坏话但是对京东的服务还是好评的，但是经过这次之后我还是得重新考虑考虑了……顺便据说启航者 S5 这个机箱前面板音频口有的是 HD Audio 有的是老版 AC97，涉嫌虚假宣传，如果你遇到 AC97 的大概可以换货，麻烦一点，不过反正便宜货就这样子，我的抽奖抽到 HD Audio 了。但是这个机箱设计的很抠门，比如主板装上了就没法在上面走 CPU 电源线了，有两个走线口直接被 ATX 主板盖住，所以主板和显卡的电源线只能从一个口里挤出去，然后固态硬盘就在这个口下面所以也很难接线……而且机箱侧板是个黑色半透明的亚克力（那就别宣传透明啊！），金属外壳感觉也不是很厚实。所以最后还是换了先马的鲁班 1，各种设计都宽松了许多，装起来也很好看。&lt;/p&gt;
&lt;p&gt;其他的外设我自己都有，显示器 &lt;del&gt;就是之前买的优派 XG2402，1080p@144Hz 并且自带扬声器&lt;/del&gt; 换成了 DELL S2721DGF，27 寸的 2K@165Hz 屏幕，除了通病漏光以外都还不错，音箱外接了一个 JBL 的蜗牛一代（因为我觉得二代没有一代好看），鼠标就卓威 EC1-B CSGO 特别版（这个版本已经停产了，而且有偶尔指天/指地的 bug，建议买新的 EC1/2 或者 DIVINA 版本），键盘则是前段时间买的 ikbc C87 红轴，便宜还好用。&lt;/p&gt;
&lt;p&gt;顺便由于我手残以及力气小和室友跃跃欲试，很多东西都是他装的，非常感谢。话说回来装这东西还真是个力气活，毕竟接口都有防呆设计仔细看看不会装错，但是真的很紧很难拔……非常担心把主板搞坏了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/1.jpg&quot; alt=&quot;装好的完全体照片&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：避免你们说我灵魂走线，重新整理了一下，线太硬了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/2.jpg&quot; alt=&quot;重新走线正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/3.jpg&quot; alt=&quot;重新走线背面&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：内存插满。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/4.jpg&quot; alt=&quot;内存插满&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：NVMe + 蓝牙无线网卡的完全体。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/5.jpg&quot; alt=&quot;完全体&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个机箱 CPU 线走上面是要把主板拿下来才能穿过去的，而且右边两个有硅胶垫的孔 ATX 完全不能用，只能用一个孔，而且不能把线固定在机箱中间，很难盖上。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;再更新：新机箱比原来的好看多了也宽敞多了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/6.jpg&quot; alt=&quot;正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/7.jpg&quot; alt=&quot;背面&quot;&gt;&lt;/p&gt;
&lt;p&gt;公司的蜥蜴（明明是变色龙！）玩偶太高了，显卡下面放不开，挂着我又不放心，盖盖子之前还是拿出来了。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新：换上了公版 2070 SUPER 和利民 AK120。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/9.jpg&quot; alt=&quot;显卡&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/10.jpg&quot; alt=&quot;全景&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020 年 10 月 12 日）：冬天到了，还是换了几个支持 ARGB 的风扇，我个人不喜欢蓝光紫光夜店土嗨风，所以就弄了点温暖的颜色假装是个电暖气。前面是利民 TL-C12R-S，后面是利民 TL-C12S，虽然是三联包，但是似乎螺丝有问题，有一个风扇螺纹被拧花了，而且后面的风扇竟然少一个角上的橡胶减震垫，于是我就没装拧花的那个，并且把它的减震垫安装到后面了。反正考虑到我最下面是机械硬盘，装上这个风扇风道也不畅通，而且那里并没有什么需要散热的设备，电源风道是独立的。每把风扇两根线，ARGB 线要串联，PWM 线要一分三，而且有前有后，风扇线还有编织保护套，还要防止线材打到风扇扇叶。理线花了好久，最后 &lt;del&gt;把他们用扎带固定到下面和前面空的风扇挂架上&lt;/del&gt; 还是走背线了，刚好够长。而且我还有三个 SATA 硬盘打算换一下 SATA 线……我真的想不出来那些水冷排且上下左右全都是 ARGB 风扇的人怎么理线的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/11.jpg&quot; alt=&quot;正面看灯光&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/12.jpg&quot; alt=&quot;侧面看灯光&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/13.jpg&quot; alt=&quot;风扇线不在下面啦&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/14.jpg&quot; alt=&quot;最终的背线效果&quot;&gt;&lt;/p&gt;
&lt;p&gt;我不会告诉你其实我是想调出我 TB 至宝的颜色：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/15.jpg&quot; alt=&quot;TB 至宝&quot;&gt;&lt;/p&gt;
&lt;p&gt;一开始我以为需要用 OpenRGB 这个项目才能在 Linux 下控制颜色，但是这种 ARGB 风扇好像有存储机制，会自动记住上次的设置。于是就在 Windows 下面安装了一个有一大堆乱七八糟组件和功能的 MSI Dragon Center，其实我只需要调成长亮，然后重启进 Linux 颜色就一直是我设置的，然后我想关掉 Dragon Center 的自启动因为反正也用不到，但是微星的软件自己拉跨，重启进 Linux 灯光不变，重启进 Windows 又变呼吸彩虹灯光了。最后发现 Dragon Center 里面有一个类似“覆盖第三方RGB软件”的选项……好像他把他自己上次存储的结果也当第三方软件了，关掉就好了。原理我猜因为 Dragon Center 只是个 Client，真正控制颜色的是他某个 SDK 里面的 Daemon，这个选项的意思其实就是 Daemon 每次启动都按照 Dragon Center 设置的颜色重新设置风扇就实现覆盖功能了……但是 Dragon Center 的启动被我关了所以就默认了，不管了，统统关掉就 OK。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020 年 11 月 16 日）：有了打人国度的眼睛感觉瞬间高贵了起来（大误）。&lt;/p&gt;
&lt;p&gt;老黄卡只有绿色一种颜色，于是只能整个机箱调个老黄绿来配合。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/16.jpg&quot; alt=&quot;老黄绿了&quot;&gt;&lt;/p&gt;
&lt;p&gt;但是我自己平时还是喜欢红色的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/17.jpg&quot; alt=&quot;平时灯光&quot;&gt;&lt;/p&gt;
&lt;p&gt;我发现主板的装饰灯正好在公版 SUPER 卡上产生倒影，很有意思。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/18.jpg&quot; alt=&quot;倒影&quot;&gt;&lt;/p&gt;
&lt;p&gt;这个主板可以完美使用 OpenRGB，在 AUR 里安装之后把 &lt;code&gt;/usr/lib/udev/rules.d/60-openrgb.rules&lt;/code&gt; 复制到 &lt;code&gt;/etc/udev/rules.d&lt;/code&gt; 重启即可支持，不过对于 Addressable Header 上的设备也就是风扇或者灯条需要手动 resize zone 也就是填写灯珠个数，我用的利民 TL-C12S 系列经过尝试是 8 个灯珠。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;更新（2020 年 12 月 1 日）：我之前有考虑过换个机箱，倒不是先马鲁班不符合我的需求了，而是一些细节问题，比如我这个玻璃侧板不那么平，有一个角翘起来一点。然后我的前面板角落里虽然我十分注意还是被我磕了一下。以及当初从宿舍搬出来的时候没有把机箱包装拿出来，以后搬家可能不方便……我一开始本来打算再买一个同款然后把侧板和前面板换了得了，然后那天发现前面 USB 2.0 接口接声卡会破音……于是打算换一个别的机箱。&lt;/p&gt;
&lt;p&gt;我个人其实比较喜欢白色的机箱，于是初步考察了一下，我很喜欢NZXT H1，但我又不可能装 ITX，然后 NZXT H710 看起来不错，我觉得很漂亮，而且我在 NGA 上看到过有人给它纯白色的前面板贴了个黑色的两仪式剪影贴纸很帅气，但是太大太贵了。为什么没选择 H510 呢，因为我有几个硬性需求，我日常使用总结出来的，是一般机箱评测和用户不会注意到的，比如最好不要显卡竖装（我个人肯定是不会竖装的），PCIE的螺丝锁孔也不要做成从机箱尾部凸出来的，其实这里的实际意思是机箱不要有太大的空洞，很多机箱的显卡竖装PCIE螺丝孔上面就那么开着口，凸出来的横着的PCIE螺丝孔虽然有一个覆盖物，但它总是不那么好用，于是这样排除掉了 NZXT H510， NZXT H510i 和 NZXT H710i。&lt;/p&gt;
&lt;p&gt;然后我也不想要钢化玻璃打孔固定的，这个大部分人应该也都不想要。我个人而言还不想要附带一个只有某些软件才能控制的控制器的机箱（点名 NZXT CAM），虽然 NZXT 的水冷确实非常漂亮，但我不放心把电脑这些基础的硬件交给一个需要联网还经常不一定能不能连得上而且只有进了 Windows 才能启动的废物控制软件——我是 Linux 用户。同理我也讨厌雷蛇和罗技难用的鼠标驱动程序。明明我可以用 BIOS 控制风扇/水泵转速，用主板的 ARGB 插针控制风扇，为什么非要用那么难用的软件？所以肯定只考虑 H710 不考虑 H710i。&lt;/p&gt;
&lt;p&gt;如果光是这些可能我就下单 H710 了，虽然贵一点，但是能满足需求也就不在乎了。可是我翻了翻各种帖子都提到了这个机箱的一个缺点：它的硬盘架需要用螺丝刀拧螺丝才能拆除。虽然现在两百块钱的机箱都能免工具调整硬盘仓了但我觉得理完线也没什么人总动机械硬盘所以这不是个问题，但是更严重的是许多人都说固定硬盘仓的螺丝非常难拧，甚至螺丝都花了也拧不下来。作为之前被笔记本内部拧花了的螺丝支配的恐惧的人，我可不要买个这样的样子货，于是只好放弃 NZXT。可能它的设计师平时是不用机械硬盘没有软件更新服务器连不上的问题也不在乎机箱开一大堆没有保护网的口的人吧！&lt;/p&gt;
&lt;p&gt;然后我又开始研究买什么，看了一下联力的鬼斧似乎很不错，虽然造型上比起 NZXT 要难看很多，但是和其它的机箱比起来也算是鹤立鸡群了。而且相比于 NZXT 只是好看来说，它在设计上就考虑到了更多的功能性的细节。比如有单独的重启键（可怜的硬盘灯已经被时代抛弃了）和 LED 控制键而且 LED 控制器可以设置为转发主板的 ARGB 信号（看看人家！），还有磁吸的合页式的玻璃侧板方便随时打开（对我这种强迫症太友好了，拧螺丝搬侧板好累），而且它的电源仓设置了单独的合页门！你可以从前面打开，然后硬盘仓设计成了 NAS 那种可以从前面拿出来的样式（甚至官方还有热插拔配件，彻底变身 NAS）（看看人家！），对折腾型用户不要太友好。但我最后还是没选它，因为我发现这个机箱第一个 PCIE 挡板和它上面的边框之间的缝隙太太太太太大了——你们厂家在这里多加两毫米宽度会赔本吗？而且后来我又想了想，合页式多半不能完全贴合（要给合页留出空间，所以还是算了）。&lt;/p&gt;
&lt;p&gt;然后我看到了海盗船新出的 4000D，纯白色的前面板 + 非外凸的 PCIE 螺丝孔 + 独立的重启键 + 滑动抽拉的硬盘仓 + 有卡口的侧板，虽然它只有一个前置 USB 3.0 和一个 Type-C，不过也不是不能接受，而且有独立的重启键（硬盘灯：四个人的接头我却不能拥有姓名）。虽然它也支持显卡竖装，但它显卡竖装的上面有一个封得比较严实的挡板，它的 PCIE 槽相对也没有太大缝隙（相对）。颜值虽然没有 NZXT H710 好看，但在简洁上也是吊打鬼斧了，于是决定入手这个。&lt;/p&gt;
&lt;p&gt;到手了也发现这个箱子还不算完美，主要的问题在于以下几个：电源仓上边的挡板强度不够，虽然没什么人会拿这个地方承重，但是比我之前的先马鲁班软得多也太差劲了吧！好在机箱其它承重的组件都过得去。然后就是 PCIE 的螺丝孔和显卡的孔有错位！需要很大力气按着才能勉强拧上螺丝，我用的可是公版显卡，你不能说公版卡孔位不标准吧！最后最后，这个机箱底板并没有多延伸出一块盖住侧板的底部！虽然侧板不需要这个位置辅助固定（它有很多卡口固定住），但是明明你顶板是有延伸的，为什么底板要在这里留一条缝隙？？？总而言之就是搬机箱时候要注意手不要抠到侧板和机箱这里的小缝隙（挺窄的，手多往中间伸一点就好了），但是还是会让人担心抠这里把侧板抠变形了。不过总之看下去也没有更合适的选择了，所以就将就吧。送的两个风扇是 3 pin 的，不能 PWM 调速，真是抠门啊海盗船。&lt;/p&gt;
&lt;p&gt;顺便还有个对我不是问题但对大部分人可能是问题的地方，这个机器的前面板里面有一大块金属防尘网，但是根据一些国外的评测，假如你在前面板装上风扇，可能会因为风扇吸气导致这个防尘网向里面贴而蹭到风扇扇叶。但是我装了三个反向进风的风扇在前边，风扇框架在防尘网一侧所以并不担心这个问题。我也推荐所有前面板不是透明玻璃的人在前面使用反向风扇，毕竟正常来说通过侧板看到机箱内部反向风扇的灯光才是最合适的（风扇框架不会出现在机箱内部）。并且说实话，前面板通风比美观更重要，真的没必要买玻璃前面板。&lt;/p&gt;
&lt;p&gt;于是装好了以后正面和背面就是这样的，不要和我说机箱不是留了理线槽了吗为什么不把主板电源线理进去，海韵的主板电源线又粗又硬，连用这块机箱的盖线板盖住都很勉强了，扭来扭去塞到那个理线槽里根本不可能，我也不想让它接头的部分受太大的力。这块主板 Type-C 的接头在内存附近，虽然这是主流位置，但对于直插的 Type-C 线缆来说弯线同样也很困难，别的理线倒没遇到什么大问题。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/19.jpg&quot; alt=&quot;正面&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/20.jpg&quot; alt=&quot;背面&quot;&gt;&lt;/p&gt;
&lt;p&gt;白色机箱里面反光要亮一些，但是有灰尘也更明显了……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/21.jpg&quot; alt=&quot;亮起来&quot;&gt;&lt;/p&gt;
&lt;p&gt;前面侧板的灯光效果很好看，没买 Airflow 版一个是因为它挖孔太多太乱，另一个原因是以后我也打算贴上贴纸。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/22.jpg&quot; alt=&quot;前面&quot;&gt;&lt;/p&gt;
&lt;p&gt;今天看到 NGA 上有人是风扇白光配红色 ROG LOGO，我也试了一下蛮好看的，就是感觉屋子里又冷了 10 度……&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/23.jpg&quot; alt=&quot;白色&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/posts/My-Desktop-PC/24.jpg&quot; alt=&quot;全景&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;接下来是喜闻乐见的 debug 时间，首先是 Linux 下的，相对比较好调：&lt;/p&gt;
&lt;p&gt;三代 Ryzen 有一个 &lt;a href=&quot;https://www.infoq.cn/article/BRebwaBfJ9eP28X9wQQc&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;每次都返回 0xFFFFFFFF 作为随机数的 BUG&lt;/a&gt;，在我这主要影响 wireguard，巧的是购买前几天我刚读过这篇文章，AMD 已经发了新的固件修正错误，建议更新到主板厂家提供的最新 BIOS 版本一般即可解决，如果主板厂家最新的 BIOS 还没更新固件建议联系售后催一下。&lt;/p&gt;
&lt;p&gt;在我这不知道为什么 GDM 有时候没法自动启动，但是手动切 tty start 又可以显示，查了一下 &lt;a href=&quot;https://wiki.archlinux.org/index.php/GDM#GDM_freezes_with_systemd&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;ArchWiki 的 GDM 页面&lt;/a&gt; 发现有解决方案，但是并没有原因，搜索了一下也没发现原因是什么。&lt;/p&gt;
&lt;p&gt;我还发现有时候刚开机没多久很快就关机会卡在什么 systemd-udevd 进程没结束，最后 event loop failed + timed out，大概要卡好几分钟才关机，但如果你用一会再关机就没问题。检查好几次关机日志没发现问题，后来群友火眼金睛对比了完整日志发现有个叫 &lt;code&gt;ucsi_ccg&lt;/code&gt; 的模块开机加载了两分钟，猜测是这个的问题，搜索一下发现是 &lt;a href=&quot;https://github.com/torvalds/linux/blob/da94001239cceb93c132a31928d6ddc4214862d5/drivers/usb/typec/ucsi/ucsi_ccg.c&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;5.3 内核里 NVIDIA 添加的相关代码&lt;/a&gt;，用来控制 NVIDIA 显卡上的 Type-C 接口的，可是我这块显卡根本就没提供 Type-C 接口！（以及很多笔记本内置的有输出的 N 卡也有这个问题。）临时在 &lt;code&gt;/etc/modprobe.d/&lt;/code&gt; 里加了个 &lt;code&gt;blacklist ucsi_ccg&lt;/code&gt; 的 conf 屏蔽了这个，好像没什么不良影响……&lt;/p&gt;
&lt;p&gt;然后是奇怪的 Windows 的问题，我一开始装的 LTSC，不知道怎么回事输入法没了……折腾无果只能重装。以及现在除了不要联网装 Windows 之外（否则会强制你登录微软账户然后用你名字拼音前五位做用户名），还得不要联网装 NVIDIA 驱动，否则 Win10 自动更新驱动会给你安装 DCH 版的，虽然没什么影响（只是在 NVIDIA 官网升级驱动时候不能选标准选 DCH），但是就是让人很不爽。声卡驱动要装主板厂商的，Win10 自带的只能输出，不能接麦克风录音，然后如果麦克风声音很小就打开 Realtek 的声音控制程序，在右上角齿轮里取消掉什么把所有输入结合到一起的设定（什么乱七八糟的玩意！）。还有要关掉快速启动，不然直接开机会卡在黑屏一个鼠标光标……反正就很烦人。&lt;/p&gt;
&lt;p&gt;更新：还有一个奇怪的问题是 Win10 关机重启也要卡很久，上网搜了一下全是一些忽悠小白的办法，经过我不懈搜索发现了一个熟悉的名字 &lt;code&gt;UCSI&lt;/code&gt;！微软承认存在 &lt;code&gt;UCSI&lt;/code&gt; 问题，既然又是这个 &lt;code&gt;UCSI&lt;/code&gt;，多半还是 NVIDIA Type-C 的问题！反正我没这个接口，果断重新安装 N 卡驱动，选择清洁安装（删除旧驱动）并不勾选 Type-C Driver，问题解决……&lt;/p&gt;
&lt;p&gt;最后既然设备到位了，大概就每周一三四五晚上八点半在 &lt;a href=&quot;https://live.bilibili.com/4312992&quot; target=&quot;_blank&quot; rel=&quot;external nofollow noreferrer noopener&quot;&gt;Bilibili 4312991 直播间&lt;/a&gt; 播一个半小时游戏，反正我玩什么播什么，大概就 CSGO Dota2 PUBG 什么的吧，尼尔也有可能，反正不是恶心反胃的就可以。周末随缘直播，如果没什么事情白天就播一会，周二可能晚一点开播因为有课。&lt;/p&gt;

    </content>
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
    
    <category term="计算机" label="计算机" scheme="https://sh.alynx.one/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/" />
    
  </entry>
  
  
</feed>
