{"data":[{"title":"about","url":"/about/","content":"关于我\n此部分上次更新时间 2019-01-24 16:13:00。\n\n对于一些人，在对着这个页面按 Control + c 之前，麻烦先看一下第 17 条。\n\n\nAlynx 可以接受的称呼包括 Alynx Zhou，Alynx，AZ。\n\nAlynx 这个词的来历、读音是 Alynx is just a lynx。\n\nAlynx 的本命是 科学超电磁炮 中的 “超电磁炮” 御坂美琴，Misaka Mikoto 和 Fate/stay night 里面的 “Saber” 阿尔托莉雅·潘德拉贡。\n\nAlynx 是 S / M 双属性，虽然可能表现的更像 M 但是其实 S 的属性更多，除非你是让我心甘情愿的人。对 LGBTQIA 没有歧视但是 Alynx 只喜欢女孩子，想要认识可爱的小姐姐，想脱单。\n\nAlynx 像猫一样懒，目前在 北京交通大学 前北下关军事基地，计算机与信息技术学院 反恐精英专业在读。北京交通大学自由与开源软件镜像站 前任维护者。SUSE 北京分部的实习生。Alynx 还是 Arch Linux CN 社区里稀有的 GNOME 用户之一，希望大家爱护稀有动物。\n\nAlynx 喜欢 Arch Linux，Atom，C，Coffee Script，Vala，GNOME，你也许喜欢与这些对立的软件，但是 每个人选择自己喜欢的东西一定有她的理由，所以 请不要强行向 Alynx 安利你喜欢的东西。\n\nAlynx 喜欢音乐，目前最喜欢的乐器是半音阶口琴，有不到 4 年的琴龄，北京交通大学口琴联盟的创始人兼第一任社长，（此处应该有努力练琴的 Flag）。学过 4 年二胡并通过了业余水平十级（虽然现在几乎忘光了），选了扬琴选修课所以大概了解一点点，其他了解一点的乐器还有长号，选到课的小提琴。\n\nAlynx 坚持用 Steam 并拒绝 Origin/Epic/Battle.net 等不打算支持 Linux 的平台（既然你忽略 Alynx 的需求，Alynx 也忽略你），Counter-Strike: Global Offensive 是目前为止唯一一个玩了超过 600 小时的游戏，唯一能够玩进去的 RPG 大概是 NieR: Automata*，感谢室友特地带 PS4 到学校还和高中同学借了光盘让 Alynx 能和另一个室友一起以 60FPS 和高清画质通关主线（这话说的有点乱套）。另外表示室友四个人一起玩 *Overcooked! 非常开心，所以预购了 Overcooked!2。\n\nAlynx 的 Steam ID 是 Alynx Zhou，如果你想和 Alynx 一起玩游戏的话。不定期在线，并且 如果你是那种很吵很暴躁张口就喷队友的人请不要来打扰 Alynx。\n\nAlynx 喜欢 Minecraft（Java版），不接受 Win10 版，PE/Java 版正版玩家（非网易版）。\n\nAlynx 已经玩不动崩坏3rd了，即使有小姐姐 + 数一数二的渲染技术。Alynx 也肝不动 Fate/Grand Order（非的肝不过欧的）（明明是碧蓝航线！）了，还没抽到蓝呆是 Alynx 没有卸载游戏的一个重要理由，她已经快绝望了已经抽到蓝呆了（已经满破了）（我永远喜欢FGO）（快说声多谢叶哥哥）。\n\nAlynx 想研究有关游戏渲染的东西，略微懂一点 OpenGL ES 和相关的矩阵运算。\n\nAlynx 不仅想学日语，还抓住机会选到了日语二外的任选课。\n\nAlynx 认为 Kalafina 和 梶浦由纪 才是 真正的音乐，Hikaru 是 Alynx 安装 Twitter App 的唯一理由。Alynx 也喜欢陈奕迅和林俊杰以及张杰这种唱功或者音乐水平确实到位的歌手，网易云里《富士山下（live）》，《倾城》，《喜帖街》，《K歌之王》，《你给我听好》，《修炼爱情》。\n\nAlynx 经常懒癌发作什么也不想做，Alynx 是个不肥（182 cm / 72 KG）的宅。Alynx 喜欢猫，不太喜欢狗。\n\nAlynx 喜欢写一些乱七八糟的东西，即使这些没有人喜欢看，但无论如何 这是我们在面对世界这一庞然大物时能留下的一点声音，无论是惊慌失措还是泰然面对。\n\nAlynx 讨厌复制品。加上这一条是因为 Alynx 最近看到了好多部分复制这个页面的网站，Alynx 愤怒地希望这些人认清楚什么是拿来分享的什么是拿来看的。如果这些人不能理解，Alynx 表示你们 尽管使用这个页面的样式，因为代码就在 GitHub 上并使用 Apache-2.0 公开授权，Alynx 非常高兴你们喜欢这个主题，毕竟她用了两周来实现这些样式。但是对于使用 CC BY-NC-ND 4.0 授权的网站内容，希望你们不要拿来充实自己的页面，这种行为有时候会让 Alynx 觉得自己写的很中二而删除对应的文章。你有一千种介绍自己的方式，但没必要把 Alynx 的面具拿过来抠几个窟窿贴在自己脸上，因为 Alynx 会觉得痛。你也可以给自己的网站起个独特的名字，而不是看到 StackHarbor 就觉得这个词天下第一，拿来自己用可不是夸奖 Alynx 审美的好办法。\n\nAlynx 喜欢的电影和动漫有《Fate/Stay Night》系列，《Fate/Zero》，《你的名字。》，《爱乐之城》，《海上钢琴师》以及《新世纪福音战士》（包括 TV 和剧场版），《黑执事》。\n\nAlynx 最喜欢 C，曾经在 Bilibili 直播了一段时间的 C 语言教学。如果是动态类型那么一定是 Coffee Script，如果是面向对象又要静态类型，Alynx 选择 Vala。\n\nAlynx 喜欢可口可乐。\n\nAlynx 觉得能不能写出优美的句子完全看运气，即使有时候会因为自己写不出来而感到没用。\n\nAlynx 觉得谈了也没用所以 莫谈国事。\n\nAlynx 的梦想是环游世界（如果不去非洲南美洲也算的话？），一个人待在陌生的，没有人知道的地方仰望天空。\n\nAlynx 不喜欢说话，除非是对喜欢的人 / 说喜欢的东西，当然以前说的都是编程或者音乐，身边的人总是听不懂。\n\nAlynx 觉得 比起依赖别人，我更喜欢被人依赖，如果我喜欢的人能让我默默付出我就很满足了。所以不要和 Alynx 客套。\n\nAlynx 强调一下 上一条很重要。\n\nAlynx 讨厌需要鼠标不停点点点的程序，比如 MS Office，Visual Studio，手还要留着玩 FPS 游戏呢。\n\nAlynx 能有一个所爱的人这件事情和 root 密码一样重要，即使不知道她是否爱我。\n\nAlynx 讨厌刷题，讨厌为了刷题写出丑陋的代码，千金难买喵乐意。\n\nAlynx 更喜欢 Telegram 虽然不得不用 QQ 和微信。偶尔会在 Bilibili 直播 吹口琴 / 打游戏 / 写代码。\n\nAlynx 宁可不看不能在 Bilibili 上看而只能在其他国内视频网站上看的视频。Alynx 也不能接受一个乱七八糟的播放器，Alynx 现在用网易云音乐下音乐然后用 PowerAMP/Rhythmbox/MPV 听。\n\nAlynx 希望听到别人的声音，即使我常常讨厌交流如果有什么问题，欢迎发邮件 / Telegram 甚至是去 这里 发issue。\n\nAlynx 说你好，世界。\n\n\nBuild with Atom.\nA hackable text editor for the 21st Century.\n\n\n    \n\n-->\n"},{"title":"blogroll","url":"/blogroll/","content":"本来是打算把友情链接放到侧边栏里面的，但后来看好多人的网站里都是给链接单独开了个页面写点介绍。我觉得这样挺不错的，所以自己也搞一个。\n想加友链可以评论留言，或者发邮件给我。\n老相识\n\n\n\n头像\n链接\n自我介绍\n我的介绍\n\n\n\n\nLGiki\n“喵喵喵”\n节奏王 Dogiki！每天咕咕咕，从不写博客！\n\n\n\nHackGhost\n\n在五道口睡觉的某头。博客从某一天起就不更新了。\n\n\n\nArt_Chen\n\n某著名 ROM 开发者，上大学了要努力写代码啊。\n\n\n大学认识的\n\n\n\n头像\n链接\n自我介绍\n我的介绍\n\n\n\n\nMeow\n“一只有吱的喵~”\n刚入学的时候认识的学长，似乎也是一只猫，现在大概在美国呼吸自由的空气（大雾）。\n\n\n\nsqyon\n“试图让机器帮我学习的假 ACMer”\n优秀的学弟，一定是优秀的学弟。\n\n\n\n滑稽仓库\n\n董老师（咕老师）的奇怪网站。希望下次打 CSGO 前董老师能找到带麦克风的耳机。\n\n\nArch Linux CN 社区或者 Gentoo Linux CN 社区\n\n\n\n头像\n链接\n自我介绍\n我的介绍\n\n\n\n\n约伊兹的萌狼乡手札\n「虽然咱长久以来被尊为神，且被束缚在这块土地上，但咱根本不是什么伟大的神。咱就是咱。咱是赫萝。」\n我大概能理解这是个什么物种吧……反正我是猫。\n\n\n\nFarseerfc 的小窝\n\n爱呼吸 fc 老师！似乎是日本某大学的教授，人生赢家，实名羡慕。\n\n\n\njm33_ng\n\n似乎是个高产的大佬，博客里都是和安全相关的（大概）。\n\n\n\nNick&#39;s Nichijou\n\n某世界一流大学年轻巨佬（当面确认，本人保证此条可信度）。\n\n\n\n惠狐之书\n&quot;A fox called Megumi&quot;\n又是一只狐狸，私以为 Arch 社区可改名动物园。\n\n\n\n初等記憶體\n「 一個你知道的地方，和一個沒有酒的故事 ｜ 言文 」\n听起来好像萌妹啊！\n\n\n\nOriginCode 札記\n「無人訪問之無趣博客 * 1」\n好像现在是初中生来着……\n\n\n其他地方认识的\n\n\n\n头像\n链接\n自我介绍\n我的介绍\n\n\n\n\n鸡腿工坊\n\n新鲜 可爱的鸡腿！\n\n\n\nYorushika Shi\n\n评论框里认识的朋友，看来保留评论框还是有必要的。\n\n\n\nStack Pub\n\n评论框认识的朋友。\n\n\n"},{"title":"Undefined Shell Works!","url":"/Undefined-Shell-Works/","content":"Undefined Shell Works!\n1\n2\n3\n4\n5\n6\n7\n「I am the shell of my system.」\n「Command is my body, and argument is my blood.」\n「I have created over a thousand lines of logs.」\n「Unaware of less, nor aware of more.」\n「Withstood error to create many scripts, waiting for prompt's arrival.」\n「I have no mouse. This is the only bug.」\n「My whole life was `Undefined Shell Works`!」\nUnlimited Code Works\nFrom CS Slayer/Unlimited Code Works\n1\n2\n3\n4\n5\n6\n7\n「I am the bone of my program.」\n「Object is my body, and class is my blood.」\n「I have created over a thousand lines code.」\n「Unknown to delete, nor known to new.」\n「Have withstood pain to create many projects.」\n「Yet, those hands will never hold anything.」\n「So as I pray, Unlimited Code Works!」\n"},{"title":"蜗牛星际安装 Arch Linux 作为 NAS","url":"/posts/SnailSpace-as-NAS/","content":"需求\n以前我一直使用树莓派 + 移动硬盘做 Samba 服务器，好处是完全静音，功耗很低，但是树莓派 2 的网络性能差强人意，并且 USB 2.0 的速度也赶不上移动硬盘的速度，看电影什么的只是能看，要花好长时间缓冲，并且我一直开着，对树莓派的电源也不是很放心。特别是我还拆下来一块笔记本上的 1TB 机械硬盘，完全没法装在树莓派上。\n\n\n有点想买一台 NAS，但是看看群晖的价格实在接受不能，然后又看到说群晖把系统放在用户的磁盘里加速读写一类的，其实这些对我来说不太重要，但群晖是个定制化程度很高的 Linux，虽然用起来有很多便利的功能，比如官方的内网穿透（服务器似乎在台湾，速度不快），比较成熟的 btrfs 使用之类的，但比起这些我更想要一台全功能的 Linux 服务器，这样不仅可以作为存储，还可以 SSH 连接上去做一些简单工作。作为一个比较熟练的 Linux 用户，我不需要什么 Webui 或者 App 来访问文件，Solid Explorer 和 VLC 组合起来访问 Samba 好用得很。\n机缘巧合我看到隔壁的同学弄了台 D 款的蜗牛星际矿渣，研究一下之后觉得可以上车，正好 Arch CN 群里 @NickCao 打算出掉买了回来没时间玩的蜗牛 A 款，于是坐地铁到五道口一起喝了杯咖啡然后当面交易了一下。\n介绍\n蜗牛星际的矿渣是怎么来的呢？简单说就是忽悠别人说这个机器可以挖矿，打着区块链旗号骗人买机器，当然这个机器其实并不需要挖矿，所谓的挖矿就是简单的 App，让你以为自己挖出矿了（毕竟宣传说不用插电也能挖），为了降低成本机器全部都是用现成的山寨货，所以机箱造型是 NAS，而且还带硬盘背板，就是因为这个很成熟。成本不到一千块的机器五千块一台卖给受骗者，受骗者为了挖矿都是十几台几十台的买，然后放小道消息说要涨价到八千块榨干受骗者钱包，最后国际惯例圈钱跑路，受骗者血本无归。\n做人还是得懂点计算机。\n\n这个机器有好多型号，细节差距也有很多，网上有现成的帖子分析，我就不分析了，反正我这一台是 A 款单网口绿主板，妥妥的千兆。而且似乎背板有 PCI 槽，不过主板又没有 PCI 接口就不管了。A 款还有个特点是硬盘架侧面可以放个 2.5 寸硬盘，正好装上我拆下来的笔记本硬盘。（硬盘和安装方式如下图。）安装时候需要两个小螺丝固定硬盘一侧，另外一侧是卡住的，不需要螺丝。\n\n\n硬件处理\n手头这一台运气比较好，是 zumax 的 150W 电源，虽然都说这个是所有各种电源里最好的，但是接口只是刚刚够，没有多余的，没办法给侧面硬盘供电。再说都是山寨货谁又比谁强到哪里。按照隔壁老司机的推荐淘宝买了益衡 250W 的 Flex 电源（也叫小 1u 电源）替换掉，花了 250 软妹币左右，感觉车速稳了很多，而且多出了许多接口。安装时候需要把原来电源上后面用来装到侧面的铁片拆掉，然后上下翻转才能装上蜗牛里面的支撑片，然后主板有一长一方两个供电口都插上，背板用的大 4pin 接口，不太够长，把卖家赠送的两条大 4pin 延长线都接上就可以了，然后取一个 SATA 供电线给侧面的硬盘。\n蜗牛自带一个 16G 的 mSATA 硬盘，速度比 U 盘还慢，而且据说用着用着就坏了，很多人都拿这个做引导盘放系统，因为四个硬盘槽连接的 SATA 口是扩展的，不支持引导，但是 实际上蜗牛主板上还有一个 SATA2 的口可以引导，正好连接我的笔记本硬盘，直接拧下四个螺丝把主板抽出来，然后拧掉 mSATA 杂牌硬盘，插上 SATA 线装回去即可。\n蜗牛自带的风扇声音很大，因此需要更换一个静音风扇，A 款用的是 8cm 的 3pin 风扇，不支持调速，BCD 都是 12cm 的。8cm 不太好买，开始我在京东找到两个超频三的风扇，一个 2200 转一个 1400 转，标定噪音都是 18dB，于是就买了 2200 转，没想到转速上来了噪音也更大，正好之前在淘宝买了另一个超频三皓月（下面上图），1500 转应该问题不大，装上发现声音小了，但是蜗牛背板有个铆钉，这个 LED 风扇尺寸稍微大一点，正好顶着铆钉。没办法还是换了京东 1400 转的那款，噪音合适，尺寸也合适，蜗牛本来发热也不严重。因此 建议大家购买 1500 转左右不带 LED 灯效正常尺寸的。\n更换时候记得把原来蜗牛风扇上用来防止线缆伸进风扇里的塑料防护片拧下来装到新风扇没有阻拦的一侧，这一侧朝里，安装之后蜗牛向外吹风。\n\n这个防护片不要拧太紧，以免把它拧裂了，这种是和机箱配套卖的，淘宝上有卖那种金属的防护网，但是都是厂家批发，不太好买。\n\n你问我怎么知道的？当然是大力出悲剧拧裂了然后没办法只能 502 直接粘风扇边上了。\n\n\n我还在京东购买了一块 2TB 的西数紫盘，没有买 NAS 专用盘是因为太贵了，而最便宜的只便宜了十几块，但是却是大缓存叠瓦式硬盘，性能非常差，这款紫盘则是标准的 64M 缓存垂直式硬盘，建议自行搜索叠瓦式硬盘了解原因。考虑了一下还是不做 RAID1 了，经济条件不允许，而且本来 RAID 是为了高可用不是为了备份，如果是硬件损坏估计两块盘一起炸了，不如冷备份。\n\n往硬盘架安装硬盘需要四个沉孔螺丝分别锁在两侧，当然我这种硬件渣渣其实是不知道啥是沉孔螺丝的，具体多大多粗我也不懂，我装 2.5 硬盘的螺丝是同学买大疆编程小车多出来的内六角，尺寸正好，至于 3.5 硬盘是隔壁老司机送给我的装机剩下的，反正车速很稳，如果自己买的话京东淘宝好像都有装机用的成套螺丝，建议顺手买一套，不要螺丝钉难倒程序员。\n软件处理\n软件部分就十分舒服自在了，接显示器网线键盘开机按 F7 进入 BIOS 设置 UEFI 模式从 U 盘启动，然后进入 Archiso 按照 安装指南 安装系统（据说他们最近在处理 base 组，建议随时跟进 wiki，我就不复制了），分区的时候我是在能引导的 2.5 寸硬盘上建立了 ESP，然后其他空间全部用作 LVM，1T 硬盘的剩余空间作为一个 pv，并且给 2T 的硬盘分了三个区做 pv（万一我哪天脑子抽了想缩个分区出来呢？），然后建立 vg，建立给根目录和家目录的 lv，然后创建 ext4 文件系统。这一段参照 wiki 对应页面就行了，命令十分简明直观，我第一次用就成功了。配置好的效果如图：\n\n/etc/mkinitcpio.conf 里需要给 HOOKS 添加 lvm2，然后运行 mkinitcpio -p linux，这样生成的 initramfs 才能支持 LVM。我还给 MODULES 添加了和 intel 显卡有关的部分（虽然可能用不到了），具体修改的位置如下：\n1\n2\nMODULES=(intel_agp i915)\nHOOKS=(base udev autodetect modconf block lvm2 filesystems keyboard fsck)\n至于 2T 的硬盘考虑了一下还是打算再加一块硬盘做 RAID1，不然连续跨设备 lvm 坏了一个就全坏了，由于 mdadm 需要两块设备都在才能建立，但我手头只有一块，于是在 fc 老师建议下决定上 btrfs（而且这货似乎支持多块不同容量硬盘的 RAID1，保证每个文件都在两块盘上有备份），于是建了 /data 和 /data/alynx 两个子卷，/data 就挂载到 /data，/data/alynx 挂载到我家目录下面。话说 btrfs 的子卷原来很像普通目录，但是又可以分别挂载，不需要用 mount --rbind。然后在 samba 下面添加一个 datas 配置，就像 homes 一样每个用户都有个目录（当然得手动创建）：\n1\n2\n3\n4\n5\n6\n[datas]\n   comment = Data Directories\n   browseable = yes\n   writable = yes\n   valid users = %S\n   path = /data/%S\n然后我在某东买了一块东芝 2T 64M 7200 转的机械硬盘，到手之后打算加入 btrfs 里面，建立 RAID1，btrfs 的好处就在于这个可以先弄一块之后渐进修改，而且看起来目前没什么大问题的样子（按我的理解并行读取的性能问题大概是用来并行加速的，但是实际上 RAID1 不并行读取也可以读出数据吧）。虽然我本来也可以把数据移出来然后建 mdadm，但是不排除以后再加盘做 RAID 10，似乎 mdadm 没法直接转换的样子？按照 fc 老师多年使用经验似乎 btrfs 也没那么不可靠。\n安装 bootloader 的时候我直接用了 systemd-boot，我在自己笔记本上也用的这个，功能够用了就没考虑安装 GRUB，编写 entry 时候内核参数里的 root 可以写 /dev/vg0/rootlv 也可以写 /dev/mapper/vg0-rootlv（这里中文 wiki 和英文 wiki 分别是这俩，亲测都可以），比如我的就是下面这样：\n1\n2\n3\n4\n5\ntitle    Arch Linux\nlinux    /vmlinuz-linux\ninitrd    /intel-ucode.img\ninitrd    /initramfs-linux.img\noptions    root=/dev/vg0/rootlv rw add_efi_memmap\n最近 systemd-boot 添加了什么校验设置，在蜗牛上会报错，直接 chroot 进去安装根本装不上，临时解决方案是退出 chroot，然后用 Archiso 里的 bootctl 安装到 /mnt/boot，虽然有点 dirty，但是能用？不过还是会报个错，但是启动需要的文件已经安装上了，不管它也能用，只不过每次重启还是会说校验失败，目测是个 bug。\n然后由于 NAS 的网络不会经常变化，所以联网的部分也直接用 systemd-networkd 管理了，没必要上 NetworkManager。直接创建 /etc/systemd/network/wired.network，写入如下内容：\n1\n2\n3\n4\n5\n[Match]\nName=en*\n\n[Network]\nDHCP=ipv4\n意思是对于所有以 en 开头的网卡使用 DHCPv4，然后 systemctl enable --now systemd-networkd systemd-resolved 就可以了。\n其它的配置基本都是正常操作参照 Arch Wiki，我打算以后插新硬盘直接加进 LVM 加给 /home，省得还得操心挂载到哪里 决定单独安排 btrfs 数据区了，参见上面。在外面访问我选择配置 WireGuard，参照我 这篇文章 就可以了，如果只是 SSH 远程控制一下效果还可以。\n效果\n笔记本插了有线之后可以测试千兆对拷，我的路由器还是大一时候买的 WNDR3800，虽然很旧，但四个有线全部都是千兆口（当时价格和配置差不多的极路由 3 只有一个内网千兆好像），samba 拷贝速度轻松达到 110M/s 的满速，甚至比蜗牛的 USB3.0 还快。蜗牛后面两个 USB3.0 只有下面的那个是真的，上面的也就 2.0 速度，下面的跑满了也就 80 到 90M/s，我的 U 盘是 CZ80，放笔记本上比这快多了，而且有时候上面那个也可以跑到 70M/s，具体原因不知道，如果是真的土豪建议直接换主板算了，非土豪完全可以插笔记本然后网络拷进蜗牛，比这奇葩接口还快。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"前端博客搜索引擎","url":"/posts/Frontend-Blog-Search/","content":"本来我的博客有一个前端搜索框，当输入文字时就在侧边栏展开搜索结果，虽然看起来很时髦，但也不能算是什么食用啊不实用的设计方式。而且一开始我觉得既然没有后端处理请求，也就没法单独打开一个专门搜索页面了。\n但是这个设计引发了 lilydjwg 的吐槽，有一个单独的搜索页面并且对每个搜索结果有专门的 URL 看起来还是个挺合理的需求。但第一我不知道怎么实现第二我一直觉得能用就行所以开始并没有改。不过 lilydjwg 给我发了 Python 文档的搜索实现，让我突然想明白其实按照标准的 HTML 和 JavaScript 是可以实现无后端的搜索引擎的，然后就动手实现了一个。\n\n\n首先既然要搜索那还是得有个索引或者数据库，比较简单的方案就是把所有文章的标题 URL 和内容丢到一个 json 文件里面，这个功能在 Hexo 里可以使用 hexo-generator-search 实现，我也给我的 Hikaru 添加了这个生成器。然后下面的事情基本就与生成器无关了。\n首先第一件事是实现搜索跳转页面，这一步只要简单的使用 HTML 表单就能实现，首先将我的搜索框改造为如下格式：\n1\n2\n3\n4\n5\n6\n&lt;form action=\"{{ getPath(\"search.html\") }}\" method=\"get\"&gt;\n  &lt;button type=\"submit\" class=\"search-submit\" aria-label=\"{{ __(\"search\") }}\"&gt;\n    &lt;i class=\"fas fa-search\"&gt;&lt;/i&gt;\n  &lt;/button&gt;\n  &lt;input type=\"search\" id=\"search-input\" class=\"search-input\" name=\"q\" results=\"0\" placeholder=\"{{ __(\"search\") }}\" aria-label=\"{{ __(\"search\") }}\"&gt;\n&lt;/form&gt;\n使用 button 而不是 input 的原因是我想用我的图标做搜索按钮，反正 &lt;input type=&quot;submit&quot;&gt; 只是个特化的 button。理论上来说不放按钮靠回车提交也是 OK，但是觉得这样又会被某些用户批评不友好了……\n搜索框就很简单，name=&quot;q&quot; 表示生成的 query string 里 keywords 的 key 是 q，然后按照表单写法会被提交到 search.html，理论上来说搜索应该发 GET 请求所以就是 method=&quot;get&quot;，当然 POST 就实现不了复制链接查看搜索结果了。\n这个表单就是标准的 HTML 表单，不需要用 JavaScript 处理。生成的 GET 请求的 URL 类似于 /search.html?q=xxx\n然后接下来是处理请求了，既然是发送到 search.html，对于静态后端肯定是要返回这个页面的，那就得先创建页面，然后对这个页面进行特殊处理，我选择给它 layout 设置成 search，然后就可以单独给它编写模板添加处理部分了。\nsearch.html 加载之后是可以通过 window.location.search 获取到 query string 的，然后我加载我修改过的 search.js（这里），用它处理搜索过程。同时在页面里添加了一个 container 用来放置检索结果。\nsearch.js 其实没什么黑科技，毕竟我们的难点就是在无后端情况下处理关键词和数据库，关键词已经用 window.location.search 拿到了，调用 API 里面 URLSearchParams 类就可以解析，然后只要通过 ajax 请求数据就行了，封装 ajax 的代码网上到处都是，实在不行用 jQuery 也成。\n然后剔除重复关键词主要是为了优化一下性能，接下来我的解决方案就是简单粗暴 indexOf()，不要跟我提什么算法什么优化，短平快实现效果，我是个实用主义者，目前这一步其实还没有成为瓶颈。\n然后对于原版文件我的改进主要是按匹配次数排序，文章出现关键词越多则排序越靠前，相对可以提高效率。\n接下来使用正则表达式给关键词加上 &lt;strong&gt;，这样显示起来比较显眼。最后把字符串拼起来显示就好了。\n如果有性能瓶颈的话，多半也会先出现在 ajax，不过目前我文章还没有多到加载不出来的情况，也许可以靠分块加载解决？\n最后我加了个简单的 SpinKit 动画，在查询结束之前先跑一下提升用户体验。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"Linux 用户的月饼食用手册","url":"/posts/Linux-Mooncake-Jokes/","content":"中秋节到了，Arch Linux CN 社区里富有生活情趣（？）的用户们聚在一起，开始讨论起如何食用月饼。\n\n\n\nGentoo 用户需要自己编译月饼，并且可以设置不同的 USE 编译不同口味。（farseerfc，outvi 和 AlynxZhou）\nDebian 用户习惯将月饼拆成月饼馅、月饼皮和月饼油分别打包食用。（AlynxZhou）\nArch Linux 用户喜欢购买 Debian 的月饼，然后将月饼馅、月饼皮和月饼油拆开自行组装并打包。（AlynxZhou）\nManjaro 用戶買來 Arch 組裝好的 Debian 月餅然後敲了個花紋上去重新裝了起來。（farseerfc）\nManjaro 用户经常吃了 Arch Linux 的月饼然后抱怨这个月饼为什么不是 Manjaro 牌的。（AlynxZhou）\nCentOS 的月饼过期了。（KRyuJo）但总有人喜欢这个传统口味，不想换。甚至有人资助 RedHat 厨师学校传承老字号。（whyme）\nRedHat：我们将通过电话联系在线指导您服用月饼。（ArielAxionL）\nopenSUSE 用户也喜欢将月饼拆成月饼馅、月饼皮和月饼油分别打包食用，但他们通常编写一个 月饼.spec 文件，然后将买来的月饼原料和此文件一同上传到 Open Build Service 而不是自己打包月饼。（AlynxZhou）\n随后 openSUSE 的月饼被冻结了，存放到 SUSE Linux Enterprise 的冰箱里。（AlynxZhou）\nUbuntu 的月饼馅过期了，但是依旧没有更新。（wuliao00）\nUbuntu 的月饼包装写着豆沙，用户咬了一口发现是五仁，大喊“内部错误！”。（AlynxZhou）\nDeepin 用户表示吃月饼时应该配点红酒（wine）。（AlynxZhou）\nLFS 用戶發現需要先自己製作用於製作月餅的工具。（YHNdnzj）然后开始阅读“如何开办一家月饼工厂”。（AlynxZhou）\nAntergos 用户收到了一个不幸的消息“此品牌已破产”。（AlynxZhou）\n\n随后话题变得奇怪了起来，不再仅限于常见的 Linux 发行版。\n\nWindows 10 用户您好！感谢您选购本公司最新发行的月饼，不过要敬告您的是，您的月饼马上就要过期了。（lilydjwg）\nWindows 用户的冰箱被锁死了，因为“Windows 正在等待月饼”。（AlynxZhou）\niOS 用户只能购买苹果自家的月饼，买别家月饼苹果抽成 30%。（outvi）\nGoogle 表示对于月饼生产商收取 25 美元的生产费。（AlynxZhou）除非你只吃没有馅料的 YOSP。（oldherl）\nPython 用户用 pip 安装了一个月饼，然后发现自己安装的月饼明年就过期了。（AlynxZhou）\nNodeJS 用户用 npm 安装了一个月饼，然后发现整个月饼流水线出现在了自己的厨房里。（AlynxZhou）\nDocker 用户发现自己的月饼比别家重很多，但没什么东西，而且吃月饼需要 root。（outvi）\nNintendo Switch 用户购买了月饼卡带然后由于太苦无法下咽。（AlynxZhou）\nJava 用户发现自己需要先安装一个月饼食用环境来食用月饼。（AlynxZhou）特别是还不知道装哪个版本。（outvi）更要命的是还区分 OpenMooncake 和 OracleMooncake。（Rocket1184）\nSteam 用户发现自己的月饼上多了绿色的 -40% 标签。（AlynxZhou）\nEpic：月饼独占一年！（KRyuJo）\nGo 用户把所有月饼当作一种月饼（interface {}）。（Sherlock_Holo）\nRust 用户表示月饼的保质期很短（离开视线就被 drop 了）。（Sherlock_Holo）Rust 家的月饼可以多人一起看着，但是吃的时候不仅只能有一个人吃，而且别人不能看。有人不信邪，使用 unsafe 魔法看到了正在吃月饼的人，然后整个世界崩塌了。（lilydjwg）\nsystemd 用户正在策划将月饼改名为 systemd-月饼 的投票。（AlynxZhou）\nC++ 用户表示月饼馅还不在厨房里。（wuliao00）建议食用 boost::月饼。（Rocket1184）\nfish 用户正在重写他们的 /etc/profile，没有时间吃月饼。（AlynxZhou）\nTensorFlow 用户依赖他们的 NVIDIA GPU 来识别月饼皮上的文字。（AlynxZhou）\nC# 用户的月饼做起来像 Java，吃起来像 Java，区别则是用户嘴里一直喊“我们的月饼比java好，而且终于开源了（一部分）！”。（AlynxZhou）\nVala 用户发现自己的月饼是 GLib 承包给 C 牌月饼的贴牌产品。（AlynxZhou）\nC 用戶不仅要自己制作月饼，还要在月饼制作过程中关注加工机器的操作问题，例如如何防止月饼馅料溢出。更重要的是这些操作都是纯手动完成的。（wnereiz）\n\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"可能只适合我自己的 RIME 配置","url":"/posts/My-RIME/","content":"在第 n 次忍受不了 RIME 的奇怪操作逻辑之后，我终于决定彻底教育一下这个不听话的输入法，考虑到已经有 n - 1 次失败的前提，做这个决定并不容易。\n\n\n首先说明我是 Linux 用户，使用 ibus-rime 做输入引擎，所以使用什么小狼毫鼠须管或者 fcitx-rime 的如果发现不好用最好别烦我，那些我都没用过。（不好意思因为配置这玩意有点暴躁。）\n然后我要吐槽一下 RIME 的文档，完全没有一致的类似 API 手册的东西，而且全繁体加上佛振独特的说话风格读起来真的很累，然后这个项目习惯又是起一大堆奇奇怪怪的名字（虽然我有时候也这样）。假如你想修改一点配置，读了文档里的示例“我懂了，巴拉巴拉”，打开配置一看一堆乱七八糟的就懵了。\n然后就是网上“致第一次用 RIME 的你”、“也致第一次用 RIME 的你”，我都看过了，首先他们不用 ibus-rime，其次文章内容毕竟有限，每个人需求不一样，有些我需要的地方他们一笔带过了。\nRIME 的拼音功能确实很好用（虽然有时候它和我对于词组的想法不太一样），我的需求其实只有几项：\n\n对于一些 RIME 默认的中国人几乎都用不到的中文标点直接改成英文标点，这个在书写 Markdown 的时候简直折磨死我了，有几个人会输入全角井号？？？打个标题真的很麻烦。\n有些符号键在其他输入法里约定俗成的就直接输出特定的中文符号，RIME 的默认操作是弹出选择菜单，完全没这个必要，弹出菜单还需要二次选择而且打断了我的按键操作，需要英文标点时候直接切为英文就好了。\n关掉 RIME 的中英混输功能，在候选框输入英文字母真的很打断思路，我要输入英文要么就是打代码要么就是打单词，反正都不需要输入法，RIME 来就是给我找麻烦。\n还有一些奇奇怪怪的 RIME 的键位设置，偏偏要和其他输入法不一样，我已经习惯了那些操作，RIME 的键位只会降低输入速度。\n\n下面介绍一下我的配置，只需要一个文件就可以，我没有对朙月拼音的配置做修改，只是修改了默认配置，朙月拼音自己的配置优先级低于默认配置。\n首先建立一个干净的 RIME 配置环境，直接移走 ~/.config/ibus/rime 然后执行 ibus-daemon -rdx 重新生成（就是它文档里扯的部署部署部署）一套配置，由于我用的都是内置输入法所以也不需要什么乱七八糟的东风破RIME Kit地球拼音之类的。\n然后你进去 ~/.config/ibus/rime 新版大概有以下几个东西：\n\n目录 build：里面放了各种 RIME 的默认配置，我们不需要动这个。\n目录 luna_pinyin.userdb：看起来像是朙月拼音的词库，当然也不用修改。\n文件 installation.yaml：我猜不用管。\n文件 user.yaml：我猜也不用管。\n\n按照 RIME 打 patch 的配置方式我们需要在这个目录下创建一个叫 default.custom.yaml 的文件，当然你得先会写 YAML。第一行首先写个叫 patch: 的 key，RIME 要求这样，所有的自定义配置都是在 patch 字段下面。\n怎么确定要修改的 key 名字呢？我这里的都是在 build/default.yaml 下面找到的，你也可以试试其他的 YAML 文件。\nRIME 的文档说什么要用 / 把不同层次的 key 折叠成一个比如 ascii_composer/switch_key，亲测无所谓，我就爱展开了写完整的 YAML，这样更规范。\n然后首先第一步我要修改输入法列表，我只用朙月拼音简化字模式就行了：\n1\n2\n3\npatch:\n  schema_list:\n    - schema: \"luna_pinyin_simp\"\n然后就是改掉那个自作聪明的英文输入模式：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n  ascii_composer:\n    # 按 CapsLock 输出大写英文字母。\n    good_old_caps_lock: true\n    # `inline_ascii` 在输入框内插入英文。\n    # `commit_text` 候选文字上屏并切换至英文。\n    # `commit_code` 输入拼音上屏并切换至英文。\n    # `clear` 清除拼音并切换至英文。\n    # `noop` 屏蔽此按键。\n    switch_key:\n      # 如果你设置 `Caps_Lock` 为 `noop`，\n      # 一个奇怪的问题是退格键不能用了，除非取消大写锁定。\n      # 所以我直接设置文字上屏了。\n      Caps_Lock: \"commit_text\"\n      Shift_L: \"commit_code\"\n      Shift_R: \"commit_code\"\n      Control_L: \"noop\"\n      Control_R: \"noop\"\n大部分坑我都写在注释里了可以自己看。\n然后我看那个设置选单也不是很爽，我习惯简体字，这个也可以自己改：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n  switcher:\n    # 改掉原来的繁体字标题。\n    caption: \"【设置菜单】\"\n    # 用半角斜线而不是奇丑无比的全角斜线做分隔符。\n    option_list_separator: \"/\"\n    # 屏蔽 Ctrl-s 开启菜单，只允许 Ctrl-` 和 F4。\n    hotkeys:\n      # - \"Control+s\"\n      - \"Control+grave\"\n      - \"F4\"\n然后就是改掉它奇怪的键位，Emacs 键位挺好的，但是有几个不知道为什么用不了，再者就是为什么按向左是跳一个字拼音向右是跳一个字母？\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n  key_binder:\n    bindings:\n      # Emacs 键位，我喜欢。\n      # 可是谁给我解释一下为什么 Left 是按字拼音跳而 Right 是按字母跳？\n      - accept: \"Control+p\"\n        send: \"Up\"\n        when: \"composing\"\n      - accept: \"Control+n\"\n        send: \"Down\"\n        when: \"composing\"\n      - accept: \"Control+b\"\n        send: \"Left\"\n        when: \"composing\"\n      - accept: \"Control+f\"\n        send: \"Right\"\n        when: \"composing\"\n      - accept: \"Alt+b\"\n        send: \"Shift+Left\"\n        when: \"composing\"\n      - accept: \"Alt+f\"\n        send: \"Shift+Right\"\n        when: \"composing\"\n      - accept: \"Control+a\"\n        send: \"Home\"\n        when: \"composing\"\n      - accept: \"Control+e\"\n        send: \"End\"\n        when: \"composing\"\n      - accept: \"Control+d\"\n        send: \"Delete\"\n        when: \"composing\"\n      # 这个用不了，不过估计也用不到。\n      # - accept: \"Control+k\"\n      #   send: \"Shift+Delete\"\n      #   when: \"composing\"\n      - accept: \"Control+h\"\n        send: \"BackSpace\"\n        when: \"composing\"\n      - accept: \"Alt+h\"\n        send: \"Shift+BackSpace\"\n        when: \"composing\"\n      - accept: \"Control+g\"\n        send: \"Escape\"\n        when: \"composing\"\n      - accept: \"Control+bracketleft\"\n        send: \"Escape\"\n        when: \"composing\"\n      - accept: \"Alt+v\"\n        send: \"Page_Up\"\n        when: \"composing\"\n      - accept: \"Control+v\"\n        send: \"Page_Down\"\n        when: \"composing\"\n还没完，我觉得正常人不会用 Tab 在拼音之间切换，除非你一次输入一句话（那你不觉得候选框太小了看着累吗？？？），设置 Tab 为跳候选词更自然一点，但我也不知道为什么 Shift-Tab 用不了：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n      # 正常人不会用 Tab 切换拼音光标的，相信我。用它切换选项更快。\n      # - accept: \"ISO_Left_Tab\"\n      #   send: \"Shift+Left\"\n      #   when: \"composing\"\n      # - accept: \"Shift+Tab\"\n      #   send: \"Shift+Left\"\n      #   when: \"composing\"\n      # - accept: \"Tab\"\n      #   send: \"Shift+Right\"\n      #   when: \"composing\"\n      - accept: \"Tab\"\n        send: \"Down\"\n        when: \"has_menu\"\n      - accept: \"ISO_Left_Tab\"\n        send: \"Up\"\n        when: \"has_menu\"\n      # 鬼知道为什么这个也用不了！\n      - accept: \"Shift+Tab\"\n        send: \"Up\"\n        when: \"has_menu\"\n以及我觉得正常人不用逗号和句号翻页，毕竟下面的默认设置是逗号句号直接上屏，你设置了翻页也没啥卵用，反正我用减号等号或者上下，不过方括号也不错就是了：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n      - accept: \"minus\"\n        send: \"Page_Up\"\n        when: \"has_menu\"\n      - accept: \"equal\"\n        send: \"Page_Down\"\n        when: \"has_menu\"\n      - accept: \"bracketleft\"\n        send: \"Page_Up\"\n        when: \"has_menu\"\n      - accept: \"bracketright\"\n        send: \"Page_Down\"\n        when: \"has_menu\"\n      # 我觉得正常人不应该用逗号和句号翻页。\n      # - accept: \"comma\"\n      #   send: \"Page_Up\"\n      #   when: \"paging\"\n      # - accept: \"period\"\n      #   send: \"Page_Down\"\n      #   when: \"has_menu\"\n最后就是那一堆乱七八糟的快捷键了，鬼才记得住，有那时间直接翻菜单就行了，那个 Shift+Space 就是我动不动就变成全角的罪魁祸首，全部不要：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n      # 鬼才记得住这么多乱七八糟的快捷键，我翻菜单比背这玩意快多了。\n      # - accept: \"Control+Shift+1\"\n      #   select: \".next\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+2\"\n      #   toggle: \"ascii_mode\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+3\"\n      #   toggle: \"full_shape\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+4\"\n      #   toggle: simplification\n      #   when: \"always\"\n      # - accept: \"Control+Shift+5\"\n      #   toggle: \"extended_charset\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+exclam\"\n      #   select: \"\".next\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+at\"\n      #   toggle: \"ascii_mode\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+numbersign\"\n      #   toggle: \"full_shape\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+dollar\"\n      #   toggle: \"simplification\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+percent\"\n      #   toggle: \"extended_charset\"\n      #   when: \"always\"\n      # 你就是那个经常害我变成全角的罪魁祸首！\n      # - accept: \"Shift+space\"\n      #   toggle: \"full_shape\"\n      #   when: \"always\"\n      # - accept: \"Control+period\"\n      #   toggle: \"ascii_punct\"\n      #   when: \"always\"\n我自己是不习惯写 inline 的字典和列表，都写的展开的。\n然后是符号设置了，因为我们上面取消了逗号句号翻页，所以这里也就不用显式写 commit 直接上屏了。然后我去掉了一大堆菜单，我输入井号星号波浪线百分号就是想要英文标点，你给我弹个菜单我还得多确认好麻烦的。以及我觉得真的没人用那个巨长的全角斜杠，输入斜杠就是为了斜杠，什么通过朙月拼音命令输入假名有意义吗？我为什么不直接切日语输入法呢？另一些标点在中文语境下直接输出中文标点就好了，需要英文标点时候我敲一下 Shift 比看菜单选容易多了！比如书名号，竖线输出人名中间的点，反斜杠输出顿号之类的。\n由于我不是金融行业的，我就把一些英文标点常见但对应中文标点也可能会用到的都丢到了 $ 的菜单里面：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n  # 为了方便编写 Markdown，把一些奇怪的写中文根本用不到的符号弹出菜单改成直接输出英文符号。\n  # 另一些直接默认输出中文符号，需要英文符号可以切换英文输入。\n  # 有关 `\"!\": {commit: \"！\"}` 的写法含义是你设置这个键为翻页按键了，\n  # 但是你又想在输入拼音出现选单之后输入这个按键直接上屏（常见的逗号句号问号叹号），\n  # 我觉得这是多此一举，为什么你非要拿这几个符号翻页？反正我不用。\n  # 乱七八糟的符号都塞给 `$` 就好了反正我不是会计不用天天输入 `￥`。\n  punctuator:\n    # 我不会使用全角标点的，所以只改半角。\n    half_shape:\n      \"!\": \"！\"\n      \"\\\"\":\n        pair:\n          - \"“\"\n          - \"”\"\n      \"#\": \"#\"\n      \"$\":\n        - \"￥\"\n        - \"$\"\n        - \"€\"\n        - \"～\"\n        - \"×\"\n        - \"÷\"\n        - \"°\"\n        - \"℃\"\n        - \"‰\"\n        - \"‱\"\n        - \"℉\"\n        - \"©\"\n        - \"®\"\n      \"%\": \"%\"\n      \"&amp;\": \"&amp;\"\n      \"'\":\n        pair:\n          - \"‘\"\n          - \"’\"\n      \"*\": \"*\"\n      \"+\": \"+\"\n      \",\": \"，\"\n      \"-\": \"-\"\n      \".\": \"。\"\n      \"/\": \"/\"\n      \"\\\\\": \"、\"\n      \":\": \"：\"\n      \";\": \"；\"\n      \"=\": \"=\"\n      \"?\": \"？\"\n      \"@\": \"@\"\n      \"(\": \"（\"\n      \")\": \"）\"\n      \"[\": \"【\"\n      \"]\": \"】\"\n      \"{\": \"「\"\n      \"}\": \"」\"\n      \"&lt;\": \"《\"\n      \"&gt;\": \"》\"\n      \"^\": \"……\"\n      \"_\": \"——\"\n      \"`\": \"`\"\n      \"|\": \"·\"\n      \"~\": \"~\"\n总之写完这些配置再执行 ibus-daemon -rdx 就可以应用了，现在 RIME 用起来就更让我愉快了，接下来就是慢慢养词库就行了。\n最后如果你想试一试，点击 这里 下载。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"翻译：我很幸运，但你不是。","url":"/posts/I-Am-Lucky-You-Are-Not/","content":"这是一篇 Jérôme Gamez 的文章 I am lucky, you are not. 的简体中文翻译。\n\n\n你好，我的名字是杰罗姆（Jérôme）！对于分享名字我感觉很自在，因为我住在德国，并且我也不总是对我们国家的政府感到高兴。\n对于我能公开谈论此类事情，而不需要感到对我的言论产生的反响感到恐惧，我感觉很幸运。并且我拥有 甚至都不需要考虑 需要考虑我有多么幸运的奢侈的权利（这里的重复是有意为之）。\n通过最近在 Discord 社区 有关 PHP 的 Firebase Admin SDK 的讨论，我才意识到以上这些事情。\n某位成员试图通过这个 SDK 去访问 Firebase API，但是却触发了一个既没有详细信息也没有说明错误来源的异常。事实上原因是因为他们在中国而且忘记了给代码运行的环境设置代理。是个可以修复的问题。\n当我在忙于在 SDK 里实现连接错误处理的时候（这是一件我以往甚至没有考虑过去做的事情，因为我在一个很幸运的位置，处于一个拥有普及且无限制的互联网连接的国家里），另一位社区成员补充说到：\n\n@jeromegamez：看看我处在一个多么令人愉悦的情形：由于美国贸易管制法律限制，您的 GitHub 账户已被限制。对于个人账户，您可能仅仅拥有用于个人交流的对于免费的 GitHub 公开仓库服务的受限访问权限。请阅读有关 GitHub 和贸易管制的文章以获取更多信息。如果您确信您的账户是被错误地标为受限，请发起申诉。\n\n他们曾经有某次在自己祖国不通过 VPN 或代理直接访问 GitHub，然后立刻被标为受限，现在无法访问自己的私有仓库。\n\n这太差劲了……你们会为这个申请判决吗？\n\n我是这样幼稚地回复的，没意识到他们的申诉当然无法成功。\n\n@jeromegamez：非常不幸，你没法选择在哪出生！在大概 200 来个国家里面我就处在一个疯狂的国家里。在内部的审查制度和制裁开始之后我通常使用 VPN，拿 whatsapp 举例，有些时候我没法上传图片于是我需要使用代理或 VPN。正常来说你可以通过使用 VPN 来使用像 Nvidia.com 或者 Android.developers.com 等等国际服务，但是这次不太一样，如果你曾经用某些地方的 IP 地址访问过他们的服务，他们直接阻拦你自己。至少我仍然可以使用公开仓库，并且希望我能备份我的私有仓库！\n至于申请判决，作为这些国家的公民我没法做这件事情。\n\n我们在私有频道继续了我们的对话，他们和我聊了他们出身的国家（这是个通常让他们感到不适的话题），他们为此努力并且在公开频道展示了这些以便引起注意。\n人们像我一样（特别来说像我：白人、男性、欧洲人、有一份薪水不错的工作并且可以访问任何我需要和大部分想要的事物）看待这个世界并且对在一些令人不那么舒适的地方正在发生的事情感到不满和恐惧。\n但是还有可能成为更令人不适、敌对或者危险的地方，并且像你或我一样的人正在那生活。\n当我在为了躲避酷暑而努力时，有些人在努力谋生。\n当我因为不能在互联网平台上使用我中意的用户名而感到气愤时，有些人在确保他们的用户名不会透露太多他们的个人信息。\n当政府 A 在制裁国家 B，在制裁导致的后果中挣扎的是那些国家的平民百姓，而不是领导者。\n当我在尽力唤起人们注意的时候，有些人在尽力活下去。\n这不代表我们的个人问题是不相干的，但我认为，认识到我们中的大多数是幸运地出生在一个好地方，并且也有好多人不像我们这么幸运，是十分重要的。\n最起码我们可以做的是以尊敬、礼貌和同情对待他人，而不在乎他们的出身和背景。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"在 Pixel C 上安装 Lineage OS","url":"/posts/Pixel-C-Lineage/","content":"Pixel C 刚出来的时候我就很喜欢，但无奈价格太贵，同时 Android M 不能说是很好的利用平板电脑硬件。由于咕鸽战略失误，现在 Pixel C 已经变成热门洋垃圾了，所以在咸鱼捡了一台玩玩。\n官方系统升级只支持到 8.1（真的好意思起名叫 Pixel），Lineage OS 支持也是到 8.1（LOS 版本号就是 15.1，没有 Bug），所有的 9.0 都是 Unofficial 的，不过反正我就拿来看看文档，所以直接刷 LOS 15.1 Official 了（为什么不刷官方？因为我手机不想刷第三方，就拿平板过过瘾）。\n\n\n由于刷机时候没拍照片我就不上图了，到手时候已经解锁了，不过既然是亲儿子想必也不会像一些国内厂商一样恶心你。按照 Lineage OS 的说法就是打开开发者选项里 允许 OEM 解锁 和 允许 USB 调试，按住 音量下 + 电源 直到重启进入 bootloader，然后连接电脑，fastboot devices，如果检测到了就 fastboot oem unlock，然后结束之后重启。（会清除所有数据，并且解锁之后每次开机会在 bootloader 停止 30 秒）。\n首先是去 Lineage OS 官网 下载给 Pixel C（代号 dragon）的 nightly build ZIP。\n然后去 这个 Google Drive 下载开发者提供的 vendor.img。（务必要下载这个，如果有不止一个就选择最新的，因为 ROM 里不包含 vendor，其他下载的版本又和 ROM 包不匹配。）\n然后去 TWRP 官网 下载给 Pixel C 用的 Recovery。\n需要 Google Apps 就去 Open GApps 下一个 ZIP，我用的是 ARM64 -&gt; 8.1 -&gt; stock。\n如果你需要 Magisk 就自己去下载一个。\n把这些都放好，在自己电脑上安装 adb 和 fastboot，然后打开 允许 USB 调试。按住 音量下 + 电源 直到重启进入 bootloader，然后 fastboot flash recovery TWRP-IMG-FILE 刷入 TWRP，然后再按住 音量下 + 电源 直到重启进入 bootloader，选择 Recovery Mode 确认 TWRP 已经刷进去了。\n接下来在 TWRP 里面全部 wipe（syste, data, cache, sdcard），然后接上电脑用 adb push FILE /sdcard/ 把下好的 ROM ZIP、verdor.img 和 OpenGApps ZIP 都 push 到 sdcard 里面。\n然后选择 Install 刷入 Lineage 的 ZIP。接下来选择右侧 Install IMG，刷入下好的 vendor.img，然后刷入 OpenGApps 和 Magisk，重启。如果刷入 Magisk 的话会自动重启两次再进入向导。\n如果你日后某次更新提示 vendor 不匹配，那就去上面的咕鸽硬盘看看有没有新的刷进去就行了。\n接下来就是熟悉的开机向导了。\n大致来说作为洋垃圾这个平板还很划算，除了屏幕下端因为接键盘的磁铁的缘故会发黄（通病）、太多磕碰容易花屏（设计缺陷，购买要买少磕碰的），屏幕素质很好尺寸也很大，看文档看 PPT 看五线谱都是绝配（我期末就是用这个看 PPT 复习的超级爽）。但是毕竟是 3 年前的产品，3 GB RAM 不是很够多任务，同时 CPU 性能也不是特别高，甚至窗口特效都会卡（老黄的芯片优化好烂），但是这台机器是 NVIDIA 的芯片，GPU 性能强劲，打开开发者选项里 禁用 HW 叠加层，使用 GPU 进行窗口混成特效就不卡了。\n游戏性能很弱，大部分游戏都没有对这台机器 GPU 优化，CPU 和内存以及 IO 性能也不高（毕竟三年前），但是玩 FGO 意外的不卡，而且还让我用 维护送的石头 单抽 连续 出了 老福 和 心心念念的蓝呆！！！要知道就算把买平板的钱都氪进去也才不到两单，要靠这些石头来双黄蛋简直是白日做梦啊！\n除了垃圾 B 站 APP 不支持横屏以外，大部分对我影响都不是很大，所谓生态烂其实对我这种资深 Android 用户也没什么大影响，毕竟我对它分工很明确。日常用起来 Lineage OS 也没什么问题，升级只要傻瓜化点击就 OK 了。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"雲雀","url":"/posts/Hibari/","content":"ロード・エルメロイⅡ世の事件簿 -魔眼蒐集列車 Grace note- ED\n五线谱（带歌词）点击链接下载：PDF 格式、MSCZ 格式（需使用 MuseScore3 打开）。\n歌词参考自微博用户 @小蟲子的覺魂。曲谱由我自己听写。\n\n\n说实话好久没听到这么有梶浦由记风格的曲子了。花の唄 和 I beg you 都不算是我特别能接受的风格，二世事件簿大概是一月份放了第一集，但我那时候坚守“不看新番”的原则错过了……不过还好，第二集才算正式的放出 OP 和 ED。无人声OP对于梶浦由记来说根本不算什么难题，相对来说 ED 就更有惊喜了，不管是对小灰还是对韦伯都很好体现出了人物身上的故事感。\n当然令人欣喜的绝对不是这个番又多了一个呆毛。\n刷了两次 HF2 之后听到这个真是治愈啊啊啊啊啊，HF2 黑呆和 B 叔打戏看出了 EVA 旧剧场版明日香大战量产机的感觉，明明画面很热血，但是就是给人绝望感。\n下面是数字谱：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]\n\n67 [#1 #1 #1 2 #1] 7 [3] 67 [#1 #1 #1 #4#4 33] 7\n67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67\n[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]\n[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5]\n\n[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]\n[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]\n\n[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]\n\n67 [#1 #1#1 2 #1] 77[3] 67 [#1 #1 #1 #4 33] 7\n67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67\n[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]\n[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5 6#5#4]\n\n[#4#56 7]{#1}[#4] [#4#56 7]{32#1}[76 #4#56 7]{#1}[#4 76#5 3 #4#56]\n[6#5 #4#56 7]{#1}[#4] {#43 #1}[7]{#1} [76#5#4] [76#5#5] [#567]{#1}\n\n[#4#566#4 #4#566#4 #4#5676 #5#4#5 #566]\n[6#5 #4#566#4 #4#566#4 #4#5676 #5#4#5 #566]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #4#43 3]\n[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]\n[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]Alynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"六月，如梦一般的日子","url":"/posts/June-or-Dream/","content":"\nOne day I wake up,\nfinding that I am on one of the most crazy trips in my life.\nIt has been into my dream for many times,\nbut now it comes into reality,\nwhich becomes the best birthday present.\n\n\n\n距离上次更新大概一个半月了，主要是因为考试周太忙所以没心情写博客。实际上有好多东西可以写。\n首先是端午节去了沈阳，不过很遗憾的是我不太喜欢拍景点照片（当然这也不是什么重点内容），所以只有一些稀松平常的照片。\n\n\n\n然后是有关实习的内容了，很幸运的拿到了 SUSE 北京的实习，环境超级好，而且最关键的还是找到一个自己比较感兴趣又有了解的实习。\n接下来就是 FGO 抽卡！盼了一年之后终于如愿以偿抽到了蓝呆！而且还是先出老福然后连续出蓝呆！没有看到金卡面之前完全没有意识到是什么，就算看到金卡还以为又是兰斯洛特或者式姐（兰斯洛特四宝的我），结果翻过来的时候完全呆住了不知道该怎么反应（抽到老福的快乐还没过去）。\n\n\n以及买到了 Yuki Kajiura Live 15 上海的票（因此变得超级贫穷），虽然对我这个纯 Kalafina 粉来说性价比不是很高，但由于没去过 Kalafina 的 Live（并且再也没有了）而十分后悔，因此抱着这样的想法毅然决然的自己买了票，也算是圆多年的梦吧，毕竟可以说我整个的音乐审美都来自于梶浦由纪和 Kalafina。\n最后附上沈阳故宫墙里奇怪的石头照片。\n\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"Arch Linux 安装 UnityHub 的临时方案","url":"/posts/Archlinux-UnityHub/","content":"如果你直接使用 AUR 里 UnityHub 的 PKGBUILD 安装会出一些问题。解决方案也很简单。\n首先似乎 PKGBUILD 下载的版本很奇怪，不管你在 Unity 论坛里哪个链接下载的版本其实都是一个，并且和 PKGBUILD 里面的不一样，解决方法就是自己计算一下 md5 然后替换掉 PKGBUILD 里面的 md5sums。\n第二个就是 PKGBUILD 里面最后有这几句：\n1\n2\n3\n4\n5\n6\n7\n# Fix 7z permissions\nchmod +x \"${pkgdir}/opt/${pkgname}/resources\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64/7z\"但解压出来实际上没这些文件，然后就会报错，注释掉就好了。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"不要拿愚蠢的广告来污染我的邮箱","url":"/posts/Do-Not-Fill-My-Email-with-Silly-Ads/","content":"一个多月没更新了，这次要写的不是什么技术问题，而是技术的附属问题。\n\n\n一切问题的起源是邮箱里出现的这两封邮件：\n\n\n当你使用的邮箱服务是按某种数字顺序批量注册用户名的时候，你就没办法避免这种情况，不止我自己，而是很多人都收到这种邮件，没办法，谁叫邮箱都是连号的，甚至不需要写脚本，只要用 Excel 拖一下就能生成一大串邮箱地址，毫无技术含量。\n从哪里开始呢？今天我不打算讨论写这么个 app 的技术问题，因为不管怎么说写这么一个系统也不是个简单的活，还是要尊重别人的劳动成果。但除了技术问题，别的问题就一大堆了。\n我不想下载\n没错，最大的问题其实是我看了这个东西以后根本没有下载的欲望，甚至连让我下载下来找找里面有哪些技术缺陷的欲望都没有。我也不是什么专业的传播学者或广告设计者，但从一个用户的角度而言就没有使用欲望——而且这种现象也不止我自己。\n你的情怀和我有什么关系\n\n今年春半，凝聚了团队无数努力和心血的项目终于开启了测试阶段。这对于我们整个团队来说都是一个饱含着拼搏意义和激动情绪的时刻。\n\n上一个想要靠卖弄情怀来宣传聊天软件的人叫罗永浩，结果如何呢？提起罗永浩大家还是首先想到 TNT、打脸，有几个想到聊天宝（原子弹短信）的？罗老师的原子弹短信一开始可是给用户发红包的，这年头光卖情怀可不行，大家都喜欢红包。\n我知道你们实现了目标非常开心，但能不能冷静下来再发广告，这句话放在这里除了浪费几 Byte 流量之外，对用户了解你的应用有什么帮助嘛？\nAI 不是万能形容词\n\nDreamua 是首款 AI 社交应用。\n\n如果你做了个图片识别程序，你打个标签叫 AI 识图，那我觉得你的可信度有 90%，毕竟有很多现成的例子了。\n如果你做了个文本翻译程序，你打个标签叫 AI 翻译，那我觉得你的可信度有 70%，因为有几家财大气粗的公司在做，虽然效果不一定太好。\n如果你做了个自动驾驶程序，你打个标签叫 AI 驾驶，那你的可信度取决于你是不是在特斯拉上班。\n如果你非得叫 AI 社交……AI 社交了，还要我干什么？社交是人与人之间的互动哎，你这个 AI 社交，AI 在里面扮演什么角色呢？AI 能猜出来“今晚月色真美”的潜台词嘛？要是能猜出来，全世界的翻译官都失业了。\n写广告的人不懂的话可以问问程序员，最起码程序员应该懂。\n求你别搞假大空\n\n我们想了很久的slogan，最后把它决定为“Dreamua—遇见宇宙中最契合的TA”。\n“宇宙”、“契合”是很宏大的词，但是我们希望可以和你一起，实现这个slogan的意义。\n\n如果语文老师没教你避免假大空，那软件工程老师应该教过你怎么写文档，请问你们这个软件是想让我和外星生物配种嘛？\nedu 邮箱就很靠谱吗\n\nDreamua是一个仅对edu邮箱用户开放的高校社交App，其核心和灵魂是AI社交。注册Dreamua 账号无需填写复杂简介，仅需一个edu邮箱，一张头像，一个昵称。\n\n废话，edu 邮箱要是那么靠谱，我就不会收到这个邮件了——毕竟发件人也是 edu 邮箱。\n一个 edu 邮箱能说明什么呢？学号？学校？这个邮箱的主人可能已经毕业了，比如发邮件的这位 14xxxxxx，你是留级了在读大五？\n知道为什么我用 edu 邮箱申请 GitHub 学生认证不给过吗？就是因为国内的 edu 邮箱管理太松散了，完全没办法辨别真伪。那既然邮箱不能验证我是不是学生，再加一张头像一个昵称就能验证我是不是学生了吗？\n如果你们下次还想发广告，我觉得可以去淘宝搜索一下“教育 邮箱”，多买几个马甲，别总用一个，添加黑名单很容易的，大家只是太懒而已。\n说话能不能说准了\n\nDreamua是一个仅对edu邮箱用户开放的高校社交App。\nDreamua 测试版仅面向 edu 邮箱用户开放。\n\n第一封邮件告诉我这个社交 app 只对高校学生开放。第二封就告诉我是测试版仅面向 edu 邮箱——那以后呢？\n生人社交本身就是伪命题\n求求你了我们真的不是没社交就会孤独到死。不是每个人每个晚上都睡不着觉拿着微信疯狂摇一摇。我有自己认识的人，我可以认识我认识的人认识的人，我甚至看到有趣的人也可以直接上去要联系方式——或者我干脆就不想和别人说话。\n从小到大不爱和人说话的同学我见得多了，他们活得好好的，也没见谁需要下个 app“寻找志趣相投的伙伴”。实在不行的话，我还有沙雕网友呢。\n我为什么非要用你的\n我倒不是说微信微博 QQ 做的比你们技术好，但每个人都或多或少的被这些或者其他 app 黏着。本身这些东西已经够用了，我看不到需要切换到第 N + 1 个 app 来和别人说话的任何理由，特别是对于我们这些生活在地球外面的人，想切换就更艰难了。\n原子弹短信的尸体还在墙头上挂着呢，支付宝也有聊天功能，除了聊天框里的“转账”按钮，你按过别的吗？\nPlay 商店搜不到\n这一条可能有些不接地气，但对 Android 用户来说，Play 商店是最可靠的程序来源，就如同苹果的 App Store 一样。只有 Play 会定期检查手机里的 app 是不是有安全问题，其它的国内商店根本没有安全保证——拍个身份证照片注册就安全了吗？\n我看到你们的 app 提交了 App Store，所以应该不差那 25 美元提交 Play Store 吧，毕竟我自己的开源 app 也掏了 25 上了 Play 呢。\n官网没有可用信息\n还好我能够在 Google 搜索到 https://www.dreamua.com/，但这个页面逻辑和我自己的 app 页面 https://livewallpaper.alynx.xyz/ 逻辑差不多嘛——就一个简单的静态页面，分几个段落，写一些半通不通的话（“年轻有朝气的初创团队，致力于打造一家有影响力、有社会责任感的互联网科技公司。”这话怎么读怎么奇怪）。既然你都注册公司了，多写几个页面问题不大吧。你们是公司，我可是一个人单打独斗写的 app，不至于和我一样套开源 bootstrap 主题吧！\n顺便，上面写诞生于高校宿舍，下面又写有 Uber、Facebook、Amazon、腾讯等知名互联网公司工作经验……大概能是真的，就是会让人觉得开发之后已经换了一波人一样，再说，腾讯出来的人写个前端页面不难吧。\n化再浓的妆也没用\n说实在的，我对用户群体的评估可能有点失误，真的有人告诉我他们的室友下载了这个 app，后一句就是喜闻乐见的“想通过这玩意脱单”。\n你看看你看看，人家用户都摆明了自己的需求了，就不要写什么“将宇宙中的一座座孤岛连成一片星海”了。单身直男们也该思索一下了，为什么夏目漱石说“今晚月色真美”是表白，你说“今晚月色真美”就是华为 P30 Pro 的高端黑了，你看王跃琨一下子就被开除了！太晦涩难懂是没法脱单的！\n真的别再卖情怀了\n\n首先谢谢你打开这封信。\n我们是交大的一个学生团队，我们和你们一样在学活吃渔粉，在球场踢足球，在傍晚看明湖鸭。\nDreamua 诞生于高校宿舍。\n\n说真的，你这样会让别人对我们宿舍里这些同学的真实水平产生怀疑——我觉得我们学校的教学还是偏重于踏踏实实讲理论老老实实学技术的，而不是选个厮杀的你死我活的行业（你们的对手不止有探探陌陌 Soul 其实还有微信微博 QQ 甚至是 Bilibili 和网易云音乐）来创业，写一堆乱七八糟的文案卖情怀。\n以前好像有个公众号，文案风格如出一辙，也挺喜欢卖情怀的，结果清华评特奖的时候从简历上被人挖出来婊说实际什么都没做。我觉得这种事情给人留的印象挺差的，所以还是别卖情怀了，能好好写文案就好好写，写不出来吃点渔粉踢会足球看看鸭鸭可能就有灵感了。\n百度没收录我的网站\n最近那个《旗帜鲜明地反对李彦宏当选工程院院士》挺出名的。我先声明一下，我的网站放在地球上，谷歌必应收录了我的网站而百度搜狗 360 这种辣鸡引擎没有收录，特别是百度还把山寨我的站点放在了搜索结果首页上。所以百度和我没什么利害关系，我也就不担心这种问题。\n至于腾讯封了《旗帜鲜明》我也不太担心，毕竟我这人不喜欢用微信，连公众号都没有，生平最烦举报党。\n我恰好想起来今天是我建站的三周年零一个月整，114777 个点击量不算太多，但从第一篇文章开始我的目标就没变过——“网站是属于自己的，我可以记录我自己的想法，喜不喜欢则是你的自由”。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"Magnolia","url":"/posts/Magnolia/","content":"我不是很能欣赏花。\n我的鼻子并不懂得花的芬芳，我的眼睛也不是很了解花的鲜艳，大部分情况下，我连分辨花种类的兴趣都没有。但我今天还是认出了一株玉兰树，就像我高中楼门口两侧的玉兰树一样，开着白色花瓣。\n\n\n为什么认得玉兰花，说起来是个很奇怪的理由，有一段时间我非常喜欢一款包装上印着玉兰花的纸巾，我很喜欢那款包装的着色效果，虽然只是塑料制品，但是有着独特的温润感觉。另外大概也有原因是它味道并不是很浓，太浓的味道让我觉得不舒服。如果我没记错的话，我现在应该还留着一份包装。\n当然这件事并没有一个好的结尾，就像所有烂俗的青春文学一样。后来那款纸巾更换了新的包装，虽然还是玉兰为主题，但配色完全没有了之前的灵性。我以为我自己已经很缺乏审美了，但这个新包装的设计者不但缺乏审美，还能跑出来危害大家的眼睛。\n\n我总是记不住玉兰的英文该怎么拼，说错了，我大概对计算机之外的一切英文名词都不怎么敏感。多半是因为我并不会读这个单词，Mangolia，不对，Magnolia，有时候我会分不清楚“玉兰”和“蒙古”。\n我们先不谈有着伤感结局的玉兰纸巾，先谈真正的玉兰花。大概没有太多人注意高中校园里的两颗玉兰树，毕竟高中生每天有太多无聊的事情要考虑了，谁也没有那个闲情逸致，况且大多数人也没兴趣了解植物的区别，也包括我。\n虽然春天刮风是这个城市主要的气候，但是也并不是十分的没有人情味。通常来说，玉兰花开放的季节，也是会无缘无故落下一场春雨的时候。总是能有一些日子，可以在操场上的水洼里看见夕阳的倒影。也能在树下看到随着雨点一并落下的花瓣。什么时候树上的花瓣都落光了，什么时候有人情味的春天也就结束了。\n\n我不知道玉兰的花语是什么，因此很遗憾，我也没有办法围绕玉兰花的花语写出一篇小说。不过反正这些东西都是人附加的含义而已，就算某种花的花语是遇见幸福，那就真的能让人遇见幸福了吗？\n有些时候还是不要太相信那些本来是讲给小孩子听的话比较好，毕竟童话其实是大人写给大人看的。\n曾经我以为好搭档就应该永不分离，曾经我以为故事就应该十全十美，但后来我才知道，不完美的才更真实，大家都是成年人，就应该尊重每个人不同的决定，哪有那么多地方可以耍小孩子气。\n\n我最近在学日语，也算是终于开始实现很久以来的心愿了吧。\n老师说日语里面并不会经常重复主语，比如第一句话里已经说过主语是“我”，第二句就没必要再重复了。\n有时候我写东西也是这样，不太愿意在句子里说“我”，宁愿直接把主语省略掉，大概是欺骗自己，删掉主语的话，就可以当成是在说另一个人，写出来就不会觉得那么不好意思。\n\n“灵气”并不是什么容易获得的东西。有时候写了很多却完全不知道自己在说什么，我好像没有能把自己若无其事地叙述出来的能力。逐渐地就开始理解，物质是多么拖累精神的东西。反正喜欢的话总是被别人说出口了，电影台词也好歌词也罢，阅读总是比自己创作要舒服得多。\n只是很想听别人的故事而已，仿佛是身处不知何处的梦境中一样。身边的事物太吵闹了，生活太无聊，也太寒冷。\n四月只是春天的谎言吧，这样寒冷的日子，春天真的来了吗？还是说开放的 Magnolia，只是春天的假象而已呢？\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"如何编写 Android 视频壁纸","url":"/posts/Android-Video-Wallpaper-Implementation/","content":"最近我编写了一个 Android 的视频壁纸应用（GitHub Repo），一开始觉得并没有什么难写的地方，应该很快就可以写出来，但是后来发现我想的太简单了。或许你也看过许多写视频壁纸的教程，但我发现他们都有一些问题，写出来的程序基本不能用，所以我打算在这里写一下如何编写一个可以发布的 Android 视频壁纸，而不是一个 demo。\n\n\n首先你需要新建一个项目，通常应该都是使用 Android Studio，我就忽略你如何与网络搏斗让 Android Studio 可用了。什么程序模板可以随便选，反正你还是要自己新建 class。最低 API 版本不要太低就行，如果你只是写一个动态壁纸，应该不需要很高的 API，因为 Android 很早就支持动态壁纸了（但为了让开发方便一点，建议只考虑 5.0 以上的就行了，反正现在即使有 5.0 以下的机器多半也成垃圾了）。\n首先让系统知道你是个壁纸……\n在开始写逻辑代码之前，我们还得先让系统知道你写的这是个壁纸，这需要一些起声明作用的代码。先把你 Android Studio 左侧侧栏调成文件树模式（忘了什么诡异的分类模式吧，不然你连文件在哪都找不到，试图隐藏细节只会让事情变的更复杂）。\n应该有一个自动生成的 AndroidManifest.xml 文件，我觉得你应该比我更了解这玩意是干嘛的，因为实际上我没系统地研究过 Android，我只是会一点点 Java 而已——然后靠不停的查看手册来自学。加上这两行：\n1\n2\n3\n4\n&lt;uses-permission android:name=\"android.permission.SET_WALLPAPER\" /&gt;\n&lt;uses-feature\n  android:name=\"android.software.live_wallpaper\"\n  android:required=\"true\" /&gt;\n你要是能把这一行加到 &lt;manifest&gt; 标签外面，我觉得你也没必要写代码了……但这个要放在 &lt;application&gt; 标签的外面，具体放在哪直接翻我仓库里的文件好了，比我用文字描述清晰的多。\n但是下面这个要加到 &lt;application&gt; 标签的里面：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n&lt;service\n  android:name=\".GLWallpaperService\"\n  android:permission=\"android.permission.BIND_WALLPAPER\"&gt;\n  &lt;intent-filter&gt;\n    &lt;action android:name=\"android.service.wallpaper.WallpaperService\" /&gt;\n  &lt;/intent-filter&gt;\n  &lt;meta-data\n    android:name=\"android.service.wallpaper\"\n    android:resource=\"@xml/wallpaper\" /&gt;\n&lt;/service&gt;\n看到那个叫 android:name 的属性了吗，. 不能少，后面的名字则是一会你的 class 叫什么名字这里就什么名字。然后别的都是套路，可以不管，除了那个 @xml/wallpaper，这玩意要自己写。\n在你侧栏找到 res 目录，如果底下没有叫 xml 的目录的话，你就新建一个。然后你刚才那里斜杠后面是什么你就建立一个叫什么的 xml 文件，比如我写了 @xml/wallpaper，那就建立一个 wallpaper.xml 的文件，内容如下：\n1\n2\n3\n4\n5\n6\n&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;wallpaper\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:thumbnail=\"@drawable/ic_icon\"\n  android:description=\"@string/wallpaper_description\"\n  android:settingsActivity=\"xyz.alynx.livewallpaper.MainActivity\" /&gt;\n这里面也有些地方需要改，首先那个 @drawable/ic_icon 是你这个程序在系统的动态壁纸列表里面的图标（然而大部分定制的系统都忽略了这玩意），你可以用 Android Studio 在 res/drawable 目录下面生成一个，这个可以自己去查官方文档，ic_icon 要换成你生成的文件的名字。@string/wallpaper_description 则是你的程序在列表里的名字或介绍，这个格式的意思是去 res/values/strings.xml 或者其他语言的 strings.xml 里面找字符串（写过点复杂程序的人应该都懂吧！不懂自学去！我这不是教你怎么写代码！），你可以用 Android Studio 的字符串编辑器添加一条，然后把这里的键改成你添加的。最后一个 settingsActivity 是干嘛的呢？在预览动态壁纸的页面会有个设置按钮，如果你的动态壁纸可以设置参数，点击那个按钮会跳进动态壁纸设置页面，设置页面就是在这里指定的类，因为我设置项不多直接放菜单里了，所以我写的是直接跳进 MainActivity，你写的时候也可以这样，但记得换成你的包名（不换的人我怀疑你没写过 Java，那你学个毛 Android App 开发？）。\n废话终于说完了可以写代码了好开心啊……\n然后你看见网上一堆胶水代码……\n如果你找过网上的教程，你会觉得视频壁纸是很简单的，他们都告诉你播放视频有现成的组件，你只要写几行胶水代码把它和壁纸连起来就行了……\n行个头！要是那么简单我就不用写这一篇文章了好吗？\n我们先从最基础的知识开始，动态壁纸实际上是一个 Service，你去实现一个 Service，然后系统来调用，你需要继承一个叫做 WallpaperService 的类，实现里面的一些方法。但实际上这个类只是个包装，真正的工作代码是里面一个叫 Engine 的类，具体的动态壁纸实现都是在它里面。\n所以你需要建立一个随便你爱叫什么的 java 文件（我不会用 Kotlin，但你愿意的话也可以用）来存放你自己的 Service……或者用 Android Studio 的向导也不错。比如我的就叫 GLWallpaperService，里面的代码看起来大概像这样：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\npackage xyz.alynx.livewallpaper;\n\nimport android.service.wallpaper.WallpaperService;\n\npublic class GLWallpaperService extends WallpaperService {\n    public class GLWallpaperEngine extends Engine {\n\n    }\n\n    @Override\n    public Engine onCreateEngine() {\n        return new GLWallpaperEngine();\n    }\n}\n所以你看，你只需要实现 WallpaperService 的一个方法，就是在系统需要 Engine 的时候，返回你自己的 Engine 实例。\n然后你需要在你的 Engine（我的是 GLWallpaperEngine）里面实现一些系统要求的方法，我们先说最基础的几个：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n        @Override\n        public void onSurfaceCreated(SurfaceHolder surfaceHolder) {\n            super.onSurfaceCreated(surfaceHolder);\n        }\n\n        @Override\n        public void onVisibilityChanged(boolean visible) {\n            super.onVisibilityChanged(visible);\n        }\n\n        @Override\n        public void onSurfaceDestroyed(SurfaceHolder holder) {\n           super.onSurfaceDestroyed(holder);\n        }\n        @Override\n        public void onOffsetsChanged(\n            float xOffset, float yOffset,\n            float xOffsetStep, float yOffsetStep,\n            int xPixelOffset, int yPixelOffset\n        ) {\n            super.onOffsetsChanged(\n                xOffset, yOffset, xOffsetStep,\n                yOffsetStep, xPixelOffset, yPixelOffset\n            );\n        }\nAndroid 的动态壁纸实际上是一个 Surface（Android 的 Surface 你可以理解为画布……大概吧），系统调用你的 Engine，然后给你一个可以绘制的 SurfaceHolder，你只要往这个 SurfaceHolder 里面的 Surface 画东西就行了。onSurfaceCreated() 表示画布准备好了，onVisibilityChanged() 则表示画布看不见了或者又出来了，onSurfaceDestroyed() 表示画布没了（我不是你英语老师！），onOffsetsChanged() 则是桌面通知壁纸偏移量，通常是实现壁纸随桌面滚动的效果。\n不要把他们和 onCreate() 和 onDestoryed() 搞混了，那俩说的是 Engine，但我们做绘制工作时候操心的是画布。\n为什么说是个胶水代码呢……因为 Android 内建了一个播放器叫 MediaPlayer，它有个方法叫 setSurface()，可以把视频渲染到画布上，然后我们就美滋滋地看……到 bug。\n怎么设置 MediaPlayer 我就不讲了，因为网上有很多现成的，总之就是实例化设置静音设置来源再 setSurface(getSurfaceHolder().getSurface())（getSurfaceHolder() 是 Engine 的，可以获取当前的 SurfaceHolder），然后开始播放，你需要在 onSurfaceCreated() 的时候弄出个播放器，onSurfaceDestroyed() 的时候 release() 掉播放器，然后在由可见变成不可见的时候保存进度删掉播放器（其实暂停也行，但是暂停仍然占据着资源），在可见时候建立播放器并回复到之前的进度（如果看不见了还一直播，你手机的电池估计坚持不了几小时）。反正代码网上一大堆，我就不贴了。\n然后你就可以运行这个程序啦，如果你用的模拟器，你就美滋滋的发现，你的视频被硬生生压缩或拉伸成了桌面比例，视频比例没了。大部分视频应该都是横向更长一点，而手机竖向长，所以……\n如果你开始翻文档，你会发现一个 setVideoScalingMode() 的方法，可以设置为 FIT_WITH_CROPPING，你想着这不就是我们要的效果嘛：把视频放屏幕中间，然后裁出正中间最大的一块……当然不行啦！不然我写什么！\n很高兴告诉你这个其实是包装了系统的 MediaCodec 的参数，但这个实现及其不靠谱，比如在模拟器上这个功能根本就没实现！在我的 Galaxy S9+ 上虽然实现了，但在切换界面的时候（比如锁屏啦，打开应用界面啦），会突然变成没有剪裁的，总之你会看到一个奇怪的切换（这哪个程序员写的出来祭天）。\n所以如果你想正确剪裁视频的话……当然要自己动手！Android 的 View 是可以设置尺寸缩放没错，但是别忘了，这里只有 Surface，没有 View，所以没戏。用 CPU 剪裁视频的话（剪裁不是剪辑！）怕是你一帧剪完那边 30 帧都播完了，解决方案就是用 OpenGL ES 来进行这个操作。\n明明是杀鸡，还是得掏牛刀！\n如果你比较熟悉 OpenGL 的话，其实这个剪裁本身的难度比构建一个 OpenGL 环境的难度低的多……只要算一下比例做个缩放矩阵就行了，视频是矩形所以我们就先弄个正方形出来然后把每一帧解码的画面当成纹理贴上去。\n解码的工作我们可以交给 MediaPlayer，然后因为性能需要，我们不能每一帧都保存为图片然后再转读为 OpenGL 的纹理，Android 有一个 OpenGL 的扩展，可以把视频解码到的 Surface 作为一个纹理，大部分机型都支持，不支持的机型其实也可以告别动态壁纸了，啥都不支持，你还不给我钱，我为啥要给你写代码？\n但是这个过程需要一些 hack。\n显然系统不给你现成的 GLSurfaceView，而只是一个 SurfaceHolder，所以正常的思路是自己弄 GLThread 白手起家……并不，我们在 Engine 里插入下面的代码：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n        private class GLWallpaperSurfaceView extends GLSurfaceView {\n            private static final String TAG = \"GLWallpaperSurface\";\n\n            public GLWallpaperSurfaceView(Context context) {\n                super(context);\n            }\n\n            @Override\n            public SurfaceHolder getHolder() {\n                return getSurfaceHolder();\n            }\n\n            public void onDestroy() {\n                super.onDetachedFromWindow();\n            }\n        }\n看到那个 getHolder() 了吗？没错！GLSurfaceView 似乎内部自己有个 SurfaceHolder，我们 hack 一下它，扩展出一个 GLWallpaperSurfaceView，因为它是个内部类，当它要往自己的 SurfaceHolder 上渲染时，我们偷梁换柱，返回它 Engine.getSurfaceHolder()，可怜的家伙还蒙在鼓里，自己内部的 SurfaceHolder 已经没用了，现在它画的实际上是桌面壁纸的 Surface。\n我也不知道谁先想出的这个套路，但第一个想出这个办法的老哥可真是个天才。\n至于你问 Context 从哪来？Service 就是个 Context，所以你改写一下 Engine 的构造函数把 Service 传进去，然后创建 GLWallpaperSurfaceView 时传给它就行了，基本操作基本操作。\n然后我们就可以实现 GLSurfaceView.Renderer 了，这是个已经包装好的 OpenGL Renderer，我们只要负责在里面画就行了。至于 GLES 的版本，如果你想省事，只用 v2 就好了，除非像我一样对 v3 很熟悉，当然我 v2 v3 都写了 Renderer，能支持 v3 的先调用 v3（除了模拟器不支持，手机基本都支持了）。我这里用 v3 做例子，你应该自己也会写 v2 吧？如果你只会写固定管线，请你不要说自己会 OpenGL。\n当然最好在 AndroidManifest.xml 声明一下你这个应用需要的 GLES 版本：\n1\n2\n3\n&lt;uses-feature\n  android:glEsVersion=\"0x00020000\"\n  android:required=\"true\" /&gt;\n如果你只支持 v3，就把 2 改成 3。\n（已经进入这个阶段了，打算拿这个当“我的第一个 Android App”的同学就自己退出吧。）\n我直接帖完整代码解释好了，因为实在是不好一点点讲了，反正会写 OpenGL 的人应该也能理解这种程度的代码了。\n我先把 Shader 代码贴上来，我是把它们放在 res/raw 下面的，Android 会自动生成 R.raw. 的 ID。\n\nvertex shader\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n#version 300 es\n\n// Some Android phone driver needs to put pre-processor in the first line. (e.g. Huawei Kirin)\n\nlayout(location = 0) in vec2 in_position;\nlayout(location = 1) in vec2 in_tex_coord;\n\nuniform mat4 mvp;\n\nout vec2 tex_coord;\n\nvoid main() {\n    gl_Position = mvp * vec4(in_position, 1.0f, 1.0f);\n    tex_coord = in_tex_coord;\n}\n应该在你画三角形的时候就学会这玩意了吧？注意有些手机的实现要求第一行不能是注释，否则会报错。\n\nfragment shader\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n#version 300 es\n#ifdef GL_OES_EGL_image_external_essl3\n#extension GL_OES_EGL_image_external_essl3 : require\n#else\n#extension GL_OES_EGL_image_external : require\n#endif\n\n// Some Android phone driver needs to put pre-processor in the first line. (e.g. Huawei Kirin)\n\nprecision mediump float;\n\nuniform samplerExternalOES frame;\n\nin vec2 tex_coord;\nout vec4 frag_color;\n\nvoid main() {\n    frag_color = texture(frame, tex_coord);\n}\n注意开头的判断！本来在 GLESv3 里面，对这种 Android 直接拿 Surface 当纹理的 flag 是 GL_OES_EGL_image_external_essl3，GL_OES_EGL_image_external 已经被废弃了，但有些支持 GLESv3 的手机只支持旧的表达方法，所以我们判断一下就好。GLESv2 则直接用后面那个，不要用前面的。\n同样，纹理类型也要换成 samplerExternalOES，别的都没关系了。\n编译和链接的过程我直接写成工具函数了，连同加载 res/raw 的代码，我贴上来：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\nstatic int compileShaderResourceGLES30(\n    @NonNull Context context,\n    final int shaderType,\n    final int shaderRes\n) throws RuntimeException {\n    final InputStream inputStream = context.getResources().openRawResource(shaderRes);\n    final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n    String line;\n    final StringBuilder stringBuilder = new StringBuilder();\n    try {\n        while ((line = bufferedReader.readLine()) != null) {\n            stringBuilder.append(line);\n            stringBuilder.append('\\n');\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        return 0;\n    }\n    final String shaderSource = stringBuilder.toString();\n    int shader = GLES30.glCreateShader(shaderType);\n    if (shader == 0) {\n        throw new RuntimeException(\"Failed to create shader\");\n    }\n    GLES30.glShaderSource(shader, shaderSource);\n    GLES30.glCompileShader(shader);\n    final int[] status = new int[1];\n    GLES30.glGetShaderiv(shader, GLES30.GL_COMPILE_STATUS, status, 0);\n    if (status[0] == 0) {\n        final String log = GLES30.glGetShaderInfoLog(shader);\n        GLES30.glDeleteShader(shader);\n        throw new RuntimeException(log);\n    }\n    return shader;\n}\n\nstatic int linkProgramGLES30(\n    final int vertShader,\n    final int fragShader\n) throws RuntimeException {\n    int program = GLES30.glCreateProgram();\n    if (program == 0) {\n        throw new RuntimeException(\"Failed to create program\");\n    }\n    GLES30.glAttachShader(program, vertShader);\n    GLES30.glAttachShader(program, fragShader);\n    GLES30.glLinkProgram(program);\n    final int[] status = new int[1];\n    GLES30.glGetProgramiv(program, GLES30.GL_LINK_STATUS, status, 0);\n    if (status[0] == 0) {\n        final String log = GLES30.glGetProgramInfoLog(program);\n        GLES30.glDeleteProgram(program);\n        throw new RuntimeException(log);\n    }\n    return program;\n}\n当然还是那个令人头疼的问题，你需要传个 Context，这个问题不大，Engine 创建 Renderer 的时候传给它就好了。\nRenderer 则是按下面的写：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\npackage xyz.alynx.livewallpaper;\n\nimport android.content.Context;\nimport android.opengl.GLSurfaceView;\nimport android.support.annotation.NonNull;\n\npublic class GLWallpaperRenderer implements GLSurfaceView.Renderer {\n    private static final int BYTES_PER_FLOAT = 4;\n    private static final int BYTES_PER_INT = 4;\n    private Context context;\n    private FloatBuffer vertices;\n    private FloatBuffer texCoords;\n    private IntBuffer indices;\n    private float[] mvp;\n    private int program = 0;\n    private int mvpLocation = 0;\n    private int[] textures;\n    private SurfaceTexture surfaceTexture = null;\n    private int screenWidth = 0;\n    private int screenHeight = 0;\n    private int videoWidth = 0;\n    private int videoHeight = 0;\n    private int videoRotation = 0;\n    private float xOffset = 0;\n    private float yOffset = 0;\n    private long updatedFrame = 0;\n    private long renderedFrame = 0;\n上面这部份的变量都是一会要用到的，一会再说。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n    GLWallpaperRenderer(@NonNull final Context context) {\n        this.context = context;\n\n        // Those replaced glGenBuffers() and glBufferData().\n        final float[] vertexArray = {\n            // x, y\n            // bottom left\n            -1.0f, -1.0f,\n            // top left\n            -1.0f, 1.0f,\n            // bottom right\n            1.0f, -1.0f,\n            // top right\n            1.0f, 1.0f\n        };\n        vertices = ByteBuffer.allocateDirect(\n            vertexArray.length * BYTES_PER_FLOAT\n        ).order(ByteOrder.nativeOrder()).asFloatBuffer();\n        vertices.put(vertexArray).position(0);\n\n        final float[] texCoordArray = {\n            // u, v\n            // bottom left\n            0.0f, 1.0f,\n            // top left\n            0.0f, 0.0f,\n            // bottom right\n            1.0f, 1.0f,\n            // top right\n            1.0f, 0.0f\n        };\n        texCoords = ByteBuffer.allocateDirect(\n            texCoordArray.length * BYTES_PER_FLOAT\n        ).order(ByteOrder.nativeOrder()).asFloatBuffer();\n        texCoords.put(texCoordArray).position(0);\n\n        final int[] indexArray = {\n            0, 1, 2,\n            3, 2, 1\n        };\n        indices = ByteBuffer.allocateDirect(\n            indexArray.length * BYTES_PER_INT\n        ).order(ByteOrder.nativeOrder()).asIntBuffer();\n        indices.put(indexArray).position(0);\n\n        textures = new int[1];\n\n        mvp = new float[] {\n            1.0f, 0.0f, 0.0f, 0.0f,\n            0.0f, 1.0f, 0.0f, 0.0f,\n            0.0f, 0.0f, 1.0f, 0.0f,\n            0.0f, 0.0f, 0.0f, 1.0f\n        };\n    }\n\n    @NonNull\n    public Context getContext() {\n        return context;\n    }这部份很好懂吧？先处理 Context，然后我们准备 OpenGL 需要的坐标，正方形的模型坐标，纹理坐标，以及一个索引 buffer，不同的是在 Android 里面不用写 glGenBuffers、glBindBuffer 了，我们用 java 的 nio 准备数组，然后 Android 可以直接加载这里面的 buffer。（但是 mvp 矩阵仍然是数组。）\n当然，这里是没有 OpenGL 的上下文的，所以我们现在不能处理 OpenGL 的设置，需要实现下面这些方法：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n42\n43\n44\n45\n46\n47\n48\n49\n50\n51\n52\n53\n54\n55\n56\n57\n58\n59\n60\n61\n62\n63\n64\n65\n66\n67\n68\n69\n70\n71\n72\n73\n74\n75\n76\n77\n78\n79\n80\n    @Override\n    public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) {\n        // No depth test for 2D video.\n        GLES30.glDisable(GLES30.GL_DEPTH_TEST);\n        GLES30.glDepthMask(false);\n        GLES30.glDisable(GLES30.GL_CULL_FACE);\n        GLES30.glDisable(GLES30.GL_BLEND);\n\n        GLES30.glActiveTexture(GLES30.GL_TEXTURE0);\n        GLES30.glGenTextures(textures.length, textures, 0);\n        GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textures[0]);\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_MIN_FILTER,\n            GLES30.GL_LINEAR\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_MAG_FILTER,\n            GLES30.GL_LINEAR\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_WRAP_S,\n            GLES30.GL_CLAMP_TO_EDGE\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_WRAP_T,\n            GLES30.GL_CLAMP_TO_EDGE\n        );\n\n        program = Utils.linkProgramGLES30(\n            Utils.compileShaderResourceGLES30(\n                context, GLES30.GL_VERTEX_SHADER, R.raw.vertex_30\n            ),\n            Utils.compileShaderResourceGLES30(\n                context, GLES30.GL_FRAGMENT_SHADER, R.raw.fragment_30\n            )\n        );\n        mvpLocation = GLES30.glGetUniformLocation(program, \"mvp\");\n        // Position is set in shader sources.\n        GLES30.glVertexAttribPointer(\n            0, 2, GLES30.GL_FLOAT,\n            false, 0, vertices\n        );\n        GLES30.glVertexAttribPointer(\n            1, 2, GLES30.GL_FLOAT,\n            false, 0, texCoords\n        );\n\n        GLES30.glEnableVertexAttribArray(0);\n        GLES30.glEnableVertexAttribArray(1);\n    }\n\n    @Override\n    public void onSurfaceChanged(GL10 gl10, int width, int height) {\n        GLES30.glViewport(0, 0, width, height);\n    }\n\n    @Override\n    public void onDrawFrame(GL10 gl10) {\n        if (surfaceTexture == null) {\n            return;\n        }\n\n        if (renderedFrame &lt; updatedFrame) {\n            surfaceTexture.updateTexImage();\n            ++renderedFrame;\n            // Utils.debug(\n            //     TAG, \"renderedFrame: \" + renderedFrame + \" updatedFrame: \" + updatedFrame\n            // );\n        }\n\n        GLES30.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);\n        GLES30.glUseProgram(program);\n        GLES30.glUniformMatrix4fv(mvpLocation, 1, false, mvp, 0);\n        GLES30.glDrawElements(GLES30.GL_TRIANGLES, 6, GLES30.GL_UNSIGNED_INT, indices);\n    }\n这部份方法看名字就能看出来，需要注意的是那个 gl10 是 GLESv1 的用法，至于 v2 和 v3 都改成静态类了，所以我们用不到它。既然是 2D 贴图，就不需要深度测试和背面剔除了。然后设置纹理参数时需要用 GLES11Ext.GL_TEXTURE_EXTERNAL_OES，这个和 shader 里面是关联的。（哪个家伙把 GLESv2 和 v3 都支持的变量归属到 GLES11Ext 的，出来挨打！），别的地方会 OpenGL 的人都能看懂吧？最后，只有这三个函数有 OpenGL 上下文，其它的里面不能执行 OpenGL 操作。\n绘图时候 设置 mvp 矩阵不要用 nio 的 ByteBuffer，虽然有一个多态函数可以用，但似乎那个函数不能工作，所以我直接使用了 float 数组。\n下面是一些针对这个程序用到的方法。\n1\n2\n3\n4\n5\n6\n7\n    @Override\n    void setSourcePlayer(@NonNull final SimpleExoPlayer exoPlayer) {\n        // Re-create SurfaceTexture when getting a new player.\n        // Because maybe a new video is loaded.\n        createSurfaceTexture();\n        exoPlayer.setVideoSurface(new Surface(surfaceTexture));\n    }这里是让播放器把解码的目标位置设置成 Renderer 里面和 OpenGL 纹理绑定的 SurfaceTexture 上，这个类是 Android 专门设置用来干这个的，可以阅读手册。\n为什么是把播放器给 Renderer 让 Renderer 设置呢？因为 Engine 的生命周期里只用了一个 Renderer 但会经常释放重建 Player，每次都要重新建立对应视频大小的 SurfaceTexture，所以不能让 Renderer 暴露 SurfaceTexture 出去。\n我这里没有用 MediaPlayer，而是用了 Google 的 ExoPlayer 这个项目，具体原因一会再说。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n    @Override\n    void setScreenSize(int width, int height) {\n        if (screenWidth != width || screenHeight != height) {\n            screenWidth = width;\n            screenHeight = height;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set screen size to %dx%d\", screenWidth, screenHeight\n            ));\n            updateMatrix();\n        }\n    }\n\n    @Override\n    void setVideoSizeAndRotation(int width, int height, int rotation) {\n        // MediaMetadataRetriever always give us raw width and height and won't rotate them.\n        // So we rotate them by ourselves.\n        if (rotation % 180 != 0) {\n            final int swap = width;\n            width = height;\n            height = swap;\n        }\n        if (videoWidth != width || videoHeight != height || videoRotation != rotation) {\n            videoWidth = width;\n            videoHeight = height;\n            videoRotation = rotation;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set video size to %dx%d\", videoWidth, videoHeight\n            ));\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set video rotation to %d\", videoRotation\n            ));\n            updateMatrix();\n        }\n    }因为要计算缩放，所以我这里设置了两个方法，分别获取屏幕尺寸和视频尺寸。然后只要在每次尺寸变化时候重新计算矩阵就行了，因为不是经常变化，所以就不用每次绘制都重新计算。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n    @Override\n    void setOffset(float xOffset, float yOffset) {\n        final float maxXOffset = (1.0f - (\n            (float)screenWidth / screenHeight) / ((float)videoWidth / videoHeight)\n        ) / 2;\n        final float maxYOffset = (1.0f - (\n            (float)screenHeight / screenWidth) / ((float)videoHeight / videoWidth)\n        ) / 2;\n        if (xOffset &gt; maxXOffset) {\n            xOffset = maxXOffset;\n        }\n        if (xOffset &lt; -maxXOffset) {\n            xOffset = -maxXOffset;\n        }\n        if (yOffset &gt; maxYOffset) {\n            yOffset = maxYOffset;\n        }\n        if (yOffset &lt; -maxXOffset) {\n            yOffset = -maxYOffset;\n        }\n        if (this.xOffset != xOffset || this.yOffset != yOffset) {\n            this.xOffset = xOffset;\n            this.yOffset = yOffset;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set offset to %fx%f\", this.xOffset, this.yOffset\n            ));\n            updateMatrix();\n        }\n    }桌面在滑动的时候会调用 Engine 的方法告诉它滑动的值，为了实现视频随桌面平移的效果，我们可以在 Engine 里把值传给 Renderer，但我们要限制一下，偏移的位置不能超出视频尺寸，否则就出黑边了。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n    private void createSurfaceTexture() {\n        if (surfaceTexture != null) {\n            surfaceTexture.release();\n            surfaceTexture = null;\n        }\n        updatedFrame = 0;\n        renderedFrame = 0;\n        surfaceTexture = new SurfaceTexture(textures[0]);\n        surfaceTexture.setDefaultBufferSize(videoWidth, videoHeight);\n        surfaceTexture.setOnFrameAvailableListener(new SurfaceTexture.OnFrameAvailableListener() {\n            @Override\n            public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n                ++updatedFrame;\n            }\n        });\n    }需要注意这个函数里面的回调，为什么要设置一个计数器，而不是直接在这里执行 SurfaceTexture.updateTexImage() 呢？因为后者要求必须有 OpenGL 上下文……有上下文的只有之前的几个方法，其它是没有的。所以为什么这里用了两个计数器而不是一个 bool 变量呢（请自己回看 onDrawFrame() 函数）？因为这个 SurfaceTexture 内部似乎有排队机制，然后如果队列里有内容的话是不会调回调的……假如某一次传来了多于一帧，用 bool 变量翻转的时候就只能解决第一帧，后续视频就会卡住（这都是什么神仙写的 bug 啊喂！）。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n31\n32\n33\n34\n35\n36\n37\n38\n39\n40\n41\n    private void updateMatrix() {\n        // Players are buggy and unclear, so we do crop by ourselves.\n        // Start with an identify matrix.\n        for (int i = 0; i &lt; 16; ++i) {\n            mvp[i] = 0.0f;\n        }\n        mvp[0] = mvp[5] = mvp[10] = mvp[15] = 1.0f;\n        // OpenGL model matrix: scaling, rotating, translating.\n        final float videoRatio = (float)videoWidth / videoHeight;\n        final float screenRatio = (float)screenWidth / screenHeight;\n        if (videoRatio &gt;= screenRatio) {\n            Utils.debug(TAG, \"X-cropping\");\n            // Treat video and screen width as 1, and compare width to scale.\n            Matrix.scaleM(\n                mvp, 0,\n                ((float)videoWidth / videoHeight) / ((float)screenWidth / screenHeight),\n                1, 1\n            );\n            // Some video recorder save video frames in direction differs from recoring,\n            // and add a rotation metadata. Need to detect and rotate them.\n            if (videoRotation % 360 != 0) {\n                Matrix.rotateM(mvp, 0, -videoRotation, 0,0, 1);\n            }\n            Matrix.translateM(mvp, 0, xOffset, 0, 0);\n        } else {\n            Utils.debug(TAG, \"Y-cropping\");\n            // Treat video and screen height as 1, and compare height to scale.\n            Matrix.scaleM(\n                mvp, 0, 1,\n                ((float)videoHeight / videoWidth) / ((float)screenHeight / screenWidth), 1\n            );\n            // Some video recorder save video frames in direction differs from recoring,\n            // and add a rotation metadata. Need to detect and rotate them.\n            if (videoRotation % 360 != 0) {\n                Matrix.rotateM(mvp, 0, -videoRotation, 0,0, 1);\n            }\n            Matrix.translateM(mvp, 0, 0, yOffset, 0);\n        }\n        // This is a 2D center crop, so we only need model matrix, no view and projection.\n    }\n}最后是计算矩阵，这里也很简单，只要注意计算时候，要分别以视频和屏幕最长的一条边作为单位一，然后分别缩放两者的另一侧，只是数学计算而已。然后为什么会有旋转呢？如果你不写旋转而又使用手机拍摄的竖屏视频做壁纸，就会发现方向是旋转了 90 度的，所以宽和高也都错了。原因是一些设备录像时候不会旋转帧内容，而是以传感器原生的方向存放像素，然后在视频 Metadata 里面记录一下旋转角度，由播放器做旋转。MediaPlayer 自己直接输出是会旋转的，但由于我们这里用它做解码器，所以它传过来的帧是原样的。\n解决方法是在 Engine 加载视频的时候先读取一下元数据，从元数据里获取视频的尺寸旋转量设置给 Renderer：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n23\n24\n25\n26\n27\n28\n29\n30\n        private void getVideoMetadata() throws IOException {\n            final MediaMetadataRetriever mmr = new MediaMetadataRetriever();\n            switch (wallpaperCard.getType()) {\n            case INTERNAL:\n                final AssetFileDescriptor afd = getAssets().openFd(wallpaperCard.getPath());\n                mmr.setDataSource(\n                    afd.getFileDescriptor(),\n                    afd.getStartOffset(),\n                    afd.getDeclaredLength()\n                );\n                afd.close();\n                break;\n            case EXTERNAL:\n                mmr.setDataSource(context, wallpaperCard.getUri());\n                break;\n            }\n            final String rotation = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION\n            );\n            final String width = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH\n            );\n            final String height = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT\n            );\n            mmr.release();\n            videoRotation = Integer.parseInt(rotation);\n            videoWidth = Integer.parseInt(width);\n            videoHeight = Integer.parseInt(height);\n        }\n当然 WallpaperCard 是我自己封装的类，关系不大。总之是使用 MediaMetadataRetriever 就可以了。至于你说视频元数据和实际内容不符怎么办？那是用户问题，用户自己处理不好视频为什么要我来解决？随便让他拿电脑上修改一下好了。\n这些实际上是这个应用的核心内容，其它的播放之类的都大同小异，总之如果你实现了 OpenGL 的剪裁功能，应该就可以正常播放壁纸了。其它部分直接参考我的代码或者网上的样例就可以了。\n顺便说一下，SurfaceTexture 似乎会给一个纹理矩阵，但我试着用了一下发现并不是需要的效果……所以还是自己处理吧。\n然后声音又不对劲了……\n就算你给 MediaPlayer 设置了静音，还是不太对劲！正常来说在桌面按音量键设置的是铃声音量，为什么变成了媒体音量！\n这当然是因为虽然 MediaPlayer 虽然静音了，但还是占据着音频通道，我们都知道 Android 分为媒体、铃声、系统等音量通道，如果 MediaPlayer 一直占着媒体通道，其它的媒体 App 比如音乐播放器一类的就没有办法播放。\n使用 MediaPlayer 是没有解决办法的，因为它没提供关闭音轨的接口，一开始我差点基于 MediaCodec 自己编写一个视频播放器，但始终没办法把解码器从主线程转移开，而且 CPU 占用率很高。后来发现 ExoPlayer 有办法关闭音轨，所以我换成了 ExoPlayer。\n具体怎么引入 ExoPlayer 请参照官方文档，只要引入 core 部分就可以了。\n我这里给出一段用于关闭音轨的代码，网上不太好找：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n            trackSelector = new DefaultTrackSelector();\n            exoPlayer = ExoPlayerFactory.newSimpleInstance(context, trackSelector);\n            exoPlayer.setVolume(0.0f);\n            // Disable audio decoder.\n            final int count = exoPlayer.getRendererCount();\n            for (int i = 0; i &lt; count; ++i) {\n                if (exoPlayer.getRendererType(i) == C.TRACK_TYPE_AUDIO) {\n                    trackSelector.setParameters(\n                        trackSelector.buildUponParameters().setRendererDisabled(i, true)\n                    );\n                }\n            }\n主要是创建 Player 时候单独给它一个 DefaultTrackSelector。然后关掉音轨。\n这样大概就可以运行了，剩下的一些问题都和视频渲染无关。\n写 UI 也很麻烦！\n虽然我知道你肯定不满足只使用内嵌视频，但如果你像我一样写了个可以设置其它视频的 UI，就会遇到各种各样的问题。写 UI 的时候，你不是在编写回调函数，就是在调用回调函数的路上。\n最令人恶心的是 Context 管理，很多地方都需要 Context，但很多地方都没法传 Context，比如 Android 推荐你用 Uri 而不是直接用文件路径，但所有使用 Uri 的地方都要求你传 Context 来解析 Uri！比如我添加视频，需要解析 Uri 并生成缩略图，为了不阻塞线程，必须开启一个 AsyncTask，但是，AsyncTask 不能直接拿走 MainActivity 作为自己的 Context！必须要传弱引用，总之没有一个优雅的解决方案。\n再比如你需要一些在各个位置都能访问到的数据，你可以自己写一个 Application 类并给它静态变量，但是静态和动态不能互相交叉，也就是说你不能封装一个操作数据的同时需要访问 Context 的方法，所以很多地方就只能拆开写，没办法封装。\n以及列表和数据的绑定写起来真的很麻烦，说实在的，HTML 和 JavaScript 写 UI 真的比 Android 和 Java 舒服的多……\n顺便，你可能会想在 UI 里调用系统的动态壁纸预览，然后根据它返回的结果来设置选中的视频，但这个真的很不靠谱，比如某些版本的 MIUI 修改的预览器即使你点击了应用，它仍然会返回一个取消的结果。明明是 MIUI 的问题，却需要我来解决，我大概可以理解为什么 sway 的开发者大骂 NVIDIA 用户了。你们给了小米钱买它的手机和系统，然后小米造成的问题要我来解决，我一分钱都没有拿到，哪里来的义务和责任解决？？？\n当然我最后还是想办法绕开了，添加了一个单独的应用按钮，用户点击这个按钮就是忽略预览，直接设置为壁纸。\n动态壁纸预览器调用你的壁纸服务的时候，你的 Engine 里 isPreview() 方法会返回 true，可以根据这个判断是不是在预览状态。因为我只有一个壁纸服务，所以我做了一些判断，对预览和桌面分别做了一些不同了逻辑，以便防止预览的结果影响到本来桌面上的壁纸效果。\n最后要注意：你可以在 Service 里面访问 Application 的静态方法，但似乎你不能一直依靠这个。比如当你设置壁纸以后重启了，Service 会被启动，但这时似乎没办法访问到 Application 里的变量。我解决的办法是将数据写入到 SharedPreference，如果从 Application 加载失败就去读取 SharedPreference，但总之我没找到有关 Service 和 Application 会不会一起创建的说明，所以这部份的代码写的很混乱（也包含上面说的不能封装的原因）。\n一杯咖啡都没有……\n如果你只是觉得市面上所有的视频动态壁纸程序都太臃肿太不可靠（包括抖音和火萤）而想自己写一个，我建议你还是放弃，因为遇到的坑比你想象的多，解决起来也很麻烦。而且实际上，你完全可以使用我写好的程序。\n这个程序只有 3.06M，支持加载本地壁纸，支持平板电脑，支持壁纸滑动，不显示时自动暂停播放节约电量，严格遵循 Android 规范，没有任何敏感权限（比如联网和操作外置存储），不请求文件真实路径，测试下来功能基本没有问题。如果你还不放心，所有的代码都在 GitHub 上，我不怕你说我代码写的不好，你大可以看一遍有没有后门。\n你可以分别从 GitHub Release，Google Play 和 酷安网 下载这个应用。\n为了上架 Google Play 我支付了 25 美元申请了开发者账户，应用是免费的，但我放置了捐赠页面。不过已经有几百个下载量（大部分是酷安）之后，我还没有从这个应用里得到一点回报，如果你觉得应用不错并且手头宽裕，可以打开 App 赞助我一杯咖啡。毕竟解决上面提到的所有的坑并不容易。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"在中国 Android 环境下传个 APK 有多难","url":"/posts/Hard-to-Transfer-APK-with-Chinese-Android/","content":"事情的起因是这样的，我写了 一个 Android App，打算把它发给更多的人试用，发给同学什么的都好说，但我想发给我妈用的时候遇到了一系列问题。我觉得恰好可以说一下在国内用 Android 环境是多么痛苦。\n\n\n首先尝试最简单的方法，不是所有人都有 QQ，但差不多所有人都有微信，特别是一些中年的亲戚，所以直接在微信里传送 APK 文件，然后失败了。微信自作聪明地给 APK 加了 .1 的后缀名，不用想都知道理由：“哎呀我们的用户都是可爱的啥都不会的小宝宝，要为了他们安全考虑呢”。\n微信失败了，那就换个方式吧，发个网址去下载 APK，应该就不会被改名了，所以我直接复制了 GitHub Release 的链接，然后大家一概回复：“这个网址打不开”。\n行吧，开个 GitHub 都要折腾来折腾去的地方学习写代码有多艰难我就不哭诉了，那我们换个网站，我记得两个月前酷安网还是可以在电脑上下载 APK 的，我就把我上架之后的链接发了过去。不一会我妈说：“你这个链接让我 下载他的那个市场，然后 微信里要下载还得装 QQ 浏览器”，我妈还是有在这个艰难环境下使用手机电脑的知识的，所以看到要装这些乱七八糟的就放弃了。\n打开电脑一看，没想到啊没想到，酷安你这个浓眉大眼的家伙也叛变革命了。我不知道是哪个闲鱼用多了自己脑袋都咸了的产品经理一拍脑袋删掉了网站的搜索框，然后又关掉了 APK 的下载渠道。为了秉持优雅，我就不在这里问候这个经理的家人了。\n事已至此，总不能用百度云吧？靠百度云的限速估计能下载到猴年，我觉得百度除了竞价排名技术，网盘限速技术也是独步全球，而且似乎百度云稍微大一点的文件就让你下客户端？虽然我对我应用的体积很有信心，但也不想再趟混水了。\n我不知道别的开发者怎么分发他们的安装包，但我不想备案，也不想为了 APK 一直掏钱供着一个国内服务器，而且 要想在微信能访问域名，还得给腾讯交保护费，否则说你不安全，去哪说理去？\n后来我还是把文件传到服务器上然后用 IP 做了个链接，我自己的电脑能下载，但 微信内置浏览器就是不行。\n我可以教我妈怎么找到微信的下载文件然后修改后缀名，但是别人呢？我妈想把这个应用介绍给身边人试试，有些人连文件管理都没开过，总不能一个一个教他们吧？打包更不现实了，什么是 zip 什么是 tar 和你七大姑八大姨的工作生活可能一点关系都没有，当然也不是所有人工作都用 Email，大家都要恰饭，生活已经很艰难了。\n别说多提交几个商店，每次发新版本 GitHub Google Play 和酷安三个一起更新填表就已经花了好多时间了，每个品牌的手机都非得做一个自己的商店，用户量不大要求还不少，谁有那好心一个个提交去。\n这肯定不是 Android 的问题，毕竟如果能用 Google Play 问题就不存在了，或者如果能用 Telegram 这种聊天软件也行，但如果你是鸡群里的鹤，怕不是会被鸡群起而攻之。至于 Firefox Send 什么的估计在国内也没戏。这个时候我甚至开始怀念 QQ 了，虽然流氓，但是还是能传文件的。\n但说到 QQ，我又想起了几年前的事情，我相当佩服 QQ 的开发者这种在一个软件里打两个包的技术，当你用 QQ 点开一个网页链接，然后点菜单选“用 QQ 浏览器打开”的时候，你会发现 QQ 内嵌了一个 QQ 浏览器 —— 怪不得 QQ 浏览器有脸说自己装机量第一，以前我以为是很多人蠢瞎了用这种垃圾，后来发现我失算了 —— 当然最魔幻的不止于此，这个内嵌的 QQ 浏览器版本当然是很旧的，所以你打开了之后它第一件事是让你下载安装最新的 QQ 浏览器 —— 你看一个人能装两个 QQ 浏览器，发明这个技术的产品经理真是个小天才，他推动了手机存储空间上升！跟他比起来苹果算个什么东西！\n现在 QQ 的体积还是巨无霸，这个按钮也依然在那里，大概 QQ 浏览器仍然嵌在里面吧，而且估计版本一直都没变过，毕竟能变成俩鸡蛋的双黄蛋大家都喜欢。祝 QQ 未来能把其他所有腾讯的应用都嵌进去，早日突破 1 GB 大关。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"GNOME 的修改开发与测试","url":"/posts/GNOME-Develop/","content":"对于一些 GNOME 比较核心的程序比如 GNOME Shell，调试的时候没办法简单的运行，需要构建一个隔离的环境然后替代系统的 WM。GNOME 项目使用 JHBuild 构建这个环境。我的系统是 Arch Linux，介绍一下中间遇到的一些问题。\n\n\ngitlab.gnome.org 这个网站国内访问很慢，而且 jhbuild 使用 git clone 有时候不会遵循 git 的代理设置（指 git config --global http.proxy &#39;socks5://127.0.0.1:1080&#39; &amp;&amp; git config --global https.proxy &#39;socks5://127.0.0.1:1080&#39;），经常不好用，我家里的网又不太好。我改 GNOME Shell 代码只用了一小时，但下载和编译环境来测试用了两天一夜。\n我调试的是 GNOME Shell，首先按照 说明页面 安装 JHBuild，将安装到的 ~/.local/bin 加入 PATH，然后建立 ~/jhbuild 目录，运行 jhbuild build gnome-shell 会自动下载编译所有需要的依赖（大概 80 个）。\nJHBuild 编译下载一些包的时候经常会出问题，一般编译一个包有四个阶段：\n\ncheckout：clone 仓库，设置 origin，然后 fetch。\nconfigure：运行 autogen.sh，configure 或者 meson。\nbuild：make 或者 ninja。\ninstall：就是 install，目的地是 JHBuild 的环境。\n\n按了 Ctrl+C 之后会给几个选项，第一个通常是继续当前阶段，第二个是进行下一阶段，第三个是放弃当前的包，第四个是开一个 shell 子程序，第五个是刷新配置文件，对于 JHBuild 不走代理 clone 没速度的时候可以先 Ctrl+C，然后开启 shell，自己手动 clone，然后 Ctrl+D 退出 Shell 回到 JHBuild，这时候会继续让你选择，如果是 checkout 的话选择继续当前阶段，它会发现你同步好了。\n如果是某个包需要特殊操作，默认的参数配置不过去的话，建议也是 Ctrl+C 开 shell 手动运行 ./autogen.sh 之类的，然后选择下一阶段（configure 的下一阶段是 build），如果继续的话它会再 configure 一遍，就覆盖了你的。虽然可以在 JHBuild 配置文件里添加某个包的参数，但是似乎我也搞不清楚 JHBuild 什么时候重新加载配置，经常选了 5 它没变化，把配置文件对应的行删掉它又加上了之前的参数。\n反正 JHBuild 搞不定的都手动搞定然后切换下一阶段基本都可以。\ncolord 这个包的 man page 构建时候依赖 docbook-xsl-ns，这个包在 AUR 里，但是装上了它也检测不到，所以建议添加 -Dman=false 到 autogen.sh 的参数，关闭 man page 的生成，反正也用不到（所以 Arch 官方的打包姬怎么打包的啊！）。\nwebkitgtk 不负众望是编译起来最慢的，几年前用 Gentoo 的时候轻松两小时（我当时 Skylake 移动版 Xeon E3-1505M 可是最强的笔记本 CPU），最近有改善了，但还是要半个小时多。\nibus 配置的时候需要加 --with-ucd-dir=/usr/share/unicode/ 不然它默认去 /usr/share/unicode/ucd/ 找文件但 Arch 打包的路径不是这个。\nlibgdata 不支持 automake-1.16，需要降级到 1.15 来 configure，但是生成的 Makefile 有一句没展开的宏（我这里是 4141 行的 @CODE_COVERAGE_RULES@）（开发者出来修 bug ！），需要注释掉，然后 make 就可以过了，似乎没啥不利影响。\nuhttpmock 的来源 URL 搞错了，现在指向的旧的是被废弃的仓库，新仓库是 这个，需要修改 ~/.config/jhbuildrc 添加 branches[&#39;uhttpmock&#39;] = (&#39;https://gitlab.com/uhttpmock/uhttpmock.git&#39;, &#39;master&#39;)。\n都编译完就可以用 jhbuild run gnome-shell --replace 启动你编译的版本了，其他的 GNOME 程序编译的也可以 run 比如 jhbuild run dconf-editor。但是用 wayland 会话似乎既不能直接运行 gnome-shell --replace 也不能 gnome-shell --nested （像 weston 小窗口一样，但 gnome-shell 有 lock），所以我用的 x11 测试。测试时候不要锁屏不要看 lookingGlass，锁屏了回去就会没法输密码解锁，看了 lookingGlass 之后我卡住了……测试完最好重启，不然似乎没啥简单办法回到你系统的程序里。\n没搞清楚怎么修改 jhbuild 的仓库来源，也就是说它只会去 GNOME/gnome-shell clone 但没法改成你 fork 的仓库，我只能把改过的文件复制到 ~/jhbuild/checkout 目录下面对应的仓库里，然后 jhbuild buildone -n gnome-shell，buildone 的意思是不管其他依赖，只重新编译后面的（用 build 会依次检查依赖，很慢的！），-n 是就算仓库被改了也不要重新 checkout，不然你的文件就被覆盖回去了……\n哦对了，GNOME Shell 有个单独的 gnome-shell-sass 的仓库存放样式表（CSS/SASS），但看说明这是个只读仓库，是从 gnome-shell 里分离出来给别的扩展用的，所以直接修改 gnome-shell 里面的就好了。还有一般跟顶栏有关的 GSettings 选项都在 org.gnome.desktop.interface 下面，但是这些 schema 对应的 XML 文件都在一个叫 gsettings-desktop-schemas 的仓库里，所以需要去那边改。\n最后狠狠地吐槽一下砍掉 GNOME Shell 顶栏透明的老哥，为了一点点边缘情况（有人说高对比度颜色壁纸下看不清顶栏文字，但大部分人都看得清并且实在不行换壁纸呗！）就砍掉这个好评如潮的功能。我提了个添加一个 GSettings 选项，让顶栏根据选项决定是透明还是纯黑（壁纸看不清就设成纯黑呗），结果被这个老哥拒绝了，还说添加个选项只会阻止其他人修 bug……大部分人都不觉得这是个 bug 好吗？我不觉得程序识别壁纸颜色改变顶栏会比用户自己调更准确，Android 的变色顶栏过了这么久，在许多壁纸上也不能正确识别颜色，添加一个让用户自己选择的功能才会更方便。但我又不想因为一个奇葩老哥就放弃我这么久的 GNOME 使用习惯，看来还是等等看能折腾出什么名堂吧！\n等到 GNOME 3.32 释出稳定版之后我尽量生成一个透明顶栏的 patch 就好了，反正主要的代码都是前人做的，大概 Arch Linux CN 的源愿意接受一个新包。不要和那个奇葩老哥一样说为啥不写扩展，就算是程序员家里养的猫也该知道 GNOME Shell 扩展 API 经常变还经常把整个桌面搞崩，真亏他们好意思提出来！\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"Linux 下面常见的代理设置","url":"/posts/Proxy-Settings/","content":"通常情况下在 Linux 下面配置好的是 socks5 代理（你懂的），但是这个代理并不能让所有程序自动走它，需要手动的做一些转换。\n\n\nproxychains\nproxychains 通过 hook libc 里面网络访问的函数实现劫持流量经过代理，配置时首先编辑 /etc/proxychains.conf 添加一行有关自己的代理的配置比如\n1\nsocks5 [IP 地址] [端口号]然后就可以将你需要走代理的程序跟在 proxychains 后面比如\n1\n$ proxychains wget google.com环境变量\n有些奇葩的语言设计时完全静态链接，不会调用 libc 的运行时库（说的就是那个叫 go 的），因此没办法使用 proxychains 进行 hook。但对于命令行程序，通常有个约定，如果用户设置了 http_proxy 和 https_proxy，程序就会使用这个作为代理。可以在这两个里设置 socks5 代理，比如 export http_proxy=socks5://127.0.0.1:1080，但问题不是所有程序都支持 socks5 代理，所以需要一些方案将 socks5 转换成 http 代理。当然如果你遇到一个 go 程序不读取这两个变量怎么办？当然是在心里问候一下开发者先人。\nprivoxy\n我个人比较习惯使用 privoxy 做代理转换，当然能实现这个功能的程序非常多，privoxy 是其中一个，安装好之后修改配置文件，添加一行\n1\nforward-socks5   /               [IP 地址]:[端口号] .然后使用 systemctl start privoxy 启动即可。\n桌面环境\n诸如 GNOME 和 KDE Plasma 等都在网络设置里提供了代理选项，按表格填写即可，对于一些内建代理支持的也可以同理比如 Telegram Desktop，本地的 socks5 代理是不需要填写用户名和密码的。对于另外一些同学想要使用 Automatic 的选项的，你需要生成一个 pac 文件，这个文件里记录了哪些网站需要走代理，可以搜索 你用的 socks5 代理协议的名字 + pac 得到更多相关内容，然后在这个选项里填写以 file:// 开头的 URL，支持的程序就会使用这个 pac。\n浏览器\n通常大家使用插件来调用代理，但如果你上一步设置了桌面环境的代理比如 pac，可以直接走系统代理。\n端口转发\n有时候你的网络很奇葩，连接所有代理服务器都很慢，可以通过一个国内服务器做端口转发，需要在国内服务器执行下列命令。\n开启流量转发\n1\n2\n# echo \"net.ipv4.ip_forward=1\" &gt;&gt; /etc/sysctl.conf\n# sysctl -p配置转发规则\n1\n2\n3\n4\n# iptables -t nat -A PREROUTING -p tcp --dport [端口号] -j DNAT --to-destination [代理服务器地址]\n# iptables -t nat -A PREROUTING -p udp --dport [端口号] -j DNAT --to-destination [代理服务器地址]\n# iptables -t nat -A POSTROUTING -p tcp -d [代理服务器地址] --dport [端口号] -j SNAT --to-source [国内服务器地址]\n# iptables -t nat -A POSTROUTING -p tcp -d [代理服务器地址] --dport [端口号] -j SNAT --to-source [国内服务器地址]然后修改你本地的 socks5 配置，IP 改为国内的服务器的 IP。如果国内服务器默认有防火墙（安全组），添加规则放行该端口（TCP + UDP）。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"WireGuard 配置与使用","url":"/posts/WireGuard-Usage/","content":"需求\n本来想给内网的树莓派做 frp 一类的公网映射以便能够在外面访问 Samba 服务器，但是后来想想似乎把设备暴露在公网不太安全。换个角度想，其实没有必要把树莓派映射出去，只要能够连接进来就好了。所以选用 VPN 建虚拟专用网就好了，这里使用的 WireGuard 将我的各个设备连到一个子网内部。\n\n\nWireGuard 的原理是使用一个公网服务器做 Endpoint，内网的数据通过该服务器进行转发，因此子网的各个设备可以没有固定的 IP，只要都能连接公网服务器就好了。\n安装\n由于不同的系统安装方法不一样，建议参照 WireGuard 官网的安装说明 和各个系统的 Wiki，Android 手机可以搜索下载 WireGuard 的 APK 进行安装。\n配置\n以下部分内容参考自 WireGuard - ArchWiki。\n\n首先需要生成公钥和私钥，建议将其设置为只有拥有者才能操作，我这里放在 /etc/wireguard 这个目录里面，这个目录应该是只有 root 才可以访问的。服务器和客户端都需要分别进行这一步。\n1\n2\n# cd /etc/wireguard\n# wg genkey | tee privatekey | wg pubkey &gt; publickey服务端\n然后需要手写配置文件，这一步对于服务端和客户端不一样，先进行服务端的配置。\n首先在 /etc/wireguard 目录下面建立 wg0.conf（如果你已经有一个了就 wg1，依此类推），服务端的配置文件内容看起来像这个样子：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n[Interface]\nAddress = 10.0.0.1\nListenPort = 7456\nPrivateKey = [服务器的私钥]\nPostUp   = iptables -A FORWARD -i %i -j ACCEPT; iptables -A FORWARD -o %i -j ACCEPT; iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE\nPostDown = iptables -D FORWARD -i %i -j ACCEPT; iptables -D FORWARD -o %i -j ACCEPT; iptables -t nat -D POSTROUTING -o eth0 -j MASQUERADE\nDNS = 8.8.8.8\n\n[peer]\nPublicKey = [客户端 1 的公钥]\nAllowedIPs = 10.0.0.2/32\n\n[peer]\nPublicKey = [客户端 2 的公钥]\nAllowedIPs = 10.0.0.3/32\n\n[peer]\nPublicKey = [客户端 3 的公钥]\nAllowedIPs = 10.0.0.4/32然后我们依次分析每个字段的内容，首先是 Interface，这个部分指的是 WireGuard 在本机上面的接口，它是以内核模块的形式工作的，Address 指本机在子网内的私有 IP 地址，我这里分配了保留段 10.0.0.0/24 作为子网网段（看不懂的自己去复习计网），你也可以用 10.0.0.0/8 这个网段再进行划分，这个主机地址是你自己随意分配的，只要不冲突就行。ListenPort 是监听的服务器 UDP 端口，这个也是自己设置，只要不冲突就行。PrivateKey 则是刚刚 服务端 生成的 privatekey 这个文件的内容。PostUp 和 PostDown 是配置 iptables 的命令，建议直接复制即可，如果你服务器的公网网卡不是 eth0 则需要自己修改。DNS 则是解析域名用的 DNS，这里直接使用 8.8.8.8。\n然后每一个 Peer 字段对应了一个客户端（或其他服务端，WireGuard 实际上是 P2P 的），需要分别将该客户端的 publickey 文件的内容贴到 PublicKey，以及需要转发到该客户端的流量的 IP 地址范围贴到 AllowedIPs，我这里直接给每个客户端设置固定的 IP，因此就写了 10.0.0.2/32（看不懂的自己去复习计网），意思是该客户端对应的 IP 就是这个，所有向这个 IP 发送的流量都会被转发到这个客户端。\n每添加一个新的客户端，就要在这个文件里添加一个 Peer 字段，然后设置 PublicKey 和 AllowedIPs。\n然后在服务器的 /etc/sysctl.conf 最后加上一句 net.ipv4.ip_forward=1，开启 IPv4 流量转发，然后运行下面的命令加载新设置：\n1\n# sysctl -p客户端\n客户端也需要在 /etc/wireguard 目录下面建立 wg0.conf（如果你已经有一个了就 wg1，依此类推），内容看起来是这样：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n[Interface]\nAddress = 10.0.0.4\nPrivateKey = [客户端的私钥]\n\n[Peer]\nPublicKey = [服务端 1 的公钥]\nAllowedIPs = 10.0.0.0/24\nEndpoint = [服务端 1 的公网 IP]:[服务端 1 的端口]\nPersistentKeepalive = 25Interface 字段自然是客户端本机的设置，Address 还是给本机分配的 IP，这里要和服务器在同一个子网，并且要和服务器配置文件里允许的 IP 段对上。PrivateKey 则是刚刚 客户端 生成的 privatekey 这个文件的内容。\n然后通过添加 Peer 字段来添加服务端，服务端作为这个网络的出口和转发点，首先需要填写对应的 服务端 的公钥，然后这里的 AllowedIPs 设置的是 该客户端有哪些 IP 段的流量要通过该服务端进行转发，由于我只希望内网的流量进行转发，自然设置的是内网的 IP 段 10.0.0.0/24（看不懂的你计网挂科了！），然后需要设置 Endpoint 以便能正确的在公网上找到服务器（虚拟专用网，连不上网还哪来的虚拟网啊？），格式就是 服务器公网 IP:你设置的监听端口。PersistentKeepalive 则是用来保持连接的参数，直接复制即可。\n如果你有多个服务器，就在这里添加多个 Peer，分别设置不同的 AllowedIPs 让他们转发，但 不需要让客户端之间互相添加 Peer，本来我们要解决的问题就是客户端之间不能互相连接，所有的流量是经由公网的服务端进行转发才可以到达，公网的服务器是各个不固定的客户端的接头地点。所以只需要保证服务端和所有的客户端认识就可以了。\n启动\n在分别配置好客户端和服务端之后就可以启动了，这一步两边都一样。注意把 wg0 换成你配置文件的名字。\n1\n# wg-quick up wg0然后使用 wg 命令可以查看状态，由于这些涉及到网络配置，都需要 root 权限。服务端和客户端输出的结果是不一样的，下面这个是我的笔记本输出的结果。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n# wg\ninterface: wg0\n  public key: [不给你看]\n  private key: (hidden)\n  listening port: 51676\n\npeer: [不给你看]\n  endpoint: [不给你看]\n  allowed ips: 10.0.0.0/24\n  latest handshake: 1 minute, 41 seconds ago\n  transfer: 38.36 KiB received, 141.71 KiB sent\n  persistent keepalive: every 25 seconds\n建立成功的话，子网之间是可以使用内网地址互相 ping 的：\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n$ ping 10.0.0.11\nPING 10.0.0.11 (10.0.0.11) 56(84) bytes of data.\n64 bytes from 10.0.0.11: icmp_seq=1 ttl=64 time=30.1 ms\n64 bytes from 10.0.0.11: icmp_seq=2 ttl=64 time=30.4 ms\n64 bytes from 10.0.0.11: icmp_seq=3 ttl=64 time=30.5 ms\n64 bytes from 10.0.0.11: icmp_seq=4 ttl=64 time=30.4 ms\n64 bytes from 10.0.0.11: icmp_seq=5 ttl=64 time=30.5 ms\n^C\n--- 10.0.0.11 ping statistics ---\n5 packets transmitted, 5 received, 0% packet loss, time 11ms\nrtt min/avg/max/mdev = 30.133/30.393/30.521/0.209 ms如果你确定没有问题，就可以使用 Systemd 管理连接，首先关闭刚才的连接：\n1\n# wg-quick down wg0然后启动现成的 Unit：\n1\n# systemctl enable wg-quick@wg0 --now后记\n如果你需要在内网之间传递数据，建议选择一个访问较快的服务器，因为数据转发要通过这个服务器。\n但如果你想使用 WireGuard 访问一些被河蟹的内容也可以，首先需要一个在海外的服务器，然后设置客户端该服务器的 AllowedIPs 为 0.0.0.0/0（意思就是所有 IP 都经过这个服务器转发啦！或者你知道该设置某些网段也行！或者避开内网和本地地址！我不建议用这个番茄！所以就写个最蠢的！），就可以了！记得不用时候关掉，不然一些国内 App 也会走海外的！\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"使用 Moment 处理 JavaScript 与 YAML 的时区转换","url":"/posts/JavaScript-YAML-Timezone-Moment/","content":"开始之前先来一段惊喜：我是在中国标准时间 21 点写的这篇文章，但我在 front matter 写的是 21:00:00 并解析为东京时间。\n\n\n今天想给 Hikaru 添加文章时间显示时区的功能，本来以为只要无脑调用 Moment.js 就好了，但发现其中坑有很多，本来我就很不擅长计算时区转换，难度变得很大，好在后来处理完了，记录一下遇到的坑。\n首先 Moment 是不支持地区解析和时区显示的，需要安装 moment-timezone 这个扩展包才可以处理，文档在这里。\n然后就是 js-yaml 开发者认为是标准但我觉得是 Bug 的问题。我在 front matter 里写的时间是不包含时区的，比如 2018-12-31 16:00:00，按照正常的解析方式（就是直接 new Date(&quot;2018-12-31 16:00:00&quot;)），应当把这个时间当作 localtime 来看待，也就是 UTC+8h 的时间，但偏偏 js-yaml 的开发者认为按照 YAML 标准应当把这个时间当作 UTC 来处理（问题是他 根本解析不了附加时区的表示方式啊！）然后时间就错乱了，不过还好，JS Date() 对象内置的 getTimezoneOffset() 方法可以获取到 UTC 与 localtime 的分钟差（和标注的 UTC+8h 正好相反，这个是 -8h，在这里正好把这个错误的 UTC 换算回正确的 UTC）。具体的代码如下。\n1\n2\n3\n4\n5\nconst yaml = require(\"js-yaml\")\nconst d = yaml.safeLoad(\"2018-12-31 16:00:00\")  // -&gt; 2018-12-31T16:00:00.000Z\nnew Date(\"2018-12-31 16:00:00\") // -&gt; 2018-12-31T08:00:00.000Z\nd.getTimezoneOffset() // -&gt; -480\nnew Date(d.getTime() + d.getTimezoneOffset() * 60 * 1000) // -&gt; 2018-12-31T08:00:00.000Z\n接下来遇到另一个问题，Nunjucks 似乎对传递参数有很大限制，比如 moment 既是函数也有成员，我没办法在 Nunjucks 里面调用它的 moment.tz.guess() 成员，所以只能把设置地区单独做成文章参数传进去。\n然后发现这样有一个问题，比如我在日本写文章的时间是 21 点，回到中国发布，它解析时会当成东 8 区的 21 点来解析，然后使用 moment(&quot;2019-01-01 21:00&quot;).tz(&quot;Asia/Tokyo&quot;).format() 时进行转换，将东 8 区（中国）的 21 点转换成东 9 区（日本）的 22 点。然而实际上我觉得更常见的是一个人在国外写了一篇文章，自然标注的是国外时间（谁叫 js-yaml 不支持时区记号呢！），然后用另一个参数注明自己现在的地区，这样回到自己的国家之后，发布时仍然以外国时区解析时间。\n很显然解决方案是要改变解析时间的时区，但似乎 JavaScript 并没有什么好的修改时区的办法，使用 moment.tz(时间，地区) 似乎可以限定解析的时区，但是直接像下面这样做完全没用。\n1\n2\n3\n4\n5\n6\nconst yaml = require(\"js-yaml\")\nconst moment = require(\"moment-timezone\")\nconst d = yaml.safeLoad(\"2019-01-01 21:00:00\")  // -&gt; 2019-01-01T21:00:00.000Z\nconst newd = new Date(d.getTime() + d.getTimezoneOffset() * 60 * 1000) // -&gt; 2019-01-01T13:00:00.000Z\nmoment.tz(newd, \"Asia/Tokyo\").toISOString() // -&gt; 2019-01-01T13:00:00.000Z\nmoment.tz(newd, \"Asia/Tokyo\").format(\"YYYY-MM-DD HH:mm:ss z\")  // -&gt; 2019-01-01 22:00:00 JST\n它仍然是将 21 点当作东 8 区转换为东 9 区的 22 点了，时区完全没变，不然应该是有一小时的变化（从东 8 到 东 9），原因是如果一个时间已经标注了时区（各种合法的格式，比如 JST、CST、+0800 等，单独的 Z 在 ISO 标准里就表示 UTC，因此也算标定），Moment 就不会用程序员给定的地区做解析，而是用作输出时的转换（等价于 moment(时间).tz(地区)）（这么设计 API 的人你出来我保证不打死你）（我觉得我应该去看一眼那个叫 You-Dont-Need-Momentjs）的项目。\n解决方案似乎没什么特别优雅的，既然你不肯去掉，那我自己造一个没时区的字符串然后再解析一次呗。\n1\n2\n3\n4\n5\n6\nconst yaml = require(\"js-yaml\")\nconst moment = require(\"moment-timezone\")\nconst d = yaml.safeLoad(\"2019-01-01 21:00:00\")  // -&gt; 2019-01-01T21:00:00.000Z\nconst newd = new Date(d.getTime() + d.getTimezoneOffset() * 60 * 1000) // -&gt; 2019-01-01T13:00:00.000Z\nmoment.tz(moment(newd).format(\"YYYY-MM-DD HH:mm:ss\"), \"Asia/Tokyo\").toISOString() // -&gt; 2019-01-01T12:00:00.000Z\nmoment.tz(moment(newd).format(\"YYYY-MM-DD HH:mm:ss\"), \"Asia/Tokyo\").format(\"YYYY-MM-DD HH:mm:ss z\") // -&gt; 2019-01-01 21:00:00 JST\n这样结果就对了。至于接下来你想用什么地区的时间输出无所谓，反正内部的时间已经改变了，不再是你本机的时间。\n新年新 Bug：当我在研究为什么我的生成器没有在首页生成这篇新文章半小时之后，我发现问题的源头是我把 2019-01-01 写成了 2018-01-01。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"StackHarbor 的 2018 尾记","url":"/posts/2018-Tail/","content":"\n还没有到月亮升起的时候呢。\n\n\n不是所有特殊的日子都能让人开心，特别是对于一个记性不太好的人来说。虽然距离上一个这样标题的已经过了一年，但我似乎想不起来这一年有什么值得开心的事情。我是指那种能维持很久的开心，但是很遗憾似乎让人难过的事情总是能持续的更久一点。\n今年大概保证了一个月一篇 post 的频率，虽然有些月份就懒的什么也不想干，但回头翻一翻之前还有存货，让人变懒的原因不是无事可做，往往是由于各种没什么意义还不得不做的事情，一旦沉迷在这些事情里太久，就容易让人忘记自己应该做什么事情。\n似乎这一年来就一直不清楚自己该做什么，虽然对于自己不想做什么有清晰的了解，但是说到做什么，似乎每一件事都不是很容易完成，特别是一些没接触过的东西。而且糟糕的是我觉得这个状态还会继续存在下去——我还没搞到该死的创新创业学分！\n说句实在话，我不想当韭菜，也没当韭菜的成本。我还有好多事情没有完成呢！大概对于一棵韭菜来说，长得和其他韭菜不一样就是错误。\n所以说实话，最近没有什么值得开心的事情，更远一些也没有。\n如果从最早开始说的话，今年大概从 空之境界 开始，然后是 Fate/Stay Night，然后是 Fate/Zero。第一遍看空之境界的时候还不知道整个在说什么，只是模糊地觉得十分喜欢，最近又拿起来重新看了一遍，才发现一些不一样的意思。\n话说回来，虽然是第一次看，但是却有十分熟悉的感觉，大概是因为里面一些插曲早就不知道循环了多少个深夜的原因。总有一些旋律是停留在记忆里面的，理解它们从来就没有什么困难。\n然后是 Fate，最开始只是因为把 卫宫家今天的饭 当成泡面番来看的，没想到一下子就点开了一年霸权（真·年番）。当然看过 Stay Night 之后和没看之前看这部的感觉是不一样的——一同经历过很多，怎么能不留下些痕迹呢——大概和所有人一样，只要看到他们还在一起就满足了。\n然后大概 Unlimited Blade Works 线的动画从音乐上整个就输给了 Fate 线动画，除了 LAST STARDUST 是确确实实的超水平，believe 和 ring your bell 表现实际很一般（这里一般的意思就是指没什么第一遍就吸引人的地方）。Fate/Zero 也是完完全全的超出 Unlimited Blade Works 的音乐（只要把满天拉出来就可以吊打了），至于 2019 年 1 月 11 日的 Heaven&#39;s Feel……我并不是樱厨，所以大概这条线不适合我吧。还有 幻想嘉年华 大概和卫宫家今天的饭是同一水平的作品，太严肃了也是很累的。至于 Fate/Apocrypha？这不是讲的莫德雷德和狮子劫界离的故事嘛？写的挺好的！就是 23 集就完结有点奇怪……后面还做两集多余的骗收视率嘛？（摸着良心说，阿福这个配角也挺可爱的。）\nFate 系列其他的作品就没看过了，我觉得也没有看的必要，FGO 从看完 Stay Night 开始玩，到现在也差不多没什么动力了（主要是懒），反正一年过去了，我还是没有抽到蓝呆毛。（93 连抽！279 个石头！一个五星都没有！）虽然金卡有了一大堆一般的本也都轻轻松松，但是我还是很想要蓝呆。（无独有偶，信用卡我也只拿到武藏的，没有蓝呆。）明年有第六七章的动画化，第七章我只是觉得故事性很好，但第六章的动画是我最期待的。\n导致不开心的大概是在我重新开始听 Kalafina 的时候听见了 Keiko 退出的消息，完全不愿意回想这件事发生的前后过程。无论希望还是失望也都已经过去了，那剩下的复杂的感情又是什么呢？与其空怀希望，不如让时间回到一切还没发生的时候，重来一遍的话，我应该不会错过那些不该错过的机会了吧。与已经得不到的相比，每天都在重复的无聊事情有什么意义吗？\n顺便一提，假期之前通关了 NieR: Automata，但现在的我恐怕没有再来一次的勇气。\n也许我可以有更多的事情可以做，但是实际上我只有两个作品，一个是现在正在用的主题 ARIA，某种程度上它和我的想法一样简单，本来就是非常简单的逻辑嘛。这个东西写的非常直白，样式也全部是我自己完成的，不会出现什么奇怪的乱七八糟的调用。也没有对一些历史垃圾进行没必要的适配，直接采用最合适的技术，去掉那些对内容没什么帮助还消耗资源的东西就好了。\n还有一个是 Hikaru，基于和上面类似的原因，我对 Hexo 也有一定的不满，虽然看起来其它的让我更没什么兴趣。于是大致按照逻辑设计了自己的生成器，并且给它起了我最喜欢的歌手的名字。这个程序也是一样的直白，反正只是生成一遍页面而已，没有必要搞什么乱七八糟的数据库嘛，就算有必要也可以直接上 SQLite（当然我没有，而是直接用对象引用了）。包括一些乱七八糟的模板里的工具，总之是把所有不符合自己习惯的地方都改了一遍。截至目前一切工作的都很良好，甚至一些我开始不知道怎么实现的地方也都工作了。我也并不觉得需要有多少多少人来用它，只要满足我自己用就行了，至于别人，随意。\n然后大概就是换手机，一加 3T 使用了两年已经是伤痕累累，但是看起来又没什么符合要求的手机，一加的后几代产品完全就是“不讲究”，MIX2S 看起来不错但没有耳机孔也没有防水，而且我并不是很喜欢 MIUI，Pixel 3 的性价比完全就是冲着“有种别买”去的，何况这个价格一旦出了问题没保修就要了命了。反正我都是晚上充电，充的太快反而让我不放心，快充完全没什么需求，所以最后考虑加钱买 Galaxy S9（因为 128G 的 S9+ 实在是超出预算了），但是看到 S9+ 有 64G 的版本（反正可以插存储卡），同时 4G 内存实在是太小，咬咬牙就 S9+ 了，反正有奖学金和上个月的结余。别问我 6k+ 为什么不买 iPhone，我考虑了一下，这东西我拿来完全不能用（没文件管理 怎么愉快的用 Samba 在 Arch 和手机之间交换文件，以及 Shadowsocks 处理起来也很麻烦，我也不可能因为一个 iPhone 迁移我整个生态和习惯，顺便还 没有耳机孔，以及 被限制的 NFC，也 不能随便外接 U 盘……），所以还不如当它不存在，不存在的东西就不考虑了，这样一来 Galaxy S9+ 就变成了第一档配置的选项。\n拿到 S9+ 以后才发现多出来的价格完全没有白花。对我来说这个手机唯一的缺点就是这个曲屏太难贴膜以及担心摔碎（所以想办法搞了碎屏险）。至于其它的完全 OK，防水是一个平时我不会故意去用（我不洗手机！）但总能让人很安心的功能，双摄也是到手了之后发现 2X 变焦在拍猫的时候很有用（不用担心追的太近猫猫跑掉了），指纹识别在后面总比没有要强（毕竟我很讨厌实体按压 Home 键），有 NFC，屏幕水平中规中矩（手机居然可以切换分辨率你敢信！平时用 1080P 就很清晰了。），可以插存储卡，耳机孔绝对是加分项目，特别是 随包装送了 AKG 耳机、USB-C 到 MicroUSB 的转接头，USB-C 到 USB-A 的转接头（本来是换机助手用的，但完全可以用来接 U 盘）、透明手机壳甚至还有无线充电器（聊胜于无，对我来说只是多了一个充电的位置，角度什么的并不十分合适），甚至似乎还可以一边接收 WiFi 一边开热点（！！！）。另外软件上也和当初的 TouchWiz 有天壤之别，整个系统的动画很复杂，可配置项多到根本翻不完（对我来说这是优点），比如我喜欢返回键在左侧（OK），还可以设置桌面下拉通知栏，不但可以设置是否显示二级菜单（二级菜单爱好者手动吐槽一众国产和 iPhone），甚至可以设置是手势开启二级菜单还是单独图标（可惜图标不能换位置，不过反正我用手势），桌面可以横屏……以及 Android P 的更新……顺便还有能解决毒瘤但是又不过分突出的智能管理器（真的好用，不是假的，实名推荐），连我这种原生党也非常满意。甚至在 Note 9 上用任意线缆就能开启 DeX 的特性也在 Android P 通过软件更新就实现了（在 S9 上 不是硬件限制！三星也 没有强行要求你买他自家底座 的意思！亲测完全没有阉割。），手动 @ 某没良心配件厂一下。\n最后一个月稍微有点安慰的就是又看了一部 9.8 分的番（上一个 9.8 的是卫宫家今天的饭），青春猪头少年不会梦到兔女郎学姐，真正的高情商男主和真正的高情商女主以及不狗血的爱情故事让人实名羡慕啊，顺便樱岛麻衣真可爱！回头再看看某些废物后宫男，整个的质量已经是在恶心人了，要不是为了明年的电磁炮，谁会花钱看这种东西啊喂！都不是小学生了，天天比这个强比那个强算战斗力有意思吗？\n总而言之，幸福的事情都是相似的，不幸的事情则各有各的不幸，某种程度上来说，幸福的事情并不在于事情本身，而是在等待这件事情到来的过程中，就像一个慢慢升起的气球，当它上升到看不见的时候，反而会有难以掩盖的失落感。反正天下没有不散的宴席，幸福的事情也总会结束，也许是如此人们才会给自己一个又一个理由让平凡的日子变的不平凡，好有下一个盼头支撑自己活下去。但是回过头来看，这些事情又留下了什么呢？\n已经是月亮升起的时候了，何等愚蠢而幸福的人啊！\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"C 语言学习 1","url":"/posts/Learning-C-1/","content":"这个是给 2018 级 C 语言辅导准备的文档，写来写去写了好多，索性在网站也发一份。有很多是我觉得老师不会讲，但一开始很难理解，不理解又听不懂的，有学 C 的可以看一看。\n\n\n基础中的基础\n计算机只能识别机器码，机器码对程序员不友好，肯·汤普森和丹尼斯·里奇为了能更容易编写 UNIX，设计和实现了 C 语言。\n从代码到程序\nC 语言本质上是纯文本（就是所谓的 txt 文本文件），使用扩展名 .c 和 .h 主要是为了能够让人从名字上识别这是 C 源码或头文件，你可以使用任何能够编辑文本的程序编辑 C 语言。\n编写 C 程序主要有下面几个步骤：\n\n用任何你喜欢的文本 编辑器 编写代码（记事本也行，但很难用）。\n调用 编译器 将程序员能看懂的代码翻译成机器码组成的程序。\n运行程序，得到结果。\n\n名词解释\n\n编辑器：用来编写代码，可以是任何能编写纯文本文件的程序（Word 这类程序生成的并不是纯文本）。\n编译器：用来翻译代码到机器码，属于比较复杂的程序，通用的有微软的 MSVC，GNU 的 GCC 或者 LLVM 配套的 clang。\n集成开发环境（IDE）：一种集合了文本编辑和编译代码功能的程序，通常还会集合一些附加的功能比如调试等。其中编译代码的功能通常是调用上面提到的那几种编译器进行。\n\n注意：IDE 并不是编写代码的必需品，只要能编写文本又能调用编译器就可以写程序，因此不要问诸如“要用 VS 写 C 语言，那 VS 是用什么写的？写 VS 的公司是神吗？”这种 弱智 问题。没有 C 或者 C++ 很可能就不会有 VS，但是没有 VS 依然可以写程序。\n注意：不建议使用 VC++ 6.0 编写 C 程序，这个程序的年龄比在座各位都大，当时 C 语言还没有完整的标准，和我们现在的 C 相差很多。并且实际上这是个 C++ 的 IDE，而 C 和 C++ 并不完全一样，应该视为两种语言。\n可以使用 VS 或者 Code::Blocks 编写 C 程序，苹果 macOS 用户可以使用 Xcode，这些程序对于最新的 C 标准有着非常好的支持。\n注意：对于 VS 用户需要注意默认 VS 会要求你使用它私有的一些函数而不是标准的 C 函数，这个需要在代码开始添加一行 #define _CRT_SECURE_NO_WARNINGS 来关闭。对于 Code::Blocks 用户请下载集成了编译器的安装包（简而言之，体积最大的），否则你下载下来以后会发现自己并没有编译器，没法编译代码。\n学习 C 语言的正确方法\n多写，多练，光动脑不动手什么语言都学不会，可以从模仿别人的代码开始：\n\n首先对照别人的代码，自己完整的输入一遍程序，这里不是要你复制粘贴，当你能正确的输入程序的时候，说明你已经记住了 C 的结构，不会漏掉分号或者括号等。\n然后阅读代码，并推测这段程序会得到什么结果。然后运行代码\n如果和你预测的结果不一样，研究为什么不一样。\n修改代码中的某一部分，然后重新进行 2 3 4 步，直到你已经完全掌握了这个程序的功能。\n接下来你可以尝试自己从头写一份代码解决问题了。\n\n语法基础\n对于计算机最基础的功能自然是做计算，所以 C 语言需要有 数字 和 符号（必须是英文符号）两种组成成分。\n数字\n没什么好说的，你可以直接写十进制的数字，但是如果你想写十六进制的数字，只要以 0x 或 0X 开头就行，比如 0x1F 就是 31，八进制则是以 0 开头，比如 076 就是 62。\n运算符\n最基础的运算符自然是加减乘除，即 +、-、*、/。（除号这个方向叫斜杠，\\ 这个叫反斜杠。）\n求余数又叫做取模，符号是 %，比如 5 % 2 结果是 1。\n还有位运算 按位与 &amp;，按位或 |，按位异或 ^，左移 &lt;&lt;，右移 &gt;&gt;，它们处理的是内存中的二进制。\n然后是赋值运算符 =，这个符号 将右边的值赋给左边，因此左边必须是变量，右边必须是有值的表达式（表达式的概念往后看），比如 2 = 1 + 1; 很显然不行，2 不是变量，这里也不是比较相等。\n还有一些整合的运算符，比如 +=、-=、*=、/=，x += 1 就等价于 x = x + 1。取模和位运算也可以这样和赋值结合起来。\n然后是一些用来比较关系的符号，比如 大于 &gt;，小于 &lt;，等于 ==（判断相等用两个等号），不等于 !=，大于等于 &gt;=，小于等于 &lt;=。还有逻辑运算符号 与 &amp;&amp;（同真则真），或 ||（同假则假），非 !（反转）。\n在说明之前，需要先了解在 C 语言里什么是真，什么是假，简单来说，0 和所有等于 0 的值都是假，其他所有值都是真。对于关系运算，真返回 1，假返回 0。\n需要注意比如数学上的 1 &lt; x &lt; 2，在 C 语言中是不成立的，因为按照 C 的处理顺序，会先处理 1 &lt; x，这个式子只可能是 0 或者 1，最后就变成 1 &lt; 2 或者 0 &lt; 2，永远是真的了。正确写法是 x &gt; 1 &amp;&amp; x &lt; 2，使用逻辑运算。\na != b 就等价于 !(a == b)。\n, 逗号运算符表示按顺序进行用逗号分隔的子表达式。\n() 小括号就如同数学中的括号一般改变运算顺序。\n[] 中括号用于取数组元素，比如取 数组 arr 的第五个元素（如果有）就是 arr[5]。\n&amp; 用于获取一个变量在内存中的地址，而 * 用于通过地址获取该位置的值。\n. 用于通过结构体变量名字访问结构体内容，比如对于 struct point 变量 point 取 point.position_x。而 * 用于通过结构体指针取结构体内容，比如有指向 struct point 变量 point 的指针 ptr，可以 ptr-&gt;position_x。\n++ 和 -- 分别是让变量自增 1 和自减 1。\nsizeof 这个运算符会给出后面变量的类型或类型本身的字节数，比如 sizeof char 或者 sizeof(char) 值为 1。\n?: 是唯一一个三元运算符，使用类似于 条件 ? 表达式1 : 表达式2，如果条件为真，运行表达式1，否则运行表达式2。\n运算符有非常复杂的优先级顺序，在这里列出表格，建议经常查阅，如果你在写程序的时候遇到不确定的地方，给你想先算的式子加上小括号总没错。\n\n\n\n类别\n运算符\n结合顺序\n\n\n\n后缀\n() [] -&gt; . ++ --\n从左到右\n\n\n一元\n+ - ! ~ ++ -- (type) * &amp; sizeof\n从右到左\n\n\n乘除\n* / %\n从左到右\n\n\n加减\n+ -\n从左到右\n\n\n移位\n&lt;&lt; &gt;&gt;\n从左到右\n\n\n关系\n&lt; &lt;= &gt; &gt;=\n从左到右\n\n\n相等\n== !=\n从左到右\n\n\n位与\n&amp;\n从左到右\n\n\n位异或\n^\n从左到右\n\n\n位或\n|\n从左到右\n\n\n逻辑与\n&amp;&amp;\n从左到右\n\n\n逻辑或\n`\n\n\n\n条件\n?:\n从右到左\n\n\n赋值\n= += -= *= /= %=&gt;&gt;= &lt;&lt;= &amp;= ^= |=\n从右到左\n\n\n逗号\n,\n从左到右\n\n\n注意：C 并没有用于计算类似于 xy 这种乘方的运算符，而是需要调用函数计算，这里没有 **，^ 也不是用来算这个的。\n标识符\n除数字和符号之外，我们还需要更多的词语来给 C 中的东西起名字，这些词语被称为标识符，合法（说人话就是有效）的标识符需要满足以下两条要求：\n\n组成成分是 字母 A-Za-z（区分大小写），数字 0-9，下划线 _（下划线不是连字符 -，因为这个是加减乘除的减）。\n第一个字符必须是字母或者下划线，不能是数字（如果以数字开头，判断这个词到底是数字还是标识符就会变得很麻烦，所以不支持）。\n\n比如 if，areYouOK，Areyouok，Dota2_357 甚至是 _（单个下划线）都是合法且 不同 的标识符。\n注意：尽量不要在程序里使用中文，如果你实在不知道某个词怎么翻译成英语，用拼音也可以勉强接受。千万不要在程序里使用中文标点符号，它们和英文的标点符号是不同的字符，编译器不认识它们。如果你经常分不清中文和英文标点符号，考虑更换你编辑器的字体。\n在大部分情况下，代码中连续的空白符（制表符 tab，换行符 newline 和空格 space）会被当作一个空白处理，因此写几个空格都是无关紧要的。\n关键字\n在合法的标识符的基础上，C 语言规定如下的标识符是它自己 本身 用到的词，这些词 不能被用户或者其他的库用作名字。最开始的 C 语言只有如下 32 个关键字：\n1\n2\n3\n4\n5\n6\n7\n8\nchar        short       int        unsigned\nlong        float       double     struct\nunion       void        enum       signed\nconst       volatile    typedef    auto\nregister    static      extern     break\ncase        continue    default    do\nelse        for         goto       if\nreturn      switch      while      sizeofC99 标准（就是 1999 年出来的标准）添加了这几个：\n1\n_Bool        _Complex        _Imaginary        inline        restrictC11 标准（就是 2011 年出来的标准）添加了这几个：\n1\n2\n_Alignas        _Alignof        _Atomic        _Generic        _Noreturn\n_Static_assert  _Thread_local除去这些，其他都是用户可用的标识符，你可以给你的变量或者函数起任意满足标识符要求并且不是关键字的名字。\n注意：考试的时候看清楚题干要求，如果问的是 标识符，那么关键字也是正确的，如果问的是 用户标识符、函数名或者变量名，那就不能是关键字。\n关键字说明\n这次只说明一些基础的关键字，对于存储类别关键字暂时不做说明。\n数据类型关键字\n除了 void 这个特别的词用来表示“没有类型”，其它的类型关键字都有具体的指代。这些关键字用来标记内存中存储的数据类型是什么，基础的类型有下面几个:\n\nchar：长度为 1 字节，通常用来存储字符。\nshort：长度为 2 字节，用来存储短整数。\nint：长度不确定，考试时候通常认为是 4 字节，通常用来存储整数。\nlong：长度不确定，通常用来存储长整数（大部分现代机器上，int 和 long 一样长）。\nlong long：长度为 8 字节，是 C 里最长的整数类型。\nfloat：长度为 4 字节，存储单精度浮点数，通常精确度较低。\ndouble：长度为 8 字节，存储双精度浮点数，精确度较高，开销略大。\n\n还有一些修饰这些类型用的关键字：\n\nsigned：这个数据可以表示带符号的数字，通常第一位用作符号位，总的数据范围一半正数一半负数（大部分数据类型默认就是带符号的）。\nunsigned：这个数据表示的是不带符号位的数字，即只有 0 和正数，没有负数。例如 unsigned int。\n\n声明变量参照下面的 结构 部分。\n有关数据范围，对于整数，先把长度转成 bit 数，然后有多少 bit 范围就是 2 的多少次方，有符号数正负分别一半一半，负数比正数多一个数，无符号数则就是 0 到这个数。\n还有一个定义结构类型的关键字 struct，这个关键字用来定义结构体，结构体可以把一些数据打包在一起，构成一个独立的类型，比如\n1\n2\n3\n4\nstruct point {\n        int position_x;\n        int position_y;\n};\n定义了一个结构体，以后就可以使用 struct point 作为一个新的数据类型。访问结构体使用 . 和 -&gt;。\n还有一个类型别名关键字 typedef，它用来给一个现有的数据定义一个别名，例如 typedef float scalar;，然后就可以用 scalar 作为一个类型，这个类型和 float 是一样的。\n有关数据类型还要注意一点，相同的数据类型进行运算，得到的类型还是原来的类型，如果是不同的数据，会向表示范围更大的数据类型转变。比如整数和短整数进行计算得到整数，整数和浮点数运算得到浮点数，双精度浮点数和单精度浮点数运算得到双精度浮点数。\n在将一个值赋给另一个值的时候类型会被转换成被赋值的数据类型，比如 int a = 3.0; 实际上 a 的值为 3。但上述的运算规则发生在赋值之前，因此就算你写 float b = 5 / 2;，b 的值也是 2.0f 而不是 2.5，因为首先 5 / 2 是整数除整数，得到的就是整数 2，2 转换成浮点数也是 2.0f，因此正确的写法是把 5 或者 2 中的一个改成小数比如 float b = 5.0 / 2;，此时是浮点数与整数运算，首先将整数 2 变成浮点数 2.0，然后得到 2.5。\n流程控制关键字\n条件语句\nif else 的格式如下，如果条件为真，执行语句1，否则执行语句2，也可以不写 else 和语句2。\n1\n2\n3\n4\nif (条件)\n        语句1;\nelse\n        语句2;\n嵌套的 else 会和最近的 if 匹配，除非使用大括号显式限制范围。\n1\n2\n3\n4\n5\nif (条件)\n        if (条件)\n                语句1;\nelse\n        语句2;\n上面这个 else 会和第二个 if 匹配，而不是第一个。\n1\n2\n3\n4\n5\nif (条件) {\n        if (条件)\n                语句1;\n} else\n        语句2;\n这个就和第一个匹配了。\nswitch case 也可以用作条件判断，switch 后面必须接一个条件变量而不是条件语句（这个变量的值必须可以直接用 == 判断相等，很抱歉字符串不可以哈哈哈）。形式如下。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\nswitch (条件变量) {\ncase 值1:\n        语句1;\ncase 值2:\ncase 值3:\n        语句2;\n        break;\ndefault:\n        语句3;\n        break;\n}\n根据条件变量值的不同，会跳到不同的 case 向下执行，重点是向下，也就是说如果匹配了值1，运行语句1后会向下运行语句2，只有在遇到 break 的时候才会跳出 switch 语句，同样不管匹配的是值2还是值3，都会运行语句2，如果没有匹配，会运行 default 标签下面的内容，当然也可以不写 default。\n循环语句\n有三种循环语句，首先是 while 语句，语法如下。\n1\n2\nwhile (条件)\n        语句;\n该循环会在条件为真时执行语句，条件为假则退出循环，每次循环都会先判断一次条件再决定是否循环。\n然后是 for 语句，语法如下。\n1\n2\nfor (循环开始前做一次; 条件; 每次循环结束都做)\n        语句;\n该语句在循环开始前执行第一个分号前的内容 一次，然后判断条件决定是否进入循环，在每次循环中的语句结束后，都会做第二个分号之后的内容。如果不想做某一个部分，直接空着就可以，但要保留分号。比如下面的 for 循环就和 while 循环等价。\n1\n2\nfor (; 条件;)\n        语句;\n最后是 do while 循环，用于需要先做一次循环内容再做判断的情况。\n1\n2\n3\ndo\n        语句;\nwhile (条件);\n1\n2\n3\n4\n5\ndo {\n        语句1;\n        语句2;\n        语句3;\n} while (条件);\n跳转语句\n有四种跳转。\ngoto 是无条件的基于标签的跳转。标签就是在某一句前写一个标识符然后加冒号。\n1\n2\n标签: 语句；\ngoto 标签;\n这段代码会造成一个死循环，用于在这两句之间跳来跳去。不建议使用 goto 语句，因为在程序里跳来跳去很容易让人逻辑混乱，从而无法调试。\nreturn 语句通常用于在函数中返回一个值，比如 return 0; 返回整数 0，当函数返回之后，该函数就结束了，即使后面还有语句也会被忽略，如果不想返回值，直接 return;。\n剩余两种都是主要用于循环中的语句。\nbreak 用于打断一个循环，从循环中跳出来，比如下面的循环。\n1\n2\nfor (; 1; 语句)\n        break;\n如果没有 break 这个语句是一个死循环并且每次都运行语句，但是有 break，第一次进入循环之后就跳了出来，不会执行语句。\ncontinue 用于跳过本次循环中的剩余部分，直接进行下次循环。\n1\n2\n3\n4\n5\nfor (开始; 1; 语句1) {\n        语句2;\n        continue;\n        语句3;\n}\n这个程序在执行完开始之后，每次循环都执行语句1，然后 continue 直接结束这次循环进入下一次，因此语句3就不会被执行，但对于 for 循环语句1会被执行。\n通常情况下，break 和 continue 都和 if 搭配使用，它们可以解决大部分情况而不需要 goto。\n结构\nC 程序主要包含以下部分：\n\n预处理器指令\n函数\n变量\n语句和表达式\n注释\n\n注释\n注释用于表示“这部份是给我自己看的，编译器并不需要这部份”，通常我们用它写一些提示自己的语句，编译器会忽略它们。写注释是个好习惯。\n第一种注释使用 /* 和 */，凡是在这两个符号之间的都是注释，这种注释可以跨越多行。\n1\n2\n3\n4\n5\n6\n/*\n我是注释\n我是注释\n我是注释\n*/\n/*我是注释*/\n第二种注释使用 //，它的范围是从 // 到这一行的结尾（换行符）。\n1\n2\n// 我是注释\n我不是注释\n调试程序的时候也可以临时注释掉一部分问题代码，相比删除，这样可以随时恢复它们。\n语句和表达式\n表达式通常做一个动作并得到一个值（注意没有值也算是一种特殊的值），比如 1 + 1 是一个表达式，这个表达式的值为 2，表达式可以互相组合，比如 (1 + 1) * 2，这个表达式的结果为 4。\n需要注意一些特别的运算符表达式的值，比如我们令 int i = 1;。不管是 i++ 还是 ++i，执行结束后 i 都会变成 2，但是从表达式的值的角度来说，i++ 这个式子的值是 1，而 ++i 值是 2，-- 同理。\n也就是说， i++ == 1 是 真的，++i == 1 是 假的，++ 在前就先加后值，++ 在后就先值后加。\n不要自作聪明，对于 C 语言标准，并没有规定诸如 y=i+++++i（其实就是 y = i++ + ++i）的运算过程。编译器可以认为这两个式子里的 i 都是 1，也可以认为一个是 1 一个是 2，还可以认为都是 2，那 y 就可能是 2 3 4 甚至是奇奇怪怪的不可预测的值。如果考试出现这种问题，建议直接告诉老师题有问题。\nC 语言规定语句以分号 ; 结束而不是以换行符结束，因此你可以在一行里写多条语句，也可以在多行里写一条语句，编译器会阅读其中的分号。一个单独的分号也是一个语句——它什么也不做，我们叫它空语句。\n比如\n1\n1 + 1; 2 + 2;\n是两条语句。但是\n1\n2\n3\n(\n        1 + 1\n) * 2;\n是一条语句。\n对于 C 关键字中的流程控制关键字，通常它们的作用 只能控制它们下面的一条语句，大括号 {} 可以在文法上将几个语句结合成一个语句（说人话就是如果你想在这些关键字后面接两条或以上的语句，就要加大括号），例如\n1\n2\n3\n4\nif (true) {\n        do_one();\n        do_another();\n}\n当然，一个空的大括号 {} 也是空语句。\n函数\n函数是 C 语言中最主要的组成部分，C 语言程序主要就是由各个函数组成。函数类似于数学中的函数，它们接受一些参数，然后做一些操作，最后返回 一个 值（C 限定函数只能返回单个结果或者不返回结果）。\n一个函数的结构通常是像下面这样\n1\n2\n3\n4\n返回值的类型 函数名(参数类型 参数变量名, 参数类型 参数变量名)\n{\n        函数的内容\n}返回值的类型限制了函数返回的数据的类型（说人话就是你前面写啥类型后面就得返回啥），如果没有返回值，这里使用 void。\n函数名则是一个用户标识符，然后在小括号 () 里放接受的参数列表，按照 参数类型 参数变量名 的格式，中间用逗号连接，如果不接受参数，这里使用 void。\n上面这一部分通常叫做 函数头。\n函数的内容放在大括号里面，这一部分也通常叫 函数体，在这里你可以写 C 语句。\n如果你指定了函数类型，函数内容里必须用 return 表达式返回一个对应类型的值，否则你会得到一个 Error。\n比如有一个限制为处理整数的数学函数 f(x) = x * 2，写成 C 的函数就是下面这样。\n1\n2\n3\n4\nint f(int x)\n{\n        return x * 2;\n}\n变量\n变量对应着内存里的一块空间，里面存储着一些数据，必须 先声明一个变量才能使用，声明指定了变量的类型和名字。\n声明变量的时候使用类似这样的格式。\n1\n变量类型 变量名 = 初始值, 变量名 = 初始值;首先是变量的类型，然后跟着变量名组成的列表，列表之间用逗号分割，也可以同时提供初始值，只需要使用 = 赋值，可以省略 = 和初始值，这时这个变量的值是 不确定的。\n例如 int a, b, c = 2;。\n题外话：建议给变量起个容易理解它是什么的名字，而不是一堆乱七八糟的字母，比如 my_age 就比 x3 更容易理解。在变量名里写上变量类型倒不是个好主意，因为稍微高级点的编辑器都能推导类型，这样写纯粹是浪费空间。\n变量是有作用域的，你不能在作用域外面调用作用域里面的变量，但反过来是可以的，也就是说作用域满足嵌套关系。\n同一个作用域里变量不可以重复声明，否则会得到一个 Error。但如果内层作用域声明了一个和外层重名的变量，内层的会暂时覆盖外层的，也就是说你暂时没办法访问外层的那个。\n通常来说，函数是一层作用域，然后则是对于每个判断或循环语句，它们的条件和它们控制的代码块（就是大括号里面）有一个单独的作用域。也就是说你在循环体里面声明的变量在外面是不能访问的。比如这段代码。\n1\n2\n3\n4\n5\n6\n7\n8\n9\n// 你应该能看懂这个函数没有返回值也没有参数。\nvoid func(void)\n{\n        int x = 1; // 函数作用域。\n        int y = 2;\n        for (int x = 2; x &lt; 10; ++x)\n                printf(\"%d %d\\n\", x, y);        // 这里会输出 2 2 到 9 2 共八行数。\n        printf(\"%d\\n\", x);        // 这里的 x 还是 1！\n}\n如你所见，第一次我们声明的变量 x 和 y 属于函数作用域，随后 for 语句中声明的 x 就是循环代码块作用域了，这个 x 暂时掩盖了外面的 x，当离开循环之后，我们又访问到了函数作用域的 x。\n我们还可以一次批量分配多个元素，这种方式被称为数组，数组的声明方式通常是下面这样：\n1\n数据类型 变量名[数组长度] = {元素, 元素, 元素};= 和后面的部分是为了进行初始化，当然你也可以不进行初始化。\n数组中的元素在内存中是连续的，当你想访问其中的某个元素，只需要使用 数组名[元素序号]。这里的序号是从 0 开始的！也就是说长度为 5 的数组，元素序号分别是 0、1、2、3、4。\n你可以写超出数组长度的序号，C 并不会阻止你这样做，但通常这样会触发一个错误，因为那个位置的内存并不一定让你访问。换句话说，C 语言相信你会限制访问的长度，所以它不进行限制。\n如果你在声明的时候没有进行初始化，那你以后就不能再像初始化元素一样给整个数组直接用 = 赋值了，具体的原因需要等讲过指针之后再进行说明。这个时候你可以给 数组名[元素序号] 进行单个的赋值。比如把 arr 的三个元素都设置成 0。\n1\n2\n3\n4\nint arr[3];\narr[0] = 0;\narr[1] = 0;\narr[2] = 0;\n相比于在代码里书写多个变量如 int a1, a2, a3; 使用类似 int arr[3]; 让我们有了在循环中处理它们的办法，你不能在循环中处理变量的名字（这可不是简单地拼字），但你却可以循环处理数组的下标。比如把 arr 的三个元素都设置成 0 还可以这样做。\n1\n2\n3\nint arr[3];\nfor (int i = 0; i &lt; 3; ++i)\n        arr[i] = 0;\n预处理器指令\n严格来说，预处理器指令并不是 C 语言的一部分，它们在编译器最开始处理代码的时候进行工作，然后当编译器开始将代码翻译成机器码的时候，预处理器已经工作完毕了。\n预处理指令以 # 开头，每一行为一个语句，大部分预处理指令都是与文本替换有关。\n这里介绍几个简单的例子，复杂的后面会单独说明。\n#include &lt;文件名&gt; 表示将这个文件的内容插入到这一行的位置，一般用来引用头文件，&lt; &gt; 括起来的是系统的头文件名，如果引用的是自己项目里的头文件，则需要用 #include &quot;文件名&quot;。\n#define 标识符1 标识符2 表示在文件里所有出现的标识符2都会被替换成标识符1，比如下面的代码。\n1\n2\n3\n#define PI 3.14\nint c = 2 * PI * 5;\nint s = PI * 5 * 5;\n在编译器翻译代码到机器码的时候，它看到的代码其实是\n1\n2\nint c = 2 * 3.14 * 5;\nint s = 3.14 * 5 * 5;\n示范\nHello world!\n好了，在介绍完这些复杂的东西之后，终于可以进行一个简单的程序示范了，现在书写一个 hello world 就不会遇到有哪里说不明白的情况。\n1\n2\n3\n4\n5\n6\n#include &lt;stdio.h&gt;\nint main(void)\n{\n        printf(\"Hello world!\\n\");\n        return 0;\n}\n首先第一行的 #include &lt;stdio.h&gt; 表示我们把 stdio.h 这个头文件里的内容全部插入进来，stdio 表示 standard input output 即标准输入输出（这里的输入输出是从程序的角度）。C 语言自身标准规定了许多有用的内置函数给我们使用，但我们首先要在代码里声明它们，这个头文件就包含了一些函数的声明，后续会继续说明头文件的作用与内容。\n然后我们声明一个名称为 main，返回类型为 int，不接受参数的函数，这个函数是 C 语言规定的程序入口，也就是说操作系统运行你的程序，实际上是从调用 main() 开始的，这里需要注意的是在 C 语言标准中，main() 的返回值必须为 int，你可能见到过 void main() 或者干脆连 void 这种返回类型都不写的，这些都是错误写法，某些不标准的编译器可能支持，但实际上标准里没有它们，你在写代码的时候不能这么写。\n这个函数的内容只有两句，第一句 printf(&quot;Hello world!\\n&quot;); 会在你的终端界面输出一句 Hello world! 并换行，在这个过程中我们调用了这个叫做 printf() 的函数，它是 C 标准库规定的格式化输出函数（f 可以理解成 format），但我们这次只是用它输出一条字符串，\\n 是一个转义字符，我们用它表示“回车”这个无法在代码里打出来的符号，如果你去掉它，然后再输出点什么，你会发现这两次的输出会出现在同一行里面——C 不会乱做任何你没让它做的事情。有关 printf() 和转义字符的更多内容，下次会进行介绍。\n对于字符串，你可以简单的理解为小说或剧本里面人物说的话，如果不用双引号，剧本里的文字就是叙述性的语句，并不会被观众得知，程序也是一样，不加双引号的均是程序代码，当你想跟用户交流，使用字符串吧。有关字符串的存储方式，也会在后续讲解。\n最后，main() 函数返回整数 0，这个返回值会被它上层的程序捕获（可以简单理解为操作系统），0 在这里约定是程序运行成功的意思，一个复杂的程序可能有多种多样的失败原因，这个时候我们可以用无数的非零值代表各种错误。\n还记得之前关于 return 的说明吗？如果我们把 main() 改写成下面这样。\n1\n2\n3\n4\n5\n6\nint main(void)\n{\n        printf(\"Hello world!\\n\");\n        return 0;\n        printf(\"老师永远也不会看见这句话。\");\n}\n你有可能会得到编译器的警告，但它只是提醒你最后这句 printf() 不会被执行，如果你的老师不看源码，他/她永远也不知道这句话。（另外这句话输出之后并不会换行。）\n有关缩进\n缩进这个词有点陌生，程序员用它指代代码的排版格式，尽管 C 给了你把所有程序写在同一行里的能力，但我估计看过这种代码的人都想把作者打一遍出气。\n1\n2\n#include &lt;stdio.h&gt;\nint main(void){printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");printf(\"Hello world!\\n\");return 0;}\n当你写了一个复杂一点的程序的时候，有必要修理一下程序格式，让它变的更容易理解，我们在前面说过一个分层次的东西叫作用域，刚好可以利用它。我们可以在每一个作用域的内部语句的行首增加一定数量的空白，来突出层次感。比如在这段代码里指出一个错误\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\nvoid func(void)\n{\n        for (int i = 0; i &lt; 10; ++i) {\n                for (int j = 0; j &lt; 10; ++j) {\n                        for (int k = 0; k &lt; 10; ++k) {\n                                if (0 = k % 2) {\n                                        printf(\"老师会看见很多次这句话。\");\n                                }\n                        }\n                        for (int k = 0; k &lt; 10; ++k) {\n                                for (int l = 0; l &lt; 10; ++l) {\n                                        if (l % 2 == 0) {\n                                                printf(\"老师会看见很多次这句话。\");\n                                        }\n                                }\n                        }\n                }\n        }\n}\n就比在这段代码里\n1\nvoid func(void){for(int i=0; i&lt;10; ++i){for(int j=0; j&lt;10; ++j){for(int k=0; k&lt;10; ++k){if(0=k%2){printf(\"老师会看见很多次这句话。\");}}for(int k=0; k&lt;10; ++k){for(int l=0; l&lt;10; ++l){if(l%2==0){printf(\"老师会看见很多次这句话。\");}}}}}}\n要容易的不止一点半点。\n通常这个空白是一个 Tab 按键，或者八个空格，或者四个空格，只要你的一份代码里选择其中一个就可以了，不要搞得参差不齐就行。\n通常还建议你只在一行里书写一个语句，因为你所看见的代码可能有误导性，比如\n1\n2\nif (条件) do_one();\n        do_another();\n究竟哪个函数受到条件控制呢？现在也许你分得清，当你写了几百行代码后，可能你就感觉它开始辣眼睛了，建议你写成下面这样：\n1\n2\n3\nif (条件)\n        do_one();\ndo_another();\n还有一个建议是，虽然人们在左大括号放在上一行行尾还是单起一行的行首争论不清，但右大括号单独放一行总是没错的。左大括号的两种风格都是好的，你只需要坚持某一个风格就好了。\n1\n2\n3\nif (条件) {\n        do_one(); }\n        do_another();\n就不如\n1\n2\n3\n4\nif (条件) {\n        do_one();\n}\ndo_another();\n二元运算符两侧建议加空格，比如 int a = 1 + 1 * 3; 就比 int a=1+1*3; 清晰。\n这些都只是建议，但当你写了一定数目的代码，它们能帮助你少犯乱七八糟的错误，别人读你的代码也会更容易。\n提问的艺术\n有时候你自己实在搞不清楚一个问题了，需要问别人。且慢！别人可能很忙，时间宝贵，在一大片代码里找出错的位置就像大海捞针一样愚蠢，特别是许多时候，编译器已经可以告诉你代码哪里错了的情况下。\n在 Google 上搜索“提问的艺术”能找到好多有用的东西，这里只说一条最重要的：当你提问时，请贴上你完整的代码、编译器编译过程中输出的警告和错误（通常在 IDE 下面的小窗口里）以及你代码运行时的输出截图（如果程序通过了编译但运行出错了）。\n最愚蠢的是只说一句没头没脑的“我代码错了！怎么办！”，你就是说一千遍，它还是错的。第二愚蠢的是说一句“我代码错了！我先干了什么什么后干了什么什么又怎么怎么样！”，你是要自己重新描述一遍？还是打算自己从嘴里重新发明个 C 语言？万一你犯的错误是漏了个分号或者括号，我不信你能用嘴描述一遍你代码里的所有分号的位置。\n贴上完整代码保证别人帮你除错的时候不需要回头问你然后等待回复，贴上编译器输出可以直接看到它提示的可能错误的位置（而不是一句一句去读去想），输出截图也是同样的道理。\n别人帮你是自愿花费他的时间，做到以上这一点至少能让别人帮你找错误更容易。\n"}]}