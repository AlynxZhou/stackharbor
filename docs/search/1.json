{"data":[{"title":"关于","url":"/about/","content":"个人简介\nAlynx Zhou\n Arch Linux CN 社区成员\n 邮箱：alynx.zhou@gmail.com\n Telegram: @AlynxZhou\n GitHub: @AlynxZhou\n PGP Fingerprint: 87F2 E316 E0AB C98B 9DE8  D4EF 042F D810 6009 54EF\n关于 Alynx 的 33 条\n对于一些人，在对着这个页面按 Control + c 之前，麻烦先看一下第 17 条。\n\n\nAlynx 可以接受的称呼包括 Alynx Zhou，Alynx，AZ。\n\nAlynx 这个词的来历、读音是 Alynx is just a lynx。\n\nAlynx 的本命是 科学超电磁炮 中的 “超电磁炮” 御坂美琴，Misaka Mikoto 和 Fate/stay night 里面的 “Saber” 阿尔托莉雅·潘德拉贡。\n\nAlynx 是 S / M 双属性，虽然可能表现的更像 M 但是其实 S 的属性更多，除非你是让我心甘情愿的人。对 LGBTQIA 没有歧视但是 Alynx 只喜欢女孩子，想要认识可爱的小姐姐，想脱单。\n\nAlynx 像猫一样懒。Alynx 是 Arch Linux CN 社区里稀有的 GNOME 用户之一，希望大家爱护稀有动物。\n\nAlynx 喜欢 Arch Linux、Atom、C、Coffee Script、Vala、GNOME、Firefox、Android，你也许喜欢与这些对立的软件，但是 每个人选择自己喜欢的东西一定有她的理由，所以 请不要强行向 Alynx 安利你喜欢的东西。\n\nAlynx 喜欢音乐，目前最喜欢的乐器是半音阶口琴，有不到 6 年的琴龄。学过 4 年二胡并通过了业余水平十级（虽然现在几乎忘光了），选了扬琴选修课所以大概了解一点点，其他了解一点的乐器还有长号，选到课的小提琴。\n\nAlynx 坚持用 Steam 并拒绝 Origin/Epic/Battle.net 等不打算支持 Linux 的平台（既然你忽略 Alynx 的需求，Alynx 也忽略你），Counter-Strike: Global Offensive 是目前为止唯一一个玩了超过 600 小时的游戏，唯一能够玩进去的 RPG 大概是 NieR: Automata，感谢室友特地带 PS4 到学校还和高中同学借了光盘让 Alynx 能和另一个室友一起以 60FPS 和高清画质通关主线（这话说的有点乱套）。另外表示室友四个人一起玩 Overcooked! 非常开心，所以预购了 Overcooked!2。\n\nAlynx 的 Steam ID 是 AlynxZhou，如果你想和 Alynx 一起玩游戏的话。不定期在线，并且 如果你是那种很吵很暴躁张口就喷队友的人请不要来打扰 Alynx。\n\nAlynx 喜欢 Minecraft（Java版），不接受 Win10 版，PE/Java 版正版玩家（非网易版）。\n\nAlynx 已经玩不动崩坏3rd了，即使有小姐姐 + 数一数二的渲染技术。Alynx 也肝不动 Fate/Grand Order（非的肝不过欧的）（明明是碧蓝航线！）了，还没抽到蓝呆是 Alynx 没有卸载游戏的一个重要理由，她已经快绝望了已经抽到蓝呆了（已经满破了）（我永远喜欢FGO）（快说声多谢叶哥哥）。\n\nAlynx 想研究有关游戏渲染的东西，略微懂一点 OpenGL ES 和相关的矩阵运算。\n\nAlynx 不仅想学日语，还抓住机会选到了日语二外的任选课。\n\nAlynx 认为 Kalafina 和 梶浦由纪 才是 真正的音乐，Hikaru 是 Alynx 安装 Twitter App 的唯一理由。Alynx 也喜欢陈奕迅和林俊杰以及张杰这种唱功或者音乐水平确实到位的歌手，网易云有里《富士山下（live）》，《倾城》，《喜帖街》，《K歌之王》，《你给我听好》，《修炼爱情》。\n\nAlynx 经常懒癌发作什么也不想做，Alynx 是个不肥（182 cm / 72 KG）的宅。Alynx 喜欢猫，不太喜欢狗。\n\nAlynx 喜欢写一些乱七八糟的东西，即使这些没有人喜欢看，但无论如何 这是我们在面对世界这一庞然大物时能留下的一点声音，无论是惊慌失措还是泰然面对。\n\nAlynx 讨厌复制品。加上这一条是因为 Alynx 最近看到了好多部分复制这个页面的网站，Alynx 愤怒地希望这些人认清楚什么是拿来分享的什么是拿来看的。如果这些人不能理解，Alynx 表示你们 尽管使用这个页面的样式，因为代码就在 GitHub 上并使用 Apache-2.0 公开授权，Alynx 非常高兴你们喜欢这个主题，毕竟她用了两周来实现这些样式。但是对于使用 CC BY-NC-ND 4.0 授权的网站内容，希望你们不要拿来充实自己的页面，这种行为有时候会让 Alynx 觉得自己写的很中二而删除对应的文章。你有一千种介绍自己的方式，但没必要把 Alynx 的面具拿过来抠几个窟窿贴在自己脸上，因为 Alynx 会觉得痛。你也可以给自己的网站起个独特的名字，而不是看到 StackHarbor 就觉得这个词天下第一，拿来自己用可不是夸奖 Alynx 审美的好办法。\n\nAlynx 喜欢的电影和动漫有《科学超电磁炮》，《Fate/Stay Night》系列，《Fate/Zero》，《你的名字。》，《爱乐之城》，《海上钢琴师》以及《新世纪福音战士》（包括 TV 和剧场版），《黑执事》。\n\nAlynx 最喜欢 C，曾经在 Bilibili 直播了一段时间的 C 语言教学。如果是动态类型那么一定是 Coffee Script，如果是面向对象又要静态类型，Alynx 选择 Vala。\n\nAlynx 喜欢可口可乐。\n\nAlynx 觉得能不能写出优美的句子完全看运气，即使有时候会因为自己写不出来而感到没用。\n\nAlynx 觉得谈了也没用所以 莫谈国事。\n\nAlynx 的梦想是环游世界（如果不去非洲南美洲也算的话？），一个人待在陌生的，没有人知道的地方仰望天空。\n\nAlynx 不喜欢说话，除非是对喜欢的人 / 说喜欢的东西，当然以前说的都是编程或者音乐，身边的人总是听不懂。\n\nAlynx 觉得 比起依赖别人，我更喜欢被人依赖，如果我喜欢的人能让我默默付出我就很满足了。所以不要和 Alynx 客套。\n\nAlynx 强调一下 上一条很重要。\n\nAlynx 讨厌需要鼠标不停点点点的程序，比如 MS Office，Visual Studio，手还要留着玩 FPS 游戏呢。\n\nAlynx 能有一个所爱的人这件事情和 root 密码一样重要，即使不知道她是否爱我。\n\nAlynx 讨厌刷题，讨厌为了刷题写出丑陋的代码，千金难买喵乐意。\n\nAlynx 更喜欢 Telegram 虽然不得不用 QQ 和微信。偶尔会在 Bilibili 直播 吹口琴 / 打游戏 / 写代码。\n\nAlynx 宁可不看不能在 Bilibili 上看而只能在其他国内视频网站上看的视频。Alynx 也不能接受一个乱七八糟的播放器，Alynx 现在用网易云音乐下音乐然后用 Retro Music / Rhythmbox / MPV 听。\n\nAlynx 希望听到别人的声音，即使我常常讨厌交流如果有什么问题，欢迎发邮件 / Telegram 甚至是去 这里 发issue。\n\nAlynx 说你好，世界。\n\n\n有关域名和点击量\n由于选择困难和没事折腾的原因，建站以来换过三个域名了，然而我用的是不蒜子计数，它按照完整 URL 计算点击量，所以每更换一次域名就会丢失一次数据，并且作者一直咕咕咕所以没办法把数据转移过来，而我又想不到好的造轮子方案，所以丢了也就丢了，记在这里主要是怕我忘了，而且可以写一下换域名的理由，还挺好玩的：\n\nalynx.xyz：用了三年，点击量大概 10 万以上。2016 年我租这个域名的时候，xyz 后缀还没有打折，直到后来它开始搞活动变成垃圾站最爱……\nalynx.moe：用了不到一年，点击量大概 3 万以上。主要是有了收入发现自己能负担得起稍微贵一点的域名，然后觉得这个 moe 很可爱，直到后来我发现要给非动漫迷介绍这个实在是有点难……而且想了想以后年纪大了也不能总充可爱，会惹年轻人讨厌的（这都哪跟哪啊）……\nalynx.one：现在用的这个。主要原因是我有另一个 ismyonly.one 的域名，one 后缀年费很便宜也没套路，而且介绍起来也很简单。其实一开始我很想注册 ooo 后缀，后来发现是个印度公司搞的而且有人说容易和 000 混……我倒不是对印度公司有什么偏见（你就是有吧喂！），我只是想起 cat 后缀不是猫猫却被加泰罗尼亚人霸占的悲惨事实……\n\n\n\n\n    \n\n-->\n"},{"title":"404 Not Found!","url":"/404.html","content":" -->\n\n走错了走错了，这里没有东西！\n"},{"title":"吐槽频道","url":"/channel/","content":"由妮可草云强力驱动.jpg\nhttps://t.me/aztucao\n\n  \n\n"},{"title":"友情链接","url":"/blogroll/","content":"本来是打算把友情链接放到侧边栏里面的，但后来看好多人的网站里都是给链接单独开了个页面写点介绍。我觉得这样挺不错的，所以自己也搞一个。\n在这个页面学一下狼说话应该不会挨打吧？\n想和咱交换友链？\n你添加咱\n想添加我友链比较简单，打个招呼然后加到你的网站就行了。\n网站的标题是“喵's StackHarbor”，而我的名字是“Alynx Zhou”，希望你不要弄混了，比如把名字写到了网站标题里或者大小写标点符号搞乱了。不过其实我一般懒得管所以问题不大。\n如果你的友链页面可以显示 logo 或者头像，请务必优先使用本人在侧边栏里的头像，直接复制图片链接即可。或者复制咱的 GitHub 头像链接也可以。如果你分别显示 logo 和头像那有点难办，不过我想 logo 可以放 这个高清的 favicon。\n网站介绍建议使用 subtitle \"Whisper to the World\"，不过你用侧边栏的 description 也是可以的，只不过这个可能经常跟我的心情一起变化。\n咱添加你\n要我添加你可能比较困难，首先我会优先考虑熟悉并且聊得来的人，陌生人的话建议不要贸然提出申请？社交还是比较困难的事情吧。\n如果聊得比较熟的话可能我自己就会和你提出交换友链的申请并且主动添加你了，但是也有可能我只是忘记了，那就发邮件或者消息告诉我你的博客链接吧！\n一般来说我会主动的按照上面要求别人的方式去获取博客相关信息，但你也可以直接把下面表格的内容发给我，朋友的意见总是优先考虑的。\n我会先阅读你的博客再考虑添不添加，所以假如你的博客文章质量很低或者和咱不是一路人，可能你要先从自己身上找找原因？\nLast but not least，侧边栏也有一个友情链接，但是因为空间限制，我不会把所有的友链都放上去，只会放一些比较重要或者干货很多的链接！希望你不要见怪。\n老相识\n这都是咱好久之前就认识并且一起写代码搞设备到现在的朋友。\n\n\n\n头像\n链接\n自我介绍\n我的介绍\n\n\n\n\nLGiki's Blog\n“喵喵喵”\n节奏王 Dogiki！每天咕咕咕，从不写博客！\n\n\n\nHackGhost\n\n在五道口睡觉的某头。博客从某一天起就不更新了。\n\n\n\nArt_Chen's Blog\n\n某著名 ROM 开发者，上大学了要努力写代码啊。\n\n\n大学认识的\n大学里面对面交流过而且关系很不错的朋友。\n\n\n\n头像\n链接\n自我介绍\n我的介绍\n\n\n\n\nMeow\n“一只有吱的喵~”\n刚入学的时候认识的学长，似乎也是一只猫，现在大概在美国呼吸自由的空气（大雾）。\n\n\n\nsqyon\n“试图让机器帮我学习的假 ACMer”\n优秀的学弟，一定是优秀的学弟。\n\n\n\n滑稽仓库\n\n董老师（咕老师）的奇怪网站。希望下次打 CSGO 前董老师能找到带麦克风的耳机。\n\n\n\nLitterboy's Blog\n\"Good Luck and Have Fun\"\n有女朋友的人生赢家……\n\n\n\nBo Lin's Blog\n“既来之 则安之”\n是学术界大佬了！是学术界大佬了！\n\n\nArch Linux CN 社区或者 Gentoo Linux CN 社区\n这里的人懂得好像都很多，咱经常向他们提问题，而且他们经常回复咱在群里的碎碎念，不加个友链好像说不过去。\n\n\n\n头像\n链接\n自我介绍\n我的介绍\n\n\n\n\n约伊兹的萌狼乡手札\n「虽然咱长久以来被尊为神，且被束缚在这块土地上，但咱根本不是什么伟大的神。咱就是咱。咱是赫萝。」\n我大概能理解这是个什么物种吧……反正我是猫。\n\n\n\nFarseerfc 的小窝\n「要是會能讓時間停下的魔法就好了… The World!」\n爱呼吸 fc 老师！似乎是日本某大学的教授，人生赢家，实名羡慕。\n\n\n\njm33_ng\n\n似乎是个高产的大佬，博客里都是和安全相关的（大概）。\n\n\n\nNichi Yorozuya\n\"🐰🐰\"\n某世界一流大学年轻巨佬（当面确认，本人保证此条可信度）。\n\n\n\nBruce Z Blog\n「我不是兔子」\n经常迫害我的大白兔子，如果有人捉到了建议先放进锅里煮了再说。\n\n\n\nLiolok's Blog\n\"I am not a cat, how disappointing :(\"\n纠结的皓奇老师，他好像也想当猫。\n\n\n\nEdward-P's Blog\n\n虽然咱经常叫他坏德华，但并不是什么坏人，保护各种德华从我做起。\n\n\n\n依云's Blog\n\n这也是一只狐狸，而且懂得很多很多很多于是我经常经常经常阅读博客。\n\n\n\n惠狐之书\n\"A fox called Megumi\"\n又是一只狐狸，私以为 Arch 社区可改名动物园。\n\n\n\nCS Slayer\n\n资深 休伯利安号甲板清洁工 崩坏三玩家，Fcitx 的作者。可是这和我冷酷无情的 iBus 用户有有什么关系呢。\n\n\n\nSukka's Blog\n“童话只美在真实却从不续写”\n自称有大尾巴那我猜也是狐狸？是 Hexo 的维护者之一。虽然我不用 Hexo 了但是觉得还是很厉害因为我之前看过 Hexo 的代码觉得迷迷糊糊。\n\n\n\nwgjak47's blog\n“运维开发工程师”\n是我看不懂的那种（指 k8s）\n\n\n\n初等記憶體\n「 一個你知道的地方，和一個沒有酒的故事 ｜ 言文 」\n听起来好像萌妹啊！\n\n\n\nOriginCode 札記\n「無人訪問之無趣博客 * 1」\n好像现在是 初中生 高中生来着……\n\n\n\nVifly 的博客\n“世上只有一种英雄主义——就是在认清生活的真相之后依然热爱生活。”\n好像是炼丹的，反正我又不懂炼丹……加速迫害不要停下来啊！\n\n\n\nLeo's Field\n\"Time to change drinks and mix... wait\"\n呃……之前忘记了……（逃\n\n\n其他地方认识的\n不符合其它几个模块的描述并不意味着不重要！\n\n\n\n头像\n链接\n自我介绍\n我的介绍\n\n\n\n\n鸡腿工坊\n\n新鲜 可爱的鸡腿！\n\n\n"},{"title":"Undefined Script Works!","url":"/Undefined-Script-Works/","content":"Undefined Script Works!\n「I am the shell of my system.」\n「Command is my body, and argument is my blood.」\n「I have created over a thousand lines of logs.」\n「Unaware of less, nor aware of more.」\n「Withstood error to create many scripts, waiting for prompt's arrival.」\n「I have no mouse. This is the only bug.」\n「My whole life was `Undefined Script Works`!」\n一些个人项目\n大概都是些我觉得比较有意思的小玩意。\nHikaru\n生成这个网站的静态生成器。\n\n主页：https://hikaru.alynx.one/\n仓库：https://github.com/AlynxZhou/hikaru/\n\nFlipClock\nC 语言实现的一个开源 Fliqlo 替代品（macOS 用户视频里经常出现的翻页时钟屏保）。基于 SDL2。\n支持 Linux/Windows 且 不依赖 Adobe Flash。可直接设置为 Windows 屏保，绿色免安装。\n\n仓库：https://github.com/AlynxZhou/flipclock/\nWindows 编译好的安装包下载：点击带有 win 的压缩包\n\nGNOME Terminal Middle Click Close Tab Patch\n一个添加了使用鼠标中键关闭 Tab 功能的 GNOME Terminal（上游不知道为什么一直没收我的 Patch）。\nArch Linux 用户直接到 AUR 安装。\nAZTGBot\n零依赖 Node.JS Telegram Bot API 框架。\n\n主页：https://tgbot.alynx.one/\n仓库：https://github.com/AlynxZhou/aztgbot/\n酒仙：点这里让酒仙帮你决定晚上吃什么\n\nAZPiano\n一个把你的按键映射成钢琴并且能记录下来的 React Web App。\n\n主页：https://piano.alynx.one/\n仓库：https://github.com/AlynxZhou/azpiano-react/\n\nAlynx Live Wallpaper\n让你选择视频作为壁纸的 Android 应用。\n\n主页：https://livewallpaper.alynx.moe/\n仓库：https://github.com/AlynxZhou/alynx-live-wallpaper/\n\n"},{"title":"基于 GitHub Issue 的前端评论框","url":"/posts/Frontend-GitHub-Issue-Based-Comment/","content":"造轮子是病，得治。\n自从造了 前端博客搜索引擎 的轮子之后，我对自己的能力有了极大的信心，同时也掌握了一些有趣的用法，于是把枪口瞄准了下一个我看着不顺眼的地方——评论框。\n（这标题怎么写的和毕业论文似的！）\n\n\n轮子也不是白造的。\n从我建站以来我的评论框就命途多舛，Disqus 虽然是最著名的评论系统，但是在国内访问不太顺畅。多说火了一段时间之后便关门大吉，HyperComments 则在我用了一段时间后发邮件提示要收费了，于是我之前的评论便华丽流失。而对于 Valine 这种基于 LeanCloud 的评论系统，我对 LeanCloud 不甚了解所以也不想尝试（而且 Valine 现在似乎转向闭源了，当初也许是个正确的决定）。然后赶上 Gitment 和 Gitalk 火了起来，大家意识到 GitHub Issue 正是个放评论的好地方。但是由于 Gitment 和 Gitalk 采用他们自己的服务器实现博客评论框提交——转发到 GitHub API 的实现，以及 采用的 OAuth App 权限过高，有人怀疑这不太安全，于是我也没太敢参与。后来遇到 comment.js 这个项目，它绕过了提交评论的问题——直接给一个到 GitHub Issue 的评论框的链接就可以了。于是我就开始用这个，至于什么 utterances 这种用 GitHub App 降低权限的评论系统，我也懒得尝试了。\n但我为什么决定替换掉 comment.js 我已经记不清楚了，可能是为了对主题的显示有更好的掌握吧，毕竟它带有自己的 CSS 样式而且经常和我的冲突，也可能是因为它迟迟没提供像 Disqus 一样查找每篇文章评论数目的功能，不过它现在已经不再维护了，所以我也算是未雨绸缪。\n事情本该很简单。\n研究了一下原理其实并不是很难，首先就是从 GitHub 的 API 上 ajax 获取数据，然后操作 DOM 添进去就可以了，所以我就先阅读了 GitHub API 的文档，总之还算容易，只要先获取一个仓库的 issue 列表，然后按照某种方法在里面查找相关的 issue，如果没有就渲染一个到新建 issue 的链接，否则获取该 issue 的全部评论并显示就可以了。\n查找 issue 的 key 也算容易，我给它做成了函数参数，然后在主题模板里填一个每个页面唯一的字符串就行了，比如文章标题，然后新生成 issue 页面时候就把这个作为 issue 的标题，这样查找 GitHub Issue 页面时候也比较容易看。然后 GitHub 把 PR 也视为 issue，这个不要紧，收到数组之后过滤一下就好了。而显示数目我琢磨了一下其实也没什么难的嘛！我都获取到所有 issue 的信息了。做一个新的函数，主题作者在页面上放置一系列空的元素并设置好 class 属性，然后同样地把每个页面唯一的字符串设置成这些元素的属性（Disqus 也是这样的），加载函数时候把 class 作为参数传进去，分别从 issue 列表里查找对应的标题就可以了。还有一个奇葩问题是 GitHub issue 的 comments 指的是除了顶楼以外的评论，但很显然看起来不是这样的，这个也简单，直接把顶楼加到数组里就成了嘛。剩下就是艰苦的在浏览器里刀耕火种写 JS 拼 HTML 字符串发 ajax 请求写嵌套回调（没有 async/await 也太痛苦了吧！。\n一切正常工作了一段时间一后我发现不太对劲，怎么评论太多的时候显示不全呢？仔细查了一下发现 GitHub API 是强制分页的，也就是说不管你怎么设置，最多一次只能获取 100 条评论，默认则是 30 条，本来我不太想给博客加评论分页功能的，现在看来是 GitHub 被迫让我加啊。当然这个并不是最痛苦的，最痛苦的是它查找仓库的 issue 列表的时候也是强制分页的！这就麻烦了，还记得我们之前说要获取到列表之后查找标题吗？获取不到完整列表还怎么查找啊！\n当然你可以说按顺序多查几页不就行了嘛，这就是它分页难受的地方了！ajax 是异步的啊亲！你不会想让我一个 for 循环几个 ajax 还指望优雅的等他们结束了再跑查找吧！我知道能用 Promise.all() 解决，但是由于我大发慈悲的支持使用 IE11 的用户（微软我&amp;A%￥S&amp;……省略一千字儒雅随和），所以我的函数是基于回调的，那也没什么办法。而且这样首先你得读一下仓库信息才能知道有多少个 open 的 issue（没错只能算 open 的不能算 close 的！所以在后面查 issue 的时候我也不得不筛选掉 close 的，不过这大概也许是个 feature？），然后自己计算有多少页。最后我只能造了一个不那么优雅的尾递归回调（反正就那个意思），不过它工作的不错，这样我就可以获取到全部的 issue 列表了。\n然后后面其实还是差不多，至于评论分页又不一样了，既然 GitHub 只有分页 API，我也就半推半就啊不是将计就计吧。我才不要继续获取全部评论了，我也每次直接获取 GitHub 那边的一页就行了，每页个数则由主题作者传参进来。至于如何确定我要哪一页呢？和搜索功能一样，继续前端解析 query string 呗。根据 issue 评论总数计算一下有几页，然后生成几个链接放在页尾，每次加载时候解析一下参数确定当前页是哪个即可。当然，不要忘了 issue 顶楼不算评论，计算分页的时候也不要给它加进去！而且既然是这么分页，我也懒得把顶楼算在里面了（不然真的麻烦的要死啊后面分页和每页个数全乱了），所以假如你设置每页 10 个评论，那第一页其实有 11 个，别烦我，代码在那，不满意自己改……然后继续刀耕火种……\n为了减轻负担，我没有实现太多的功能，比如时间戳我没有搞成什么几分钟几小时前，这种东西又不清晰又浪费带宽，我只搞了基于 marked 的 Markdown 渲染（必须的）和语法高亮，Markdown 渲染不是必须的，因为你可以 设置 header 让 GitHub 直接返回 HTML。为了保证效果统一，这个 JS 只是建立了 HTML 布局，给每个元素添加了 class，具体的样式则完全是主题自己编写的，所以配合起来也比较好看。\n最后的效果其实还可以，完整的脚本就是 这个网站在用的 JS，具体和主题的整合方法就慢慢翻 ARIA 的模板吧。唯一的缺点是 GitHub API 的频率限制太低，按照这个弱智的 issue 列表分页的话又不得不多一次读取仓库有多少 issue 的请求，假如你的 issue 太多估计也是问题？不过应该不会有那么多博文吧！我只有调试脚本的时候遇到过被 GitHub 提示等会的问题，所以对于访问者应该没什么影响。有影响以后再想解决办法（或者没办法）。\n也许最好的办法是解决掉需求——要什么评论框？不就是破事水？如果有问题想联系作者电子邮件又不是不能用！（逃\n其实你知道，烦恼（bug）会解决烦恼（bug）。\n这一部分更新于 2020-08-17 10:34:00。\n\nGitHub API 推荐用户 缓存之前的请求响应，然后根据缓存的响应的 Header 里面的 ETag 发送请求查询是否过期，若未过期则返回一个不消耗频率限制次数的 304 状态码。我心想这也简单，那就在前端搞一个缓存就可以了。\n然后我搜索了一番找到了 CacheStorage，看起来它是唯一一个跨标签页的基于 Session 的正宗的前端缓存。但是很显然 IE 又不支持，而且这个 API 基于 Promise 并且只能缓存 Response 对象，也就是说没办法简单的通过在 XHR 的时候判断一下跳过不支持的情况，要 Polyfill 则需要引入完整的 Promise 和 fetch/Response，所以我们做了一个艰难容易的决定——是时候去掉 IE 支持了！\n于是我把请求 API 的函数改成了如下操作：\n {\n  let cachedResponse = null;\n  return cachePromise.then((cache) => {\n    return cache.match(path);\n  }).then((response) => {\n    // No cache or no ETag, just re-fetch;\n    if (response == null || !response.headers.has(&quot;ETag&quot;)) {\n      return window.fetch(path, opts);\n    }\n    // Ask GitHub API whether cache is outdated.\n    cachedResponse = response;\n    opts[&quot;headers&quot;] = opts[&quot;headers&quot;] || {};\n    opts[&quot;headers&quot;][&quot;If-None-Match&quot;] = cachedResponse.headers.get(&quot;ETag&quot;);\n    return window.fetch(path, opts);\n  }).then((response) => {\n    if (response.status === 200) {\n      // No cache or cache outdated and succeed.\n      // Update cache.\n      cachePromise.then((cache) => {\n        return cache.put(path, response);\n      });\n      // Cache needs an unconsumed response,\n      // so we clone respone before consume it.\n      return response.clone().json();\n    } else if (response.status === 304 &amp;&amp; cachedResponse != null) {\n      // Not modified so use cache.\n      return cachedResponse.clone().json();\n    } else {\n      // fetch does not reject on HTTP error, so we do this manually.\n      throw new Error(&quot;Unexpected HTTP status code &quot; + response.status);\n    }\n  });\n};\" data-info=\"language-JavaScript\" data-lang=\"JavaScript\" class=\"code-block\">let cachePromise = window.caches.open(\"cacheName\");\n\n// Fetching JSON with cache for GitHub API.\nconst cachedFetchJSON = (path, opts = {}) =&gt; {\n  let cachedResponse = null;\n  return cachePromise.then((cache) =&gt; {\n    return cache.match(path);\n  }).then((response) =&gt; {\n    // No cache or no ETag, just re-fetch;\n    if (response == null || !response.headers.has(\"ETag\")) {\n      return window.fetch(path, opts);\n    }\n    // Ask GitHub API whether cache is outdated.\n    cachedResponse = response;\n    opts[\"headers\"] = opts[\"headers\"] || {};\n    opts[\"headers\"][\"If-None-Match\"] = cachedResponse.headers.get(\"ETag\");\n    return window.fetch(path, opts);\n  }).then((response) =&gt; {\n    if (response.status === 200) {\n      // No cache or cache outdated and succeed.\n      // Update cache.\n      cachePromise.then((cache) =&gt; {\n        return cache.put(path, response);\n      });\n      // Cache needs an unconsumed response,\n      // so we clone respone before consume it.\n      return response.clone().json();\n    } else if (response.status === 304 &amp;&amp; cachedResponse != null) {\n      // Not modified so use cache.\n      return cachedResponse.clone().json();\n    } else {\n      // fetch does not reject on HTTP error, so we do this manually.\n      throw new Error(\"Unexpected HTTP status code \" + response.status);\n    }\n  });\n};\n当然理想很丰满现实很骨感，在不支持 CacheStorage 的浏览器里要 fallback 到不带缓存的版本，本来我以为很简单，但是……（下面开启吐槽时间。）\n支持 IE 的前端的痛苦都是相似的，不支持 IE 的前端则各有各的痛苦。\n\n为什么非 HTTPS + localhost 不能用 CacheStorage 啊，难道他们没考虑过在电脑上开发然后手机访问测试移动版吗？还是说他们打算在手机上起一个开发服务器？为什么 Firefox 在非 HTTPS 时限制 CacheStorage 的方法是在 Promise 里 reject 一个 Error 从而导致这个过程变成了异步的？为什么 CacheStorage 只能缓存 Response 而不是任意数据结构？Safari 不能完整支持 Response 对象也就算了，为什么移动版 Chrome 和 Firefox 也不支持？合着你们 fetch 返回的 Response 还不是 Response？这世界到底怎么了……\n所以最后需要一个长长的基于 Promise 的判断加载函数：\n {\n  // Unlike in .then(),\n  // we must explicit resolve and reject in a Promise's execuator.\n  return new Promise((resolve, reject) => {\n    if (cachePromise != null &amp;&amp; fetchJSON !== uncachedFetchJSON) {\n      return reject(new Error(&quot;Cache is already loaded!&quot;));\n    }\n    // Old version browsers does not support Response.\n    if (window.Response == null) {\n      return reject(\n        new Error(&quot;Old version browsers does not support Response.&quot;)\n      );\n    }\n    const testResponse = new window.Response();\n    // Safari and most mobile browsers do not support `Response.clone()`.\n    if (testResponse.headers == null || testResponse.clone == null) {\n      return reject(new Error(\n        &quot;Safari and most mobile browsers do not support `Response.clone()`.&quot;\n      ));\n    }\n    // Chromium and Safari set `window.caches` to `undefined` if not HTTPS.\n    if (window.caches == null) {\n      return reject(new Error(\n        &quot;Chromium and Safari set `window.caches` to `undefined` if not HTTPS.&quot;\n      ));\n    }\n    window.caches.open(&quot;CacheStorageTest&quot;).then((cache) => {\n      fetchJSON = cachedFetchJSON;\n      cachePromise = window.caches.open(name);\n      return window.caches.delete(&quot;CacheStorageTest&quot;);\n    }).then(() => {\n      return resolve();\n    }).catch((error) => {\n      // Firefox throws `SecurityError` if not HTTPS.\n      console.error(error);\n      return reject(new Error(&quot;Firefox throws `SecurityError` if not HTTPS.&quot;));\n    });\n  }).catch((error) => {\n    console.error(error);\n  });\n};\" data-info=\"language-JavaScript\" data-lang=\"JavaScript\" class=\"code-block\">// 加载评论的时候才加载缓存。\nlet cachePromise = null;\n\nlet fetchJSON = uncachedFetchJSON;\n\nconst loadCache = (name) =&gt; {\n  // Unlike in .then(),\n  // we must explicit resolve and reject in a Promise's execuator.\n  return new Promise((resolve, reject) =&gt; {\n    if (cachePromise != null &amp;&amp; fetchJSON !== uncachedFetchJSON) {\n      return reject(new Error(\"Cache is already loaded!\"));\n    }\n    // Old version browsers does not support Response.\n    if (window.Response == null) {\n      return reject(\n        new Error(\"Old version browsers does not support Response.\")\n      );\n    }\n    const testResponse = new window.Response();\n    // Safari and most mobile browsers do not support `Response.clone()`.\n    if (testResponse.headers == null || testResponse.clone == null) {\n      return reject(new Error(\n        \"Safari and most mobile browsers do not support `Response.clone()`.\"\n      ));\n    }\n    // Chromium and Safari set `window.caches` to `undefined` if not HTTPS.\n    if (window.caches == null) {\n      return reject(new Error(\n        \"Chromium and Safari set `window.caches` to `undefined` if not HTTPS.\"\n      ));\n    }\n    window.caches.open(\"CacheStorageTest\").then((cache) =&gt; {\n      fetchJSON = cachedFetchJSON;\n      cachePromise = window.caches.open(name);\n      return window.caches.delete(\"CacheStorageTest\");\n    }).then(() =&gt; {\n      return resolve();\n    }).catch((error) =&gt; {\n      // Firefox throws `SecurityError` if not HTTPS.\n      console.error(error);\n      return reject(new Error(\"Firefox throws `SecurityError` if not HTTPS.\"));\n    });\n  }).catch((error) =&gt; {\n    console.error(error);\n  });\n};\n不管怎么样现在这个网站在支持 CacheStorage 和 Response 的浏览器上（似乎也就桌面版 Chrome/Firefox……）是缓存 GitHub API 的结果了，打开 DevTools 切到 Network 面板可以看到 GitHub API 返回的是 304 而不是 200，其他浏览器则 fallback 到无缓存的 fetch。当然其他浏览器不包含 IE 咯。\n由俭入奢易，由奢入俭难。\n这一部分更新于 2020-08-18 12:25:00。\n\n我后来又仔细想了想，其实要兼容 IE 还是有办法的，首先 fetch 和 Promise 都有成熟的 polyfill，甚至 URLSearchParams 也有，只要写一段脚本在不支持的时候加载他们就可以了。然后去掉所有 IE 不支持的 ES6 特性，比如箭头函数、模板字符串、for…of… 循环以及 MapReduce（IE 竟然支持 const 和 let 真是惊到我了）。但是能做到并不意味着一定要做，人总是还要向前看的，现在是 2020 年，连罪魁祸首始作俑者微软都放弃了 IE，就算是照顾用户量，IE 用户也是可以忽略的那一部分了。既然我已经用 ES6 重写了，就不要想再让我为这种历史垃圾放弃我得到的好处了，从我开始写主题到现在丢掉 IE 支持也算是仁至义尽了，所以为什么不让这些用户支持一下 Firefox 呢？\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"和 cheerio 说再见！","url":"/posts/Drop-Cheerio/","content":"我早就想把 cheerio 从 Hikaru 的依赖里移出去了，倒不是我对他的功能有什么不满，但是一年不更新 NPM 上的包也太恶心了吧！\n\n我的生成器使用 cheerio 的地方主要有两个，一是给标题生成喵点并依次生成 TOC，二是检查文章里相对路径的图片和链接引用并改成绝对路径，否则如果截取之后放在首页的摘要包含图片的话，会因为当前页面的地址变化而不工作。后者也是我自己编写生成器的原因之一，就是因为像 Hexo 或者 Hugo 这种已有的生成器内部并没有考虑，只能通过插件解决，我在写 Hexo 主题时嵌入了一个使用正则表达式的脚本，但相比之下我觉得还是一个能理解 HTML 的库更加可靠。所以后来我选了 cheerio 来做解析和修改以实现这些功能。\n但是 cheerio 有一个 很古怪的 bug，存在于它目前在 NPM 上最新的版本 1.0.0-rc3 上。假如你使用 cheerio 解析并编辑包含中文的 HTML 的话，导出字符串时所有的中文都被编码成了 HTML 实体，导致进行下一步处理比如用 substring 截断的话，字符串长度变化了，而且可能会在文字中间截断。假如你使用 decodeEntities: false 的话，原本文档里的 &amp;lt; 一类的字符反而会被 cheerio 导出成 &lt;，变成一团乱麻。\n这个 bug 非常古怪并且我花了一段时间来研究它，上一个版本 0.22.0 使用 decodeEntities: false 是没有这个问题的。最后发现原因是 cheerio 在 1.0.0-rc1 开始引入 parse5 代替原本的 htmlparser2 作为默认的 HTML 解析器，而 parse5 在解析时并不会使用 decodeEntities 这个参数，比如你输入 &amp;lt;，parse5 解析时会在节点里存储原本的值 &lt;，但 cheerio 在序列化的时候还是会依赖这个参数进行编码，所以假如传递 false 进去，cheerio 就不会主动进行 encode，导致最后出来的是 &lt;。而 htmlparser2 会按照这个参数选择解不解码，所以也不会发生这种错误。\n那这么看起来是 parse5 的问题？并不！parse5 有自己的序列化函数，和自己的解析函数是配套的，所以只要使用 parse5 的序列化函数就不会存在这个问题了。\n最后总结起来修复的办法也有很多：首先其实序列化的时候并不需要将所有元素都编码成 HTML 实体，只要对几个字符进行转义即可，我提交了这样的 PR，但因为 cheerio 和它自己的序列化库 dom-serializer 是两个仓库，不是很好处理，而且其实也没有从根源上解决 htmlparser2 和 parse5 表现不一致的问题。cheerio 后来的提交中采用的是简单办法，假如使用 parse5 解析就继续使用 parse5 序列化就好了。\n但是这个提交之后并没有发布到 NPM 上，NPM 挂的一直是有问题的 1.0.0-rc3 版本，至于原因呢很简单，他们打算释出第一个稳定版本 1.0.0，所以要等到所有 TODO 都解决了再发新版本！\n搞毛啊老哥，你这样放着有 bug 的版本是把用户做宝搞吗？而且你是个函数库，下面好多人依赖你处理 DOM 呢，NodeJS 上提供 jQuery 模式的函数库大概也没什么别的替代品了，一堆项目在 issue 里问你就给个这破理由？\n我选择的是锁死 0.22.0 版本，其他下游的项目也都各自做了 workaround，要么安装 GitHub 上的 1.0.0 分支要么回退版本。但总之都让强迫症很不爽啊！\n大家等他发稳定版就这么等了一年，在这一年间有些项目比如 Hexo 直接抛弃了 cheerio 用正则处理 HTML，虽然他们主要是为了性能。我倒不是那么在乎生成器的性能（真的在乎的话我就该去用 Hugo，而且我也不敢说我自己的代码写的很好）。\n晚上睡觉前我突然想到假如只是过滤链接和图片并检查他们的属性的话其实不需要 jQuery 一样的 API，只需要能理解 HTML，那找个简单的解析器就可以了。而且第二天正好读了 卷老师的这篇博文，发现和我想的也差不多。于是就开始动手。\n卷老师用的 sanitize-html 对我来说不太合适，因为我的静态生成器并不需要过滤内容——都是 Markdown 生成的，而且不安全也是使用者自己故意写的，不是我的责任，生成器也没有不安全的 HTML 的运行环境。sanitize-html 和 cheerio 用的都是 htmlparser2 作为解析器，虽然它号称自己是跑得最快的 HTML 解析器，但经过之前那个问题我还是心有余悸。而且 htmlparser2 是非常简单的基于事件回调的解析器（就像 Python 自带的那个，我太久不写 Python 不记得叫什么了），不会给你构建树状结构也不包含序列化，自己写序列化就容易像之前那个 cheerio bug 一样出问题。所以我考察了一下 parse5 发现还不错，会构建树状结构，数据结构都写在文档里，同时就是简单的可以直接操作的 Object，至于速度虽然慢一点但我并不太在乎那 10 毫秒。\n于是我就先手动造了一些 wrapper 函数比如递归前置遍历一颗树来代替 cheerio 的 $.each()，前置遍历正好是 HTML 文档自上往下的顺序，生成 TOC 的时候也是按照这个顺序来的，然后就是比如获取结点内文本的函数、获取属性和设置属性的函数之类的。至于插入结点我想了个巧妙的办法，因为 parse5 把最终解析到的文本作为单独的结点，我就直接在插入文本的函数里让 parse5 解析输入的 HTML，然后用得到的子结点替换被插入结点的子结点即可。\n随后我重写了生成 TOC，生成标题 ID 和检查文章里相对路径的图片和链接引用并改成绝对路径的函数。然后写了点简单的测试样例跑了一下发现没问题，就用它们替换掉 Hikaru 的 utils.js 里面用 cheerio 的版本，然后修改了 process 代码。我造的这几个简单的 wrapper 完全符合我的要求，于是提交打版本号发布一气呵成，一年不更新的 cheerio 就从我的生成器里拜拜了。\n虽然嘴上说着不追求速度，但是凭我肉体的感觉还是多少快了一点儿，不过我也并不是很在乎生成的时间，感知真的不强，无所谓了。但我真的不能理解这种为了憋个大的不发版本把用户做宝搞的行为，就算是发个 1.0.0-rc4 也比一年不发强吧！就算只是 make user happy 也好，何况面对的不是 user 而是其它项目的 dev 呢，都是同行，这行为算不算托大？反正我是习惯做了点改动就打个新版本，即使我自己安装的都是开发版本，我也希望能把我最新的修改送到用户手上，又不是 breaking change 或者什么不能随便更新的软件，打个小版本号至于那么难吗？？？\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"给你的主题来点暗色！","url":"/posts/Dark-Mode-in-Theme/","content":"我自己对暗色模式其实是没什么兴趣的，因为设计一种配色就已经让我绞尽脑汁了，还要我设计另一种。但是我也确实意识到暗色模式在晚上玩手机实在是很方便，而且做这个也很流行，于是我也做了一个，只是因为我能做到。\n\n跟着系统变色就行了吗？\n现在的系统大概都支持暗色模式（Linux 的桌面环境早就有这种设置了，Firefox 可以直接读取我的系统设置，Android/iOS 也都有暗色模式开关），浏览器也紧跟潮流提供了 @media 的 查询属性（IE：那……是……什……么……）。理论上来说只要简单地在 CSS 里面查询然后编写修改颜色的代码就可以了，问题只是如何修改颜色比较轻松。\nCSS 变量是好东西！\n使用 CSS 变量 当然是最简单的解决方案了，就像我们平时编程一样使用变量作为 color 和 background 的值，然后在查询到暗色模式的代码块里给这些变量重新赋值，一切都十分简单有条理，而且最重要的是你不需要一个一个选择器查找有哪些需要变色的属性，所有的颜色变量都是放在一起的。\n真是恨死 IE 这废物了！\n虽然 IE 有很多不支持的选项，但是不支持 CSS 变量真是让我工作量剧增的一件事情。虽然我从不测试我的网站在 IE 上能否运行，但是在最新版 IE 上一般都是没问题的，因此我也会放弃一些最新版 IE 不支持的新特性，CSS 变量就是其中之一。\n既然没有办法用 CSS 变量，那就只能自己一个一个找选择器下面和颜色相关的属性，然后给它们重新设置属性了，真是找的人头晕眼花啊。\n可能有人会说你不是用 CSS 预处理器吗，预处理器不是也有变量吗？但是预处理器是在生成阶段把变量编译掉了啊！不方便到运行时（浏览器）里去替换变量。\n我就是想在暗色浏览器里用亮色啊！\n在全部重新调整过颜色并能看之后（其实就是把浅色的色块换成深色，颜色层次基本不变，背景图搞个反色，至于那些彩色的按钮标签我实在没精力重新配色了，把透明度调低一点就好了），我自己还是比较喜欢自己一开始设计的样子，但我又是个习惯电脑全局暗色的人，这怎么能忍！\nCSS 的媒体属性不像一般的属性，只能是浏览器设置我们读取，没有办法用 JS 控制，于是也就没法简单地利用这个添加切换按钮。上网搜了半天也只有曲线救国的方案。\n曲线救国\n如果并不是想那么和系统的设置同步而只是给自己的网站添加切换的话，并不需要媒体查询。只要设计一个按钮给 &lt;html&gt; 或 &lt;body&gt; 添加删除 class/attribute 就行了。然后如果要和系统同步，在 JavaScript 里也有 相关的 API 可以做到查询和监听，在检测到变化的时候也修改 class/attribute 即可。\n我选择的是给 &lt;html&gt; 加 data-theme=\"dark\" 或 data-theme=\"light\" 属性，不选 &lt;body&gt; 是因为 WebKit 那些该死的不遵循标准的 scrollbar 伪类，文档没有说他们到底依附哪个元素，我尝试得到的是 &lt;html&gt;。接下来只要把之前的 CSS 里面的媒体查询选择器改成 html[data-theme=\"dark\"] 就行了。\n不过还要注意继承关系，这样写的话有些属性并不是继承外面的，而是在这个选择器里面就近继承。比如假如修改了 html[data-theme=\"dark\"] a 的边框，那 html[data-theme=\"dark\"] a.cls 的边框会优先继承这个，而不是 a.cls。我知道有些人可能会笑我半懂不懂了，但是我确实遇到了这个问题，并且思考了一下找到了原因。\n还有一个比较尴尬的事情，我给一些元素设置了 transition 用于 :hover 之后加一个渐变颜色的效果，现在暗色模式也是修改颜色，导致这些元素会比其他元素慢变一下，没什么好办法因为你分不开两种 color 变化。我的解决方案是一个一个找切换暗色模式时候会变属性的选择器，给它们也添加 transition。效果还不错，不过 Chrome 在处理这种 CSS 动画时候竟然会掉帧？？？\n不管了，反正我用 Firefox，Firefox 效果好得很，完全不掉帧。\n更新（2020-08-07 10:50:00）：我怀疑 Chrome 想做新时代的 IE，其实并不是性能问题导致掉帧，WebKit 对于继承来的属性的 transition 存在问题，会导致不是同时变换而是有延迟的变换，效果糟透了，StackOverflow 上也有人遇到这个问题，看起来是 bug 并且不打算解决，而 Firefox 就没有这个问题。使用 CSS 变量在 WebKit 下效果会好一点，不过也不能给所有变色的元素加 transition，还是会卡，只能给 &lt;body&gt; 加一个，因为我的链接有 :hover 时变色的 transition，都是 color 就没办法在那时 transition 而暗色模式时候不 transition。总之由于 WebKit 的存在导致没法让全部元素同步 transition，只能近似。两权相害取其轻，还是让 IE 用户只能用亮色吧，我最后还是选择了 CSS 变量。\n怎么你这破网站换个页面还要重新点一次？\n一切看起来都十分美好，直到我把一个暗色页面切成亮色然后点了个链接，下一个页面并不会理会我们上一个页面设置了什么主题，又变成了暗色。每个页面点一下切换按钮也太烦人了，我们得来点持久化。\n某个域名想在用户的浏览器里存点是完全可行的，使用 localStorage 就行了，就是简单的键值对。但是这样我们就有了多种可能切换亮暗的动作：localStorage 里面存的选项，网页加载时浏览器媒体查询的结果，用户点了网页上的切换按钮，用户点了系统切换亮暗的设置。这些的判断顺序要好好处理一下，不然某些就会被忽视掉变成“我点了怎么不动啊！！！”。\n经过我考虑一下之后，这个玩意的逻辑应该是这样的：\n\n假如 localStorage 里面没有值，用户是首次打开网站，此时读取媒体查询按照系统的主题设置。\n否则说明用户之前打开过网站，已经有他自己的喜好了，按照 localStorage 里面的值设置。\n上两个步骤结束之后注册一个媒体查询监听器，用于响应用户修改系统设置。\n注册一个按钮监听器，用于响应用户点击网页切换按钮设置。\n\n以上 1 和 2 的顺序不能反了，并且每一个设置动作里都要把这次设置的值写入 localStorage 用于后续加载用户的选择。\n现在看起来一切都很满意，是时候发布了！\n用户：啊！我的眼睛！\n我躺在床上用手机测试的时候又发现了一个问题。因为网页在生成的时候总有一个初始状态（JS 要等到 document 加载完成才开始处理 DOM，不像那些单页应用），假如我设置成暗色然后切换到别的页面，网页就会以亮色加载然后变成暗色，用户在晚上看起来就像是个闪光弹（伏拉什棒！）。\n其实没什么好的解决办法，因为这是传统 HTML 页面的限制之一，我也不想找有没有什么新的东西能解决这些问题，最后的方案其实相当简单，既然亮色到暗色会让人受不了，我搞成暗色到亮色不就行了。\n于是就是把模板里按钮的初始状态修改一下，渲染的时候出来的是 data-theme=\"dark\"，假如用户选择亮色，加载页面时会有一个暗色到亮色的变化。反正我自己都不在意。\n更新（2020-08-06 18:23:00）：我后来阅读了一些其它主题的代码，看它们是怎么在不使用单页应用的前提下解决这个问题的，结果方法相当简单，我自己也想得到：不用等到 DOMContentLoaded 事件之后，反正只是修改 &lt;html&gt; 标签，直接在 &lt;script&gt; 标签里面编辑 document.documentElement 是可以的，因为反正加载到 &lt;script&gt; 的时候肯定也已经加载到 &lt;html&gt; 了。所以就把修改这个属性和修改按钮的 DOM 分开了两部分，并且添加了一个 storage 的监听器，这样假如打开了多个页面，一个页面切换其它页面也会跟随切换。\n不要过度设计！\n经过这么一大堆折腾（代码行数++++++++），我甚至在想要不要支持每个页面单独设置亮暗初值，反正只要添加一个 front matter 然后在模板里判断一下嘛。不过后来想了想，就算有这么个功能又有什么用？实际意义几乎为零，徒增复杂度，所以还是不要过度设计了。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"修复更换 PCI-E 插槽后 Windows 下无线网卡的名称问题","url":"/posts/Fix-Windows-Wireless-Adapter-Name/","content":"这是一篇其实没什么逻辑也没什么技术的文章，但踩到这个坑又很头痛，所以记录一下。\n\n\n我用的是一张 PCI-E 的网卡，占据一个 PCI-Ex1 的插槽，对于一个主流的 ATX 主板来说有三个选择，第二条 x16 长度的插槽上面的一个和下面的两个，由于显卡一般会插在第一条 x16 上，所以如果插在第二条 x16 长度上面的那个，会挡住一部分显卡风扇，所以我一开始插在了第二条 x16 长度插槽下面的第一个插槽。这样也是有点问题的，因为这里 x16 和 x1 之间并没有留出一个槽的空位，一般主流显卡又都是双槽的，虽然我不太可能在机箱里塞第二张显卡，但是这么装直接就干掉了这种可能性，所以我一直想把无线网卡换到最底下的插槽。（这一部分比较乱，但是装过机的直接上网搜一下主流 ATX 主板的图就能理解了。）\n之前由于最后一个插槽挡板的螺丝拧的太紧我一直没换，今天买了一个柄比较粗比较省力的螺丝刀，终于拧下来螺丝把网卡换了个插槽。开机之后 Linux 下其实没什么问题，检测设备和持久化命名都正常工作了。不过 Network Manager 似乎认为更换了设备，所以建议删掉之前的连接配置重新连接网络，之后一切都正常。\n切到 Windows 发现不太对劲，首先就是我的 WiFi 适配器名字变成了 WLAN 2，想要重命名成 WLAN 又提示已经存在，但是我又看不到，点进去发现它选择的无线网卡名字后面多了个 #2 的后缀，总之我也不知道怎么回事，但是强迫症觉得很难受，明明我只有一张网卡啊。\n上网搜索了一下，首先是在设备管理器的查看菜单里选择显示隐藏的设备，这样就会发现一个灰色的没有后缀的网卡，我也不知道 Windows 为什么要存一个隐藏的之前存在现在不存在的 PCI-E 设备，首先按照网上的说法卸载掉这个设备然后重启，再开机就没有这个隐藏设备了。\n接下来需要去掉 #2 的后缀，让 Windows 把这个插槽里的卡认成唯一的一张，这里就十分晦涩，Windows 试图隐藏起这个逻辑，但导致了一个令强迫症十分不爽的问题。我搜索了一下，发现了一个 百度文库文档 提供的方案。\n首先打开注册表编辑器定位到 HKEY_LOCAL_MACHINE\\SYSTEM\\_ControlSet001\\Control\\Network\\{4D36E972-E325-11CE-BFC1-08002BE10318}\\Descriptions 这一项，然后在右侧找到你无线网卡的名称，里面的值应该是 2，改成 1，然后卸载网卡设备，然后重启，应该就解决了，而且因为设备名字恢复了，WLAN 2 也应该变回 WLAN 了。\n所以其实这篇文章并没有什么逻辑和技术，但是 Windows 自作主张非要保存一个隐藏的不存在的设备，实在是令人头痛，又没什么明显的解决方式，所以也只好记下来以防再次被恶心到。\n更新：Arch Linux CN offtopic Telegram 群组里面叫 Give Way 的网友表示并不需要这么复杂，只要把两个无线网卡的设备都卸载掉重启就可以了。理论上确实是如此，但我没机会再试了，遇到相同问题的朋友可以试试。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"让你们的主题商店离我远点！","url":"/posts/Taking-Your-Theme-Store-Away/","content":"我不觉得我是个刻薄的人，但对于一些实在令我讨厌的人，不把他们的名字挂出来就是我最后的怜悯。\n\n\n已经有不止一个人询问过我有关把博客主题移植到其他生成器上的问题了，这实际上是超出我范围的工作，因为我并不熟悉他们的生成器。但如果有人这样询问我（当然最好的方式是发 issue），我一般会先了解一下他说的生成器，然后解释是因为我没有时间或者我不熟悉目标技术栈。\n我还记得的最远范围是某个 Gridea 的用户发邮件问我怎么把我的主题用到他这个生成器上。某种程度上我觉得他要么是真的无知要么就是装成无知然后提一些在技术上很显而易见的问题来气人（我今天新学的词叫 troll），于是我去查了一下 Gridea，是个一条龙的基于 Vue 的图形化博客系统。对我足够熟悉的人可能知道我不喜欢把博客做成单页应用的样子，而且在我理解里博客生成器就应该是一个比较简单的命令行工具，而不是一个图形化数据库管理工具。尽管我不太喜欢这个项目和它的宣传方式，但万一对方真的是个并不了解这些的小白用户呢？我回复的语气可能并不是十分客气，但我还是解释了一下博客主题和生成器的关系，以及我不了解 Gridea 的技术栈也不是很喜欢这个项目，所以没办法写一个 收费/免费 的主题给这个项目。当然最后结果相对还不错，他也理解我给他的解释。\n但是我最近又收到一封标题为“诚邀合作事宜”的邮件，为了不破坏我第一句的承诺，我修改了部分名词：\n\n很喜欢你博客的风格，可否为Cxxxxx-CMS开发一套（免费/付费）主题，然后发布到Cxxxxx商店里面？\nCxxxxxJS：是一款顶级NodeJS全栈业务开发框架, 基于KoaJS + EggJS + VueJS + Framework7\nCxxxxx-CMS：是基于CxxxxxJS全栈业务开发框架开发的动静结合的CMS，可以快速构建企业网站、博客、社区、商城等Web应用\nCxxxxx商店：包括品类广泛的各类模块，满足不同场景的开发需求\nCxxxxxJS介绍：https://cxxxxx.com/zh-cn/articles/introduce.html\nCxxxxx-CMS介绍：https://cxxxxx.com/zh-cn/articles/cms-introduce.html\nCxxxxx商店运营模式：https://cxxxxx.com/zh-cn/articles/store.html\n\n我也不是个专业的前端工程师，现在不是，将来大概也不是前端“全栈”工程师，但我还是能懂这封邮件的内容。俗话说“文无第一，武无第二”，程序员的圈子里这句话应该也十分受用，所以我通读全文之后，目光就落在了“顶级”两个字上面。毕竟去掉套话之后，满足这类泛泛功能的项目也不少，所以还是先看看“顶级”比较有意思。\n在 Google 搜索这个 Cxxxxx 之后，还是有一些相关度比较高的内容的，出于个人习惯，我直接点开了他在 GitHub 上的仓库。既然是“顶级”框架，想必受益者众多，star 数量高达……108 个（截止昨日 18:00）。\n这就十分可笑了，虽然我也不是什么大牛，但是这个数量级 star 的仓库也有，虽然 star 不能说明代码质量，但是说明“顶级”这种人气形容词拿来正合适，如果我有这么个仓库，我肯定不会腆着脸在宣传语里加“顶级”二字。然后在大概阅读了一下文档和官网之后，我觉得就是个普通的 CMS，而且我也不认为静态博客生成器需要和 CMS 结合起来，我更希望静态博客生成器像编译器。而说到 JS 框架的话，既然都基于 KoaJS、EggJS、VueJS 了，我想不出还能在这些套娃外面再套什么娃（禁止套娃！）。\n于是我就回了一封有点嘲讽意味的邮件（我知道可能换个人不会说这种话，不过这种情况稍微嘲讽一下也没什么错吧）：\n\n前几天有个意思和你差不多的，但他没你这么能吹，他就是另一个博客生成器的普通用户。\n可能我这话有点刻薄，但假如我自己有一个 100 个 star 的项目，我不会在宣传语里用 顶级 这种形容词。\n写博客是我个人爱好，换句话说就是我也没打算靠这个玩意赚钱，就是自己用着爽然后开源出来有人喜欢随便用。我也没觉得自己技术强到可以靠这个吃饭了。\n既然是“诚邀”，那我觉得应该先看看我博客主题吧，不然容易让人觉得你是爬个 Hexo 主题作者列表然后群发邮件的哎。如果真看了就知道我这个主题的技术栈和你这个项目完全不搭。我的定位是静态博客生成器哎，我也不是很懂这种 CMS 或者 Koa Egg Vue，对这种快速批量构建网站没兴趣，毕竟个人博客嘛，随便折腾折腾才好玩。\n因此我建议你另请高明，或者真有兴趣，Fork 我的主题随便改。\n\n然后我就去忙别的去了，手头正好有个奇葩 Bug。我想这下大概清净了，没想到过一会又来了一封邮件。\n\n这就是一般大学生傲慢的地方了。如果是业务爱好者，我不好说什么。如果是一位志于软件开发的同行，就会一个静态博客生成器有什么可炫耀的呢？只怕你还真没有好好看看CxxxxxJS的文档了。\n\n这话说的很讨人厌哎。我脾气还算好，实在懒得一点点找出这话里有问题的地方反驳他，就随便回了一句：\n\n我再说一遍，我可没有给我自己的哪个项目加上“顶级”两个字\n\n然后他又来：\n\n你可以细细思考这个问题：我用顶级二字就把你伤到了吗？\n\nArch Linux CN 群里的群友建议我直接拉黑算了，我也这么想的，但是晚上回去闲的没事翻了翻，发现了其他的东西：\n\n好啊！你还敢说你是“诚邀”！还真被我说中了，明明就是爬了 Hexo 主题列表挨个作者群发！一开始邮件是我略有刻薄，不想再逐条反驳他，但看到这个我实在是 口区。\n首先对于这类“主题商店”，细细想想就知道不对劲，不仅仅这一个项目，还有别的没什么用户又跟你说邀请你驻入商店也是，他说他是诚邀作者设计一款主题放在他商店收费，可是主题作者真的拿到好处了吗？主题做的好，作者拿到的钱是用户掏的，而用户的使用习惯和黏性是落在他的项目上的！图里的有些主题我都看过，真的是非常优秀的作者，从作者角度想不得到任何好处地加入某一项目，也会希望这一项目的人气能给自己带来一些用户口碑，而这个项目很显然不满足！好一招空手套白狼！用户的钱三七分成，豪绅的钱……豪绅现在连钱都不用掏了，全靠一张嘴吹一吹？\n比如 Hexo、Jekyll、Hugo、Pelican 的主题页面（你愿意叫商店也行），都是作者自己主动提交的，为什么？因为这些广受好评的项目，可以为主题作者吸引人气，所以作者才会主动“合作”！\n其次说句不客气的，这类 CMS 项目说到底是拼工作量的东西，我也不是没写过。如果作者就是谦虚的说“我写了个 CMS，希望大家能给点意见使用一下”，我一个一般大学生哪里来的毛病非要嘲讽你？我最起码还得心里叨咕一句作者做这种项目坚持下来不容易，先支持一下劳动量再说。可是既然您把自己放在“顶级”的位子上，而且还看不起我，我也就不说什么客套话了。\n这种项目 V2EX 上一天能刷个十来个，有些就是很诚恳用来练手刷简历的，有些则是这种没有痛点制造痛点也要上的。我还再仔细搜了一遍这个项目，发现了好几篇什么掘金知乎甚至还真有 V2EX 上作者发的宣传帖，什么“动静结合”、“全栈开发利器”、“开发业务实战”，这种套话一套一套的。V2EX 帖子就 6 个回帖，有人表示不理解，本来 Hexo 是个静态博客生成器，为啥非得搞个动静结合解决痛点呢？然后作者复读机上身又复制了一下这类套话，换我我也不接着看了。类似我这种静态博客用户就是不想要“后台管理系统”才用静态博客生成器的，这个“痛点”我怎么理解呢？\n“一般大学生傲慢的地方”，这话说的真是让人恶心啊，一般大学生怎么了呢？一般大学生哪里傲慢了呢？一般大学生是不会在自己项目上用“顶级”二字做宣传的。“就会一个静态博客生成器有什么可炫耀的”，我倒是想问问这位同行（呕，请别叫我前端全栈工程师啊各位，我知道自己还不合格呢），您在哪里看到我炫耀啦？我也不在知乎掘金 V2EX 发宣传帖，我甚至还没来得及在我自己博客上介绍一下，我还经常说我这个有写地方写的还不够好，一边学习一边继续编写代码解决我自己的问题，请问您在哪听见我炫耀的？莫非是我在隔壁宿舍和同学聊天吹水时候跟他吹了一下您听见了？如果真是这样，我还得告您搞窃听呢。哦对了，我也不是什么就会一个静态博客生成器，我写生成器是为了解决我自己遇到的痛点的，这只是我涉及领域的一小部分，如果您真的仔细看了我的博客我的 GitHub，就知道我不是只搞前端，反而我看您 GitHub 都是 EggJS 的插件来着，真是令人眼花缭乱啊。\n什么你说让我看文档？文档有什么好看的，你想写什么就写什么，我也能把文档写出花来，那就能欺骗我自己项目本来没解决别人什么痛点嘛？\n让我细细思考？我看是您用了“顶级”二字，被我伤到了吧。都是写点胶水代码的玩意，我生成器还没用 Koa、Egg、Vue 这种框架呢，库是别人写的，框架逻辑都是我自己的，我 细细思考 一下真的很好奇在三大框架（甚至还有个企业级框架）上面能套出什么框架呢？如果你愿意一层一层一层的剥开我的心？本来我不想扯技术方面的，可是别的方面也没看到这个项目对主题作者有什么优势和好处啊！\n我要时时刻刻提醒我自己，我就是个一般大学生，不懂的东西还有很多，也不能学这种说话语气，不然会被人当成知乎上那种讨人厌的家长，就是自己本来也没什么见识还在年轻人面前的死要面子那种，年轻人说点什么就贬低他什么。\n我个人是不习惯在知乎掘金 V2EX 上写帖子骗眼球的，所以就写到我自己博客上了，想必“一般大学生”的博客，估计也没什么人看吧！如果您真的介意，还是那句话，“文无第一，武无第二”，评论区或者在您的博客上，放马过来，反驳我这篇文章，我不介意的。但是，我真的很厌恶往别人仓库刷这种“诚邀合作事宜”的 issue，issue 是用来说代码相关问题的也算是程序员的自我修养之一了吧。我写这个也是希望万一有主题作者看到了别上当了，这不是“诚邀”，是“白嫖”作者人气。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"装机小记","url":"/posts/My-Desktop-PC/","content":"由于笔记本散热和性能实在是不适合打游戏（有一说一，Optimus 双显卡还是没有直接单卡来得爽），所以很早就想组装一台台式机。特别是最近一直和高中同桌玩 Dota2，我的笔记本如果直播 Dota2，直播推流就会十分卡顿，而我又不想像 CSGO 一样降低画质玩。\n\n\n作为计算机专业的学生，当然不打算直接淘宝整机啦。经过一番挑选和参考别人意见，最后成套配置是下面这样：\n\nCPU：AMD Ryzen5 3600X\n主板：微星 X570 A-PRO 套装 2349\n显卡：NVIDIA Geforce RTX 2070 SUPER 4300（之前是 七彩虹 RTX 2060 战斧 6G 2199）\n内存：铂胜 运动白 DDR4 3000 8G x4 1000\n网卡：Intel AX200 150\n硬盘：三星 970 EVO Plus 512G 769\n硬盘：英睿达 MX500 1TB 799\n电源：海韵 CORE GX650 650W 金牌 549（特价）\n散热：利民 AK120 145（之前是 超频三 东海x5 89）\n散热：利民 M.2 硬盘散热片 39\n机箱：先马 鲁班1 209\n风扇：Arctic F12 PWM 温控 x3 120（一个被我用来替换散热器上的风扇了，就它带灯，好烦人。然后一个显卡前一个 CPU 后。）\n\n总计 10420。（有些具体价格我记不清了，而且京东价格总是波动。）性价比一般，因为我在其它人觉得没必要的地方分了很多预算比如主板风扇和硬盘，选 B450M 和西数的 NVMe 以及随便买个不带温控但是带灯的风扇的大有人在。\n选这样一套配置其实有原因，可能很多人觉得为什么要给 R5 配 X570 这种高端主板，不如换成 B450 然后把预算加到别的上面。但按照我朋友的使用经验，4 代和以前的 AMD 芯片组存在 USB 兼容性问题，而且我装好机器后就在 Arch Linux CN 群里看到有人遇到这种问题，5 代似乎重新设计了 USB 控制器，目前一切正常。\n如果仅仅是打游戏也可以把 R5-3600X + X570 换成 i5-9600KF + Z390，大概可以便宜一点然后升级一下显卡？我觉得差价是不够 2060 换 2060S 的。或者如果要求不高换成 R5-3600 也行。但 R5-3600(X) 是 12 线程而 i5-9600KF 只有 6 线程，所以我还是选择了 Ryzen，反正 AMD CPU 最近表现都很不错，没必要给 Intel 掏更多的钱。如果你在京东买，建议自己翻翻店铺，一般买主板 CPU 套装更便宜，但是它不会摆出来……\n显卡一开始我是打算买个 1999 的 GTX 1660Ti 的，反正我玩的游戏也不需要光线追踪（难道真相不是本来就没几个游戏支持光线追踪嘛？），然而看到七彩虹最便宜的 2060 正在特价 2199，果断少买一条内存，加钱上这个。反正 1999 的 1660Ti 也是便宜货，而且看了一下视频似乎这块卡也不是丐中丐中丐，质量还可以（同价位索泰铭瑄也不能说是什么高端货吧？），反正内存可以再插新的，而显卡二手不值钱。什么你说 A 卡？虽然 A 卡对于 Linux 的驱动支持更好一点，但是 N 卡也不是不能用，而且我要开直播的话 NVENC 编码挺香的，而且对我的 Steam 库存来说 N 卡也更友好一点（但是骂老黄还是要骂的）。另外虽然我不做机器学习，但万一室友毕设需要的话，反正我上班也不用台式机，装个 CUDA 让他 SSH 上去用岂不是你好我好大家好。\n内存其实没什么特别要求，不过由于 Ryzen 的设计，频率越高越好，但按照这一代的设计，最佳频率是 3600 左右，再高反而会下降，我是买不起那么奢侈的内存，甚至 3200 的都买不起，但这款 3000 的也不错，据说颗粒是镁光创下超频记录的那一批，所以就买了四条。我也不需要 RGB，这款的马甲还挺好看的。当然 3000 是 XMP 频率，需要在 BIOS 里打开 XMP，不然默认只有 2400。\n硬盘不多说了，买 MX500 还是看中一个稳，我还是不放心买同价位国产白片……而且作为一个 2016 年就在笔记本上使用 NVMe SSD 的人，表示并没感觉出 NVME 和 SATA 有什么使用差别……我也不渲染视频，写写代码打打游戏都不卡。但是后来打脸了，公司发了新年福利于是还是上了个 NVMe 硬盘。顺便还配了个无线网卡用来接蓝牙和 WiFi，似乎 Intel AX200 是对 Linux 支持比较好的，就随便买了个 PCI-E 的插上了（御三家集齐了！）（ATX 的好处终于用上了，多出来的 PCI-E 随便插）。\n电源有点买亏了，买完了发现长城同系列 550W 的电源当时也是 329，都怪京东迷一样的定价策略，好在我这一套功耗并不是很高，当然最后趁着福利 + 打折还是换成了海韵一元一瓦的金牌全模组，带我这套绰绰有余。开始我听说原装散热器也能压住 3600X，所以就没打算换，但后来发现刀法还是精准啊，3600X 带的散热器竟然不是铜芯的，再加上 Ryzen 三代的电压控制比较激进，待机温度有时候超过 50，打游戏时候机箱上方有点烤腿，所以还是换了个塔式散热器，风道科学了不少，温度控制也更好了。而且 AMD 原装风扇转速太高，3000rpm 的时候机箱都在震，换了之后安静了很多。顺便安原装散热器时候拆下来的螺丝卡扣不要扔，万一换塔式散热器，好多都是需要装在这个卡扣上的。\n说到机箱和风扇我就一肚子气！本着对京东自营品质和速度的信赖，我全套都是在京东买的，结果拿到手全部安装上之后发现机箱开机跳线是短路的，插上电源就开机，开一会因为短路主板以为你在长按电源又关了！开始我还以为是主板坏了，结果发现螺丝刀手动碰一下开机跳线开关是可以正常开机的！于是又费了九牛二虎之力拆下来退货，主板散热器显卡都在盒子里椅子上放了两天，还好新机箱没问题，但是我买风扇的时候又给我发了个断轴的！东哥呀东哥，我拿你当兄弟，你拿我当代价？你是盯上我了？虽然我平时说你两句坏话但是对京东的服务还是好评的，但是经过这次之后我还是得重新考虑考虑了……顺便据说启航者 S5 这个机箱前面板音频口有的是 HD Audio 有的是老版 AC97，涉嫌虚假宣传，如果你遇到 AC97 的大概可以换货，麻烦一点，不过反正便宜货就这样子，我的抽奖抽到 HD Audio 了。但是这个机箱设计的很抠门，比如主板装上了就没法在上面走 CPU 电源线了，有两个走线口直接被 ATX 主板盖住，所以主板和显卡的电源线只能从一个口里挤出去，然后固态硬盘就在这个口下面所以也很难接线……而且机箱侧板是个黑色半透明的亚克力（那就别宣传透明啊！），金属外壳感觉也不是很厚实。所以最后还是换了先马的鲁班 1，各种设计都宽松了许多，装起来也很好看。\n其他的外设我自己都有，显示器就是之前买的优派 XG2402，1080p@144Hz 并且自带扬声器，鼠标就卓威 EC1-B CSGO 特别版（这个版本已经停产了，而且有偶尔指天/指地的 bug，建议买新的 EC1/2 或者 DIVINA 版本），键盘则是前段时间买的 ikbc C87 红轴，便宜还好用。\n顺便由于我手残以及力气小和室友跃跃欲试，很多东西都是他装的，非常感谢。话说回来装这东西还真是个力气活，毕竟接口都有防呆设计仔细看看不会装错，但是真的很紧很难拔……非常担心把主板搞坏了。\n更新：\n\n更新：避免你们说我灵魂走线，重新整理了一下，线太硬了。 \n\n\n更新：内存插满。\n\n更新：NVMe + 蓝牙无线网卡的完全体。\n\n这个机箱 CPU 线走上面是要把主板拿下来才能穿过去的，而且右边两个有硅胶垫的孔 ATX 完全不能用，只能用一个孔，而且不能把线固定在机箱中间，很难盖上。\n再更新：新机箱比原来的好看多了也宽敞多了。\n\n\n公司的蜥蜴（明明是变色龙！）玩偶太高了，显卡下面放不开，挂着我又不放心，盖盖子之前还是拿出来了。\n更新：换上了公版 2070 SUPER 和利民 AK120。\n\n\n接下来是喜闻乐见的 debug 时间，首先是 Linux 下的，相对比较好调：\n三代 Ryzen 有一个 每次都返回 0xFFFFFFFF 作为随机数的 BUG，在我这主要影响 wireguard，巧的是购买前几天我刚读过这篇文章，AMD 已经发了新的固件修正错误，建议更新到主板厂家提供的最新 BIOS 版本一般即可解决，如果主板厂家最新的 BIOS 还没更新固件建议联系售后催一下。\n在我这不知道为什么 GDM 有时候没法自动启动，但是手动切 tty start 又可以显示，查了一下 ArchWiki 的 GDM 页面 发现有解决方案，但是并没有原因，搜索了一下也没发现原因是什么。\n我还发现有时候刚开机没多久很快就关机会卡在什么 systemd-udevd 进程没结束，最后 event loop failed + timed out，大概要卡好几分钟才关机，但如果你用一会再关机就没问题。检查好几次关机日志没发现问题，后来群友火眼金睛对比了完整日志发现有个叫 ucsi_ccg 的模块开机加载了两分钟，猜测是这个的问题，搜索一下发现是 5.3 内核里 NVIDIA 添加的相关代码，用来控制 NVIDIA 显卡上的 Type-C 接口的，可是我这块显卡根本就没提供 Type-C 接口！（以及很多笔记本内置的有输出的 N 卡也有这个问题。）临时在 /etc/modprobe.d/ 里加了个 blacklist ucsi_ccg 的 conf 屏蔽了这个，好像没什么不良影响……\n然后是奇怪的 Windows 的问题，我一开始装的 LTSC，不知道怎么回事输入法没了……折腾无果只能重装。以及现在除了不要联网装 Windows 之外（否则会强制你登录微软账户然后用你名字拼音前五位做用户名），还得不要联网装 NVIDIA 驱动，否则 Win10 自动更新驱动会给你安装 DCH 版的，虽然没什么影响（只是在 NVIDIA 官网升级驱动时候不能选标准选 DCH），但是就是让人很不爽。声卡驱动要装主板厂商的，Win10 自带的只能输出，不能接麦克风录音，然后如果麦克风声音很小就打开 Realtek 的声音控制程序，在右上角齿轮里取消掉什么把所有输入结合到一起的设定（什么乱七八糟的玩意！）。还有要关掉快速启动，不然直接开机会卡在黑屏一个鼠标光标……反正就很烦人。\n更新：还有一个奇怪的问题是 Win10 关机重启也要卡很久，上网搜了一下全是一些忽悠小白的办法，经过我不懈搜索发现了一个熟悉的名字 UCSI！微软承认存在 UCSI 问题，既然又是这个 UCSI，多半还是 NVIDIA Type-C 的问题！反正我没这个接口，果断重新安装 N 卡驱动，选择清洁安装（删除旧驱动）并不勾选 Type-C Driver，问题解决……\n最后既然设备到位了，大概就每周一三四五晚上八点半在 Bilibili 4312991 直播间 播一个半小时游戏，反正我玩什么播什么，大概就 CSGO Dota2 PUBG 什么的吧，尼尔也有可能，反正不是恶心反胃的就可以。周末随缘直播，如果没什么事情白天就播一会，周二可能晚一点开播因为有课。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"X 和 Wayland 的主要区别","url":"/posts/Difference-between-X-and-Wayland/","content":"最近在写一个 Wayland Compositor，虽然我以前大概知道这是什么，但是并不是很清楚它和 Xserver 有什么区别，虽然 fc 老师的这篇文章 写的相当不错，但我一点也不懂 X 所以看的迷迷糊糊。偶然读了 这篇文章 发现十分不错，但因为是英文文章读起来很累，打算把一些理解的内容记下来。顺便说一下，原文是带示例的，效果非常不错，建议有时间的人慢慢看一遍。\n\n\n我相信很多人在搜索 Wayland 的时候都看过这两张著名的图片：\n\n\n但我觉得可能看了也不明白，怎么把 Xserver 砍掉就提高性能了？为什么没有见到 window manager？为什么桌面环境需要去支持 Wayland？\nWikipedia 上还有一些奇奇怪怪的图片比如这种：\n\n在加上所有介绍 Wayland 的文章都会扯上 DRM，EGL，GLES 之类的，如果不懂这些就完全绕进去了，比如我就看到过有人问 Wayland 用 OpenGL ES 那用 OpenGL 的游戏是不是就跑不了了之类的。\n这一切都得从头说起。\nX 协议设计于 1980 年代，那时候窗口界面刚刚起步，人们还没什么 3D 特效一类的想法，而且机能也不允许，放到今天任何一个有点桌面基础的人都能理解应该给每个窗口一个 buffer 然后把这些 buffer 里的 texture 贴出来的设计逻辑，但 那时候可没那么多内存让你给每个窗口一个 buffer。所以就如同各种常见的领域一样，有个小天才一拍脑子想，反正 最后显示到桌面上的都是一个屏幕大小，我们只要准备这么大一块内存就行了嘛！换句话说，每个窗口的 buffer 要去掉自己被覆盖住的内存，整体内存大小就是可控的，在内存里是直接没有被覆盖的部分的。\n不得不说这位的思路在当时还是很有意义的，加上窗口大小都是矩形的假设，计算实际显示区域并不难，于是 Xserver 就是这样设计的。它维护一个屏幕大小的 buffer 自己计算窗口的实际位置，发生了变化（比如一个窗口盖住另一个），就给变化的窗口发一个重绘信号，这个窗口再发出绘图申请，直接绘制到 Xserver 的 buffer 里。由于 Xserver 知道所有窗口的位置，它就可以重定向鼠标键盘输入过去。然后具体的窗口移动缩放交给 window manager，它再把改过的位置回报给 Xserver。\n一切事情都变得很美好，直到某天一个人提出一个问题：我想要半透明的终端！\n程序员是不屑于解决提出问题的人的，如果用现代程序员的思维，做一下 alpha 混合其实很简单，只要 Xserver 能读取上层窗口的颜色和下层窗口的颜色就行了，可是你还记得当年的小天才吗？Xserver 说不太好意思，对于 一个像素我内存里只有一层，就是最上面显示的那个窗口……并且积习难改，我们不能改这个 feature……你想上下混合？死宅不要整天做梦，这是老祖宗留下来的不能改啊。\n如果你用过没开启 混成 Compositing 的 XFCE 和半透明的 XFCE-Terminal，你会发现它是可以透出窗口下面的壁纸的，先别着急喊我骗子，你在终端下面放一个别的窗口试试？神奇的现象发生了，终端显示的还是壁纸……\n上有政策下有对策嘛，一些终端作者想到反正壁纸总是固定的，我读取壁纸图片，取出终端所在的位置，然后在我窗口做个 alpha 混合不就行了？但是人不能自己骗自己啊，这是个客户端的假透明，我们要学习 GNOME 开发者的思维：不够好就砍掉。（大雾\nX 一看不行啊，那我们改一下协议吧，加一个叫 混成器 compositor 的东西，如果你写了这个东西，X 就不是直接更新他自己的内存 buffer 了，而是交给混成器。混成器可以获取一系列窗口的内容，让它们都画到不同的 buffer 里面（内存终于够大了啊！），再把它们处理了丢到屏幕上去。Xserver 只是要求 compositor 最后返回一整个屏幕（通常是，也可以小一点）然后给这个直接贴到最上面去（可以简单理解为混成器画好一整张就行了，别的都不管了）。\n理论上来说，混成器想怎么放这些窗口就怎么放这些窗口，就算想把他们丢到屏幕外边都行，反正你最后返回一个图就行了，Xserver 也不管是不是涩图。\n但是有个尴尬的事情，输出给你管了，输入你管不着啊！之前说了 Xserver 自己按照自己存的窗口位置分配输入，你把窗口挪走了，Xserver 可还是按照自己记录的窗口位置分配输入的，如果你想自己处理窗口位置分配输入，好嘛，Xserver 里面的代码你再复制到你混成器里一份吧！\n所以实际上 compositor 里面怎么做的呢？我最后处理完的窗口，位置和 Xserver 记录的位置还得一样，然后 Xserver 给我那个返回整张屏幕的顶层窗口，我就不接收输入了，这样直接透过顶层点到下面，就和窗口位置对应了（什么乱七八糟的破玩意啊！）。如果你要做个动画呢？你做动画的时候，Xserver 那边记录的位置可不跟你变（要是变，按照 X 的设计你这数据得跑好几个来回），你的鼠标点击在这时候是不准的，传不到窗口里面。\n这些 compositor 都是各个桌面环境做的，他们一般都集成到自己的 window manager 里了。\n而且随着时间发展，越来越多的 Xserver 和 client 是跑在同一个机器上的，很多 client 想自己利用显卡处理图形，就有人在协议上打洞，Xserver 做的越来越少了，更多的事情 client 自己都做了。\n你还想再往 X 协议上糊一层吗？别糊了兄弟，你这也太挫了！一开始 X 的设计是提供机制而非策略，Xserver 自己是符合了（然后除了 Xorg 其他实现都死了），和 Xserver 配合的可是被他绑的死死的比如 compositor，性能翻了几倍还得拉着这些历史垃圾跑，Xserver 终于活成了自己最讨厌的样子。\nWayland 做的事情很简单，反正 compositor 都做这么多了，那直接把 Xserver 的功能也丢给 compositor 吧！Compositor 下层接的是 DRM 控制渲染，libinput 控制输入，GBM/EGLStreams 控制内存管理，上层更简单了，每个窗口丢给我一个 texture，我负责安排你们这些 texture 放在哪里，然后我按照我安排的位置，告诉你们鼠标进谁窗口了键盘进谁窗口了。然后因为要把这些 texture 混合到屏幕上，一般都用 OpenGL 的硬件加速，但在 Linux 下创建 OpenGL Context 的 GLX 库是和 X 绑定的，所以一般大家都用 OpenGL ES Context 的库 EGL。这个库只干扰最后合成图片时候的事情，至于你的 texture 用的是 OpenGL 还是 OpenGL ES 还是 CPU 画的都没有关系，现在 Wayland 一概不管了，你自己客户端处理自己的内容吧，我又不是 Xserver！\n所以对于 GNOME 和 KDE 等等而言，现在他们打交道的一个是内核一个是窗口，而不是以前一样和 Xserver 打交道了，省了数据交换，同时自己可以自由控制窗口输入输出面积。Xorg 应该被淘汰不是因为功能性原因，而是因为它的设计在当时很聪明，但现在只是历史包袱，实在太挫了。\n看完这篇文章建议回去阅读开头的两个链接，可以了解更多的实现细节，现在再看就不会那么混乱了。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"蜗牛星际安装 Arch Linux 作为 NAS","url":"/posts/SnailSpace-as-NAS/","content":"需求\n以前我一直使用树莓派 + 移动硬盘做 Samba 服务器，好处是完全静音，功耗很低，但是树莓派 2 的网络性能差强人意，并且 USB 2.0 的速度也赶不上移动硬盘的速度，看电影什么的只是能看，要花好长时间缓冲，并且我一直开着，对树莓派的电源也不是很放心。特别是我还拆下来一块笔记本上的 1TB 机械硬盘，完全没法装在树莓派上。\n\n\n有点想买一台 NAS，但是看看群晖的价格实在接受不能，然后又看到说群晖把系统放在用户的磁盘里加速读写一类的，其实这些对我来说不太重要，但群晖是个定制化程度很高的 Linux，虽然用起来有很多便利的功能，比如官方的内网穿透（服务器似乎在台湾，速度不快），比较成熟的 btrfs 使用之类的，但比起这些我更想要一台全功能的 Linux 服务器，这样不仅可以作为存储，还可以 SSH 连接上去做一些简单工作。作为一个比较熟练的 Linux 用户，我不需要什么 Webui 或者 App 来访问文件，Solid Explorer 和 VLC 组合起来访问 Samba 好用得很。\n机缘巧合我看到隔壁的同学弄了台 D 款的蜗牛星际矿渣，研究一下之后觉得可以上车，正好 Arch CN 群里 @NickCao 打算出掉买了回来没时间玩的蜗牛 A 款，于是坐地铁到五道口一起喝了杯咖啡然后当面交易了一下。\n介绍\n蜗牛星际的矿渣是怎么来的呢？简单说就是忽悠别人说这个机器可以挖矿，打着区块链旗号骗人买机器，当然这个机器其实并不需要挖矿，所谓的挖矿就是简单的 App，让你以为自己挖出矿了（毕竟宣传说不用插电也能挖），为了降低成本机器全部都是用现成的山寨货，所以机箱造型是 NAS，而且还带硬盘背板，就是因为这个很成熟。成本不到一千块的机器五千块一台卖给受骗者，受骗者为了挖矿都是十几台几十台的买，然后放小道消息说要涨价到八千块榨干受骗者钱包，最后国际惯例圈钱跑路，受骗者血本无归。\n做人还是得懂点计算机。\n\n这个机器有好多型号，细节差距也有很多，网上有现成的帖子分析，我就不分析了，反正我这一台是 A 款单网口绿主板，妥妥的千兆。而且似乎背板有 PCI 槽，不过主板又没有 PCI 接口就不管了。A 款还有个特点是硬盘架侧面可以放个 2.5 寸硬盘，正好装上我拆下来的笔记本硬盘。\n硬件处理\n更换电源\n手头这一台运气比较好，是 zumax 的 150W 电源，虽然都说这个是所有各种电源里最好的，但是接口只是刚刚够，没有多余的，没办法给侧面硬盘供电。再说都是山寨货谁又比谁强到哪里。按照隔壁老司机的推荐淘宝买了益衡 250W 的 Flex 电源（也叫小 1u 电源）替换掉，花了 250 软妹币左右，感觉车速稳了很多，而且多出了许多接口。安装时候需要把原来电源上后面用来装到侧面的铁片拆掉，然后上下翻转才能装上蜗牛里面的支撑片，然后主板有一长一方两个供电口都插上，背板用的大 4pin 接口，不太够长，把卖家赠送的两条大 4pin 延长线都接上就可以了，然后取一个 SATA 供电线给侧面的硬盘。\n更换风扇\n蜗牛自带的风扇声音很大，因此需要更换一个静音风扇，A 款用的是 8cm 的 3pin 风扇，不支持调速，BCD 都是 12cm 的。8cm 不太好买，开始我在京东找到两个超频三的风扇，一个 2200 转一个 1400 转，标定噪音都是 18dB，于是就买了 2200 转，没想到转速上来了噪音也更大，正好之前在淘宝买了另一个超频三皓月（下面上图），1500 转应该问题不大，装上发现声音小了，但是蜗牛背板有个铆钉，这个 LED 风扇尺寸稍微大一点，正好顶着铆钉。没办法还是换了京东 1400 转的那款，噪音合适，尺寸也合适，蜗牛本来发热也不严重。因此 建议大家购买 1500 转左右不带 LED 灯效正常尺寸的。\n更换时候记得把原来蜗牛风扇上用来防止线缆伸进风扇里的塑料防护片拧下来装到新风扇没有阻拦的一侧，这一侧朝里，安装之后蜗牛向外吹风。\n\n这个防护片不要拧太紧，以免把它拧裂了，这种是和机箱配套卖的，淘宝上有卖那种金属的防护网，但是都是厂家批发，不太好买。\n\n你问我怎么知道的？当然是大力出悲剧拧裂了然后没办法只能 502 直接粘风扇边上了。\n再次提醒各位注意不要买下图的带灯条的风扇。\n\n\n安装侧面 2.5 寸硬盘\n蜗牛自带一个 16G 的 mSATA 硬盘，速度比 U 盘还慢，而且据说用着用着就坏了，很多人都拿这个做引导盘放系统，但我不打算用，直接拧下四个螺丝把主板抽出来，然后拧掉 mSATA 杂牌硬盘。\n因为四个硬盘托连接的 SATA 口是扩展的，不支持引导，但是 实际上蜗牛主板正中间上还有一个 SATA2 的口可以引导，正好连接我的笔记本硬盘，自己插上一根 SATA 线把主板装回去即可。\n硬盘本体安装时候需要两个小螺丝固定硬盘一侧，另外一侧是卡住的，不需要螺丝。然后把电源线和刚才插的 SATA 线插到硬盘上面。\n\n\n仓库盘安装\n我还在京东购买了一块 2TB 的西数紫盘和一块 2TB 的东芝 P300 硬盘，没有买 NAS 专用盘是因为太贵了。而其他便宜的比如西数蓝盘和希捷酷鱼只便宜了十几块，但是却是大缓存叠瓦式（SMR）硬盘，性能非常差，紫盘和 P300 则是标准的 64M 缓存垂直式（PMR）硬盘，价格也比较实惠。建议自行搜索叠瓦式硬盘了解不推荐的原因。考虑了一下还是不做 RAID1 了，经济条件不允许，而且本来 RAID 是为了高可用不是为了备份，如果是硬件损坏估计两块盘一起炸了，不如冷备份 还是做了 RAID1（真香！）。\n往硬盘架安装硬盘需要四个沉孔螺丝分别锁在两侧，当然我这种硬件渣渣其实是不知道啥是沉孔螺丝的，具体多大多粗我也不懂，我装 2.5 硬盘的螺丝是同学买大疆编程小车多出来的内六角，尺寸正好，至于 3.5 硬盘是隔壁老司机送给我的装机剩下的，反正车速很稳，如果自己买的话京东淘宝好像都有装机用的成套螺丝，建议顺手买一套，不要螺丝钉难倒程序员。\n\n\n\n\n\n\n\n\n\n软件处理\n分区\n软件部分就十分舒服自在了，接显示器网线键盘开机按 F7 进入 BIOS 设置 UEFI 模式从 U 盘启动，然后进入 Archiso 按照 安装指南 安装系统（据说他们最近在处理 base 组，建议随时跟进 wiki，我就不复制了），分区的时候我是在能引导的 2.5 寸硬盘上建立了 ESP，然后其他空间全部用作 LVM，1T 硬盘的剩余空间作为一个 pv，并且给 2T 的硬盘分了三个区做 pv（万一我哪天脑子抽了想缩个分区出来呢？），然后建立 vg，建立给根目录和家目录的 lv，然后创建 ext4 文件系统。这一段参照 wiki 对应页面就行了，命令十分简明直观，我第一次用就成功了。配置好的效果如图：\n\n至于 2T 的硬盘考虑了一下还是打算再加一块硬盘做 RAID1，不然连续跨设备 lvm 坏了一个就全坏了，由于 mdadm 需要两块设备都在才能建立，但我手头只有一块 决定的时候手头只有一块，于是在 fc 老师建议下决定上 btrfs（而且这货似乎支持多块不同容量硬盘的 RAID1，保证每个文件都在两块盘上有备份）。按照 fc 老师多年使用经验似乎 btrfs 也没那么不可靠。\n然后我在某东买了一块东芝 2T 64M 7200 转的机械硬盘，到手之后打算加入 btrfs 里面，建立 RAID1，btrfs 的好处就在于这个可以先弄一块之后渐进修改，而且看起来目前没什么大问题的样子（按我的理解并行读取的性能问题大概是用来并行加速的，但是实际上 RAID1 不并行读取也可以读出数据吧）。 虽然我本来也可以把数据移出来然后建 mdadm，但是不排除以后再加盘做 RAID 10，似乎 mdadm 没法直接转换的样子？\n买回来硬盘之后想想反正两块都没啥数据（搬出去了），索性直接格式化成 btrfs，不然也可以在已有一块 btrfs 设备之后 add 然后 balance，就可以修改策为 RAID1，格式化命令很简单就这样：\n# mkfs.btrfs -m raid1 -d raid1 /dev/sdXY /dev/sdZV\n-m raid1 是指 metadata 要做 RAID1 备份，-d raid1 是指 data 也要 RAID1 备份，然后需要跟两个设备，推荐是一样大的，挂载时候就随便挂一个设备就行了，btrfs 会自己执行 RAID1 策略的。\n启动配置\n/etc/mkinitcpio.conf 里需要给 HOOKS 添加 lvm2，然后运行 mkinitcpio -p linux，这样生成的 initramfs 才能支持 LVM。我还给 MODULES 添加了和 intel 显卡有关的部分（虽然可能用不到了），具体修改的位置如下：\nMODULES=(intel_agp i915)\nHOOKS=(base udev autodetect modconf block lvm2 filesystems keyboard fsck)\n安装 bootloader 的时候我直接用了 systemd-boot，我在自己笔记本上也用的这个，功能够用了就没考虑安装 GRUB，编写 entry 时候内核参数里的 root 可以写 /dev/vg0/rootlv 也可以写 /dev/mapper/vg0-rootlv（这里中文 wiki 和英文 wiki 分别是这俩，亲测都可以），比如我的就是下面这样：\ntitle    Arch Linux\nlinux    /vmlinuz-linux\ninitrd    /intel-ucode.img\ninitrd    /initramfs-linux.img\noptions    root=/dev/vg0/rootlv rw add_efi_memmap\n最近 systemd-boot 添加了什么校验设置，在蜗牛上会报错，直接 chroot 进去安装根本装不上，临时解决方案是退出 chroot，然后用 Archiso 里的 bootctl 安装到 /mnt/boot，虽然有点 dirty，但是能用？不过还是会报个错，但是启动需要的文件已经安装上了，不管它也能用，只不过每次重启还是会说校验失败，目测是个 bug。\n网络配置\n然后由于 NAS 的网络不会经常变化，所以联网的部分也直接用 systemd-networkd 管理了，没必要上 NetworkManager 我装桌面了所以还是用了 NetworkManager！不过这部分也留着好了。直接创建 /etc/systemd/network/wired.network，写入如下内容：\n[Match]\nName=en*\n\n[Network]\nDHCP=ipv4\n意思是对于所有以 en 开头的网卡使用 DHCPv4，然后 systemctl enable --now systemd-networkd systemd-resolved 就可以了。\nNetworkManager 就很简单，直接安装然后 systemctl enable NetworkManager --now 应该就行了！\nSamba 配置\nbtrfs 的子卷看起来很像普通目录，但是又可以分别直接挂载，不需要先挂载设备然后再用 mount --rbind。于是建了 /data 和 /data/alynx 两个子卷，/data 就挂载到 /data，/data/alynx 挂载到我家目录下面。\n在 /etc/samba/smb.conf 添加如下配置，就可以分别通过 home 和 data 访问每个用户在 /home 和 /data 下面的同名文件夹了，%u 代表的就是连接的用户名。（当然权限要你自己处理一下。）\n[home]\n   comment = Home Directories\n   browseable = yes\n   writeable = yes\n   path = /home/%u\n\n[data]\n   comment = Data Directories\n   browseable = yes\n   writeable = yes\n   path = /data/%u\n其它的配置基本都是正常操作参照 Arch Wiki，我打算以后插新硬盘直接加进 LVM 加给 /home，省得还得操心挂载到哪里 决定单独安排 btrfs 数据区了，参见上面。在外面访问我选择配置 WireGuard，参照我 这篇文章 就可以了，如果只是 SSH 远程控制一下效果还可以。\n效果\n笔记本插了有线之后可以测试千兆对拷，我的路由器还是大一时候买的 WNDR3800，虽然很旧，但四个有线全部都是千兆口（当时价格和配置差不多的极路由 3 只有一个内网千兆好像），samba 拷贝速度轻松达到 110M/s 的满速，甚至比蜗牛的 USB3.0 还快 用了 btrfs 之后似乎速度只有 80M/s 左右了，或者 Windows 和 Linux 下面 Samba 对拷速度显示有区别？110M/s 是我在 Windows 下面测出来的。\n蜗牛后面两个 USB3.0 只有下面的那个是真的，上面的也就 2.0 速度，下面的跑满了也就 80 到 90M/s，我的 U 盘是 CZ80，放笔记本上比这快多了，而且有时候上面那个也可以跑到 70M/s，具体原因不知道，如果是真的土豪建议直接换主板算了，非土豪完全可以插笔记本然后网络拷进蜗牛，比这奇葩接口还快。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"前端博客搜索引擎","url":"/posts/Frontend-Blog-Search/","content":"本来我的博客有一个前端搜索框，当输入文字时就在侧边栏展开搜索结果，虽然看起来很时髦，但也不能算是什么食用啊不实用的设计方式。而且一开始我觉得既然没有后端处理请求，也就没法单独打开一个专门搜索页面了。\n但是这个设计引发了 @依云 的吐槽，有一个单独的搜索页面并且对每个搜索结果有专门的 URL 看起来还是个挺合理的需求。但第一我不知道怎么实现第二我一直觉得能用就行所以开始并没有改。不过依云给我发了 Python 文档的搜索实现，让我突然想明白其实按照标准的 HTML 和 JavaScript 是可以实现无后端的搜索引擎的，然后就动手实现了一个。\n\n\n首先既然要搜索那还是得有个索引或者数据库，比较简单的方案就是把所有文章的标题 URL 和内容丢到一个 json 文件里面，这个功能在 Hexo 里可以使用 hexo-generator-search 实现，我也给我的 Hikaru 添加了这个生成器，用来生成 JSON。\n首先第一件事是实现搜索跳转页面，这一步只要简单的使用 HTML 表单就能实现，首先将我的搜索框改造为如下格式：\n\n  \n    \n  \n  \n\" data-info=\"language-html\" data-lang=\"html\" class=\"code-block\">&lt;form action=\"{{ getPath(\"search.html\") }}\" method=\"get\"&gt;\n  &lt;button type=\"submit\" class=\"search-submit\" aria-label=\"{{ __(\"search\") }}\"&gt;\n    &lt;i class=\"fas fa-search\"&gt;&lt;/i&gt;\n  &lt;/button&gt;\n  &lt;input type=\"search\" id=\"search-input\" class=\"search-input\" name=\"q\" results=\"0\" placeholder=\"{{ __(\"search\") }}\" aria-label=\"{{ __(\"search\") }}\"&gt;\n&lt;/form&gt;\n使用 button 而不是 input 的原因是我想用我的图标做搜索按钮，反正 &lt;input type=\"submit\"&gt; 只是个特化的 button。理论上来说不放按钮靠回车提交也是 OK，但是觉得这样又会被某些用户批评不友好了……\n搜索框就很简单，name=\"q\" 表示生成的 query string 里 keywords 的 key 是 q，然后按照表单写法会被提交到 search.html，理论上来说搜索应该发 GET 请求所以就是 method=\"get\"，当然 POST 就实现不了复制链接查看搜索结果了。\n这个表单就是标准的 HTML 表单，不需要用 JavaScript 处理。生成的 GET 请求的 URL 类似于 /search.html?q=xxx\n然后接下来是处理请求了，既然是发送到 search.html，对于静态后端肯定是要返回这个页面的，那就得先创建页面，然后对这个页面进行特殊处理，这里我同样利用生成器生成一个 layout 设置成 search 的页面，然后就可以单独给它编写模板添加处理部分了。\nsearch.html 加载之后是可以通过 window.location.search 获取到 query string 的，然后我加载我修改过的 search.js（这里），用它处理搜索过程。同时在页面里添加了一个 container 用来放置检索结果。\nsearch.js 其实没什么黑科技，毕竟我们的难点就是在无后端情况下处理关键词和数据库，关键词已经用 window.location.search 拿到了，解析一下然后只要通过 ajax/fetch 请求数据就行了，封装 ajax 的代码网上到处都是，实在不行用 jQuery 也成。\n然后剔除重复关键词主要是为了优化一下性能，接下来我的解决方案就是简单粗暴 indexOf()，不要跟我提什么算法什么优化，短平快实现效果，我是个实用主义者，目前这一步其实还没有成为瓶颈。\n然后对于原版文件我的改进主要是按匹配次数排序，文章出现关键词越多则排序越靠前，相对可以提高效率。\n接下来使用正则表达式给关键词加上 &lt;strong&gt;，这样显示起来比较显眼。最后把字符串拼起来显示就好了。其实这里的算法还有点意思，比如假如两个关键词出现的位置中间大于多少个字符则插入省略号，否则合并两个的上下文，具体实现也可以参照代码。\n如果有性能瓶颈的话，多半也会先出现在 ajax，不过目前我文章还没有多到加载不出来的情况，也许可以靠分块加载解决？\n更新（2020-08-15 18:25:00）：我给代码添加了简单的分块支持。由于这里需要主题和生成器约定好路径，不太适合让生成器自动生成路径，所以采用了一个简单的方法就是让用户在设置文件里手动指定几个 JSON 文件的路径，然后生成器只是读取一下配置，假如是数组就分块写到指定好的路径里面。然后前端查找的时候分别异步查找每个文件并合并排序结果，理论来说大概会有性能提升？\n最后我加了个简单的 SpinKit 动画，在查询结束之前先跑一下提升用户体验。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"Linux 用户的月饼食用手册","url":"/posts/Linux-Mooncake-Jokes/","content":"中秋节到了，Arch Linux CN 社区里富有生活情趣（？）的用户们聚在一起，开始讨论起如何食用月饼。\n\n\n\nGentoo 用户需要自己编译月饼，并且可以设置不同的 USE 编译不同口味。（farseerfc，outvi 和 AlynxZhou）\nDebian 用户习惯将月饼拆成月饼馅、月饼皮和月饼油分别打包食用。（AlynxZhou）\nArch Linux 用户喜欢购买 Debian 的月饼，然后将月饼馅、月饼皮和月饼油拆开自行组装并打包。（AlynxZhou）\nManjaro 用戶買來 Arch 組裝好的 Debian 月餅然後敲了個花紋上去重新裝了起來。（farseerfc）\nManjaro 用户经常吃了 Arch Linux 的月饼然后抱怨这个月饼为什么不是 Manjaro 牌的。（AlynxZhou）\nCentOS 的月饼过期了。（KRyuJo）但总有人喜欢这个传统口味，不想换。甚至有人资助 RedHat 厨师学校传承老字号。（whyme）\nRedHat：我们将通过电话联系在线指导您服用月饼。（ArielAxionL）\nopenSUSE 用户也喜欢将月饼拆成月饼馅、月饼皮和月饼油分别打包食用，但他们通常编写一个 月饼.spec 文件，然后将买来的月饼原料和此文件一同上传到 Open Build Service 而不是自己打包月饼。（AlynxZhou）\n随后 openSUSE 的月饼被冻结了，存放到 SUSE Linux Enterprise 的冰箱里。（AlynxZhou）\nUbuntu 的月饼馅过期了，但是依旧没有更新。（wuliao00）\nUbuntu 的月饼包装写着豆沙，用户咬了一口发现是五仁，大喊“内部错误！”。（AlynxZhou）\nDeepin 用户表示吃月饼时应该配点红酒（wine）。（AlynxZhou）\nLFS 用戶發現需要先自己製作用於製作月餅的工具。（YHNdnzj）然后开始阅读“如何开办一家月饼工厂”。（AlynxZhou）\nAntergos 用户收到了一个不幸的消息“此品牌已破产”。（AlynxZhou）\n\n随后话题变得奇怪了起来，不再仅限于常见的 Linux 发行版。\n\nWindows 10 用户您好！感谢您选购本公司最新发行的月饼，不过要敬告您的是，您的月饼马上就要过期了。（lilydjwg）\nWindows 用户的冰箱被锁死了，因为“Windows 正在等待月饼”。（AlynxZhou）\niOS 用户只能购买苹果自家的月饼，买别家月饼苹果抽成 30%。（outvi）\nGoogle 表示对于月饼生产商收取 25 美元的生产费。（AlynxZhou）除非你只吃没有馅料的 YOSP。（oldherl）\nPython 用户用 pip 安装了一个月饼，然后发现自己安装的月饼明年就过期了。（AlynxZhou）\nNodeJS 用户用 npm 安装了一个月饼，然后发现整个月饼流水线出现在了自己的厨房里。（AlynxZhou）\nDocker 用户发现自己的月饼比别家重很多，但没什么东西，而且吃月饼需要 root。（outvi）\nNintendo Switch 用户购买了月饼卡带然后由于太苦无法下咽。（AlynxZhou）\nJava 用户发现自己需要先安装一个月饼食用环境来食用月饼。（AlynxZhou）特别是还不知道装哪个版本。（outvi）更要命的是还区分 OpenMooncake 和 OracleMooncake。（Rocket1184）\nSteam 用户发现自己的月饼上多了绿色的 -40% 标签。（AlynxZhou）\nEpic：月饼独占一年！（KRyuJo）\nGo 用户把所有月饼当作一种月饼（interface {}）。（Sherlock_Holo）\nRust 用户表示月饼的保质期很短（离开视线就被 drop 了）。（Sherlock_Holo）Rust 家的月饼可以多人一起看着，但是吃的时候不仅只能有一个人吃，而且别人不能看。有人不信邪，使用 unsafe 魔法看到了正在吃月饼的人，然后整个世界崩塌了。（lilydjwg）\nsystemd 用户正在策划将月饼改名为 systemd-月饼 的投票。（AlynxZhou）\nC++ 用户表示月饼馅还不在厨房里。（wuliao00）建议食用 boost::月饼。（Rocket1184）\nfish 用户正在重写他们的 /etc/profile，没有时间吃月饼。（AlynxZhou）\nTensorFlow 用户依赖他们的 NVIDIA GPU 来识别月饼皮上的文字。（AlynxZhou）\nC# 用户的月饼做起来像 Java，吃起来像 Java，区别则是用户嘴里一直喊“我们的月饼比java好，而且终于开源了（一部分）！”。（AlynxZhou）\nVala 用户发现自己的月饼是 GLib 承包给 C 牌月饼的贴牌产品。（AlynxZhou）\nC 用戶不仅要自己制作月饼，还要在月饼制作过程中关注加工机器的操作问题，例如如何防止月饼馅料溢出。更重要的是这些操作都是纯手动完成的。（wnereiz）\n\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"可能只适合我自己的 RIME 配置","url":"/posts/My-RIME/","content":"为什么我要折腾这个\n在第 n 次忍受不了 RIME 的奇怪操作逻辑之后，我终于决定彻底教育一下这个不听话的输入法，考虑到已经有 n - 1 次失败的前提，做这个决定并不容易。\n\n\n首先说明我是 Linux 用户，使用 ibus-rime 做输入引擎，所以使用什么小狼毫鼠须管或者 fcitx-rime 的如果发现不好用最好别烦我，那些我都没用过。（不好意思因为配置这玩意有点暴躁。）\n然后我要吐槽一下 RIME 的文档，完全没有一致的类似 API 手册的东西，而且全繁体加上佛振独特的说话风格读起来真的很累，然后这个项目习惯又是起一大堆奇奇怪怪的名字（虽然我有时候也这样）。假如你想修改一点配置，读了文档里的示例“我懂了，巴拉巴拉”，打开配置一看一堆乱七八糟的就懵了。\n然后就是网上“致第一次用 RIME 的你”、“也致第一次用 RIME 的你”，我都看过了，首先他们不用 ibus-rime，其次文章内容毕竟有限，每个人需求不一样，有些我需要的地方他们一笔带过了。\nRIME 的拼音功能确实很好用（虽然有时候它和我对于词组的想法不太一样），我的需求其实只有几项：\n\n对于一些 RIME 默认的中国人几乎都用不到的中文标点直接改成英文标点，这个在书写 Markdown 的时候简直折磨死我了，有几个人会输入全角井号？？？打个标题真的很麻烦。\n有些符号键在其他输入法里约定俗成的就直接输出特定的中文符号，RIME 的默认操作是弹出选择菜单，完全没这个必要，弹出菜单还需要二次选择而且打断了我的按键操作，需要英文标点时候直接切为英文就好了。\n关掉 RIME 的中英混输功能，在候选框输入英文字母真的很打断思路，我要输入英文要么就是打代码要么就是打单词，反正都不需要输入法，RIME 来就是给我找麻烦。\n还有一些奇奇怪怪的 RIME 的键位设置，偏偏要和其他输入法不一样，我已经习惯了那些操作，RIME 的键位只会降低输入速度。\n\n下面介绍一下我的配置，只需要两个文件就可以，我没有对朙月拼音的配置做修改，只是修改了默认配置。\n首先建立一个干净的 RIME 配置环境，直接移走 ~/.config/ibus/rime 然后执行 ibus-daemon -rdx 重新生成（就是它文档里扯的部署部署部署）一套配置，由于我用的都是内置输入法所以也不需要什么乱七八糟的东风破 RIME Kit 地球拼音之类的。\n然后你进去 ~/.config/ibus/rime 新版大概有以下几个东西：\n\n目录 build：里面放了各种 RIME 的默认配置，我们不需要动这个。 很好，我搞错了，原来它是从 /usr/share/rime-data/ 和 ~/.config/ibus/rime/ 下面加载不带 custom 的文件，然后再读取 custom 文件给之前的文件打 patch，最后生成到 build 目录下面。\n目录 luna_pinyin.userdb：看起来像是朙月拼音的词库，当然也不用修改。\n文件 installation.yaml：我猜不用管。\n文件 user.yaml：我猜也不用管。\n\n各种乱七八糟操作逻辑的配置\n按照 RIME 打 patch 的配置方式我们需要在这个目录下创建一个叫 default.custom.yaml 的文件，这样就可以给 /usr/share/rime-data/default.yaml 这个文件 patch 辣，当然你得先会写 YAML。第一行首先写个叫 patch: 的 key，RIME 要求这样，所有的自定义配置都是在 patch 字段下面。\n怎么确定要修改的 key 名字呢？我这里的都是在 build/default.yaml 下面找到的， 因为 patch 的是 /usr/share/rime-data/default.yaml 所以就去看这个辣，之前又写错了，那个其实是生成的文件。你也可以试试其他的 YAML 文件。\nRIME 的文档说什么要用 / 把不同层次的 key 折叠成一个比如 ascii_composer/switch_key，亲测无所谓，我就爱展开了写完整的 YAML，这样更规范。\n然后首先第一步我要修改输入法列表，我只用朙月拼音简化字模式就行了：\npatch:\n  schema_list:\n    - schema: \"luna_pinyin_simp\"\n然后就是改掉那个自作聪明的英文输入模式：\n  ascii_composer:\n    # 按 CapsLock 输出大写英文字母。\n    good_old_caps_lock: true\n    # `inline_ascii` 在输入框内插入英文。\n    # `commit_text` 候选文字上屏并切换至英文。\n    # `commit_code` 输入拼音上屏并切换至英文。\n    # `clear` 清除拼音并切换至英文。\n    # `noop` 屏蔽此按键。\n    switch_key:\n      # 如果你设置 `Caps_Lock` 为 `noop`，\n      # 一个奇怪的问题是退格键不能用了，除非取消大写锁定。\n      # 所以我直接设置文字上屏了。\n      Caps_Lock: \"commit_text\"\n      Shift_L: \"commit_code\"\n      Shift_R: \"commit_code\"\n      Control_L: \"noop\"\n      Control_R: \"noop\"\n大部分坑我都写在注释里了可以自己看。\n然后我看那个设置选单也不是很爽，我习惯简体字，这个也可以自己改：\n  switcher:\n    # 改掉原来的繁体字标题。\n    caption: \"【设置菜单】\"\n    # 用半角斜线而不是奇丑无比的全角斜线做分隔符。\n    option_list_separator: \"/\"\n    # 屏蔽 Ctrl-s 开启菜单，只允许 Ctrl-` 和 F4。\n    hotkeys:\n      # - \"Control+s\"\n      - \"Control+grave\"\n      - \"F4\"\n然后就是改掉它奇怪的键位，Emacs 键位挺好的，但是有几个不知道为什么用不了，再者就是为什么按向左是跳一个字拼音向右是跳一个字母？\n  key_binder:\n    bindings:\n      # Emacs 键位，我喜欢。\n      # 可是谁给我解释一下为什么 Left 是按字拼音跳而 Right 是按字母跳？\n      - accept: \"Control+p\"\n        send: \"Up\"\n        when: \"composing\"\n      - accept: \"Control+n\"\n        send: \"Down\"\n        when: \"composing\"\n      - accept: \"Control+b\"\n        send: \"Left\"\n        when: \"composing\"\n      - accept: \"Control+f\"\n        send: \"Right\"\n        when: \"composing\"\n      - accept: \"Alt+b\"\n        send: \"Shift+Left\"\n        when: \"composing\"\n      - accept: \"Alt+f\"\n        send: \"Shift+Right\"\n        when: \"composing\"\n      - accept: \"Control+a\"\n        send: \"Home\"\n        when: \"composing\"\n      - accept: \"Control+e\"\n        send: \"End\"\n        when: \"composing\"\n      - accept: \"Control+d\"\n        send: \"Delete\"\n        when: \"composing\"\n      # 这个用不了，不过估计也用不到。\n      # - accept: \"Control+k\"\n      #   send: \"Shift+Delete\"\n      #   when: \"composing\"\n      - accept: \"Control+h\"\n        send: \"BackSpace\"\n        when: \"composing\"\n      - accept: \"Alt+h\"\n        send: \"Shift+BackSpace\"\n        when: \"composing\"\n      - accept: \"Control+g\"\n        send: \"Escape\"\n        when: \"composing\"\n      - accept: \"Control+bracketleft\"\n        send: \"Escape\"\n        when: \"composing\"\n      - accept: \"Alt+v\"\n        send: \"Page_Up\"\n        when: \"composing\"\n      - accept: \"Control+v\"\n        send: \"Page_Down\"\n        when: \"composing\"\n还没完，我觉得正常人不会用 Tab 在拼音之间切换，除非你一次输入一句话（那你不觉得候选框太小了看着累吗？？？），设置 Tab 为跳候选词更自然一点，但我也不知道为什么 Shift-Tab 用不了：\n      # 正常人不会用 Tab 切换拼音光标的，相信我。用它切换选项更快。\n      # - accept: \"ISO_Left_Tab\"\n      #   send: \"Shift+Left\"\n      #   when: \"composing\"\n      # - accept: \"Shift+Tab\"\n      #   send: \"Shift+Left\"\n      #   when: \"composing\"\n      # - accept: \"Tab\"\n      #   send: \"Shift+Right\"\n      #   when: \"composing\"\n      - accept: \"Tab\"\n        send: \"Down\"\n        when: \"has_menu\"\n      - accept: \"ISO_Left_Tab\"\n        send: \"Up\"\n        when: \"has_menu\"\n      # 鬼知道为什么这个也用不了！\n      - accept: \"Shift+Tab\"\n        send: \"Up\"\n        when: \"has_menu\"\n以及我觉得正常人不用逗号和句号翻页，毕竟下面的默认设置是逗号句号直接上屏，你设置了翻页也没啥卵用，反正我用减号等号或者上下，不过方括号也不错就是了：\n      - accept: \"minus\"\n        send: \"Page_Up\"\n        when: \"has_menu\"\n      - accept: \"equal\"\n        send: \"Page_Down\"\n        when: \"has_menu\"\n      - accept: \"bracketleft\"\n        send: \"Page_Up\"\n        when: \"has_menu\"\n      - accept: \"bracketright\"\n        send: \"Page_Down\"\n        when: \"has_menu\"\n      # 我觉得正常人不应该用逗号和句号翻页。\n      # - accept: \"comma\"\n      #   send: \"Page_Up\"\n      #   when: \"paging\"\n      # - accept: \"period\"\n      #   send: \"Page_Down\"\n      #   when: \"has_menu\"\n最后就是那一堆乱七八糟的快捷键了，鬼才记得住，有那时间直接翻菜单就行了，那个 Shift+Space 就是我动不动就变成全角的罪魁祸首，全部不要：\n      # 鬼才记得住这么多乱七八糟的快捷键，我翻菜单比背这玩意快多了。\n      # - accept: \"Control+Shift+1\"\n      #   select: \".next\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+2\"\n      #   toggle: \"ascii_mode\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+3\"\n      #   toggle: \"full_shape\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+4\"\n      #   toggle: simplification\n      #   when: \"always\"\n      # - accept: \"Control+Shift+5\"\n      #   toggle: \"extended_charset\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+exclam\"\n      #   select: \"\".next\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+at\"\n      #   toggle: \"ascii_mode\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+numbersign\"\n      #   toggle: \"full_shape\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+dollar\"\n      #   toggle: \"simplification\"\n      #   when: \"always\"\n      # - accept: \"Control+Shift+percent\"\n      #   toggle: \"extended_charset\"\n      #   when: \"always\"\n      # 你就是那个经常害我变成全角的罪魁祸首！\n      # - accept: \"Shift+space\"\n      #   toggle: \"full_shape\"\n      #   when: \"always\"\n      # - accept: \"Control+period\"\n      #   toggle: \"ascii_punct\"\n      #   when: \"always\"\n我自己是不习惯写 inline 的字典和列表，都写的展开的。\n然后是符号设置了，因为我们上面取消了逗号句号翻页，所以这里也就不用显式写 commit 直接上屏了。然后我去掉了一大堆菜单，我输入井号星号波浪线百分号就是想要英文标点，你给我弹个菜单我还得多确认好麻烦的。以及我觉得真的没人用那个巨长的全角斜杠，输入斜杠就是为了斜杠，什么通过朙月拼音命令输入假名有意义吗？我为什么不直接切日语输入法呢？另一些标点在中文语境下直接输出中文标点就好了，需要英文标点时候我敲一下 Shift 比看菜单选容易多了！比如书名号，竖线输出人名中间的点，反斜杠输出顿号之类的。\n由于我不是金融行业的，我就把一些英文标点常见但对应中文标点也可能会用到的都丢到了 $ 的菜单里面：\n&quot;: &quot;》&quot;\n      &quot;^&quot;: &quot;……&quot;\n      &quot;_&quot;: &quot;——&quot;\n      &quot;`&quot;: &quot;`&quot;\n      &quot;|&quot;: &quot;·&quot;\n      &quot;~&quot;: &quot;~&quot;\" data-info=\"language-yaml\" data-lang=\"yaml\" class=\"code-block\">  # 为了方便编写 Markdown，把一些奇怪的写中文根本用不到的符号弹出菜单改成直接输出英文符号。\n  # 另一些直接默认输出中文符号，需要英文符号可以切换英文输入。\n  # 有关 `\"!\": {commit: \"！\"}` 的写法含义是你设置这个键为翻页按键了，\n  # 但是你又想在输入拼音出现选单之后输入这个按键直接上屏（常见的逗号句号问号叹号），\n  # 我觉得这是多此一举，为什么你非要拿这几个符号翻页？反正我不用。\n  # 乱七八糟的符号都塞给 `$` 就好了反正我不是会计不用天天输入 `￥`。\n  punctuator:\n    # 我不会使用全角英文的，我觉得其他程序员也不会。\n    # 但是中文的标点又是全角的，所以我就只留下半角然后改它的标点。\n    half_shape:\n      \"!\": \"！\"\n      \"\\\"\":\n        pair:\n          - \"“\"\n          - \"”\"\n      \"#\": \"#\"\n      \"$\":\n        - \"￥\"\n        - \"$\"\n        - \"€\"\n        - \"～\"\n        - \"×\"\n        - \"÷\"\n        - \"°\"\n        - \"℃\"\n        - \"‰\"\n        - \"‱\"\n        - \"℉\"\n        - \"©\"\n        - \"®\"\n      \"%\": \"%\"\n      \"&amp;\": \"&amp;\"\n      \"'\":\n        pair:\n          - \"‘\"\n          - \"’\"\n      \"*\": \"*\"\n      \"+\": \"+\"\n      \",\": \"，\"\n      \"-\": \"-\"\n      \".\": \"。\"\n      \"/\": \"/\"\n      \"\\\\\": \"、\"\n      \":\": \"：\"\n      \";\": \"；\"\n      \"=\": \"=\"\n      \"?\": \"？\"\n      \"@\": \"@\"\n      \"(\": \"（\"\n      \")\": \"）\"\n      \"[\": \"【\"\n      \"]\": \"】\"\n      \"{\": \"「\"\n      \"}\": \"」\"\n      \"&lt;\": \"《\"\n      \"&gt;\": \"》\"\n      \"^\": \"……\"\n      \"_\": \"——\"\n      \"`\": \"`\"\n      \"|\": \"·\"\n      \"~\": \"~\"\n总之写完这些配置 之后要手动移除 ~/.config/ibus/rime/build/ 这个生成目录 再执行 ibus-daemon -rdx 就可以应用了，现在 RIME 用起来就更让我愉快了，接下来就是慢慢养词库就行了。\n有关为什么 ibus-rime 总是竖着的\nibus-rime 是读取 rime 配置而不是 ibus 配置来设置横竖这一点本身就很离谱了，然后由于 bug 啦其他奇奇怪怪的原因啦好像很难搞清楚，我最近终于搞清楚啦！其实也不是很麻烦。\nibus-rime 会读一个叫做 ibus_rime.yaml 的配置文件，有这么一个配置可以让他变成横着的：\nstyle:\n  horizontal: true\n可能看了之前的你会和我一样想那就打个 patch 到 ibus_rime.custom.yaml 不就行了嘛！但是不行，为什么呢？因为不管是 rime 还是 librime 还是 ibus-rime 都没有提供 /usr/share/rime-data/ibus_rime.yaml 的文件，所以你的 patch 找不到被打的文件，那就不会被生成到 build 目录里。\n不要忘了之前说 rime 会读取 ~/.config/ibus/rime/ 下面的 yaml，所以其实只要自己建立 ~/.config/ibus/rime/ibus_rime.yaml 写入那段配置就可以啦，因为本来也没有所以就不用打 patch 了，或者你在那两个位置建立一个空的 ibus_rime.yaml 然后再打 patch 也行……\n不要忘了删掉 build 目录再 ibus-daemon -rdx。\n下载\n如果你想试一试我的配置，其实就两个文件，default.custom.yaml 和 ibus_rime.yaml。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"翻译：我很幸运，但你不是。","url":"/posts/I-Am-Lucky-You-Are-Not/","content":"这是一篇 Jérôme Gamez 的文章 I am lucky, you are not. 的简体中文翻译。\n\n\n你好，我的名字是杰罗姆（Jérôme）！对于分享名字我感觉很自在，因为我住在德国，并且我也不总是对我们国家的政府感到高兴。\n对于我能公开谈论此类事情，而不需要感到对我的言论产生的反响感到恐惧，我感觉很幸运。并且我拥有 甚至都不需要考虑 需要考虑我有多么幸运的奢侈的权利（这里的重复是有意为之）。\n通过最近在 Discord 社区 有关 PHP 的 Firebase Admin SDK 的讨论，我才意识到以上这些事情。\n某位成员试图通过这个 SDK 去访问 Firebase API，但是却触发了一个既没有详细信息也没有说明错误来源的异常。事实上原因是因为他们在中国而且忘记了给代码运行的环境设置代理。是个可以修复的问题。\n当我在忙于在 SDK 里实现连接错误处理的时候（这是一件我以往甚至没有考虑过去做的事情，因为我在一个很幸运的位置，处于一个拥有普及且无限制的互联网连接的国家里），另一位社区成员补充说到：\n\n@jeromegamez：看看我处在一个多么令人愉悦的情形：由于美国贸易管制法律限制，您的 GitHub 账户已被限制。对于个人账户，您可能仅仅拥有用于个人交流的对于免费的 GitHub 公开仓库服务的受限访问权限。请阅读有关 GitHub 和贸易管制的文章以获取更多信息。如果您确信您的账户是被错误地标为受限，请发起申诉。\n\n他们曾经有某次在自己祖国不通过 VPN 或代理直接访问 GitHub，然后立刻被标为受限，现在无法访问自己的私有仓库。\n\n这太差劲了……你们会为这个申请判决吗？\n\n我是这样幼稚地回复的，没意识到他们的申诉当然无法成功。\n\n@jeromegamez：非常不幸，你没法选择在哪出生！在大概 200 来个国家里面我就处在一个疯狂的国家里。在内部的审查制度和制裁开始之后我通常使用 VPN，拿 whatsapp 举例，有些时候我没法上传图片于是我需要使用代理或 VPN。正常来说你可以通过使用 VPN 来使用像 Nvidia.com 或者 Android.developers.com 等等国际服务，但是这次不太一样，如果你曾经用某些地方的 IP 地址访问过他们的服务，他们直接阻拦你自己。至少我仍然可以使用公开仓库，并且希望我能备份我的私有仓库！\n至于申请判决，作为这些国家的公民我没法做这件事情。\n\n我们在私有频道继续了我们的对话，他们和我聊了他们出身的国家（这是个通常让他们感到不适的话题），他们为此努力并且在公开频道展示了这些以便引起注意。\n人们像我一样（特别来说像我：白人、男性、欧洲人、有一份薪水不错的工作并且可以访问任何我需要和大部分想要的事物）看待这个世界并且对在一些令人不那么舒适的地方正在发生的事情感到不满和恐惧。\n但是还有可能成为更令人不适、敌对或者危险的地方，并且像你或我一样的人正在那生活。\n当我在为了躲避酷暑而努力时，有些人在努力谋生。\n当我因为不能在互联网平台上使用我中意的用户名而感到气愤时，有些人在确保他们的用户名不会透露太多他们的个人信息。\n当政府 A 在制裁国家 B，在制裁导致的后果中挣扎的是那些国家的平民百姓，而不是领导者。\n当我在尽力唤起人们注意的时候，有些人在尽力活下去。\n这不代表我们的个人问题是不相干的，但我认为，认识到我们中的大多数是幸运地出生在一个好地方，并且也有好多人不像我们这么幸运，是十分重要的。\n最起码我们可以做的是以尊敬、礼貌和同情对待他人，而不在乎他们的出身和背景。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"在 Pixel C 上安装 Lineage OS","url":"/posts/Pixel-C-Lineage/","content":"Pixel C 刚出来的时候我就很喜欢，但无奈价格太贵，同时 Android M 不能说是很好的利用平板电脑硬件。由于咕鸽战略失误，现在 Pixel C 已经变成热门洋垃圾了，所以在咸鱼捡了一台玩玩。\n官方系统升级只支持到 8.1（真的好意思起名叫 Pixel），Lineage OS 支持也是到 8.1（LOS 版本号就是 15.1，没有 Bug），所有的 9.0 都是 Unofficial 的，不过反正我就拿来看看文档，所以直接刷 LOS 15.1 Official 了（为什么不刷官方？因为我手机不想刷第三方，就拿平板过过瘾）。\n\n\n由于刷机时候没拍照片我就不上图了，到手时候已经解锁了，不过既然是亲儿子想必也不会像一些国内厂商一样恶心你。按照 Lineage OS 的说法就是打开开发者选项里 允许 OEM 解锁 和 允许 USB 调试，按住 音量下 + 电源 直到重启进入 bootloader，然后连接电脑，fastboot devices，如果检测到了就 fastboot oem unlock，然后结束之后重启。（会清除所有数据，并且解锁之后每次开机会在 bootloader 停止 30 秒）。\n首先是去 Lineage OS 官网 下载给 Pixel C（代号 dragon）的 nightly build ZIP。\n然后去 这个 Google Drive 下载开发者提供的 vendor.img。（务必要下载这个，如果有不止一个就选择最新的，因为 ROM 里不包含 vendor，其他下载的版本又和 ROM 包不匹配。）\n然后去 TWRP 官网 下载给 Pixel C 用的 Recovery。\n需要 Google Apps 就去 Open GApps 下一个 ZIP，我用的是 ARM64 -&gt; 8.1 -&gt; stock。\n如果你需要 Magisk 就自己去下载一个。\n把这些都放好，在自己电脑上安装 adb 和 fastboot，然后打开 允许 USB 调试。按住 音量下 + 电源 直到重启进入 bootloader，然后 fastboot flash recovery TWRP-IMG-FILE 刷入 TWRP，然后再按住 音量下 + 电源 直到重启进入 bootloader，选择 Recovery Mode 确认 TWRP 已经刷进去了。\n接下来在 TWRP 里面全部 wipe（syste, data, cache, sdcard），然后接上电脑用 adb push FILE /sdcard/ 把下好的 ROM ZIP、verdor.img 和 OpenGApps ZIP 都 push 到 sdcard 里面。\n然后选择 Install 刷入 Lineage 的 ZIP。**接下来选择右侧 Install IMG，刷入下好的 vendor.img**，然后刷入 OpenGApps 和 Magisk，重启。如果刷入 Magisk 的话会自动重启两次再进入向导。\n如果你日后某次更新提示 vendor 不匹配，那就去上面的咕鸽硬盘看看有没有新的刷进去就行了。\n接下来就是熟悉的开机向导了。\n大致来说作为洋垃圾这个平板还很划算，除了屏幕下端因为接键盘的磁铁的缘故会发黄（通病）、太多磕碰容易花屏（设计缺陷，购买要买少磕碰的），屏幕素质很好尺寸也很大，看文档看 PPT 看五线谱都是绝配（我期末就是用这个看 PPT 复习的超级爽）。但是毕竟是 3 年前的产品，3 GB RAM 不是很够多任务，同时 CPU 性能也不是特别高，甚至窗口特效都会卡（老黄的芯片优化好烂），但是这台机器是 NVIDIA 的芯片，GPU 性能强劲，打开开发者选项里 禁用 HW 叠加层，使用 GPU 进行窗口混成特效就不卡了。\n游戏性能很弱，大部分游戏都没有对这台机器 GPU 优化，CPU 和内存以及 IO 性能也不高（毕竟三年前），但是玩 FGO 意外的不卡，而且还让我用 维护送的石头 单抽 连续 出了 老福 和 心心念念的蓝呆！！！要知道就算把买平板的钱都氪进去也才不到两单，要靠这些石头来双黄蛋简直是白日做梦啊！\n除了垃圾 B 站 APP 不支持横屏以外，大部分对我影响都不是很大，所谓生态烂其实对我这种资深 Android 用户也没什么大影响，毕竟我对它分工很明确。日常用起来 Lineage OS 也没什么问题，升级只要傻瓜化点击就 OK 了。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"雲雀","url":"/posts/Hibari/","content":"ロード・エルメロイⅡ世の事件簿 -魔眼蒐集列車 Grace note- ED\n五线谱（带歌词）点击链接下载：PDF 格式、MSCZ 格式（需使用 MuseScore3 打开）。\n歌词参考自微博用户 @小蟲子的覺魂。曲谱由我自己听写。\n\n\n说实话好久没听到这么有梶浦由记风格的曲子了。花の唄 和 I beg you 都不算是我特别能接受的风格，二世事件簿大概是一月份放了第一集，但我那时候坚守“不看新番”的原则错过了……不过还好，第二集才算正式的放出 OP 和 ED。无人声OP对于梶浦由记来说根本不算什么难题，相对来说 ED 就更有惊喜了，不管是对小灰还是对韦伯都很好体现出了人物身上的故事感。\n当然令人欣喜的绝对不是这个番又多了一个呆毛。\n刷了两次 HF2 之后听到这个真是治愈啊啊啊啊啊，HF2 黑呆和 B 叔打戏看出了 EVA 旧剧场版明日香大战量产机的感觉，明明画面很热血，但是就是给人绝望感。\n下面是数字谱：\n[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]\n\n67 [#1 #1 #1 2 #1] 7 [3] 67 [#1 #1 #1 #4#4 33] 7\n67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67\n[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]\n[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5]\n\n[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]\n[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]\n\n[6 #1 #43#4 #5 3] [#4#56 #1 #4 #56 6#5#4 3]\n\n67 [#1 #1#1 2 #1] 77[3] 67 [#1 #1 #1 #4 33] 7\n67 [#1 #1 #1 #4#56#5#4#43 #4 3 #1] 67\n[#1]7 6 6 7 67[#13] [#1#23 #23#4 #2#1]\n[#4#56 #5#4#5 3#4323 #1#2#24 #4#44#4#5 6#5#4]\n\n[#4#56 7]{#1}[#4] [#4#56 7]{32#1}[76 #4#56 7]{#1}[#4 76#5 3 #4#56]\n[6#5 #4#56 7]{#1}[#4] {#43 #1}[7]{#1} [76#5#4] [76#5#5] [#567]{#1}\n\n[#4#566#4 #4#566#4 #4#5676 #5#4#5 #566]\n[6#5 #4#566#4 #4#566#4 #4#5676 #5#4#5 #566]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #4#43 3]\n[#4#56#4 #4#56#4 #4#5676 #5#4#5 #566]\n[6#5 #4#56#4 #4#56#4 #4#5676 #5#4#5 676]\n[6#5 #4#566 #4#566 #4#5676 #5#4#5 676]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]\n[6#5#4 #43 3#1] [6#5#4 #43 3#4#4]\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"六月，如梦一般的日子","url":"/posts/June-or-Dream/","content":"\nOne day I wake up,\nfinding that I am on one of the most crazy trips in my life.\nIt has been into my dream for many times,\nbut now it comes into reality,\nwhich becomes the best birthday present.\n\n\n\n距离上次更新大概一个半月了，主要是因为考试周太忙所以没心情写博客。实际上有好多东西可以写。\n首先是端午节去了沈阳，不过很遗憾的是我不太喜欢拍景点照片（当然这也不是什么重点内容），所以只有一些稀松平常的照片。\n\n\n\n然后是有关实习的内容了，很幸运的拿到了 SUSE 北京的实习，环境超级好，而且最关键的还是找到一个自己比较感兴趣又有了解的实习。\n接下来就是 FGO 抽卡！盼了一年之后终于如愿以偿抽到了蓝呆！而且还是先出老福然后连续出蓝呆！没有看到金卡面之前完全没有意识到是什么，就算看到金卡还以为又是兰斯洛特或者式姐（兰斯洛特四宝的我），结果翻过来的时候完全呆住了不知道该怎么反应（抽到老福的快乐还没过去）。\n\n\n以及买到了 Yuki Kajiura Live 15 上海的票（因此变得超级贫穷），虽然对我这个纯 Kalafina 粉来说性价比不是很高，但由于没去过 Kalafina 的 Live（并且再也没有了）而十分后悔，因此抱着这样的想法毅然决然的自己买了票，也算是圆多年的梦吧，毕竟可以说我整个的音乐审美都来自于梶浦由纪和 Kalafina。\n最后附上沈阳故宫墙里奇怪的石头照片。\n\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"Arch Linux 安装 UnityHub 的临时方案","url":"/posts/Archlinux-UnityHub/","content":"如果你直接使用 AUR 里 UnityHub 的 PKGBUILD 安装会出一些问题。解决方案也很简单。\n首先似乎 PKGBUILD 下载的版本很奇怪，不管你在 Unity 论坛里哪个链接下载的版本其实都是一个，并且和 PKGBUILD 里面的不一样，解决方法就是自己计算一下 md5 然后替换掉 PKGBUILD 里面的 md5sums。\n第二个就是 PKGBUILD 里面最后有这几句：\n# Fix 7z permissions\nchmod +x \"${pkgdir}/opt/${pkgname}/resources\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64\" \\\n         \"${pkgdir}/opt/${pkgname}/resources/app.asar.unpacked/external/7z/linux64/7z\"\n但解压出来实际上没这些文件，然后就会报错，注释掉就好了。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"不要拿愚蠢的广告来污染我的邮箱","url":"/posts/Do-Not-Fill-My-Email-with-Silly-Ads/","content":"一个多月没更新了，这次要写的不是什么技术问题，而是技术的附属问题。\n\n\n一切问题的起源是邮箱里出现的这两封邮件：\n\n\n当你使用的邮箱服务是按某种数字顺序批量注册用户名的时候，你就没办法避免这种情况，不止我自己，而是很多人都收到这种邮件，没办法，谁叫邮箱都是连号的，甚至不需要写脚本，只要用 Excel 拖一下就能生成一大串邮箱地址，毫无技术含量。\n从哪里开始呢？今天我不打算讨论写这么个 app 的技术问题，因为不管怎么说写这么一个系统也不是个简单的活，还是要尊重别人的劳动成果。但除了技术问题，别的问题就一大堆了。\n我不想下载\n没错，最大的问题其实是我看了这个东西以后根本没有下载的欲望，甚至连让我下载下来找找里面有哪些技术缺陷的欲望都没有。我也不是什么专业的传播学者或广告设计者，但从一个用户的角度而言就没有使用欲望——而且这种现象也不止我自己。\n你的情怀和我有什么关系\n\n今年春半，凝聚了团队无数努力和心血的项目终于开启了测试阶段。这对于我们整个团队来说都是一个饱含着拼搏意义和激动情绪的时刻。\n\n上一个想要靠卖弄情怀来宣传聊天软件的人叫罗永浩，结果如何呢？提起罗永浩大家还是首先想到 TNT、打脸，有几个想到聊天宝（原子弹短信）的？罗老师的原子弹短信一开始可是给用户发红包的，这年头光卖情怀可不行，大家都喜欢红包。\n我知道你们实现了目标非常开心，但能不能冷静下来再发广告，这句话放在这里除了浪费几 Byte 流量之外，对用户了解你的应用有什么帮助嘛？\nAI 不是万能形容词\n\nDreamua 是首款 AI 社交应用。\n\n如果你做了个图片识别程序，你打个标签叫 AI 识图，那我觉得你的可信度有 90%，毕竟有很多现成的例子了。\n如果你做了个文本翻译程序，你打个标签叫 AI 翻译，那我觉得你的可信度有 70%，因为有几家财大气粗的公司在做，虽然效果不一定太好。\n如果你做了个自动驾驶程序，你打个标签叫 AI 驾驶，那你的可信度取决于你是不是在特斯拉上班。\n如果你非得叫 AI 社交……AI 社交了，还要我干什么？社交是人与人之间的互动哎，你这个 AI 社交，AI 在里面扮演什么角色呢？AI 能猜出来“今晚月色真美”的潜台词嘛？要是能猜出来，全世界的翻译官都失业了。\n写广告的人不懂的话可以问问程序员，最起码程序员应该懂。\n求你别搞假大空\n\n我们想了很久的slogan，最后把它决定为“Dreamua—遇见宇宙中最契合的TA”。\n“宇宙”、“契合”是很宏大的词，但是我们希望可以和你一起，实现这个slogan的意义。\n\n如果语文老师没教你避免假大空，那软件工程老师应该教过你怎么写文档，请问你们这个软件是想让我和外星生物配种嘛？\nedu 邮箱就很靠谱吗\n\nDreamua是一个仅对edu邮箱用户开放的高校社交App，其核心和灵魂是AI社交。注册Dreamua 账号无需填写复杂简介，仅需一个edu邮箱，一张头像，一个昵称。\n\n废话，edu 邮箱要是那么靠谱，我就不会收到这个邮件了——毕竟发件人也是 edu 邮箱。\n一个 edu 邮箱能说明什么呢？学号？学校？这个邮箱的主人可能已经毕业了，比如发邮件的这位 14xxxxxx，你是留级了在读大五？\n知道为什么我用 edu 邮箱申请 GitHub 学生认证不给过吗？就是因为国内的 edu 邮箱管理太松散了，完全没办法辨别真伪。那既然邮箱不能验证我是不是学生，再加一张头像一个昵称就能验证我是不是学生了吗？\n如果你们下次还想发广告，我觉得可以去淘宝搜索一下“教育 邮箱”，多买几个马甲，别总用一个，添加黑名单很容易的，大家只是太懒而已。\n说话能不能说准了\n\nDreamua是一个仅对edu邮箱用户开放的高校社交App。\nDreamua 测试版仅面向 edu 邮箱用户开放。\n\n第一封邮件告诉我这个社交 app 只对高校学生开放。第二封就告诉我是测试版仅面向 edu 邮箱——那以后呢？\n生人社交本身就是伪命题\n求求你了我们真的不是没社交就会孤独到死。不是每个人每个晚上都睡不着觉拿着微信疯狂摇一摇。我有自己认识的人，我可以认识我认识的人认识的人，我甚至看到有趣的人也可以直接上去要联系方式——或者我干脆就不想和别人说话。\n从小到大不爱和人说话的同学我见得多了，他们活得好好的，也没见谁需要下个 app“寻找志趣相投的伙伴”。实在不行的话，我还有沙雕网友呢。\n我为什么非要用你的\n我倒不是说微信微博 QQ 做的比你们技术好，但每个人都或多或少的被这些或者其他 app 黏着。本身这些东西已经够用了，我看不到需要切换到第 N + 1 个 app 来和别人说话的任何理由，特别是对于我们这些生活在地球外面的人，想切换就更艰难了。\n原子弹短信的尸体还在墙头上挂着呢，支付宝也有聊天功能，除了聊天框里的“转账”按钮，你按过别的吗？\nPlay 商店搜不到\n这一条可能有些不接地气，但对 Android 用户来说，Play 商店是最可靠的程序来源，就如同苹果的 App Store 一样。只有 Play 会定期检查手机里的 app 是不是有安全问题，其它的国内商店根本没有安全保证——拍个身份证照片注册就安全了吗？\n我看到你们的 app 提交了 App Store，所以应该不差那 25 美元提交 Play Store 吧，毕竟我自己的开源 app 也掏了 25 上了 Play 呢。\n官网没有可用信息\n还好我能够在 Google 搜索到 https://www.dreamua.com/，但这个页面逻辑和我自己的 app 页面 https://livewallpaper.alynx.xyz/ 逻辑差不多嘛——就一个简单的静态页面，分几个段落，写一些半通不通的话（“年轻有朝气的初创团队，致力于打造一家有影响力、有社会责任感的互联网科技公司。”这话怎么读怎么奇怪）。既然你都注册公司了，多写几个页面问题不大吧。你们是公司，我可是一个人单打独斗写的 app，不至于和我一样套开源 bootstrap 主题吧！\n顺便，上面写诞生于高校宿舍，下面又写有 Uber、Facebook、Amazon、腾讯等知名互联网公司工作经验……大概能是真的，就是会让人觉得开发之后已经换了一波人一样，再说，腾讯出来的人写个前端页面不难吧。\n化再浓的妆也没用\n说实在的，我对用户群体的评估可能有点失误，真的有人告诉我他们的室友下载了这个 app，后一句就是喜闻乐见的“想通过这玩意脱单”。\n你看看你看看，人家用户都摆明了自己的需求了，就不要写什么“将宇宙中的一座座孤岛连成一片星海”了。单身直男们也该思索一下了，为什么夏目漱石说“今晚月色真美”是表白，你说“今晚月色真美”就是华为 P30 Pro 的高端黑了，你看王跃琨一下子就被开除了！太晦涩难懂是没法脱单的！\n真的别再卖情怀了\n\n首先谢谢你打开这封信。\n我们是交大的一个学生团队，我们和你们一样在学活吃渔粉，在球场踢足球，在傍晚看明湖鸭。\nDreamua 诞生于高校宿舍。\n\n说真的，你这样会让别人对我们宿舍里这些同学的真实水平产生怀疑——我觉得我们学校的教学还是偏重于踏踏实实讲理论老老实实学技术的，而不是选个厮杀的你死我活的行业（你们的对手不止有探探陌陌 Soul 其实还有微信微博 QQ 甚至是 Bilibili 和网易云音乐）来创业，写一堆乱七八糟的文案卖情怀。\n以前好像有个公众号，文案风格如出一辙，也挺喜欢卖情怀的，结果清华评特奖的时候从简历上被人挖出来婊说实际什么都没做。我觉得这种事情给人留的印象挺差的，所以还是别卖情怀了，能好好写文案就好好写，写不出来吃点渔粉踢会足球看看鸭鸭可能就有灵感了。\n百度没收录我的网站\n最近那个《旗帜鲜明地反对李彦宏当选工程院院士》挺出名的。我先声明一下，我的网站放在地球上，谷歌必应收录了我的网站而百度搜狗 360 这种辣鸡引擎没有收录，特别是百度还把山寨我的站点放在了搜索结果首页上。所以百度和我没什么利害关系，我也就不担心这种问题。\n至于腾讯封了《旗帜鲜明》我也不太担心，毕竟我这人不喜欢用微信，连公众号都没有，生平最烦举报党。\n我恰好想起来今天是我建站的三周年零一个月整，114777 个点击量不算太多，但从第一篇文章开始我的目标就没变过——“网站是属于自己的，我可以记录我自己的想法，喜不喜欢则是你的自由”。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"Magnolia","url":"/posts/Magnolia/","content":"我不是很能欣赏花。\n我的鼻子并不懂得花的芬芳，我的眼睛也不是很了解花的鲜艳，大部分情况下，我连分辨花种类的兴趣都没有。但我今天还是认出了一株玉兰树，就像我高中楼门口两侧的玉兰树一样，开着白色花瓣。\n\n\n为什么认得玉兰花，说起来是个很奇怪的理由，有一段时间我非常喜欢一款包装上印着玉兰花的纸巾，我很喜欢那款包装的着色效果，虽然只是塑料制品，但是有着独特的温润感觉。另外大概也有原因是它味道并不是很浓，太浓的味道让我觉得不舒服。如果我没记错的话，我现在应该还留着一份包装。\n当然这件事并没有一个好的结尾，就像所有烂俗的青春文学一样。后来那款纸巾更换了新的包装，虽然还是玉兰为主题，但配色完全没有了之前的灵性。我以为我自己已经很缺乏审美了，但这个新包装的设计者不但缺乏审美，还能跑出来危害大家的眼睛。\n\n我总是记不住玉兰的英文该怎么拼，说错了，我大概对计算机之外的一切英文名词都不怎么敏感。多半是因为我并不会读这个单词，Mangolia，不对，Magnolia，有时候我会分不清楚“玉兰”和“蒙古”。\n我们先不谈有着伤感结局的玉兰纸巾，先谈真正的玉兰花。大概没有太多人注意高中校园里的两颗玉兰树，毕竟高中生每天有太多无聊的事情要考虑了，谁也没有那个闲情逸致，况且大多数人也没兴趣了解植物的区别，也包括我。\n虽然春天刮风是这个城市主要的气候，但是也并不是十分的没有人情味。通常来说，玉兰花开放的季节，也是会无缘无故落下一场春雨的时候。总是能有一些日子，可以在操场上的水洼里看见夕阳的倒影。也能在树下看到随着雨点一并落下的花瓣。什么时候树上的花瓣都落光了，什么时候有人情味的春天也就结束了。\n\n我不知道玉兰的花语是什么，因此很遗憾，我也没有办法围绕玉兰花的花语写出一篇小说。不过反正这些东西都是人附加的含义而已，就算某种花的花语是遇见幸福，那就真的能让人遇见幸福了吗？\n有些时候还是不要太相信那些本来是讲给小孩子听的话比较好，毕竟童话其实是大人写给大人看的。\n曾经我以为好搭档就应该永不分离，曾经我以为故事就应该十全十美，但后来我才知道，不完美的才更真实，大家都是成年人，就应该尊重每个人不同的决定，哪有那么多地方可以耍小孩子气。\n\n我最近在学日语，也算是终于开始实现很久以来的心愿了吧。\n老师说日语里面并不会经常重复主语，比如第一句话里已经说过主语是“我”，第二句就没必要再重复了。\n有时候我写东西也是这样，不太愿意在句子里说“我”，宁愿直接把主语省略掉，大概是欺骗自己，删掉主语的话，就可以当成是在说另一个人，写出来就不会觉得那么不好意思。\n\n“灵气”并不是什么容易获得的东西。有时候写了很多却完全不知道自己在说什么，我好像没有能把自己若无其事地叙述出来的能力。逐渐地就开始理解，物质是多么拖累精神的东西。反正喜欢的话总是被别人说出口了，电影台词也好歌词也罢，阅读总是比自己创作要舒服得多。\n只是很想听别人的故事而已，仿佛是身处不知何处的梦境中一样。身边的事物太吵闹了，生活太无聊，也太寒冷。\n四月只是春天的谎言吧，这样寒冷的日子，春天真的来了吗？还是说开放的 Magnolia，只是春天的假象而已呢？\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"如何编写 Android 视频壁纸","url":"/posts/Android-Video-Wallpaper-Implementation/","content":"最近我编写了一个 Android 的视频壁纸应用（GitHub Repo），一开始觉得并没有什么难写的地方，应该很快就可以写出来，但是后来发现我想的太简单了。或许你也看过许多写视频壁纸的教程，但我发现他们都有一些问题，写出来的程序基本不能用，所以我打算在这里写一下如何编写一个可以发布的 Android 视频壁纸，而不是一个 demo。\n\n\n首先你需要新建一个项目，通常应该都是使用 Android Studio，我就忽略你如何与网络搏斗让 Android Studio 可用了。什么程序模板可以随便选，反正你还是要自己新建 class。最低 API 版本不要太低就行，如果你只是写一个动态壁纸，应该不需要很高的 API，因为 Android 很早就支持动态壁纸了（但为了让开发方便一点，建议只考虑 5.0 以上的就行了，反正现在即使有 5.0 以下的机器多半也成垃圾了）。\n首先让系统知道你是个壁纸……\n在开始写逻辑代码之前，我们还得先让系统知道你写的这是个壁纸，这需要一些起声明作用的代码。先把你 Android Studio 左侧侧栏调成文件树模式（忘了什么诡异的分类模式吧，不然你连文件在哪都找不到，试图隐藏细节只会让事情变的更复杂）。\n应该有一个自动生成的 AndroidManifest.xml 文件，我觉得你应该比我更了解这玩意是干嘛的，因为实际上我没系统地研究过 Android，我只是会一点点 Java 而已——然后靠不停的查看手册来自学。加上这两行：\n\n\" data-info=\"language-xml\" data-lang=\"xml\" class=\"code-block\">&lt;uses-permission android:name=\"android.permission.SET_WALLPAPER\" /&gt;\n&lt;uses-feature\n  android:name=\"android.software.live_wallpaper\"\n  android:required=\"true\" /&gt;\n你要是能把这一行加到 &lt;manifest&gt; 标签外面，我觉得你也没必要写代码了……但这个要放在 &lt;application&gt; 标签的外面，具体放在哪直接翻我仓库里的文件好了，比我用文字描述清晰的多。\n但是下面这个要加到 &lt;application&gt; 标签的里面：\n\n  \n    \n  \n  \n\" data-info=\"language-xml\" data-lang=\"xml\" class=\"code-block\">&lt;service\n  android:name=\".GLWallpaperService\"\n  android:permission=\"android.permission.BIND_WALLPAPER\"&gt;\n  &lt;intent-filter&gt;\n    &lt;action android:name=\"android.service.wallpaper.WallpaperService\" /&gt;\n  &lt;/intent-filter&gt;\n  &lt;meta-data\n    android:name=\"android.service.wallpaper\"\n    android:resource=\"@xml/wallpaper\" /&gt;\n&lt;/service&gt;\n看到那个叫 android:name 的属性了吗，. 不能少，后面的名字则是一会你的 class 叫什么名字这里就什么名字。然后别的都是套路，可以不管，除了那个 @xml/wallpaper，这玩意要自己写。\n在你侧栏找到 res 目录，如果底下没有叫 xml 的目录的话，你就新建一个。然后你刚才那里斜杠后面是什么你就建立一个叫什么的 xml 文件，比如我写了 @xml/wallpaper，那就建立一个 wallpaper.xml 的文件，内容如下：\n\n\" data-info=\"language-xml\" data-lang=\"xml\" class=\"code-block\">&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;wallpaper\n  xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  android:thumbnail=\"@drawable/ic_icon\"\n  android:description=\"@string/wallpaper_description\"\n  android:settingsActivity=\"xyz.alynx.livewallpaper.MainActivity\" /&gt;\n这里面也有些地方需要改，首先那个 @drawable/ic_icon 是你这个程序在系统的动态壁纸列表里面的图标（然而大部分定制的系统都忽略了这玩意），你可以用 Android Studio 在 res/drawable 目录下面生成一个，这个可以自己去查官方文档，ic_icon 要换成你生成的文件的名字。@string/wallpaper_description 则是你的程序在列表里的名字或介绍，这个格式的意思是去 res/values/strings.xml 或者其他语言的 strings.xml 里面找字符串（写过点复杂程序的人应该都懂吧！不懂自学去！我这不是教你怎么写代码！），你可以用 Android Studio 的字符串编辑器添加一条，然后把这里的键改成你添加的。最后一个 settingsActivity 是干嘛的呢？在预览动态壁纸的页面会有个设置按钮，如果你的动态壁纸可以设置参数，点击那个按钮会跳进动态壁纸设置页面，设置页面就是在这里指定的类，因为我设置项不多直接放菜单里了，所以我写的是直接跳进 MainActivity，你写的时候也可以这样，但记得换成你的包名（不换的人我怀疑你没写过 Java，那你学个毛 Android App 开发？）。\n废话终于说完了可以写代码了好开心啊……\n然后你看见网上一堆胶水代码……\n如果你找过网上的教程，你会觉得视频壁纸是很简单的，他们都告诉你播放视频有现成的组件，你只要写几行胶水代码把它和壁纸连起来就行了……\n行个头！要是那么简单我就不用写这一篇文章了好吗？\n我们先从最基础的知识开始，动态壁纸实际上是一个 Service，你去实现一个 Service，然后系统来调用，你需要继承一个叫做 WallpaperService 的类，实现里面的一些方法。但实际上这个类只是个包装，真正的工作代码是里面一个叫 Engine 的类，具体的动态壁纸实现都是在它里面。\n所以你需要建立一个随便你爱叫什么的 java 文件（我不会用 Kotlin，但你愿意的话也可以用）来存放你自己的 Service……或者用 Android Studio 的向导也不错。比如我的就叫 GLWallpaperService，里面的代码看起来大概像这样：\npackage xyz.alynx.livewallpaper;\n\nimport android.service.wallpaper.WallpaperService;\n\npublic class GLWallpaperService extends WallpaperService {\n    public class GLWallpaperEngine extends Engine {\n\n    }\n\n    @Override\n    public Engine onCreateEngine() {\n        return new GLWallpaperEngine();\n    }\n}\n所以你看，你只需要实现 WallpaperService 的一个方法，就是在系统需要 Engine 的时候，返回你自己的 Engine 实例。\n然后你需要在你的 Engine（我的是 GLWallpaperEngine）里面实现一些系统要求的方法，我们先说最基础的几个：\n        @Override\n        public void onSurfaceCreated(SurfaceHolder surfaceHolder) {\n            super.onSurfaceCreated(surfaceHolder);\n        }\n\n        @Override\n        public void onVisibilityChanged(boolean visible) {\n            super.onVisibilityChanged(visible);\n        }\n\n        @Override\n        public void onSurfaceDestroyed(SurfaceHolder holder) {\n           super.onSurfaceDestroyed(holder);\n        }\n        @Override\n        public void onOffsetsChanged(\n            float xOffset, float yOffset,\n            float xOffsetStep, float yOffsetStep,\n            int xPixelOffset, int yPixelOffset\n        ) {\n            super.onOffsetsChanged(\n                xOffset, yOffset, xOffsetStep,\n                yOffsetStep, xPixelOffset, yPixelOffset\n            );\n        }\nAndroid 的动态壁纸实际上是一个 Surface（Android 的 Surface 你可以理解为画布……大概吧），系统调用你的 Engine，然后给你一个可以绘制的 SurfaceHolder，你只要往这个 SurfaceHolder 里面的 Surface 画东西就行了。onSurfaceCreated() 表示画布准备好了，onVisibilityChanged() 则表示画布看不见了或者又出来了，onSurfaceDestroyed() 表示画布没了（我不是你英语老师！），onOffsetsChanged() 则是桌面通知壁纸偏移量，通常是实现壁纸随桌面滚动的效果。\n不要把他们和 onCreate() 和 onDestoryed() 搞混了，那俩说的是 Engine，但我们做绘制工作时候操心的是画布。\n为什么说是个胶水代码呢……因为 Android 内建了一个播放器叫 MediaPlayer，它有个方法叫 setSurface()，可以把视频渲染到画布上，然后我们就美滋滋地看……到 bug。\n怎么设置 MediaPlayer 我就不讲了，因为网上有很多现成的，总之就是实例化设置静音设置来源再 setSurface(getSurfaceHolder().getSurface())（getSurfaceHolder() 是 Engine 的，可以获取当前的 SurfaceHolder），然后开始播放，你需要在 onSurfaceCreated() 的时候弄出个播放器，onSurfaceDestroyed() 的时候 release() 掉播放器，然后在由可见变成不可见的时候保存进度删掉播放器（其实暂停也行，但是暂停仍然占据着资源），在可见时候建立播放器并回复到之前的进度（如果看不见了还一直播，你手机的电池估计坚持不了几小时）。反正代码网上一大堆，我就不贴了。\n然后你就可以运行这个程序啦，如果你用的模拟器，你就美滋滋的发现，你的视频被硬生生压缩或拉伸成了桌面比例，视频比例没了。大部分视频应该都是横向更长一点，而手机竖向长，所以……\n如果你开始翻文档，你会发现一个 setVideoScalingMode() 的方法，可以设置为 FIT_WITH_CROPPING，你想着这不就是我们要的效果嘛：把视频放屏幕中间，然后裁出正中间最大的一块……当然不行啦！不然我写什么！\n很高兴告诉你这个其实是包装了系统的 MediaCodec 的参数，但这个实现及其不靠谱，比如在模拟器上这个功能根本就没实现！在我的 Galaxy S9+ 上虽然实现了，但在切换界面的时候（比如锁屏啦，打开应用界面啦），会突然变成没有剪裁的，总之你会看到一个奇怪的切换（这哪个程序员写的出来祭天）。\n所以如果你想正确剪裁视频的话……当然要自己动手！Android 的 View 是可以设置尺寸缩放没错，但是别忘了，这里只有 Surface，没有 View，所以没戏。用 CPU 剪裁视频的话（剪裁不是剪辑！）怕是你一帧剪完那边 30 帧都播完了，解决方案就是用 OpenGL ES 来进行这个操作。\n明明是杀鸡，还是得掏牛刀！\n如果你比较熟悉 OpenGL 的话，其实这个剪裁本身的难度比构建一个 OpenGL 环境的难度低的多……只要算一下比例做个缩放矩阵就行了，视频是矩形所以我们就先弄个正方形出来然后把每一帧解码的画面当成纹理贴上去。\n解码的工作我们可以交给 MediaPlayer，然后因为性能需要，我们不能每一帧都保存为图片然后再转读为 OpenGL 的纹理，Android 有一个 OpenGL 的扩展，可以把视频解码到的 Surface 作为一个纹理，大部分机型都支持，不支持的机型其实也可以告别动态壁纸了，啥都不支持，你还不给我钱，我为啥要给你写代码？\n但是这个过程需要一些 hack。\n显然系统不给你现成的 GLSurfaceView，而只是一个 SurfaceHolder，所以正常的思路是自己弄 GLThread 白手起家……并不，我们在 Engine 里插入下面的代码：\n        private class GLWallpaperSurfaceView extends GLSurfaceView {\n            private static final String TAG = \"GLWallpaperSurface\";\n\n            public GLWallpaperSurfaceView(Context context) {\n                super(context);\n            }\n\n            @Override\n            public SurfaceHolder getHolder() {\n                return getSurfaceHolder();\n            }\n\n            public void onDestroy() {\n                super.onDetachedFromWindow();\n            }\n        }\n看到那个 getHolder() 了吗？没错！GLSurfaceView 似乎内部自己有个 SurfaceHolder，我们 hack 一下它，扩展出一个 GLWallpaperSurfaceView，因为它是个内部类，当它要往自己的 SurfaceHolder 上渲染时，我们偷梁换柱，返回它 Engine.getSurfaceHolder()，可怜的家伙还蒙在鼓里，自己内部的 SurfaceHolder 已经没用了，现在它画的实际上是桌面壁纸的 Surface。\n我也不知道谁先想出的这个套路，但第一个想出这个办法的老哥可真是个天才。\n至于你问 Context 从哪来？Service 就是个 Context，所以你改写一下 Engine 的构造函数把 Service 传进去，然后创建 GLWallpaperSurfaceView 时传给它就行了，基本操作基本操作。\n然后我们就可以实现 GLSurfaceView.Renderer 了，这是个已经包装好的 OpenGL Renderer，我们只要负责在里面画就行了。至于 GLES 的版本，如果你想省事，只用 v2 就好了，除非像我一样对 v3 很熟悉，当然我 v2 v3 都写了 Renderer，能支持 v3 的先调用 v3（除了模拟器不支持，手机基本都支持了）。我这里用 v3 做例子，你应该自己也会写 v2 吧？如果你只会写固定管线，请你不要说自己会 OpenGL。\n当然最好在 AndroidManifest.xml 声明一下你这个应用需要的 GLES 版本：\n\" data-info=\"language-xml\" data-lang=\"xml\" class=\"code-block\">&lt;uses-feature\n  android:glEsVersion=\"0x00020000\"\n  android:required=\"true\" /&gt;\n如果你只支持 v3，就把 2 改成 3。\n（已经进入这个阶段了，打算拿这个当“我的第一个 Android App”的同学就自己退出吧。）\n我直接帖完整代码解释好了，因为实在是不好一点点讲了，反正会写 OpenGL 的人应该也能理解这种程度的代码了。\n我先把 Shader 代码贴上来，我是把它们放在 res/raw 下面的，Android 会自动生成 R.raw. 的 ID。\n\nvertex shader\n\n#version 300 es\n\n// Some Android phone driver needs to put pre-processor in the first line. (e.g. Huawei Kirin)\n\nlayout(location = 0) in vec2 in_position;\nlayout(location = 1) in vec2 in_tex_coord;\n\nuniform mat4 mvp;\n\nout vec2 tex_coord;\n\nvoid main() {\n    gl_Position = mvp * vec4(in_position, 1.0f, 1.0f);\n    tex_coord = in_tex_coord;\n}\n应该在你画三角形的时候就学会这玩意了吧？注意有些手机的实现要求第一行不能是注释，否则会报错。\n\nfragment shader\n\n#version 300 es\n#ifdef GL_OES_EGL_image_external_essl3\n#extension GL_OES_EGL_image_external_essl3 : require\n#else\n#extension GL_OES_EGL_image_external : require\n#endif\n\n// Some Android phone driver needs to put pre-processor in the first line. (e.g. Huawei Kirin)\n\nprecision mediump float;\n\nuniform samplerExternalOES frame;\n\nin vec2 tex_coord;\nout vec4 frag_color;\n\nvoid main() {\n    frag_color = texture(frame, tex_coord);\n}\n注意开头的判断！本来在 GLESv3 里面，对这种 Android 直接拿 Surface 当纹理的 flag 是 GL_OES_EGL_image_external_essl3，GL_OES_EGL_image_external 已经被废弃了，但有些支持 GLESv3 的手机只支持旧的表达方法，所以我们判断一下就好。GLESv2 则直接用后面那个，不要用前面的。\n同样，纹理类型也要换成 samplerExternalOES，别的都没关系了。\n编译和链接的过程我直接写成工具函数了，连同加载 res/raw 的代码，我贴上来：\nstatic int compileShaderResourceGLES30(\n    @NonNull Context context,\n    final int shaderType,\n    final int shaderRes\n) throws RuntimeException {\n    final InputStream inputStream = context.getResources().openRawResource(shaderRes);\n    final BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream));\n    String line;\n    final StringBuilder stringBuilder = new StringBuilder();\n    try {\n        while ((line = bufferedReader.readLine()) != null) {\n            stringBuilder.append(line);\n            stringBuilder.append('\\n');\n        }\n    } catch (IOException e) {\n        e.printStackTrace();\n        return 0;\n    }\n    final String shaderSource = stringBuilder.toString();\n    int shader = GLES30.glCreateShader(shaderType);\n    if (shader == 0) {\n        throw new RuntimeException(\"Failed to create shader\");\n    }\n    GLES30.glShaderSource(shader, shaderSource);\n    GLES30.glCompileShader(shader);\n    final int[] status = new int[1];\n    GLES30.glGetShaderiv(shader, GLES30.GL_COMPILE_STATUS, status, 0);\n    if (status[0] == 0) {\n        final String log = GLES30.glGetShaderInfoLog(shader);\n        GLES30.glDeleteShader(shader);\n        throw new RuntimeException(log);\n    }\n    return shader;\n}\n\nstatic int linkProgramGLES30(\n    final int vertShader,\n    final int fragShader\n) throws RuntimeException {\n    int program = GLES30.glCreateProgram();\n    if (program == 0) {\n        throw new RuntimeException(\"Failed to create program\");\n    }\n    GLES30.glAttachShader(program, vertShader);\n    GLES30.glAttachShader(program, fragShader);\n    GLES30.glLinkProgram(program);\n    final int[] status = new int[1];\n    GLES30.glGetProgramiv(program, GLES30.GL_LINK_STATUS, status, 0);\n    if (status[0] == 0) {\n        final String log = GLES30.glGetProgramInfoLog(program);\n        GLES30.glDeleteProgram(program);\n        throw new RuntimeException(log);\n    }\n    return program;\n}\n当然还是那个令人头疼的问题，你需要传个 Context，这个问题不大，Engine 创建 Renderer 的时候传给它就好了。\nRenderer 则是按下面的写：\npackage xyz.alynx.livewallpaper;\n\nimport android.content.Context;\nimport android.opengl.GLSurfaceView;\nimport android.support.annotation.NonNull;\n\npublic class GLWallpaperRenderer implements GLSurfaceView.Renderer {\n    private static final int BYTES_PER_FLOAT = 4;\n    private static final int BYTES_PER_INT = 4;\n    private Context context;\n    private FloatBuffer vertices;\n    private FloatBuffer texCoords;\n    private IntBuffer indices;\n    private float[] mvp;\n    private int program = 0;\n    private int mvpLocation = 0;\n    private int[] textures;\n    private SurfaceTexture surfaceTexture = null;\n    private int screenWidth = 0;\n    private int screenHeight = 0;\n    private int videoWidth = 0;\n    private int videoHeight = 0;\n    private int videoRotation = 0;\n    private float xOffset = 0;\n    private float yOffset = 0;\n    private long updatedFrame = 0;\n    private long renderedFrame = 0;\n上面这部份的变量都是一会要用到的，一会再说。\n    GLWallpaperRenderer(@NonNull final Context context) {\n        this.context = context;\n\n        // Those replaced glGenBuffers() and glBufferData().\n        final float[] vertexArray = {\n            // x, y\n            // bottom left\n            -1.0f, -1.0f,\n            // top left\n            -1.0f, 1.0f,\n            // bottom right\n            1.0f, -1.0f,\n            // top right\n            1.0f, 1.0f\n        };\n        vertices = ByteBuffer.allocateDirect(\n            vertexArray.length * BYTES_PER_FLOAT\n        ).order(ByteOrder.nativeOrder()).asFloatBuffer();\n        vertices.put(vertexArray).position(0);\n\n        final float[] texCoordArray = {\n            // u, v\n            // bottom left\n            0.0f, 1.0f,\n            // top left\n            0.0f, 0.0f,\n            // bottom right\n            1.0f, 1.0f,\n            // top right\n            1.0f, 0.0f\n        };\n        texCoords = ByteBuffer.allocateDirect(\n            texCoordArray.length * BYTES_PER_FLOAT\n        ).order(ByteOrder.nativeOrder()).asFloatBuffer();\n        texCoords.put(texCoordArray).position(0);\n\n        final int[] indexArray = {\n            0, 1, 2,\n            3, 2, 1\n        };\n        indices = ByteBuffer.allocateDirect(\n            indexArray.length * BYTES_PER_INT\n        ).order(ByteOrder.nativeOrder()).asIntBuffer();\n        indices.put(indexArray).position(0);\n\n        textures = new int[1];\n\n        mvp = new float[] {\n            1.0f, 0.0f, 0.0f, 0.0f,\n            0.0f, 1.0f, 0.0f, 0.0f,\n            0.0f, 0.0f, 1.0f, 0.0f,\n            0.0f, 0.0f, 0.0f, 1.0f\n        };\n    }\n\n    @NonNull\n    public Context getContext() {\n        return context;\n    }\n这部份很好懂吧？先处理 Context，然后我们准备 OpenGL 需要的坐标，正方形的模型坐标，纹理坐标，以及一个索引 buffer，不同的是在 Android 里面不用写 glGenBuffers、glBindBuffer 了，我们用 java 的 nio 准备数组，然后 Android 可以直接加载这里面的 buffer。（但是 mvp 矩阵仍然是数组。）\n当然，这里是没有 OpenGL 的上下文的，所以我们现在不能处理 OpenGL 的设置，需要实现下面这些方法：\n    @Override\n    public void onSurfaceCreated(GL10 gl10, EGLConfig eglConfig) {\n        // No depth test for 2D video.\n        GLES30.glDisable(GLES30.GL_DEPTH_TEST);\n        GLES30.glDepthMask(false);\n        GLES30.glDisable(GLES30.GL_CULL_FACE);\n        GLES30.glDisable(GLES30.GL_BLEND);\n\n        GLES30.glActiveTexture(GLES30.GL_TEXTURE0);\n        GLES30.glGenTextures(textures.length, textures, 0);\n        GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textures[0]);\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_MIN_FILTER,\n            GLES30.GL_LINEAR\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_MAG_FILTER,\n            GLES30.GL_LINEAR\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_WRAP_S,\n            GLES30.GL_CLAMP_TO_EDGE\n        );\n        GLES30.glTexParameteri(\n            GLES11Ext.GL_TEXTURE_EXTERNAL_OES,\n            GLES30.GL_TEXTURE_WRAP_T,\n            GLES30.GL_CLAMP_TO_EDGE\n        );\n\n        program = Utils.linkProgramGLES30(\n            Utils.compileShaderResourceGLES30(\n                context, GLES30.GL_VERTEX_SHADER, R.raw.vertex_30\n            ),\n            Utils.compileShaderResourceGLES30(\n                context, GLES30.GL_FRAGMENT_SHADER, R.raw.fragment_30\n            )\n        );\n        mvpLocation = GLES30.glGetUniformLocation(program, \"mvp\");\n        // Position is set in shader sources.\n        GLES30.glVertexAttribPointer(\n            0, 2, GLES30.GL_FLOAT,\n            false, 0, vertices\n        );\n        GLES30.glVertexAttribPointer(\n            1, 2, GLES30.GL_FLOAT,\n            false, 0, texCoords\n        );\n\n        GLES30.glEnableVertexAttribArray(0);\n        GLES30.glEnableVertexAttribArray(1);\n    }\n\n    @Override\n    public void onSurfaceChanged(GL10 gl10, int width, int height) {\n        GLES30.glViewport(0, 0, width, height);\n    }\n\n    @Override\n    public void onDrawFrame(GL10 gl10) {\n        if (surfaceTexture == null) {\n            return;\n        }\n\n        if (renderedFrame &lt; updatedFrame) {\n            surfaceTexture.updateTexImage();\n            ++renderedFrame;\n            // Utils.debug(\n            //     TAG, \"renderedFrame: \" + renderedFrame + \" updatedFrame: \" + updatedFrame\n            // );\n        }\n\n        GLES30.glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);\n        GLES30.glUseProgram(program);\n        GLES30.glUniformMatrix4fv(mvpLocation, 1, false, mvp, 0);\n        GLES30.glDrawElements(GLES30.GL_TRIANGLES, 6, GLES30.GL_UNSIGNED_INT, indices);\n    }\n这部份方法看名字就能看出来，需要注意的是那个 gl10 是 GLESv1 的用法，至于 v2 和 v3 都改成静态类了，所以我们用不到它。既然是 2D 贴图，就不需要深度测试和背面剔除了。然后设置纹理参数时需要用 GLES11Ext.GL_TEXTURE_EXTERNAL_OES，这个和 shader 里面是关联的。（哪个家伙把 GLESv2 和 v3 都支持的变量归属到 GLES11Ext 的，出来挨打！），别的地方会 OpenGL 的人都能看懂吧？最后，只有这三个函数有 OpenGL 上下文，其它的里面不能执行 OpenGL 操作。\n绘图时候 设置 mvp 矩阵不要用 nio 的 ByteBuffer，虽然有一个多态函数可以用，但似乎那个函数不能工作，所以我直接使用了 float 数组。\n下面是一些针对这个程序用到的方法。\n    @Override\n    void setSourcePlayer(@NonNull final SimpleExoPlayer exoPlayer) {\n        // Re-create SurfaceTexture when getting a new player.\n        // Because maybe a new video is loaded.\n        createSurfaceTexture();\n        exoPlayer.setVideoSurface(new Surface(surfaceTexture));\n    }\n这里是让播放器把解码的目标位置设置成 Renderer 里面和 OpenGL 纹理绑定的 SurfaceTexture 上，这个类是 Android 专门设置用来干这个的，可以阅读手册。\n为什么是把播放器给 Renderer 让 Renderer 设置呢？因为 Engine 的生命周期里只用了一个 Renderer 但会经常释放重建 Player，每次都要重新建立对应视频大小的 SurfaceTexture，所以不能让 Renderer 暴露 SurfaceTexture 出去。\n我这里没有用 MediaPlayer，而是用了 Google 的 ExoPlayer 这个项目，具体原因一会再说。\n    @Override\n    void setScreenSize(int width, int height) {\n        if (screenWidth != width || screenHeight != height) {\n            screenWidth = width;\n            screenHeight = height;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set screen size to %dx%d\", screenWidth, screenHeight\n            ));\n            updateMatrix();\n        }\n    }\n\n    @Override\n    void setVideoSizeAndRotation(int width, int height, int rotation) {\n        // MediaMetadataRetriever always give us raw width and height and won't rotate them.\n        // So we rotate them by ourselves.\n        if (rotation % 180 != 0) {\n            final int swap = width;\n            width = height;\n            height = swap;\n        }\n        if (videoWidth != width || videoHeight != height || videoRotation != rotation) {\n            videoWidth = width;\n            videoHeight = height;\n            videoRotation = rotation;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set video size to %dx%d\", videoWidth, videoHeight\n            ));\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set video rotation to %d\", videoRotation\n            ));\n            updateMatrix();\n        }\n    }\n因为要计算缩放，所以我这里设置了两个方法，分别获取屏幕尺寸和视频尺寸。然后只要在每次尺寸变化时候重新计算矩阵就行了，因为不是经常变化，所以就不用每次绘制都重新计算。\n maxXOffset) {\n            xOffset = maxXOffset;\n        }\n        if (xOffset  maxYOffset) {\n            yOffset = maxYOffset;\n        }\n        if (yOffset     @Override\n    void setOffset(float xOffset, float yOffset) {\n        final float maxXOffset = (1.0f - (\n            (float)screenWidth / screenHeight) / ((float)videoWidth / videoHeight)\n        ) / 2;\n        final float maxYOffset = (1.0f - (\n            (float)screenHeight / screenWidth) / ((float)videoHeight / videoWidth)\n        ) / 2;\n        if (xOffset &gt; maxXOffset) {\n            xOffset = maxXOffset;\n        }\n        if (xOffset &lt; -maxXOffset) {\n            xOffset = -maxXOffset;\n        }\n        if (yOffset &gt; maxYOffset) {\n            yOffset = maxYOffset;\n        }\n        if (yOffset &lt; -maxXOffset) {\n            yOffset = -maxYOffset;\n        }\n        if (this.xOffset != xOffset || this.yOffset != yOffset) {\n            this.xOffset = xOffset;\n            this.yOffset = yOffset;\n            Utils.debug(TAG, String.format(\n                Locale.US, \"Set offset to %fx%f\", this.xOffset, this.yOffset\n            ));\n            updateMatrix();\n        }\n    }\n桌面在滑动的时候会调用 Engine 的方法告诉它滑动的值，为了实现视频随桌面平移的效果，我们可以在 Engine 里把值传给 Renderer，但我们要限制一下，偏移的位置不能超出视频尺寸，否则就出黑边了。\n    private void createSurfaceTexture() {\n        if (surfaceTexture != null) {\n            surfaceTexture.release();\n            surfaceTexture = null;\n        }\n        updatedFrame = 0;\n        renderedFrame = 0;\n        surfaceTexture = new SurfaceTexture(textures[0]);\n        surfaceTexture.setDefaultBufferSize(videoWidth, videoHeight);\n        surfaceTexture.setOnFrameAvailableListener(new SurfaceTexture.OnFrameAvailableListener() {\n            @Override\n            public void onFrameAvailable(SurfaceTexture surfaceTexture) {\n                ++updatedFrame;\n            }\n        });\n    }\n需要注意这个函数里面的回调，为什么要设置一个计数器，而不是直接在这里执行 SurfaceTexture.updateTexImage() 呢？因为后者要求必须有 OpenGL 上下文……有上下文的只有之前的几个方法，其它是没有的。所以为什么这里用了两个计数器而不是一个 bool 变量呢（请自己回看 onDrawFrame() 函数）？因为这个 SurfaceTexture 内部似乎有排队机制，然后如果队列里有内容的话是不会调回调的……假如某一次传来了多于一帧，用 bool 变量翻转的时候就只能解决第一帧，后续视频就会卡住（这都是什么神仙写的 bug 啊喂！）。\n= screenRatio) {\n            Utils.debug(TAG, &quot;X-cropping&quot;);\n            // Treat video and screen width as 1, and compare width to scale.\n            Matrix.scaleM(\n                mvp, 0,\n                ((float)videoWidth / videoHeight) / ((float)screenWidth / screenHeight),\n                1, 1\n            );\n            // Some video recorder save video frames in direction differs from recoring,\n            // and add a rotation metadata. Need to detect and rotate them.\n            if (videoRotation % 360 != 0) {\n                Matrix.rotateM(mvp, 0, -videoRotation, 0,0, 1);\n            }\n            Matrix.translateM(mvp, 0, xOffset, 0, 0);\n        } else {\n            Utils.debug(TAG, &quot;Y-cropping&quot;);\n            // Treat video and screen height as 1, and compare height to scale.\n            Matrix.scaleM(\n                mvp, 0, 1,\n                ((float)videoHeight / videoWidth) / ((float)screenHeight / screenWidth), 1\n            );\n            // Some video recorder save video frames in direction differs from recoring,\n            // and add a rotation metadata. Need to detect and rotate them.\n            if (videoRotation % 360 != 0) {\n                Matrix.rotateM(mvp, 0, -videoRotation, 0,0, 1);\n            }\n            Matrix.translateM(mvp, 0, 0, yOffset, 0);\n        }\n        // This is a 2D center crop, so we only need model matrix, no view and projection.\n    }\n}\" class=\"code-block\">    private void updateMatrix() {\n        // Players are buggy and unclear, so we do crop by ourselves.\n        // Start with an identify matrix.\n        for (int i = 0; i &lt; 16; ++i) {\n            mvp[i] = 0.0f;\n        }\n        mvp[0] = mvp[5] = mvp[10] = mvp[15] = 1.0f;\n        // OpenGL model matrix: scaling, rotating, translating.\n        final float videoRatio = (float)videoWidth / videoHeight;\n        final float screenRatio = (float)screenWidth / screenHeight;\n        if (videoRatio &gt;= screenRatio) {\n            Utils.debug(TAG, \"X-cropping\");\n            // Treat video and screen width as 1, and compare width to scale.\n            Matrix.scaleM(\n                mvp, 0,\n                ((float)videoWidth / videoHeight) / ((float)screenWidth / screenHeight),\n                1, 1\n            );\n            // Some video recorder save video frames in direction differs from recoring,\n            // and add a rotation metadata. Need to detect and rotate them.\n            if (videoRotation % 360 != 0) {\n                Matrix.rotateM(mvp, 0, -videoRotation, 0,0, 1);\n            }\n            Matrix.translateM(mvp, 0, xOffset, 0, 0);\n        } else {\n            Utils.debug(TAG, \"Y-cropping\");\n            // Treat video and screen height as 1, and compare height to scale.\n            Matrix.scaleM(\n                mvp, 0, 1,\n                ((float)videoHeight / videoWidth) / ((float)screenHeight / screenWidth), 1\n            );\n            // Some video recorder save video frames in direction differs from recoring,\n            // and add a rotation metadata. Need to detect and rotate them.\n            if (videoRotation % 360 != 0) {\n                Matrix.rotateM(mvp, 0, -videoRotation, 0,0, 1);\n            }\n            Matrix.translateM(mvp, 0, 0, yOffset, 0);\n        }\n        // This is a 2D center crop, so we only need model matrix, no view and projection.\n    }\n}\n最后是计算矩阵，这里也很简单，只要注意计算时候，要分别以视频和屏幕最长的一条边作为单位一，然后分别缩放两者的另一侧，只是数学计算而已。然后为什么会有旋转呢？如果你不写旋转而又使用手机拍摄的竖屏视频做壁纸，就会发现方向是旋转了 90 度的，所以宽和高也都错了。原因是一些设备录像时候不会旋转帧内容，而是以传感器原生的方向存放像素，然后在视频 Metadata 里面记录一下旋转角度，由播放器做旋转。MediaPlayer 自己直接输出是会旋转的，但由于我们这里用它做解码器，所以它传过来的帧是原样的。\n解决方法是在 Engine 加载视频的时候先读取一下元数据，从元数据里获取视频的尺寸旋转量设置给 Renderer：\n        private void getVideoMetadata() throws IOException {\n            final MediaMetadataRetriever mmr = new MediaMetadataRetriever();\n            switch (wallpaperCard.getType()) {\n            case INTERNAL:\n                final AssetFileDescriptor afd = getAssets().openFd(wallpaperCard.getPath());\n                mmr.setDataSource(\n                    afd.getFileDescriptor(),\n                    afd.getStartOffset(),\n                    afd.getDeclaredLength()\n                );\n                afd.close();\n                break;\n            case EXTERNAL:\n                mmr.setDataSource(context, wallpaperCard.getUri());\n                break;\n            }\n            final String rotation = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_ROTATION\n            );\n            final String width = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_WIDTH\n            );\n            final String height = mmr.extractMetadata(\n                MediaMetadataRetriever.METADATA_KEY_VIDEO_HEIGHT\n            );\n            mmr.release();\n            videoRotation = Integer.parseInt(rotation);\n            videoWidth = Integer.parseInt(width);\n            videoHeight = Integer.parseInt(height);\n        }\n当然 WallpaperCard 是我自己封装的类，关系不大。总之是使用 MediaMetadataRetriever 就可以了。至于你说视频元数据和实际内容不符怎么办？那是用户问题，用户自己处理不好视频为什么要我来解决？随便让他拿电脑上修改一下好了。\n这些实际上是这个应用的核心内容，其它的播放之类的都大同小异，总之如果你实现了 OpenGL 的剪裁功能，应该就可以正常播放壁纸了。其它部分直接参考我的代码或者网上的样例就可以了。\n顺便说一下，SurfaceTexture 似乎会给一个纹理矩阵，但我试着用了一下发现并不是需要的效果……所以还是自己处理吧。\n然后声音又不对劲了……\n就算你给 MediaPlayer 设置了静音，还是不太对劲！正常来说在桌面按音量键设置的是铃声音量，为什么变成了媒体音量！\n这当然是因为虽然 MediaPlayer 虽然静音了，但还是占据着音频通道，我们都知道 Android 分为媒体、铃声、系统等音量通道，如果 MediaPlayer 一直占着媒体通道，其它的媒体 App 比如音乐播放器一类的就没有办法播放。\n使用 MediaPlayer 是没有解决办法的，因为它没提供关闭音轨的接口，一开始我差点基于 MediaCodec 自己编写一个视频播放器，但始终没办法把解码器从主线程转移开，而且 CPU 占用率很高。后来发现 ExoPlayer 有办法关闭音轨，所以我换成了 ExoPlayer。\n具体怎么引入 ExoPlayer 请参照官方文档，只要引入 core 部分就可以了。\n我这里给出一段用于关闭音轨的代码，网上不太好找：\n            trackSelector = new DefaultTrackSelector();\n            exoPlayer = ExoPlayerFactory.newSimpleInstance(context, trackSelector);\n            exoPlayer.setVolume(0.0f);\n            // Disable audio decoder.\n            final int count = exoPlayer.getRendererCount();\n            for (int i = 0; i &lt; count; ++i) {\n                if (exoPlayer.getRendererType(i) == C.TRACK_TYPE_AUDIO) {\n                    trackSelector.setParameters(\n                        trackSelector.buildUponParameters().setRendererDisabled(i, true)\n                    );\n                }\n            }\n主要是创建 Player 时候单独给它一个 DefaultTrackSelector。然后关掉音轨。\n这样大概就可以运行了，剩下的一些问题都和视频渲染无关。\n写 UI 也很麻烦！\n虽然我知道你肯定不满足只使用内嵌视频，但如果你像我一样写了个可以设置其它视频的 UI，就会遇到各种各样的问题。写 UI 的时候，你不是在编写回调函数，就是在调用回调函数的路上。\n最令人恶心的是 Context 管理，很多地方都需要 Context，但很多地方都没法传 Context，比如 Android 推荐你用 Uri 而不是直接用文件路径，但所有使用 Uri 的地方都要求你传 Context 来解析 Uri！比如我添加视频，需要解析 Uri 并生成缩略图，为了不阻塞线程，必须开启一个 AsyncTask，但是，AsyncTask 不能直接拿走 MainActivity 作为自己的 Context！必须要传弱引用，总之没有一个优雅的解决方案。\n再比如你需要一些在各个位置都能访问到的数据，你可以自己写一个 Application 类并给它静态变量，但是静态和动态不能互相交叉，也就是说你不能封装一个操作数据的同时需要访问 Context 的方法，所以很多地方就只能拆开写，没办法封装。\n以及列表和数据的绑定写起来真的很麻烦，说实在的，HTML 和 JavaScript 写 UI 真的比 Android 和 Java 舒服的多……\n顺便，你可能会想在 UI 里调用系统的动态壁纸预览，然后根据它返回的结果来设置选中的视频，但这个真的很不靠谱，比如某些版本的 MIUI 修改的预览器即使你点击了应用，它仍然会返回一个取消的结果。明明是 MIUI 的问题，却需要我来解决，我大概可以理解为什么 sway 的开发者大骂 NVIDIA 用户了。你们给了小米钱买它的手机和系统，然后小米造成的问题要我来解决，我一分钱都没有拿到，哪里来的义务和责任解决？？？\n当然我最后还是想办法绕开了，添加了一个单独的应用按钮，用户点击这个按钮就是忽略预览，直接设置为壁纸。\n动态壁纸预览器调用你的壁纸服务的时候，你的 Engine 里 isPreview() 方法会返回 true，可以根据这个判断是不是在预览状态。因为我只有一个壁纸服务，所以我做了一些判断，对预览和桌面分别做了一些不同了逻辑，以便防止预览的结果影响到本来桌面上的壁纸效果。\n最后要注意：你可以在 Service 里面访问 Application 的静态方法，但似乎你不能一直依靠这个。比如当你设置壁纸以后重启了，Service 会被启动，但这时似乎没办法访问到 Application 里的变量。我解决的办法是将数据写入到 SharedPreference，如果从 Application 加载失败就去读取 SharedPreference，但总之我没找到有关 Service 和 Application 会不会一起创建的说明，所以这部份的代码写的很混乱（也包含上面说的不能封装的原因）。\n一杯咖啡都没有……\n如果你只是觉得市面上所有的视频动态壁纸程序都太臃肿太不可靠（包括抖音和火萤）而想自己写一个，我建议你还是放弃，因为遇到的坑比你想象的多，解决起来也很麻烦。而且实际上，你完全可以使用我写好的程序。\n这个程序只有 3.06M，支持加载本地壁纸，支持平板电脑，支持壁纸滑动，不显示时自动暂停播放节约电量，严格遵循 Android 规范，没有任何敏感权限（比如联网和操作外置存储），不请求文件真实路径，测试下来功能基本没有问题。如果你还不放心，所有的代码都在 GitHub 上，我不怕你说我代码写的不好，你大可以看一遍有没有后门。\n你可以分别从 GitHub Release，Google Play 和 酷安网 下载这个应用。\n为了上架 Google Play 我支付了 25 美元申请了开发者账户，应用是免费的，但我放置了捐赠页面。不过已经有几百个下载量（大部分是酷安）之后，我还没有从这个应用里得到一点回报，如果你觉得应用不错并且手头宽裕，可以打开 App 赞助我一杯咖啡。毕竟解决上面提到的所有的坑并不容易。\nAlynx Zhou\nA Coder &amp; Dreamer\n"},{"title":"在中国 Android 环境下传个 APK 有多难","url":"/posts/Hard-to-Transfer-APK-with-Chinese-Android/","content":"事情的起因是这样的，我写了 一个 Android App，打算把它发给更多的人试用，发给同学什么的都好说，但我想发给我妈用的时候遇到了一系列问题。我觉得恰好可以说一下在国内用 Android 环境是多么痛苦。\n\n\n首先尝试最简单的方法，不是所有人都有 QQ，但差不多所有人都有微信，特别是一些中年的亲戚，所以直接在微信里传送 APK 文件，然后失败了。微信自作聪明地给 APK 加了 .1 的后缀名，不用想都知道理由：“哎呀我们的用户都是可爱的啥都不会的小宝宝，要为了他们安全考虑呢”。\n微信失败了，那就换个方式吧，发个网址去下载 APK，应该就不会被改名了，所以我直接复制了 GitHub Release 的链接，然后大家一概回复：“这个网址打不开”。\n行吧，开个 GitHub 都要折腾来折腾去的地方学习写代码有多艰难我就不哭诉了，那我们换个网站，我记得两个月前酷安网还是可以在电脑上下载 APK 的，我就把我上架之后的链接发了过去。不一会我妈说：“你这个链接让我 下载他的那个市场，然后 微信里要下载还得装 QQ 浏览器”，我妈还是有在这个艰难环境下使用手机电脑的知识的，所以看到要装这些乱七八糟的就放弃了。\n打开电脑一看，没想到啊没想到，酷安你这个浓眉大眼的家伙也叛变革命了。我不知道是哪个闲鱼用多了自己脑袋都咸了的产品经理一拍脑袋删掉了网站的搜索框，然后又关掉了 APK 的下载渠道。为了秉持优雅，我就不在这里问候这个经理的家人了。\n事已至此，总不能用百度云吧？靠百度云的限速估计能下载到猴年，我觉得百度除了竞价排名技术，网盘限速技术也是独步全球，而且似乎百度云稍微大一点的文件就让你下客户端？虽然我对我应用的体积很有信心，但也不想再趟混水了。\n我不知道别的开发者怎么分发他们的安装包，但我不想备案，也不想为了 APK 一直掏钱供着一个国内服务器，而且 要想在微信能访问域名，还得给腾讯交保护费，否则说你不安全，去哪说理去？\n后来我还是把文件传到服务器上然后用 IP 做了个链接，我自己的电脑能下载，但 微信内置浏览器就是不行。\n我可以教我妈怎么找到微信的下载文件然后修改后缀名，但是别人呢？我妈想把这个应用介绍给身边人试试，有些人连文件管理都没开过，总不能一个一个教他们吧？打包更不现实了，什么是 zip 什么是 tar 和你七大姑八大姨的工作生活可能一点关系都没有，当然也不是所有人工作都用 Email，大家都要恰饭，生活已经很艰难了。\n别说多提交几个商店，每次发新版本 GitHub Google Play 和酷安三个一起更新填表就已经花了好多时间了，每个品牌的手机都非得做一个自己的商店，用户量不大要求还不少，谁有那好心一个个提交去。\n这肯定不是 Android 的问题，毕竟如果能用 Google Play 问题就不存在了，或者如果能用 Telegram 这种聊天软件也行，但如果你是鸡群里的鹤，怕不是会被鸡群起而攻之。至于 Firefox Send 什么的估计在国内也没戏。这个时候我甚至开始怀念 QQ 了，虽然流氓，但是还是能传文件的。\n但说到 QQ，我又想起了几年前的事情，我相当佩服 QQ 的开发者这种在一个软件里打两个包的技术，当你用 QQ 点开一个网页链接，然后点菜单选“用 QQ 浏览器打开”的时候，你会发现 QQ 内嵌了一个 QQ 浏览器 —— 怪不得 QQ 浏览器有脸说自己装机量第一，以前我以为是很多人蠢瞎了用这种垃圾，后来发现我失算了 —— 当然最魔幻的不止于此，这个内嵌的 QQ 浏览器版本当然是很旧的，所以你打开了之后它第一件事是让你下载安装最新的 QQ 浏览器 —— 你看一个人能装两个 QQ 浏览器，发明这个技术的产品经理真是个小天才，他推动了手机存储空间上升！跟他比起来苹果算个什么东西！\n现在 QQ 的体积还是巨无霸，这个按钮也依然在那里，大概 QQ 浏览器仍然嵌在里面吧，而且估计版本一直都没变过，毕竟能变成俩鸡蛋的双黄蛋大家都喜欢。祝 QQ 未来能把其他所有腾讯的应用都嵌进去，早日突破 1 GB 大关。\nAlynx Zhou\nA Coder &amp; Dreamer\n"}]}