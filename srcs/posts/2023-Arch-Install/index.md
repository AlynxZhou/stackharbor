---
title: 2023 年的 Arch Linux 安装指南
layout: post
#comment: true
created: 2023-07-28T20:42:53
#updated: 
categories:
  - 计算机
  - Linux
  - Arch Linux
tags:
  - 计算机
  - Arch Linux
---
在安装 Arch Linux 之前，首先要准备 Arch Linux 的安装媒介。如果你打算安装在虚拟机里，那你并不需要一个实体的存储介质，因为虚拟机可以直接加载 iso 文件。但不管你在哪里安装，你都需要获取这个 iso 文件，引导进入其中的临时系统才能继续安装。

Arch Linux 的安装镜像每月更新一次，如果你点开官网的下载页面，你会发现没有直接的下载链接，而是推荐你使用种子下载或者镜像站下载。这是一个非常有必要的要求，因为官方的服务器不能承受世界各地所有的请求流量，以上两种方法通过将单一的下载来源转换为多个下载来源有效的减轻了官方服务器的压力。

考虑到当今种子下载并不是一个流行的下载方式，对于部分读者而言可能难以掌握，我们这里就选择镜像站下载。所谓的镜像站就是将官方服务器上的文件原样下载到自己的服务器上，然后给别人提供下载服务的服务器。有了镜像站，世界各地的用户就不必连接相对较远较慢的官方服务器，而可以就近选择镜像站，获取到完全一样的文件。

我们可以打开某个镜像站同步 `archlinux` 的目录，然后找到 `iso/latest` 目录，里面的 `archlinux-x86_64.iso` 就是我们需要的，以清华大学的镜像站为例，链接就是 <https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/latest/archlinux-x86_64.iso>。

注意！Arch Linux 官方只对 x86-64 架构提供支持，如果你的设备不是该架构（可能性很低，如果你不是该架构，你应该已经有足够的经验自己解决问题了），可能需要使用其它分支项目并参阅相关的文档。

当下载好 iso 文件之后，需要准备对应的安装媒介，这需要一个实体的存储介质，光盘是最传统的安装媒介，这也导致了各种系统的安装程序都以光盘镜像（iso）的格式打包。但想必当今的用户寻找光盘和光驱可能有些难度，所以 U 盘成为了更流行的安装媒介，找出一个你没有使用的 U 盘，备份好原本的数据，然后连接到你下载了安装镜像的电脑上。

如果你的电脑上已经运行了 Linux，那你可以通过 `dd` 命令将 iso 文件写入到 U 盘里，Arch Linux 的安装镜像经过特殊处理，可以支持这样的 U 盘引导。首先通过 `lsblk -f` 查看你的 U 盘对应的设备文件是什么，然后使用 `dd if=/PATH/TO/archlinux-x86_64.iso of=/dev/sdX`，记得把 iso 和设备文件的路径改成你的实际路径，并且不要使用 U 盘分区的设备文件，而是使用代表整个 U 盘的设备文件。然后执行 `sync`，让内核把内存里缓冲的数据写回磁盘，保证安装镜像完全写进 U 盘里面。

但你也可能会说如果我有 Linux，我为什么要装 Linux？这种情况下我们推荐 Windows 用户使用 Rufus 创建安装 U 盘，这个软件下载即可运行，不需要安装，然后在软件里分别选择 iso 文件的位置和 U 盘设备，点击写入即可获得一个安装 U 盘。

无论你使用哪种方式，接下来弹出 U 盘，准备重启电脑。不过要保证重启的时候 U 盘仍然在你的电脑上。现在的电脑应该都支持 UEFI 引导，你需要搜索你的主板型号得知你的电脑应该按什么按键进入启动设备选单，反正无非是 F8、DEL、Enter 中的一个，在显示主板 logo 的时候狂按，直到出现一个让你选择的菜单，使用键盘上的方向键选择你刚刚做好的安装 U 盘，然后按下 Enter 选择。等屏幕上走完启动流程，你应该就会自动登录进一个 Arch Linux 的环境。如果你开启了安全启动，那你需要关掉，因为 Arch Linux 的安装镜像并没有进行安全启动需要的签名，这里就不介绍具体如何关闭了，因为各家主板的界面都不一样，建议搜索引擎搜索自己的主板型号+关闭安全启动。

Arch Linux 的安装环境是没有桌面的，你需要在命令行里自己调用各种命令完成一系列安装相关的操作，这样看起来比较难，但是也很灵活，可以根据自己的需要调整。首先你要做的是确定自己已经联网了，最简单的就是从路由器插一根网线到你的电脑上，这样应该就能上网了。如果你没有网线——那现在就该去买一根，比起现在给你讲清楚怎么在命令行下面连接无线网络，买网线更简单，真的。

然后你应该使用 `date` 命令查看系统时间是否重要，许多加密方式依赖时间正确，比如 https，因此如果它不正确，你应该改正它，不过大部分情况都是正确的。

接下来你应该准备安装系统的磁盘分区，首先你得通过 `lsblk -f` 找到要安装的硬盘，如果是 SATA 硬盘，它可能是 `/dev/sda` 或者 `/dev/sdb` 之类，如果是 NVMe 硬盘，那可能是 `/dev/nvme0n1`，一般来说根据容量判断是不会错的。你的目标磁盘上应当留有一定的未分配空间给新系统使用。注意如果分区和格式化时操作错误，可能会让你丢失已有的重要数据，因此在进行操作前务必仔细确认。

UEFI 引导的机器大部分都使用 GPT 分区表，当然这其实主要是 Windows 的限制，因此我们使用 `gdisk` 进行分区，如果你使用的不是 GPT 分区表，那你可能需要自行了解一些相关知识。当你不知道该做什么的时候，输入 `?` 可以显示帮助，输入 `p` 可以打印当前的分区表，输入 `q` 可以退出 `gdisk`，只有输入 `w` 才会真正修改硬盘上的分区表，所以如果你不确定就不要输入 `w`。

输入 `p` 打出当前的分区表之后，你应该首先找到一个小的 FAT32 分区，一般会在磁盘的开头，容量不会超过 1G，这是你的 ESP 系统分区，UEFI 要求把引导文件放在这里。然后你应该按 `n` 新建一个分区，一般它会自动计算未分配空间的开头，不过你也可以手动输入来纠正，然后输入新分区的结尾位置，也可以用 `+100G` 的方式表示从开头位置创建一个 100G 的分区。一般只要分一个分区做 Linux 的根分区就好了，不过你有需要也可以创建更多的分区，比如你可能需要一个 swap 分区，那就用相同的办法创建一个。创建完你需要的分区之后，输入 `p` 确认一下新的分区表，然后按 `w` 写入分区表。

接下来你需要在分好的分区上创建文件系统也就是格式化，因为分区表只是标记“从哪里到哪里属于哪个分区”，并没有在对应的位置创建实际的结构。比如你可以用 `mkfs.ext4 /dev/sdXY` 格式化你刚创建的根分区，然后用 `mkswap /dev/sdXY` 格式化你刚才创建的 swap 分区。记得在执行命令之前确认你使用的设备文件正确。然后你需要挂载你创建的分区到 `/mnt`，稍候会向里面写入系统文件。首先用 `mount /dev/sdXY /mnt`，把根分区挂载上，然后你需要创建其它分区的挂载点，比如 EFI 系统分区，对于这个如何挂载有很多种说法，不过我一般直接把它当作 boot 分区挂载，这样内核也会被安装到这个分区，有些预装 Windows 系统的电脑可能会分一个极小的 EFI 系统分区以至于放不下内核，那你可能需要查找更多资料，这不在这篇文章的讨论范围之内。总之先 `mkdir /mnt/boot` 然后 `mount /dev/sdXY /mnt/boot`。最后可以用 `swapon /dev/sdXY` 启用你刚才创建的 swap 分区，这样记录新系统挂载点的时候就会记录这个 swap 分区。

然后需要修改镜像站列表，和之前下载 iso 一样，系统需要的各种软件包也依靠镜像站提高分发效率。你需要用一个编辑器编辑 `/etc/pacman.d/mirrorlist`，如果你没有熟悉的编辑器，那 `nano` 应该是个适合新手的选择，因为各种操作需要的快捷键都会显示在屏幕底部，`^` 代表 Ctrl，`M` 代表 Alt，在列表里找到离你地理位置比较近的几个镜像站，然后删除对应的 `Server = ` 前面的 `#` 来启用这个镜像站，一般启用两三个就足够了。

然后就可以正式安装软件包到创建的分区了！使用 `pacstrap -K /mnt base base-devel linux linux-firmware` 安装软件包到 `/mnt`，你可以在后面附加更多你需要的软件包以便一并安装，甚至如果你不想第一次启动新系统还是命令行的话，也可以在这一步直接附加桌面环境进去。这里我贴一个基于我常用软件总结的列表作为参考：

```
base base-devel linux linux-firmware man-db man-pages btrfs-progs vim nano git rsync gnome gdm networkmanager firefox meson ninja efibootmgr haveged ibus-rime ffmpeg noto-fonts noto-fonts-cjk noto-fonts-emoji ntfs-3g btop p7zip parallel tree ttf-roboto unrar unarchiver wget usbutils bind
```

如果你和我有不同的偏好，你应该已经清楚如何安装你需要的软件，我在这里只以我自己使用的软件作为例子。为了方便使用，我在这一步直接安装了桌面环境，但桌面环境需要有可用的显卡驱动，对于 Intel 和 AMD，它们的开源驱动已经足够好用，应该会自动引入 `mesa` 所以没什么需要额外操作的，但是对于 NVIDIA，你还需要安装 `nvidia` 这个包来引入 NVIDIA 的闭源驱动。

然后等待下载安装即可，现在大家的带宽都很高，如果确实选了离自己近的镜像站，这个步骤应该花不了多少时间。

然后读取你对新系统的挂载信息并写入到新系统里，以便新系统基于这个数据挂载硬盘，使用 `genfstab -U /mnt >> /mnt/etc/fstab` 即可。

现在你的新分区里应该有一个新系统需要的各种文件了，但是你还需要对它进行各种设置，首先需要 chroot 到新的系统，这是一个 Linux 内核的功能，可以让你以另一个文件系统作为根目录从而操作其中的各种文件，这里使用 `arch-chroot /mnt` 进入新系统的根目录。

然后你要指定自己新系统的时区，比如你使用的时区是 `Asia/Shanghai`，那可以执行 `ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime`，你也可以将 `Asia/Shanghai` 修改为其它的时区，所有可用的时区都以目录和文件的形式列在 `/usr/share/zoneinfo/` 下面。

然后你需要执行 `hwclock --systohc`，这会假设你的 BIOS 时间是 UTC，这和 Windows 默认的假设不一致，Windows 认为你的 BIOS 时间就是本地时间。可以让 Linux 认为 BIOS 时间是本地时间，但是可能会导致各种问题，同样也有办法让 Windows 认为 BIOS 时间是 UTC 时间，只需要随便新建一个文本文档，写入如下内容：

```
Windows Registry Editor Version 5.00

[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\TimeZoneInformation]
"RealTimeIsUniversal"=dword:00000001
```

然后保存并修改扩展名为 `.reg`，然后双击导入注册表项并重启。

接下来修改本地化相关内容，首先是 glibc 需要对不同的语言生成不同的配置，需要用编辑器编辑 `/etc/locale.gen` 文件，必须要启用的是 `en_US.UTF-8 UTF-8`，别的可以按需求启用你需要的，只要删掉开头的 `#`，注意只要启用带 `UTF-8` 的就可以。不过这一步也可以略过其他的只启用英语，然后在桌面环境里修改语言的话桌面环境应该会自动处理相关的文件。然后运行 `locale-gen`，它会根据上述文件的内容具体生成对应文件。

然后创建 `/etc/locale.conf` 文件，写入你当前使用的 `LANG` 变量，不过其实 tty 不能显示中文，所以这一步推荐设置成英文，等到桌面起来了再改也来得及，因此推荐写入 `LANG=en_US.UTF-8`。

网络相关的配置首先需要设置 hostname，这一步只要打开 `/etc/hostname` 文件写入你想要的主机名就行了。我的习惯是使用 NetworkManager 管理网络连接，因此需要设置让系统下次启动时启用 NetworkManager，只要 `systemctl enable NetworkManager` 就可以。NetworkManager 会自动管理你的网卡，比如有线网卡就会自动尝试 DHCP，同时也提供和桌面环境的集成，方便使用无线网卡。

一些无线网卡需要的固件可能被单独划分在别的包里，此时你可以安装这些包，比如高通的网卡就是 `pacman -S linux-firmware-qcom`。

然后你需要进行启动相关的设置，首先你得生成 initramfs，这个东西解决的问题是“需要加载模块才能读取对应的文件系统，但模块就存在那个文件系统上”这种问题，为了打破鸡生蛋还是蛋生鸡的循环，解决方法就是创建一个非常小的包含必要模块的文件，和内核放在一起，保证启动时可以加载这个文件。生成这个文件很简单，因为我们没有什么特殊的配置，只要执行 `mkinitcpio -P` 就行了。

同时现代的 CPU 都支持加载微码来热修复 CPU 的 bug，这也是通过在启动时加载相关的文件实现，首先需要安装对应的微码包，如果是 Intel 就 `pacman -S intel-ucode`，AMD 就 `pacman -S amd-ucode`。

然后你还需要一个 bootloader 加载你的内核和 initramfs，最流行功能最全的是 GRUB，但我觉得 systemd-boot 也完全够用了，所以我选择 systemd-boot。因为已经安装了 systemd 所以就不需要额外安装什么了，只要 `bootctl install`，就可以安装引导需要的文件。

但我们仍然需要告诉 loader 去哪里加载内核，加载哪个内核。systemd-boot 需要我们手动编写配置文件记录这些内容。首先需要 `mkdir /boot/loader/entries` 建立用于放置不同内核启动项的文件，然后再编辑 `/boot/loader/entries/arch.conf` 给默认的内核编写一个文件。

一个配置文件推荐包含以下内容：

```
title   Arch Linux
linux   /vmlinuz-linux
initrd	/amd-ucode.img
initrd  /initramfs-linux.img
options root="UUID=xxxx-xxxx-xxxx" rw add_efi_memmap
```

基本上你需要改的有两处，一个是如果是 Intel 就把 `amd-ucode` 改成 `intel-ucode`，另一个是要把内核参数里 `root=` 的值设置为你的根分区，以便内核找到你真正的根分区。这个可以通过打开 `/etc/fstab` 找到里面挂载到 `/` 的设备得到需要的值。

然后你需要编辑 `/boot/loader/loader.conf`，这是给 loader 的配置，其实只需要一行 `default arch.conf`，告诉 loader 默认加载 arch 内核的配置就可以了。

最后需要进行密码配置，首先执行 `passwd` 设置 root 密码。由于 root 权限太高，平时不建议使用 root 操作，所以我们可以通过 `useradd -m newuser` 创建一个普通用户，`-m` 的意思是会自动给用户创建同名的 home 目录存储用户相关的文件，你也可以把 `newuser` 改成任何你想要的用户名。然后执行 `passwd newuser` 给这个新用户设置密码。同时为了方便进行高权限操作，我们需要允许新用户执行 `sudo`，首先执行 `EDITOR=nano visudo` 编辑 sudoers 文件，找到 `root ALL=(ALL) ALL` 一行，然后在下面插入 `newuser ALL=(ALL) ALL`（记得用你想要的用户名），保存即可。

然后运行 `systemctl enable gdm`，这会告诉系统启动时启用 GNOME 显示管理器，下次启动时你就会得到图形界面并可以直接登录进桌面。此时关于新系统的设置都已基本完成，执行 `exit` 退出 chroot，然后执行 `reboot` 重启电脑，你应该可以在 UEFI 启动选单里找到 Linux Boot Manager，选择就会启动新安装的 Arch Linux。

由于此时应该已经启动图形界面了，对于桌面的各种设置只要在图形界面的设置程序里设置即可，就不需要专门讲述怎么用了。
